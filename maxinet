#!/bin/bash
# =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
# Author: Arafat Ali | Email: webmaster@sofibox.com | Website: sofibox.com
# local OS fully tested: ubuntu | local OS partially tested: debian,
# remote OS fully tested: debian 11 | remote OS partially tested: Almalinux
_APP_SPECIFIC_NAME="Maxinet"
# Note that some minor versions are not published
_APP_VERSION="1.8"
_APP_STATUS="alpha"
_APP_VERSION_STATUS="${_APP_VERSION}-${_APP_STATUS}"

### START TEMPORARY NOTE
# TODO configure cloudflare IP in CSF
# TODO note for new domain of users to have custom .html edit this :/home/reseller_username/domains/default/index.html
# TODO switch to sftp using proftpd (working fine using this tutorial https://forum.directadmin.com/threads/how-to-set-up-your-proftpd-ftp-server-to-support-the-secure-protocols-while-disabling-insecure-ftp.65025/ and make sure to use port 23 as mentioned in doc)
# TODO check log for proftpd
# TODO trigger admin backup from directadmin automatically before deploy a new server (also create validation if the file restoration success first). So we will always have working restoration file.
### END TEMPORARY NOTE

# This is a personal project that I wrote for server automation to reduce server configuration time.
# The aim of this project is to have everything automated when deploying a new server without wasting a lot of time.
# For example setting up a secured server from scratch with hardened configs might take few days (I've experienced this) but this script will reduce that longer period to about 1 hour with one command!
# I focused a lot of security enhancements in this script for a new server deployment in order to reduce server malicious attack.

# Warning, you should not use this script if you dont know the purpose of this script. This script might contain bug (especially this public version)
# There is another private version without _public name URL that always have the latest code and features.
# Running example:

# maxinet create-server --rebuild-all --backup

# For example if everything is configured correctly for Directadmin and Linode in maxinet.conf,
# the above command will configure a new server disk and config in linode, it will then create custom ISO file for Debian, then it will install this operating system.
# then do a lot of thing behind ... bla2 bla2 ... (read the code to understand what it does because it is huge to write what it does) ... and finally you will get a fully working server with live websites. So, with only a single command, you will get a clean server with security hardened features
# The feature is currently huge to list out.
# It might contain bugs for other distributions. This script is fully tested on Debian 10, Debian 11 and with Directadmin custom and auto installation. This script compatible with linode + directadmin
# Author: Arafat Ali | Email: arafat@sofibox.com | Personal Blog: arafatx.com
# See maxinet --help for more information
# To update remote files from local run this: maxinet update-remote-scripts
# To login into remote: maxinet login

#######################
# FUNCTION BEGIN HERE #
#######################

# This function is used to handle exit trap that can accept multiple trap arguments
# syntax: traps <traps_cleanup_function> SIG1 SIG2 SIG3 ... SIGN[N]
# eg: traps exit_function QUIT INT TERM EXIT
traps() {
  local clean_function
  clean_function="$1"
  shift
  for sig; do
    trap "${clean_function} ${sig}" "${sig}"
  done
}

# This function is used by traps() function to clean exit
script_exit() {
  # The first argument will have the name of the trap signal executed:
  # eg: echo "Trapped: $1"
  # This variable hold the count of key press of CTRL+C
  ((CTRL_C_COUNT++))
  # Check if the locking directory is exist, if yes, remove it
  if [ -d "${LOCK_DIR}" ]; then
    rm -rf "${LOCK_DIR}"
    #echo ""
    #echo "OK, locked flag removed from ${LOCK_DIR}"
  fi
  # this if condition will determine that this cleanup function is only called a single time CTRL_C_COUNT=1
  # this function might be called several times because we passed long arguments for trap to call this function
  if [[ ${CTRL_C_COUNT} == 1 ]]; then
    local signal
    signal="$1"
    echo ""
    # if the trapped signal is INT (or interactive) then we know this is interactive exit executed by a user.
    if [ "${signal}" == "INT" ]; then
      # so print the current user who terminated this script
      msg "$(s yellow)*** Warning, this script has been terminated by user: $(s red)${USER}!$(e) $(s yellow)***$(e)" --caller="${SCRIPT_NAME}"
      # Check if trap with other signal here
      #elif [ "${signal}" == "OTHER_SIGNAL" ]; then
      :
    else
      # for other trap signals that we don't care, we just print out the trap signal type
      msg "$(s cyan)This script has been terminated with signal:$(e) $(s red)${signal}$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""
    echo "-------------------------------END-----------------------------------------"
    echo ""
    echo "Remember you can always resume installation with the following command:"
    echo "For local installation: ${SCRIPT_NAME} setup 2>&1 | tee ${SCRIPT_NAME}.log"
    echo "For remote installation: ${SCRIPT_NAME} --push-ssh-script --sp ${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT} --gu root:${C_ROOT_USERNAME} --push-maxinet-setup-script"
    echo ""
    echo "SSH user login guide:"
    echo "To login as root user: ${SCRIPT_NAME} ssh-login ${C_ROOT_USERNAME} or ${SCRIPT_NAME} login"
    echo "To login as SSH user: ${SCRIPT_NAME} ssh-login ${C_SSH_USERNAME}"
    echo ""
    echo "Server LUKS unlock guide:"
    echo "To unlock LUKS Disk encryption: ${SCRIPT_NAME} --luks-unlock"
    echo ""
    script_time
    echo ""
  fi
  # clean exit
  exit 1
}

get_listening_port() {
  local port
  port="$1"
  netstat -na | grep "${port}"
}

generate_unused_port() {
  local port
  read -r lowerport upperport </proc/sys/net/ipv4/ip_local_port_range
  while :; do
    port="$(shuf -i "${lowerport}-${upperport}" -n 1)"
    ss -lpn | grep -q ":${port} " || break
  done
  echo "${port}"
}
# Directadmin debug exit trap
da_debug_exit() {
  # echo "Trapped: $1"
  ((CTRL_C_COUNT++))
  if [[ $CTRL_C_COUNT == 1 ]]; then
    local signal
    signal="$1"
    echo ""
    if [ "${signal}" == "INT" ]; then
      echo "*** Warning, Directadmin debug mode has been terminated by ${USER}! ***"
    fi
    echo "Starting directadmin in normal mode ..."
    systemctl restart directadmin
    echo "Directadmin running status is: $(systemctl is-active directadmin)"
    echo ""
    echo "                             **END DEBUG**                        "
    echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
  fi
  # clean exit
  exit 1
}

# This function will read current status of the last script passed to the first argument whether it is return 0 or not
# If it returns 0, display [ OK ] else display [ FAILED ] and exit
get_status_message() {
  local retval
  retval="$1"
  if [[ "${retval}" -eq 0 ]]; then
    echo " [ OK ]"
  else
    echo " [ FAILED ]"
    exit 1
  fi
}

get_ordinal() {
  local integer
  integer="$1"
  case "${integer}" in
  *1[0-9] | *[04-9]) echo "${integer}"th ;;
  *1) echo "${integer}"st ;;
  *2) echo "${integer}"nd ;;
  *3) echo "${integer}"rd ;;
  esac
}
# This function will pause the current running terminal
# It will interactively ask to press enter or wait within <duration_in_seconds> to continue the next command
# syntax: _pause <optional_duration>
# eg: _pause | no timeout means we need to press enter to continue
# eg: _pause 10 | wait 10 seconds or press enter to continue
_pause() {
  echo ""
  local duration=$1
  # If argument is not an integer, we disable read timeout
  # TODO validate this statement again
  if [[ ${duration} =~ ^[0-9]+$ ]]; then
    read -t "${duration}" -r -s -n 1 -p "[${SCRIPT_NAME}]: Press any key or wait within ${duration} second(s) to continue or press (Ctrl+c) to cancel ..."
  else
    read -r -s -n 1 -p "[${SCRIPT_NAME}]: Terminal is paused! Press any key to continue or press (Ctrl+c) to cancel ..."
  fi
  echo ""
}

# This function will display a confirmation to continue (force continue; no exit function)
_confirm() {
  # call with a prompt string or use a default
  read -r -p "[${SCRIPT_NAME}->${FUNCNAME[0]}->input]: ${1:-Continue? [y] Exit? [CTRL+C]} " response
  case "$response" in
  [yY][eE][sS] | [yY])
    return 0
    ;;
  *)
    msg "Error, invalid response to the question!" --msg-type=error --caller="${SCRIPT_NAME}->${FUNCNAME[0]}->invalid"
    _confirm "$1"
    ;;
  esac
}

# This function is used to ask the next action.
# Usage: _ask [message] [default-response]
# Example: _ask "Do you want to continue?" "y"
_ask() {
  local text default_response
  text=$1
  default_response=$2
  if [ -z "${default_response}" ]; then
    default_response="Y"
  fi
  read -r -p "[${SCRIPT_NAME}->${FUNCNAME[0]}->input]: ${text} [default:${default_response}] [Y/n]: " response
  # Simulate a default response so that we can press Enter key
  if [[ -z "${response}" ]]; then
    response="${default_response}"
  fi
  if [[ "$response" =~ ^([yY][eE][sS]|[yY])$ ]]; then
    return 0
  else
    msg "Operating aborted" --msg-type=info --caller="${SCRIPT_NAME}->${FUNCNAME[0]}->cancel"
    exit 0
  fi
}
# This function is used to terminate a current running script.
# pass the normal exit code
# syntax: _exit <exit_code>
# eg: _exit 3
_exit() {
  exit "$1"
}

# This function is used to reboot the system using force reboot -r now without any arguments
# syntax _reboot
_reboot() {
  # an exit ASCII symbol invented by MaXi32
  msg "Rebooting system ..."
  echo "--<]--"
  shutdown -r now
}

# This function is used to shutdown the system using force shutdown -h now without any arguments
# syntax _shutdown
_shutdown() {
  # a shutdown ASCII symbol invented by MaXi32
  msg "Shutting down system ..."
  echo "--[]--"
  shutdown -h now
}

# decode URL, use with echo -n "string" | urldecode or printf %s "string" | urldecode
urldecode() {
  printf '%b\n' "$(sed 's/+/ /g;s/%\(..\)/\\x\1/g;')"
}
# encode URL, use with echo -n "string" | urlencode or printf %s "string" | urlencode
urlencode() {
  maxibuild --include "jq"
  printf '%b\n' "$(jq -sRr @uri)"
}

# This function will print all text as multiple row separated by separator symbol. Usage example:
# echo "Test=19-&Hello=2+" | awksep '&'
# output:
# Test=19-
# Hello=2+
awksep() {
  local separator="$1"
  printf '%b\n' "$(awk -F"${separator}" '{for(i=1;i<=NF;++i)print $i }')"
}

# This function set_linux_crlf will automatically remove CRLF character in file to make sure file is compatible with linux
# It does not return error if the file is already in unix format before
set_linux_crlf() {
  local files retval
  files="$1"
  maxibuild --include "dos2unix"
  for file in ${files}; do
    echo "Checking and converting file [ ${file} ] into unix compatible file ..."
    dos2unix <"${file}" | cmp - "${file}" 2>&1
    retval=$?
    if [ "${retval}" -ne 0 ]; then
      dos2unix "${file}"
    fi
    echo ""
  done
}

script_header() {
  # This is script header
  msg "$(s red)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)"
  msg "$(s cyan)Welcome to $(s red)${_APP_SPECIFIC_NAME}$(s cyan) Automated Script on (${C_HOST_TYPE})$(e)"
  msg "$(s blue)This powerful script is part of Sofibox/MaxiNet scripts$(e)"
  msg "$(s green)For script help: $(s yellow)${SCRIPT_NAME} --help$(e)"
  msg "$(s green)Script official URL: $(s yellow)http://sofibox.com/maxinet$(e)"
  msg "$(s green)Version: $(s yellow)${SCRIPT_NAME}-${_APP_VERSION_STATUS}$(e)"
  msg "$(s green)Distro ID: $(s yellow)${DISTRO_ID}$(e) | $(s green) Distro Version: $(s yellow)${DISTRO_VERSION}$(e)"
  msg "$(s green)Hostname: $(s magenta)$(hostname)$(e) | $(s green) Public IP: $(s magenta)${C_HOST_PUBLIC_IP}$(e)"
  msg "$(s cyan)$(s bold)(C) Author: Arafat Ali | Email: arafat@sofibox.com$(e)"
  msg "$(s red)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)"
  msg "$(s yellow)Running date and time: ${DATE_TIME_NOW}$(e)" --caller="${SCRIPT_NAME}"
  msg ""
}

help() {
  # This help section is deprecated, will update time to time when the code finish
  echo ""
  echo "Welcome to help section!"
  echo "------------------------"
  echo ""
  echo "To deploy a new server automatically with log output: "
  echo "==============="
  echo "${SCRIPT_NAME} create-server --rebuild-all 2>&1 | tee ${SCRIPT_NAME}.log"
  echo "OR with ISO backup"
  echo "${SCRIPT_NAME} create-server --rebuild-all --backup 2>&1 | tee ${SCRIPT_NAME}.log"
  echo "Note: These arguments are optional for installation log that can be omitted -> 2>&1 | tee ${SCRIPT_NAME}.log"
  echo "==============="
  echo ""
  echo "To start/resume local installation: "
  echo "==============="
  echo "${SCRIPT_NAME} setup 2>&1 | tee ${SCRIPT_NAME}.log"
  echo "==============="
  echo ""
  echo "To start/resume remote installation:"
  echo "==============="
  echo "Syntax: ${SCRIPT_NAME} ssh-login <fqdn>:<ssh_port> <user_role>:<user_name> <local_script_to_push_for_installation>"
  echo "${SCRIPT_NAME} ssh-login \"${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}\" \"root:${C_ROOT_USERNAME}\" \"${CODE_PATH}/ssh_scripts/maxinet_setup.sh\""
  echo "==============="
  echo ""
  echo "To unlock LUKS Disk encryption without login into terminal:"
  echo "==============="
  echo "Syntax: ${SCRIPT_NAME} --ssh-luks-unlock <DROP_BEAR_PORT> \"<LUKS_PASS>\""
  echo "eg:"
  echo "${SCRIPT_NAME} --ssh-luks-unlock ${C_DROP_BEAR_PORT} \"${C_LUKS_PASS}\""
  echo "==============="
  echo ""
  echo "To login server as a root user:"
  echo "==============="
  echo "${SCRIPT_NAME} ssh-login \"${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}\" \"user:root\" OR maxinet login"
  echo "Note: this will automatically unlock LUKS disk"
  echo "==============="
  echo ""

  echo "To login as an SSH user:"
  echo "==============="
  echo "${SCRIPT_NAME} ssh-login \"${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}\" \"root:${C_SSH_USERNAME}\""
  echo "Note: this will automatically unlock LUKS disk"
  echo "==============="
  echo ""
  echo "There are a lot more, this section is developing ..."
}

manual() {
  # This help section is deprecated, will update time to time when the code finish
  local manual_name="$1"
  if [ "${manual_name}" == "init_server" ]; then
    local lopt="--init-server"
    echo "----------------------------------------------"
    echo "Help section for ${SCRIPT_NAME}/${manual_name}"
    echo "----------------------------------------------"
    echo "CALL METHOD"
    echo ""
    echo "FOR EXTERNAL CALL: ${SCRIPT_NAME} ${lopt} --help"
    echo "FOR INTERNAL CALL: ${manual_name} --help"
    echo ""
    echo "SYNTAX 1: "
    echo ""
    echo "${SCRIPT_NAME} ${lopt} *<long-option1> +<long-option2> ... +<long-optionN>"
    echo ""
    echo "EXAMPLE SYNTAX 1: "
    echo ""
    echo "${SCRIPT_NAME} ${lopt} --rebuild-iso --backup-ssh-key --backup-iso"
    echo "EXAMPLE SYNTAX 2: "
    echo ""
    echo "${SCRIPT_NAME} ${lopt} --rebuild-all --backup-all"
    echo ""
    echo "DESCRIPTION"
    echo ""
    echo "1) <LONG OPTIONS>"
    echo "--rebuild-iso  -  rebuild server OS ISO image from scratch"
    echo "--rebuild-partition  -  rebuild server disk partition from scratch"
    echo "--rebuild-config - rebuild server config from scratch"
    echo "--rebuild-all  -  rebuild everything from the above"
    echo "--backup-ssh-key - backup server previous ssh key file (both private and public keys)"
    echo "--backup-iso  -  backup server previous OS ISO image file"
    echo "--backup-all  -  backup everything from the above"
    echo ""
    echo "NOTE 1:"
    echo ""
    echo "${SCRIPT_NAME} --init-server --rebuild-iso --rebuild-partition --rebuild-config"
    echo "is equivalent to"
    echo "${SCRIPT_NAME} --rebuild-all"

    echo ""
    echo "NOTE 2:"
    echo ""
    echo "${SCRIPT_NAME} --init-server --backup-ssh-key --backup-iso"
    echo "is equivalent to"
    echo "${SCRIPT_NAME} --backup-all"
    echo ""
    echo "NOTE 3:"
    echo ""
    echo "Can only accept long options that begins with 2 dashes --. eg: --rebuild-iso"
    echo ""
  fi
}

# Create dynamic variable
# variable_api <required action> <required VARIABLE --name> <optional --value>
# variable_api create-variable --name myvariable --value hello | this creates variable name with value hello
# variable_api create-variable --name testvariable | this creates a variable name testvariable without value
# variable_api get-variable-value --name testvariable | this will display the variable testvariable value
variable_api() {
  local action argnum options retval name value
  action="$1"
  argnum="$#"
  if [ ${argnum} -eq 0 ]; then
    echo "Error, no argument is supplied. Use [ ${SCRIPT_NAME} --create-var --help ] to see the valid options"
    exit 1
  fi
  short_opts=""
  long_opts="help,name:,value:"
  options=$(getopt -o "${short_opts}" --long "${long_opts}" -n "${FUNCNAME[0]} in ${SCRIPT_NAME}" -- "$@")
  retval=$?
  if [ "${retval}" != 0 ]; then
    echo "Error, invalid parse data. Terminating..."
    exit 1
  fi

  # Must quote this option variable
  eval set -- "${options}"

  name=""
  value=""
  while true; do
    case "$1" in
    --help)
      manual "${FUNCNAME[0]}"
      shift
      exit 0
      ;;
    --name)
      name="$2"
      shift 2
      ;;
    --value)
      value="$2"
      shift 2
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
    esac
  done
  if [ "${action}" == "create-variable" ]; then
    if [ -z "${name}" ]; then
      echo "Error, the option --name is required!"
      _exit 1
    fi
    # Put option -g for global variable
    if [ -n "${value}" ]; then
      declare -g "VAR_${name}=${value}"
    else
      declare -g "VAR_${name}"
    fi
  elif [ "${action}" == "get-variable-value" ]; then
    local dv
    if [ -z "${name}" ]; then
      echo "Error, the option --name is required!"
      _exit 1
    fi
    dv="VAR_${name}"
    echo "${!dv}"
  else
    echo "Error, invalid action for variable_api!"
    exit 147
  fi
}

# This function validate all data argument. Eg: check if the domain name provided is FQDN or valid
# is_valid server_record_type <data>
is_valid() {
  local type data1 data2 retval distro_id
  type="$1"
  data1="$2"
  data2="$3"
  distro_id="${DISTRO_ID}"

  maxibuild --include "iproute2"
  # is_valid version_required  <required_version> <current_version>
  if [[ "${type}" == "version_required" || "${type}" == "version_needed" ]]; then
    local current_version required_version
    required_version="${data1}"
    current_version="${data2}"
    if [ "$(printf '%s\n' "${required_version}" "${current_version}" | sort -V | head -n1)" = "${required_version}" ]; then
      return 0
    else
      return 1
    fi
  # is_valid ipv4-resolved 1.1.1.1 sun.server.com
  # is_valid ipv4_resolved
  elif [[ "${type}" == "ipv4-resolved" || "${type}" == "ipv4_resolved" ]]; then
    maxibuild --include "dnsutils"
    local ipv4 ipv4_propagated domain
    ipv4="${data1}"
    domain="${data2}"
    if [ -z "${domain}" ]; then
      domain="${C_BOX_HOSTNAME_FQHN}"
    fi

    ipv4_propagated=$(dig "${domain}" A +short)
    if [ "${ipv4_propagated}" = "${ipv4}" ]; then
      return 0
    else
      return 1
    fi

    # is_valid ipv6-resolved 1.1.1.1 sun.server.com
    # is_valid ipv6_resolved
  elif [[ "${type}" == "ipv6-resolved" || "${type}" == "ipv6_resolved" ]]; then
    maxibuild --include "dnsutils"
    local ipv6 ipv6_propagated domain
    ipv6="${data1}"
    domain="${data2}"
    if [ -z "${domain}" ]; then
      domain="${C_BOX_HOSTNAME_FQHN}"
    fi
    ipv6_propagated=$(dig ${domain} AAAA +short)
    if [ "${ipv6_propagated}" == "${ipv6}" ]; then
      return 0
    else
      return 1
    fi

  # subnet regex matching between 1-256
  elif [[ "${type}" == "ipv6_prefix" || "${type}" == "ipv6_subnet" ]]; then
    local ipv6_prefix ipv6_prefix_pattern
    ipv6_prefix="${data1}"
    ipv6_prefix_pattern='^(\/)\b(1?[1-9]{1,2}|2[0-4][0-9]|25[0-5])\b'
    if [[ ${ipv6_prefix} =~ ${ipv6_prefix_pattern} ]]; then
      return 0
    else
      return 1
    fi
    # subnet regex matching between 1-31
  elif [[ "${type}" == "ipv4_prefix" || "${type}" == "ipv4_subnet" ]]; then
    local ipv4_prefix ipv4_prefix_pattern
    ipv4_prefix="${data1}"
    ipv4_prefix_pattern='^(\/)\b([1-9]|[1-2][0-9]|3[0-1])\b'
    if [[ ${ipv4_prefix} =~ ${ipv4_prefix_pattern} ]]; then
      return 0
    else
      return 1
    fi
    #if is_valid ssl_site "${C_BOX_HOSTNAME_FQHN}:${C_DA_PORT}"; then
  elif [[ "${type}" == "ssl_site" ]]; then
    local url final_hostname status
    url="${data1}"
    # echo "url: ${url}
    host "${url}" >/dev/null 2>&1
    retval=$?
    if [ "${retval}" -eq 0 ]; then
      #echo "Link is valid"
      # Use timeout 3 instead of the built-in function because the built in function --max-wait does not work
      # This will get the final redirection for a hostname
      final_hostname=$(timeout 3 curl "${url}" -s -L -I -o /dev/null -w '%{url_effective}' | awk -F[/:] '{print $4}')
      #echo "URL: ${url}"
      #echo "FINAL_HOSTNAME: ${final_hostname}"
      #echo "PORT: ${port}"
      status=$(curl --cert-status -v "https://${final_hostname}" 2>&1 | awk 'BEGIN { cert=0 } /^\* Server certificate:/ { cert=1 } /^\*/ { if (cert) print }' | grep "\*  SSL certificate verify ok.")
      #status=$(timeout 3 openssl s_client -connect "${final_hostname}:${port}" </dev/null 2>/dev/null | grep 'Verify return code: 0 (ok)')
      if [ -n "${status}" ]; then
        #echo "Site ${final_hostname} with port ${port} is valid https"
        return 0
      else
        return 1
        #echo "Site ${final_hostname} with port ${port} is not valid https"
      fi
    else
      #echo "Link is not valid"
      return 1
    fi

  # is_valid available_port <server> <port>
  # This function will check if defined server and port is available (in a listening state)
  # Usage: available_port <server> <port>
  # eg: available_port test.sofibox.com 22
  # It will return 0 (if available), and other return codes (if listening state for the port is not available)
  elif [[ "${type}" == "available_port" ]]; then
    local server port retval
    server="${data1}"
    port="${data2}"
    nc -z -v -w5 "${server}" "${port}" 2>/dev/null
    retval=$?
    return ${retval}

  elif [[ "${type}" == "integer" ]]; then
    if [[ ${data1} =~ [0-9] ]]; then
      return 0
    else
      return 1
    fi
  elif [[ "${type}" == "domain" ]]; then
    if grep -oP '(?=^.{4,253}$)(^(?:[a-zA-Z0-9](?:(?:[a-zA-Z0-9\-]){0,61}[a-zA-Z0-9])?\.)+([a-zA-Z]{2,}|xn--[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])$)' <<<"${data1}" >/dev/null 2>&1; then
      #if grep -oP '^((?!-)[A-Za-z0-9-]{1,63}(?<!-)\.)+[A-Za-z]{2,6}$' <<< "$1" >/dev/null 2>&1;then
      return 0
      # do another check using host if regex above detected as false and return either true or false
    else
      host "${data1}" >/dev/null 2>&1
      retval=$?
      return "${retval}"
    fi

  elif [[ "${type}" == "domain_type" ]]; then
    # Convert to capital with ^^ and compare with capital letters
    if [[ "${data1^^}" == +(MASTER|SLAVE) ]]; then
      return 0
    else
      return 1
    fi
    # For linode case ttl
    #  record_ttl="300" # 300(5m), 3600(1h), 7200(2h), 14400(4h), 28800(8h), 57600(16h), 0/86400(1d)-Default, 172800(2d), 345600(4d), 691200(8d), 604800(1w), 1209600(2w), 2419200(4w).
  elif [[ "${type}" == "domain_ttl" ]]; then
    if [[ ${data1} -ge 30 && ${data1} -le 2419200 && ${data1} =~ ^[0-9]+$ ]]; then
      return 0
    else
      return 1
    fi
  elif [[ "${type}" == "record_ttl" ]]; then
    if [[ ${data1} -ge 30 && ${data1} -le 2419200 && ${data1} =~ ^[0-9]+$ ]]; then
      return 0
    else
      return 1
    fi
  elif [[ "${type}" == "record_type" ]]; then
    # Convert to capital with ^^ and compare with capital letters
    if [[ "${data1^^}" == +(NS|MX|A|AAAA|TXT|CNAME|SRV|CAA) ]]; then
      return 0
    else
      return 1
    fi
  elif [[ "${type}" == "record_priority" ]]; then
    if [[ ${data1} -ge 0 && ${data1} -le 255 && ${data1} =~ ^[0-9]+$ ]]; then
      return 0
    else
      return 1
    fi
  elif [[ "${type}" == "email" ]]; then
    if [[ "${data1}" =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$ ]]; then
      return 0
    else
      return 1
    fi
  elif [[ "${type}" == "server_record_valid_character" ]]; then

    if ! [[ ${data1} == *['!'@#\$%^\&*()+]* ]]; then
      return 0
    else
      return 1
    fi
    #Check ipv4
  elif [[ "${type}" == "ipv4" ]]; then
    local ipv4="${data1}" ipv4_pattern='^(([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))\.){3}([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))$'

    if [[ "${ipv4}" =~ ${ipv4_pattern} ]]; then
      retval=0
      # Using this command will check IP is reachable ( do not use )
      #if command -v ip &>/dev/null; then
      #method_bin=$(command -v ip)
      #"${method_bin}" route get "${ipv4}" >/dev/null 2>&1
      #retval=$?

      #else
      #  #msg "$(s yellow)Warning, unable to find suitable binary for checking ipv4 or ipv6 address. $(e)" --caller="${SCRIPT_NAME}"
      #  retval=1
      #fi
    else
      retval=1
    fi

    return ${retval}
    # Check ipv6
  elif [[ "${type}" == "ipv6" ]]; then
    local ipv6="${data1}" ipv6_pattern method_bin retval
    ipv6_pattern='^([0-9a-fA-F]{0,4}:){1,7}[0-9a-fA-F]{0,4}$'
    if [[ ${ipv6} =~ ${ipv6_pattern} ]]; then
      retval=0
      # Using this command will check IP is reachable ( do not use )
      #if command -v ip &>/dev/null; then
      #  method_bin=$(command -v ip)
      #  "${method_bin}" route get "${ipv6}" >/dev/null 2>&1
      #  retval=$?
      #else
      #  #msg "$(s yellow)Warning, unable to find suitable binary for checking ipv4 or ipv6 address. $(e)" --caller="${SCRIPT_NAME}"
      #  retval=1
      #fi

    else
      retval=1
    fi

    return ${retval}
    # Check both ipv4 and ipv6 (does not work if ip is not reachable)
  elif [[ "${type}" == "ipv46" ]]; then
    local ip="${data1}" method_bin retval

    if command -v ip &>/dev/null; then
      method_bin=$(command -v ip)
      ${method_bin} route get "${ip}" >/dev/null 2>&1
      retval=$?
    else
      #msg "$(s yellow)Warning, unable to find suitable binary for checking ipv4 or ipv6 address. $(e)" --caller="${SCRIPT_NAME}"
      retval=1
    fi
    return ${retval}

  elif [[ "${type}" == "not-empty-string" ]]; then
    if [ -n "${data1}" ]; then
      return 0
    else
      return 1
    fi

  elif [[ "${type}" == "valid-linode-disk-filetype" ]]; then
    if [[ "${data1^^}" == +(RAW|SWAP|EXT3|EXT4|INITRD) ]]; then
      return 0
    else
      return 1
    fi
    # if is_valid sha256sum data1 data2; then
  elif [[ "${type}" == "sha256sum" ]]; then
    local retval
    echo "${data1}" "${data2}" | sha256sum --check &>/dev/null
    retval=$?
    return ${retval}
  fi
}

init_server_rebuild_config() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    msg "Deleting all linode config profiles ..." --caller="${SCRIPT_NAME}"
    maxipi linode delete-configs --for-linode-label "${C_BOX_HOSTNAME_FQHN}" --without-prompt
    get_status_message "$?"
    echo ""

    # For installer
    msg "Creating a linode config ${C_LINODE_BOOT_CONFIG_LABEL} ..." --caller="${SCRIPT_NAME}"
    maxipi linode create-config --for-linode-label "${C_BOX_HOSTNAME_FQHN}" --config-label "${C_LINODE_BOOT_CONFIG_LABEL}" --config-comments "The installer boot configuration" \
      --config-kernel "linode/direct-disk" --config-rootdev "/dev/sdb" --dev-sda "disk:${C_LINODE_OS_DISK_LABEL}" --dev-sdb "disk:${C_LINODE_BOOT_DISK_LABEL}"
    get_status_message "$?"
    echo ""

    # For operating system boot
    msg "Creating linode config ${C_LINODE_OS_CONFIG_LABEL} ..." --caller="${SCRIPT_NAME}"
    maxipi linode create-config --for-linode-label "${C_BOX_HOSTNAME_FQHN}" --config-label "${C_LINODE_OS_CONFIG_LABEL}" --config-comments "The operating boot configuration" \
      --config-kernel "linode/direct-disk" --config-rootdev "/dev/sda" --dev-sda "disk:${C_LINODE_OS_DISK_LABEL}"
    get_status_message "$?"
    echo ""

    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

init_server_rebuild_partition() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    ((box_os_disk = server_main_disk_raw_size - server_boot_disk_raw_size))
    server_main_disk_raw_size="${C_BOX_MAIN_DISK_RAW_SIZE}"
    server_boot_disk_raw_size="${C_BOX_BOOT_DISK_RAW_SIZE}"

    msg "Deleting all linode disks ..." --caller="${SCRIPT_NAME}"
    maxipi linode delete-disks --for-linode-label "${C_BOX_HOSTNAME_FQHN}" --check-for-busy-status --without-prompt
    retval=$?

    if [ "${retval}" -ne 0 ]; then
      msg "Skipped deleting all disks ..." --caller="${SCRIPT_NAME}" --msg-type="warning"
    fi

    echo ""

    # Create Boot Disk that boot the operating system installer with raw format
    msg "Creating linode boot disk for boot header ..." --caller="${SCRIPT_NAME}"
    maxipi linode create-disk --for-linode-label "${C_BOX_HOSTNAME_FQHN}" --disk-label "${C_LINODE_BOOT_DISK_LABEL}" --disk-filetype "raw" --disk-size "${server_boot_disk_raw_size}" --check-for-busy-status --wait-until-disk-status ready
    get_status_message "$?"
    echo ""

    msg "Creating linode OS disk for operating system installer ..." --caller="${SCRIPT_NAME}"
    maxipi linode create-disk --for-linode-label "${C_BOX_HOSTNAME_FQHN}" --disk-label "${C_LINODE_OS_DISK_LABEL}" --disk-filetype "raw" --disk-size "${box_os_disk}" --check-for-busy-status --wait-until-disk-status ready
    get_status_message "$?"
    echo ""

    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Configure dropbox for both local and remote server
configure_dropbox_cli() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local script_install_path
    script_install_path="/usr/local/opencode/dbxcli"

    msg "$(s cyan)Configuring dbxcli (Dropbox Uploader) forked from andreafabrizi/Dropbox-Uploader ... $(e)" --caller="${SCRIPT_NAME}"

    maxibuild --include dbxcli

    echo ""
    msg "$(s cyan)Copying ${script_install_path}/dropbox_uploader.conf.sample to ${HOME}/.dropbox_uploader ...$(e)" --caller="${SCRIPT_NAME}"
    cp -f "${script_install_path}/dropbox_uploader.conf.sample" "${HOME}/.dropbox_uploader.conf"
    echo ""
    msg "Configuring dbxcli API authentication ..."
    sed -i "s|^CONFIGFILE_VERSION\=.*|CONFIGFILE_VERSION=\"2.0\"|" "${HOME}/.dropbox_uploader.conf"
    sed -i "s|^OAUTH_APP_KEY\=.*|OAUTH_APP_KEY=\"${C_DROPBOX_OAUTH_APP_KEY}\"|" "${HOME}/.dropbox_uploader.conf"
    sed -i "s|^OAUTH_APP_SECRET\=.*|OAUTH_APP_SECRET=\"${C_DROPBOX_OAUTH_APP_SECRET}\"|" "${HOME}/.dropbox_uploader.conf"
    get_status_message "$?"

    if command -v dbxcli &>/dev/null; then

      dbxcli reauth

    else
      msg "$(s red)Error, dbxcli is not installed. Please install it first. $(e)" --caller="${SCRIPT_NAME}"
      exit 1

    fi

    dbxcli test

    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

update_remote() {

  local data file_to_transfer remote_path_to_receive

  data="$1"

  if [ "${data}" == "all" ]; then

    msg "$(s cyan)Copying all setup files into server ... $(e)" --caller="${SCRIPT_NAME}"

    # Main script to update
    check_path "${SCRIPT_PATH}/maxinet" "${SCRIPT_PATH}/maxinet.conf" "${SCRIPT_PATH}/readme.txt"
    file_to_transfer="${SCRIPT_PATH}/maxinet ${SCRIPT_PATH}/maxinet.conf ${SCRIPT_PATH}/readme.txt"
    remote_path_to_receive="${HOME}/"
    ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "${C_ROOT_USERGROUP}:${C_ROOT_USERNAME}" --local-files "${file_to_transfer}" --remote-path "${remote_path_to_receive}"
    echo ""

    # GPG private key to update
    file_to_transfer="${SECURE_PATH}/gpg/gpg_private_key.gpg"
    remote_path_to_receive="${HOME}/gpg/"
    ssh_api mkdir --server-port ${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT} --group-user ${C_ROOT_USERGROUP}:${C_ROOT_USERNAME} --remote-path "${remote_path_to_receive}"
    ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "${C_ROOT_USERGROUP}:${C_ROOT_USERNAME}" --local-files "${file_to_transfer}" --remote-path "${remote_path_to_receive}"
    echo ""

    # SSL cert to update
    file_to_transfer="${SECURE_PATH}/ssl/*"
    remote_path_to_receive="${HOME}/ssl/"
    ssh_api mkdir --server-port ${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT} --group-user ${C_ROOT_USERGROUP}:${C_ROOT_USERNAME} --remote-path "${remote_path_to_receive}"
    ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "${C_ROOT_USERGROUP}:${C_ROOT_USERNAME}" --local-files "${file_to_transfer}" --remote-path "${remote_path_to_receive}"
    echo ""

    # Backup file to update
    file_to_transfer="${SECURE_PATH}/backup/admin_backups/current_backups/*"
    remote_path_to_receive="${HOME}/admin_backups/"
    ssh_api mkdir --server-port ${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT} --group-user ${C_ROOT_USERGROUP}:${C_ROOT_USERNAME} --remote-path "${remote_path_to_receive}"
    ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "${C_ROOT_USERGROUP}:${C_ROOT_USERNAME}" --local-files "${file_to_transfer}" --remote-path "${remote_path_to_receive}"
    echo ""

    # maxiaide / AIDE custom_rules file
    file_to_transfer="${SECURE_PATH}/maxiaide/custom_rules"
    remote_path_to_receive="${HOME}/maxiaide/"
    ssh_api mkdir --server-port ${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT} --group-user ${C_ROOT_USERGROUP}:${C_ROOT_USERNAME} --remote-path "${remote_path_to_receive}"
    ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "${C_ROOT_USERGROUP}:${C_ROOT_USERNAME}" --local-files "${file_to_transfer}" --remote-path "${remote_path_to_receive}"
    echo ""

    # maxiclam / maxiclam exclude scan files
    file_to_transfer="${SECURE_PATH}/maxiclam/*"
    remote_path_to_receive="${HOME}/maxiclam/"
    ssh_api mkdir --server-port ${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT} --group-user ${C_ROOT_USERGROUP}:${C_ROOT_USERNAME} --remote-path "${remote_path_to_receive}"
    ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "${C_ROOT_USERGROUP}:${C_ROOT_USERNAME}" --local-files "${file_to_transfer}" --remote-path "${remote_path_to_receive}"
    echo ""

    # add directadmin custom hook scripts
    file_to_transfer="${SECURE_PATH}/directadmin/custom_scripts/*"
    remote_path_to_receive="${HOME}/directadmin/custom_scripts"
    ssh_api mkdir --server-port ${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT} --group-user ${C_ROOT_USERGROUP}:${C_ROOT_USERNAME} --remote-path "${remote_path_to_receive}"
    ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "${C_ROOT_USERGROUP}:${C_ROOT_USERNAME}" --local-files "${file_to_transfer}" --remote-path "${remote_path_to_receive}"
    echo ""

  elif [ "${data}" == "da-hook-script" ]; then
    msg "$(s cyan)Copying da-hook-script files into server ... $(e)" --caller="${SCRIPT_NAME}"

    # add directadmin custom hook scripts
    file_to_transfer="${SECURE_PATH}/directadmin/custom_scripts/*"
    remote_path_to_receive="${HOME}/directadmin/custom_scripts"
    ssh_api mkdir --server-port ${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT} --group-user ${C_ROOT_USERGROUP}:${C_ROOT_USERNAME} --remote-path "${remote_path_to_receive}"
    ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "${C_ROOT_USERGROUP}:${C_ROOT_USERNAME}" --local-files "${file_to_transfer}" --remote-path "${remote_path_to_receive}"
    echo ""

  elif [ "${data}" == "setup-script-only" ]; then
    msg "$(s cyan)Copying maxinet setup scripts into server ... $(e)" --caller="${SCRIPT_NAME}"

    # Main script to update
    check_path "${SCRIPT_PATH}/maxinet" "${SCRIPT_PATH}/maxinet.conf" "${SCRIPT_PATH}/readme.txt"
    file_to_transfer="${SCRIPT_PATH}/maxinet ${SCRIPT_PATH}/maxinet.conf ${SCRIPT_PATH}/readme.txt"
    remote_path_to_receive="${HOME}/"
    ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "${C_ROOT_USERGROUP}:${C_ROOT_USERNAME}" --local-files "${file_to_transfer}" --remote-path "${remote_path_to_receive}"
    echo ""
  else
    msg "$(s red)Error, unknown argument passed for update_remote function  ... $(e)" --caller="${SCRIPT_NAME}"
  fi

}

ensure_internet_connected() {
  maxibuild --include "curl"
  if curl -s --head --request GET www.google.com | grep "200 OK" >/dev/null; then
    #echo "OK, connected to the internet"
    return 0
  else
    echo "Error, could not connect to the internet"
    exit 147
  fi
}

ensure_linode_label_ipv4_valid() {
  # Because labelling is important, it must be unique to represent that node is a hostname (1 node = 1 hostname)
  echo -n "Checking if linode label is matched with the host domain name ${C_LINODE_LABEL} ... "
  while :; do
    # linode_api_admin get-linode-ipv4 --scripting
    readarray -t linode_current_ipv4s <<<"$(maxipi linode get-linode-ipv4 --scripting)"
    match_label=false
    match_ip=false
    count_ip=0
    while [[ ${count_ip} -lt $(echo "${!C_IPV4_ADD@}" | wc -w) ]]; do
      local c_ipv4_add
      typeset -n c_ipv4_add="C_IPV4_ADD${count_ip}"
      for linode_current_ipv4 in "${linode_current_ipv4s[@]}"; do
        if [[ "${linode_current_ipv4}" == "${c_ipv4_add}" ]]; then
          match_ip=true
          #  linode_current_label=$(linode-cli --pretty --json linodes list | jq -r ".[] | select(.ipv4 | .[] == \"${c_ipv4_add}\") | .label")
          linode_current_label=$(maxipi linode get-linode-label --ip-address "${c_ipv4_add}" --scripting)
          # echo "Checking linode_current_label for IP ${linode_current_ipv4} if match with ${linode_current_label} (linked with IPv4)"
          # Since this script manage only 1 host name pertime, so we need to make sure it is matched with C_LINODE_LABEL and break
          if [ "${linode_current_label}" == "${C_LINODE_LABEL}" ]; then
            msg "$(s green) [OK]$(e)"
            count_ip=$(echo "${!C_IPV4_ADD@}" | wc -w) # Stop the outer loop
            match_label=true
            break
          fi
        fi
      done
      ((count_ip++))
    done
    if [ "${match_ip}" == "false" ]; then
      echo ""
      msg "warning no ipv4 from config file match in linode, please check at least one IPv4 is correctly defined in config file" --caller="${SCRIPT_NAME}" --msg-type="warning"
      exit 1
    fi
    if [ "${match_label}" == "false" ]; then
      msg "$(s red) [FAILED]$(e)"
      echo ""
      msg "$(s cyan)The current linode label value is ${linode_current_label} ...$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s cyan)Updating the current linode label to ${C_LINODE_LABEL} ...$(e)" --caller="${SCRIPT_NAME}"
      maxipi linode update-linode --for-linode-label "${linode_current_label}" --linode-label "${C_LINODE_LABEL}"
      get_status_message "$?"
      echo ""
      msg "Re-checking if linode label is matched with the host domain name ${C_LINODE_LABEL} ... " --caller="${SCRIPT_NAME}" --msg-type="info"
    else
      break
    fi
  done
}

ensure_linode_rdns_resolved() {
  echo -n "Checking if linode IPv4 reverse DNS value matched with the host domain name ${C_BOX_HOSTNAME_FQHN} for IP ${C_IPV4_ADD0} ... "
  while :; do
    local current_ipv4_reverse_dns
    current_ipv4_reverse_dns=$(maxipi linode ip-address-view --ip-address "${C_IPV4_ADD0}" --get-value rdns --scripting)
    if [[ "${current_ipv4_reverse_dns}" == "${C_BOX_HOSTNAME_FQHN}" ]]; then
      msg "$(s green) [OK]$(e)"
      break
    else
      msg "$(s red) [FAILED]$(e)"
      echo ""
      msg "$(s cyan)The current linode IPv4 reverse DNS value is ${current_ipv4_reverse_dns} ...$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s cyan)Updating reverse dns for linode IPv4 ${C_IPV4_ADD0} to ${C_BOX_HOSTNAME_FQHN} ...$(e)" --caller="${SCRIPT_NAME}"
      maxipi linode update-reverse-dns --for-ip-address "${C_IPV4_ADD0}" --domain "${C_BOX_HOSTNAME_FQHN}"
      get_status_message "$?"
      echo ""
      echo -n "Rechecking if linode IPv4 reverse DNS value matched with the host domain name ${C_BOX_HOSTNAME_FQHN} for IP ${C_IPV4_ADD0} ... "
    fi
  done

  msg "Checking if linode IPv6 reverse DNS value matched with the host domain name ${C_BOX_HOSTNAME_FQHN} for IP ${C_IPV6_ADD0} ... " --caller="${SCRIPT_NAME}" --msg-type="info" --start-spin
  while :; do
    local current_ipv6_reverse_dns
    current_ipv6_reverse_dns=$(maxipi linode ip-address-view --ip-address ${C_IPV6_ADD0} --get-value rdns --scripting)
    if [[ "${current_ipv6_reverse_dns}" == "${C_BOX_HOSTNAME_FQHN}" ]]; then
      msg "$(s green) [OK]$(e)"
      break
    else
      msg "$(s red) [FAILED]$(e)"
      echo ""
      msg "$(s cyan)The current linode IPv6 reverse DNS value is ${current_ipv6_reverse_dns} ...$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s cyan)Updating reverse dns for linode IPv6 ${C_IPV6_ADD0} to ${C_BOX_HOSTNAME_FQHN} ...$(e)" --caller="${SCRIPT_NAME}"
      maxipi linode update-reverse-dns --for-ip-address "${C_IPV6_ADD0}" --domain "${C_BOX_HOSTNAME_FQHN}"
      get_status_message "$?"
      echo ""
      echo -n "Rechecking if linode IPv6 reverse DNS value matched with the host domain name ${C_BOX_HOSTNAME_FQHN} for IP ${C_IPV6_ADD0} ... "
    fi
  done
}
ensure_domain_server_resolved() {
  if [ "${C_ENABLE_DNS_PROPAGATION_CHECKER}" == "true" ]; then
    local failed_check_count count_check_duration

    failed_check_count=0
    count_check_duration=30

    msg "Checking domain ${C_BOX_DOMAIN} A record resolves with IPv4 ${C_IPV4_ADD0} ... " --caller="${SCRIPT_NAME}" --msg-type="info" --start-spin
    while :; do
      if is_valid ipv4_resolved "${C_IPV4_ADD0}" "${C_BOX_DOMAIN}"; then
        msg "$(s green) [OK]$(e)"
        break
      else
        local check_duration
        msg "$(s red) [FAILED]$(e)"
        ((failed_check_count++))
        if [[ "${failed_check_count}" -eq 1 ]]; then
          if [ "${C_DNS_PROVIDER_NAME}" == "linode" ]; then

            # Check if the domain exist in linode if not create it first

            check_domain=$(maxipi linode get-domain-id --for-domain "${C_BOX_DOMAIN}" --scripting)
            if [[ "${check_domain}" == "error" ]]; then
              msg "$(s red)The domain ${C_BOX_DOMAIN} does not exist in linode$(e)" --caller="${SCRIPT_NAME}"
              msg "$(s cyan)Creating domain ${C_BOX_DOMAIN} ...$(e)" --caller="${SCRIPT_NAME}"
              maxipi linode create-domain --domain-type master --domain-name "${C_BOX_DOMAIN}" --domain-email "webmaster@${C_BOX_DOMAIN}" --domain-ttl 30

            fi

            check_record=$(maxipi linode get-record-id --for-domain "${C_BOX_DOMAIN}" --for-record-type "A" --for-record-name "${C_BOX_DOMAIN}" --for-record-value "${C_IPV4_ADD0}" --first-record --scripting)

            if [[ "${check_record}" == "error" ]]; then
              msg "$(s red)The domain ${C_BOX_DOMAIN} does not have an A record for ${C_IPV4_ADD0}$(e)" --caller="${SCRIPT_NAME}"
              msg "$(s cyan)Creating domain ${C_BOX_DOMAIN} A record with value ${C_IPV4_ADD0} ...$(e)" --caller="${SCRIPT_NAME}"
              maxipi linode create-record --for-domain "${C_BOX_DOMAIN}" --record-type "A" --record-name "${C_BOX_DOMAIN}" --record-value "${C_IPV4_ADD0}" --record-ttl 30
            fi

          elif
            [ "${C_DNS_PROVIDER_NAME}" == "local" ]
          then
            msg "External DNS provider for domain ${C_BOX_DOMAIN} is set to local"
            # Do nothing because it's local DNS managed by Directadmin
          fi
        fi

        #msg "$(s red)Please create / check for domain ${C_BOX_DOMAIN} that it must have an A record pointing to ${C_IPV4_ADD0}$(e)" --caller="${SCRIPT_NAME}"
        #exit 1

        if [[ "${failed_check_count}" -eq 4 ]]; then
          msg "$(s yellow)Warning, failed to propagate domain ${C_BOX_DOMAIN} ...$(e)" --caller="${SCRIPT_NAME}"
          msg "$(s cyan)Creating domain ${C_BOX_DOMAIN} in linode with rebuild option ...$(e)" --caller="${SCRIPT_NAME}"
          maxipi linode create-domain --domain-type "master" --domain "${C_BOX_DOMAIN}" --domain-email "webmaster@${C_BOX_DOMAIN}" --domain-ttl 30 --rebuild
          # get_status_message "$?"
          echo ""
          msg "$(s cyan)Creating dns A record ${C_BOX_DOMAIN} in linode...$(e)" --caller="${SCRIPT_NAME}"
          maxipi linode add-dns-record --for-domain "${C_BOX_DOMAIN}" --record-type "A" --record-name "${C_BOX_DOMAIN}" --record-value "${C_IPV4_ADD0}" --record-ttl 30
          get_status_message "$?"
        fi

        # Increase the check 30 seconds when failed on the 5th times and a above
        if [[ "${failed_check_count}" -ge 15 && "${failed_check_count}" -le 100 ]]; then
          ((count_check_duration = count_check_duration + 30))
        else
          count_check_duration=30
        fi
        check_duration="${count_check_duration}"
        while :; do
          ((check_duration--))
          msg "[${failed_check_count}]: Re-checking ${C_BOX_DOMAIN} A record resolves with IPv4 ${C_IPV4_ADD0} within ${check_duration} seconds ... " --caller="${SCRIPT_NAME}" --start-spin
          if [ "${check_duration}" -le 0 ]; then
            # echo -n "Re-checking ${C_BOX_DOMAIN} A record resolves with IPv4 ${C_IPV4_ADD0} in 120 seconds ... "
            break
          fi
          sleep 1
        done
      fi
    done

    failed_check_count=0
    count_check_duration=30
    msg "Checking domain ${C_BOX_DOMAIN} AAAA record resolves with IPv6 ${C_IPV6_ADD0} ... " --caller="${SCRIPT_NAME}" --msg-type="info" --start-spin
    while :; do
      if is_valid ipv6_resolved "${C_IPV6_ADD0}" "${C_BOX_DOMAIN}"; then
        msg "$(s green) [OK]$(e)"
        break
      else
        local check_duration
        msg "$(s red) [FAILED]$(e)"
        ((failed_check_count++))
        if [[ "${failed_check_count}" -eq 1 ]]; then
          if [ "${C_DNS_PROVIDER_NAME}" == "linode" ]; then
            local check_domain check_record
            check_domain=$(maxipi linode get-domain-id --for-domain "${C_BOX_DOMAIN}" --scripting)
            if [[ "${check_domain}" == "error" ]]; then
              msg "$(s red)The domain ${C_BOX_DOMAIN} does not exist in linode$(e)" --caller="${SCRIPT_NAME}"
              msg "$(s cyan)Creating domain ${C_BOX_DOMAIN} ...$(e)" --caller="${SCRIPT_NAME}"
              maxipi linode create-domain --domain-type master --domain-name "${C_BOX_DOMAIN}" --domain-email "webmaster@${C_BOX_DOMAIN}" --domain-ttl 30
              echo ""
            fi

            check_record=$(maxipi linode get-record-id --for-domain "${C_BOX_DOMAIN}" --for-record-type "AAAA" --for-record-name "${C_BOX_DOMAIN}" --for-record-value "${C_IPV6_ADD0}" --first-record --scripting)
            if [[ "${check_record}" == "error" ]]; then
              msg "$(s red)The domain ${C_BOX_DOMAIN} does not have an AAAA record for ${C_IPV6_ADD0}$(e)" --caller="${SCRIPT_NAME}"
              msg "$(s cyan)Creating domain ${C_BOX_DOMAIN} AAAA record with value ${C_IPV6_ADD0} ...$(e)" --caller="${SCRIPT_NAME}"
              maxipi linode create-record --for-domain "${C_BOX_DOMAIN}" --record-type "AAAA" --record-name "${C_BOX_DOMAIN}" --record-value "${C_IPV6_ADD0}" --record-ttl 30
              echo ""
            fi
          elif [ "${C_DNS_PROVIDER_NAME}" == "local" ]; then
            msg "External DNS provider for domain ${C_BOX_DOMAIN} is set to local" --caller="${SCRIPT_NAME}"
            # Do nothing because it's local DNS managed by Directadmin
          fi
        fi

        #msg "$(s red)Please create / check for domain ${C_BOX_DOMAIN} that it must have an AAAA record pointing to ${C_IPV4_ADD0}$(e)" --caller="${SCRIPT_NAME}"
        #exit 1

        # Increase the check 30 seconds when failed on the 5th times and a above
        if [[ "${failed_check_count}" -ge 15 && "${failed_check_count}" -le 100 ]]; then
          ((count_check_duration = count_check_duration + 2))
        else
          count_check_duration=30
        fi
        check_duration="${count_check_duration}"
        while :; do
          ((check_duration--))
          msg "[${failed_check_count}]: Re-checking domain ${C_BOX_DOMAIN} AAAA record resolves with IPv6 ${C_IPV6_ADD0} within ${check_duration} seconds ... " --caller="${SCRIPT_NAME}" --start-spin
          if [ "${check_duration}" -le 0 ]; then
            # echo -n "Re-checking ${C_BOX_DOMAIN} AAAA record resolves with IPv6 ${C_IPV6_ADD0} in 120 seconds ... "
            break
          fi
          sleep 1
        done
      fi
    done

  else
    msg "$(s yellow)Skip checking domain for propagation for domain because C_ENABLE_DNS_PROPAGATION_CHECKER is not set to true$(e)" --caller="${SCRIPT_NAME}"
  fi
}
############## FOR HOSTNAME test.server.com ################
ensure_fqhn_server_resolved() {
  if [ "${C_ENABLE_DNS_PROPAGATION_CHECKER}" == "true" ]; then
    local failed_check_count count_check_duration

    failed_check_count=0
    count_check_duration=30
    msg "Checking hostname ${C_BOX_HOSTNAME_FQHN} A record resolves with IPv4 ${C_IPV4_ADD0} ... " --caller="${SCRIPT_NAME}" --msg-type="info" --start-spin
    while :; do
      if is_valid ipv4_resolved "${C_IPV4_ADD0}" "${C_BOX_HOSTNAME_FQHN}"; then
        msg "$(s green) [OK]$(e)"
        break
      else
        local check_duration
        msg "$(s red) [FAILED]$(e)"
        ((failed_check_count++))
        if [[ "${failed_check_count}" -eq 1 ]]; then
          if [ "${C_DNS_PROVIDER_NAME}" == "linode" ]; then

            check_domain=$(maxipi linode get-domain-id --for-domain "${C_BOX_HOSTNAME_FQHN}" --scripting)
            if [[ "${check_domain}" == "error" ]]; then
              msg "$(s red)The domain ${C_BOX_HOSTNAME_FQHN} does not exist in linode$(e)" --caller="${SCRIPT_NAME}"
              msg "$(s cyan)Creating domain ${C_BOX_HOSTNAME_FQHN} ...$(e)" --caller="${SCRIPT_NAME}"
              maxipi linode create-domain --domain-type master --domain-name "${C_BOX_HOSTNAME_FQHN}" --domain-email "webmaster@${C_BOX_HOSTNAME_FQHN}" --domain-ttl 30
              echo ""
            fi

            check_record=$(maxipi linode get-record-id --for-domain "${C_BOX_HOSTNAME_FQHN}" --for-record-type "A" --for-record-name "${C_BOX_HOSTNAME_FQHN}" --for-record-value "${C_IPV4_ADD0}" --first-record --scripting)
            if [[ "${check_record}" == "error" ]]; then
              msg "$(s red)The domain ${C_BOX_HOSTNAME_FQHN} does not have an A record for ${C_IPV4_ADD0}$(e)" --caller="${SCRIPT_NAME}"
              msg "$(s cyan)Creating domain ${C_BOX_HOSTNAME_FQHN} A record with value ${C_IPV4_ADD0} ...$(e)" --caller="${SCRIPT_NAME}"
              maxipi linode create-record --for-domain "${C_BOX_HOSTNAME_FQHN}" --record-type "A" --record-name "${C_BOX_HOSTNAME_FQHN}" --record-value "${C_IPV4_ADD0}" --record-ttl 30
              echo ""
            fi

          elif [ "${C_DNS_PROVIDER_NAME}" == "local" ]; then
            msg "External DNS provider for domain ${domain} is set to local"
            # Do nothing because it's local DNS managed by Directadmin
          fi
        fi

        #msg "$(s red)Please create / check for domain ${C_BOX_HOSTNAME_FQHN} that it must have an A record pointing to ${C_IPV4_ADD0}$(e)" --caller="${SCRIPT_NAME}"
        #exit 1
        # 30,4, 15 ,100,30
        # If failed for the 3rd time, readd domain with --force
        if [[ "${failed_check_count}" -eq 30 ]]; then
          msg "$(s yellow)Warning, failed to propagate domain ${C_BOX_HOSTNAME_FQHN} ...$(e)" --caller="${SCRIPT_NAME}"
          msg "$(s cyan)Creating domain ${C_BOX_HOSTNAME_FQHN} in linode with rebuild option ...$(e)" --caller="${SCRIPT_NAME}"
          maxipi linode create-domain --domain-type "master" --domain "${C_BOX_HOSTNAME_FQHN}" --domain-email "webmaster@${C_BOX_HOSTNAME_FQHN}" --domain-ttl 30 --rebuild
          # get_status_message "$?"
          echo ""
          msg "$(s cyan)Creating dns A record ${C_BOX_HOSTNAME_FQHN} in linode...$(e)" --caller="${SCRIPT_NAME}"
          maxipi linode add-dns-record --for-domain "${C_BOX_HOSTNAME_FQHN}" --record-type "A" --record-name "${C_BOX_HOSTNAME_FQHN}" --record-value "${C_IPV4_ADD0}" --record-ttl 30
          get_status_message "$?"
        fi

        # Increase the check 30 seconds when failed on the 5th times and a above
        if [[ "${failed_check_count}" -ge 4 && "${failed_check_count}" -le 100 ]]; then
          ((count_check_duration = count_check_duration + 2))
        else
          count_check_duration=30
        fi
        check_duration="${count_check_duration}"
        while :; do
          ((check_duration--))
          msg "[${failed_check_count}]: Re-checking hostname ${C_BOX_HOSTNAME_FQHN} A record resolves with IPv4 ${C_IPV4_ADD0} within ${check_duration} seconds ... " --caller="${SCRIPT_NAME}" --start-spin
          if [ "${check_duration}" -le 0 ]; then
            # echo -n "Re-checking ${C_BOX_HOSTNAME_FQHN} A record resolves with IPv4 ${C_IPV4_ADD0} in 120 seconds ... "
            break
          fi
          sleep 1
        done
      fi
    done

    failed_check_count=0
    count_check_duration=30
    msg "Checking hostname ${C_BOX_HOSTNAME_FQHN} AAAA record resolves with IPv6 ${C_IPV6_ADD0} ... " --caller="${SCRIPT_NAME}" --msg-type="info" --start-spin
    while :; do
      if is_valid ipv6_resolved "${C_IPV6_ADD0}" "${C_BOX_HOSTNAME_FQHN}"; then
        msg "$(s green) [OK]$(e)"
        break
      else
        local check_duration
        msg "$(s red) [FAILED]$(e)"
        ((failed_check_count++))
        if [[ "${failed_check_count}" -eq 1 ]]; then
          if [ "${C_DNS_PROVIDER_NAME}" == "linode" ]; then
            check_domain=$(maxipi linode get-domain-id --for-domain "${C_BOX_HOSTNAME_FQHN}" --scripting)
            if [[ "${check_domain}" == "error" ]]; then
              msg "$(s red)The domain ${C_BOX_HOSTNAME_FQHN} does not exist in linode$(e)" --caller="${SCRIPT_NAME}"
              msg "$(s cyan)Creating domain ${C_BOX_HOSTNAME_FQHN} ...$(e)" --caller="${SCRIPT_NAME}"
              maxipi linode create-domain --domain-type master --domain-name "${C_BOX_HOSTNAME_FQHN}" --domain-email "webmaster@${C_BOX_HOSTNAME_FQHN}" --domain-ttl 30
              echo ""
            fi

            check_record=$(maxipi linode get-record-id --for-domain "${C_BOX_HOSTNAME_FQHN}" --for-record-type "AAAA" --for-record-name "${C_BOX_HOSTNAME_FQHN}" --for-record-value "${C_IPV6_ADD0}" --first-record --scripting)
            if [[ "${check_record}" == "error" ]]; then
              msg "$(s red)The domain ${C_BOX_HOSTNAME_FQHN} does not have an AAAA record for ${C_IPV6_ADD0}$(e)" --caller="${SCRIPT_NAME}"
              msg "$(s cyan)Creating domain ${C_BOX_HOSTNAME_FQHN} AAAA record with value ${C_IPV6_ADD0} ...$(e)" --caller="${SCRIPT_NAME}"
              maxipi linode create-record --for-domain "${C_BOX_HOSTNAME_FQHN}" --record-type "AAAA" --record-name "${C_BOX_HOSTNAME_FQHN}" --record-value "${C_IPV6_ADD0}" --record-ttl 30
              echo ""
            fi

          elif [ "${C_DNS_PROVIDER_NAME}" == "local" ]; then
            msg "External DNS provider for domain ${C_BOX_HOSTNAME_FQHN} is set to local"
            # Do nothing because it's local DNS managed by Directadmin
          fi
        fi
        #msg "$(s red)Please create / check for domain ${C_BOX_HOSTNAME_FQHN} that it must have an AAAA record pointing to ${C_IPV6_ADD0}$(e)" --caller="${SCRIPT_NAME}"
        #exit 1

        # Increase the check 30 seconds when failed on the 5th times and a above
        if [[ "${failed_check_count}" -ge 15 && "${failed_check_count}" -le 100 ]]; then
          ((count_check_duration = count_check_duration + 2))
        else
          count_check_duration=30
        fi
        check_duration="${count_check_duration}"
        while :; do
          ((check_duration--))
          msg "[${failed_check_count}]: Re-checking hostname ${C_BOX_HOSTNAME_FQHN} AAAA record resolves with IPv6 ${C_IPV6_ADD0} within ${check_duration} seconds ... " --caller="${SCRIPT_NAME}" --start-spin
          if [ "${check_duration}" -le 0 ]; then
            break
          fi
          sleep 1
        done
      fi
    done

  else
    msg "$(s yellow)Skip checking domain for propagation for hostname because C_ENABLE_DNS_PROPAGATION_CHECKER is not set to true$(e)" --caller="${SCRIPT_NAME}"
  fi

}

# This function initialize or deploy server installation from scratch with few options
# See <script_name> --init-server --help or look at manual() section under "init_server" for more information
init_server() {
  local argnum options retval rebuild_iso rebuild_partition rebuild_config rebuild_all backup max_wait wait_count
  argnum="$#"
  # We should allow empty argument for creating server without rebuild or backup option
  #if [ ${argnum} -eq 0 ]; then
  #  echo "Error, no argument is supplied. Use [ ${SCRIPT_NAME} --init-server --help ] to see the valid options"
  #  exit 1
  #fi
  short_opts=""
  long_opts="help,rebuild-iso,rebuild-partition,rebuild-config,rebuild-all,backup"
  options=$(getopt -o "${short_opts}" --long "${long_opts}" -n "${FUNCNAME[0]} in ${SCRIPT_NAME}" -- "$@")
  retval=$?
  if [ ${retval} != 0 ]; then
    echo "Error, invalid parse data. Terminating..." >&2
    exit 1
  fi

  # Must quote this option variable
  eval set -- "${options}"

  rebuild_iso=false
  rebuild_partition=false
  rebuild_config=false
  rebuild_all=false
  backup=false
  while true; do
    case "$1" in
    --help)
      manual "${FUNCNAME[0]}"
      shift
      exit 0
      ;;
    --rebuild-iso)
      rebuild_iso=true
      shift
      ;;
    --rebuild-partition)
      rebuild_partition=true
      shift
      ;;
    --rebuild-config)
      rebuild_config=true
      shift
      ;;
    --rebuild-all)
      rebuild_all=true
      rebuild_iso=true
      rebuild_partition=true
      rebuild_config=true
      shift
      ;;

    --backup)
      backup=true
      shift
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
    esac
  done

  [[ "${rebuild_partition}" == "true" ]] && _ask "Warning, this command will wipe the entire server because --rebuild-partition is supplied! Continue?"
  echo ""

  # This will make sure that the hostname resolved
  ensure_internet_connected
  ensure_domain_server_resolved
  ensure_fqhn_server_resolved
  echo ""

  msg "$(s yellow)Updating local system ...$(e)" --caller="${SCRIPT_NAME}"
  apt-get -y update
  apt-get -y upgrade
  echo ""

  msg "$(s cyan)Deploying a new server for ${C_BOX_HOSTNAME_FQHN} ...$(e)" --caller="${SCRIPT_NAME}"

  echo "Server Physical Information:"
  # Get all of this from provider

  if [ "${C_DNS_PROVIDER_NAME}" == "linode" ]; then
    echo "Provider: ${C_DNS_PROVIDER_NAME}"
    echo "Provider type: ${C_BOX_TYPE^^}"
    echo ""

    msg "$(s cyan)Disabling linode watchdog ...$(e)" --caller="${SCRIPT_NAME}"
    maxipi linode update-linode --for-linode-label "${C_BOX_HOSTNAME_FQHN}" --enable-watchdog no
    get_status_message "$?"
  else
    :
  fi

  echo "IPv4 address: ${C_IPV4_ADD0}"
  echo "IPv6 address: ${C_IPV6_ADD0}"
  echo "============="
  echo ""
  #echo "Disk space: "
  #echo "Memory/RAM: "

  msg "$(s yellow)Testing dropbox token permission ...$(e)" --caller="${SCRIPT_NAME}"
  dbxcli test
  get_status_message "$?"
  echo ""
  if [ ${backup} == "true" ]; then
    msg "$(s blue)Notice, the option --backup-all is set. The following backup events will be triggered automatically: $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s blue)1) Previous iso image will be backed up automatically $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s blue)2) Previous RSA SSH key will be backed up automatically $(e)" --caller="${SCRIPT_NAME}"
  fi

  msg "$(s newline)"
  if [ ${rebuild_all} == "true" ]; then
    msg "$(s yellow)Warning, --rebuild-all is set. The following options are enabled by default: $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)Warning, --rebuild-iso is set. Hence new ISO will be rebuilt $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)Warning, --rebuild-partition is set. Hence, all disk partitions will be rebuilt $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)Warning, --rebuild-config is set. Hence, all configs will be rebuilt $(e)" --caller="${SCRIPT_NAME}"
  else
    if [ ${rebuild_iso} == "true" ]; then
      msg "$(s yellow)Warning, --rebuild-iso is set. Hence new ISO will be rebuilt $(e)" --caller="${SCRIPT_NAME}"
    fi

    if [ ${rebuild_partition} == "true" ]; then
      msg "$(s yellow)Warning, --rebuild-partition is set. Hence, all disk partitions will be rebuilt $(e)" --caller="${SCRIPT_NAME}"
    fi

    if [ ${rebuild_config} == "true" ]; then
      msg "$(s yellow)Warning, --rebuild-config is set. Hence, all configs will be rebuilt $(e)" --caller="${SCRIPT_NAME}"
    fi
  fi
  _pause 3

  if [ "${C_DNS_PROVIDER_NAME}" == "linode" ]; then
    # This will make sure rdns in external DNS is matched with value of hostname (Note: this will take 24 hours to propagate!)
    ensure_linode_rdns_resolved

    # This will check if the current hostname in linode matched with the config file and also it will check if IPv4 in config file (even multiple IP) match the label.
    # This is a very important check for external DNS
    ensure_linode_label_ipv4_valid

    server_main_disk_raw_size="${C_BOX_MAIN_DISK_RAW_SIZE}"
    server_boot_disk_raw_size="${C_BOX_BOOT_DISK_RAW_SIZE}"

    ((box_os_disk = server_main_disk_raw_size - server_boot_disk_raw_size))

    # Turn off linode if it's running
    msg "Shutting down linode ${C_BOX_HOSTNAME_FQHN} ..." --caller="${SCRIPT_NAME}"

    maxipi linode shutdown-linode --where-linode-label-is "${C_BOX_HOSTNAME_FQHN}" --wait-for-busy-status --wait-until-linode-status offline
    get_status_message "$?"

    # linode_api_admin shutdown-linode --linode-label "${C_BOX_HOSTNAME_FQHN}"
    # Delete all existing disks (if exist)
    echo ""

    # Rebuild linode disks if set (delete and create)

    if [ ${rebuild_partition} == "true" ]; then
      init_server_rebuild_partition --run-force
    fi

    if [ ${rebuild_config} == "true" ]; then
      init_server_rebuild_config --run-force
    fi

    msg "$(s cyan)Booting linode ${C_BOX_HOSTNAME_FQHN} into Finnix rescue mode ...$(e)" --caller="${SCRIPT_NAME}"
    maxipi linode reboot-to-rescue --for-linode-label "${C_BOX_HOSTNAME_FQHN}" --dev-sda "disk:${C_LINODE_BOOT_DISK_LABEL}" --dev-sdb "disk:${C_LINODE_OS_DISK_LABEL}" --wait-for-busy-status --wait-until-linode-status online
    get_status_message "$?"
    # linode_api_admin reboot-to-rescue --linode-label "${C_BOX_HOSTNAME_FQHN}" --label-devsda "disk:${C_LINODE_BOOT_DISK_LABEL}" --label-devsdb "disk:${C_LINODE_OS_DISK_LABEL}"
    echo ""
    # Installing dropbox_cli here

    if [ "${rebuild_iso}" == "true" ]; then
      if [ "${backup}" == "true" ]; then
        msg "$(s yellow)Warning, the option --rebuild-iso is set. Hence the existing ISO will be replaced with the new one $(s green)but do not worry this ISO file will be backed up because --backup option is set$(e)" --caller="${SCRIPT_NAME}"
      else
        msg "$(s yellow)Warning, the option --rebuild-iso is set. Hence the existing ISO will be replaced with the new one!$(e)" --caller="${SCRIPT_NAME}"
      fi
      _pause 5
      msg "$(s cyan)Creating ISO file ...$(e)" --caller="${SCRIPT_NAME}"
      # Create ISO type for Hard disk boot, pull from web, upload to dropbox and write an automation script for installation
      # From my finding, it seems like delete ISO after using it many times, make the download faster. Maybe dropbox limit download for specific file.
      if [ "${backup}" == "true" ]; then
        iso_api create-os-iso --iso-type hdd-boot --iso-base web --upload-to-dropbox --write-script --backup
      else
        iso_api create-os-iso --iso-type hdd-boot --iso-base web --upload-to-dropbox --write-script
      fi

    else
      msg "$(s yellow)Notice, linode will install server operating system using existing automated ISO because the option rebuild-iso is not set$(e)" --caller="${SCRIPT_NAME}"
      # If the rebuild_iso is set to false, we delay this for 7 seconds more
      sleep 7
    fi
    msg "$(s cyan)Writing OS into ${C_LINODE_BOOT_DISK_LABEL} Partition via SSH background (this will be completed until linode is turned off automatically) ...$(e)" --caller="${SCRIPT_NAME}"
    # ssh -q -o "StrictHostKeyChecking no" -i /root/.ssh/linode_lish.id_rsa -tt "${C_LINODE_API_USERNAME}@${C_LINODE_TERMINAL_SERVER}" "${C_BOX_HOSTNAME_FQHN}" <"${CODE_PATH}/ssh_scripts/os_write_ag.sh" >/dev/null 2>&1 &
    # This above lish ssh command is equivalent to below using --push-iso-write-script option and other config will be used the default values from config file:
    ssh_api lish-push-script --push-iso-write-script
    #ssh -q -o "StrictHostKeyChecking no" -i /root/.ssh/linode_lish.id_rsa -tt "${C_LINODE_API_USERNAME}@${C_LINODE_TERMINAL_SERVER}" "${C_BOX_HOSTNAME_FQHN}" <"${CODE_PATH}/ssh_scripts/os_write_ag.sh" >/dev/null 2>&1 &
    # Wait until linode status is offline
    msg "$(s cyan)Waiting or the installer to shutdown linode ...$(e)" --caller="${SCRIPT_NAME}"
    maxipi linode get-status --for-linode-label "${C_BOX_HOSTNAME_FQHN}" --wait-until-linode-status offline
    get_status_message "$?"
    echo ""
    # linode_api_admin wait-linode-status --linode-label "${C_BOX_HOSTNAME_FQHN}" --until-status offline

    # After system shutdown, then we can execute the following`
    # Note I can use reboot-linode or boot-linode (boot-linode is used if the linode status is offline, if it's running you cannot use it)
    msg "$(s cyan)Booting linode using config ${C_LINODE_BOOT_CONFIG_LABEL} ...$(e)" --caller="${SCRIPT_NAME}"
    maxipi linode boot-linode --for-linode-label "${C_BOX_HOSTNAME_FQHN}" --for-config-label "${C_LINODE_BOOT_CONFIG_LABEL}" --wait-for-busy-status --wait-until-linode-status online
    get_status_message "$?"
    # linode_api_admin reboot-linode --linode-label "${C_BOX_HOSTNAME_FQHN}" --linode-config-label "${C_LINODE_BOOT_CONFIG_LABEL}"
    echo ""
    msg "$(s cyan)Installing operating system automatically using preseed configuration (Server will turned off automatically when finish): $(e)" --caller="${SCRIPT_NAME}"
    # Do not over call the API, use sleep 5 minutes (300 seconds). The installation approximate time is  + minutes.
    # For debian 11 installation time take more than 300 seconds .. so we wait at this duration
    if [[ "${C_BOX_ISO_OS_NAME}" == "debian" ]]; then
      max_wait=250
    else
      max_wait=120
    fi

    wait_count=0
    while :; do
      ((wait_count++))
      msg "$(s cyan)Waiting for initial installation ... Maximum wait of ${wait_count}/${max_wait} seconds ...$(e)" --start-spin --caller="${SCRIPT_NAME}"
      sleep 1
      if [[ "${wait_count}" -ge "${max_wait}" ]]; then
        echo ""
        msg "$(s cyan)Please wait ...$(e)" --stop-spin --caller="${SCRIPT_NAME}"
        break
      fi
    done
    echo ""
    msg "$(s cyan)Waiting or the installer to shutdown linode ...$(e)" --caller="${SCRIPT_NAME}"
    maxipi linode get-status --for-linode-label "${C_BOX_HOSTNAME_FQHN}" --wait-until-linode-status offline
    get_status_message "$?"
    # linode_api_admin wait-linode-status --linode-label "${C_BOX_HOSTNAME_FQHN}" --until-status offline
    echo ""
    # Remove boot config here
    msg "Deleting linode config profile ${C_LINODE_BOOT_CONFIG_LABEL}" --caller="${SCRIPT_NAME}"
    maxipi linode delete-config --for-linode "${C_BOX_HOSTNAME_FQHN}" --for-config-label "${C_LINODE_BOOT_CONFIG_LABEL}"
    get_status_message "$?"
    # Boot into the new OS
    msg "Booting into operating ..." --caller="${SCRIPT_NAME}"
    maxipi linode boot-linode --for-linode-label "${C_BOX_HOSTNAME_FQHN}" --for-config-label "${C_LINODE_OS_CONFIG_LABEL}" --wait-for-busy-status --wait-until-linode-status online
    get_status_message "$?"
    # linode_api_admin boot-linode --linode-label "${C_BOX_HOSTNAME_FQHN}" --linode-config-label "${C_LINODE_OS_CONFIG_LABEL}"
    echo ""

    #linode_api_admin delete-config --linode-label "${C_BOX_HOSTNAME_FQHN}" --linode-config-label "${C_LINODE_BOOT_CONFIG_LABEL}"

    if [ "${C_DISK_ENCRYPTION}" == "true" ]; then
      msg "Unlocking disk encryption ..." --caller="${SCRIPT_NAME}"
      msg "$(s cyan)Checking if initial boot port ${C_DROP_BEAR_PORT} is open from --server ${C_BOX_HOSTNAME_FQHN} ...$(e)" --caller="${SCRIPT_NAME}"
      count=0
      while :; do
        sleep 1
        ((count++))
        msg "$(s yellow) Waiting for LUKS boot port ${C_DROP_BEAR_PORT} to be available ...$(e)" --start-spin --caller="${SCRIPT_NAME}"

        if is_valid available_port "${C_BOX_HOSTNAME_FQHN}" "${C_DROP_BEAR_PORT}"; then
          msg "$(s green)OK, LUKS boot port ${C_DROP_BEAR_PORT} is now available. Unlocking encrypted LUKS disk on boot ...$(e)" --stop-spin --caller="${SCRIPT_NAME}"
          # Wait 10 seconds
          sleep 5
          ssh_api unlock-luks --port "${C_DROP_BEAR_PORT}" --password "${C_LUKS_PASS}"
          # This is very important wait, file copy will have trouble if startup is late
          msg "$(s cyan)Waiting 10 seconds to finish start operating system after finished unlocking LUKS partition ...$(e)" --stop-spin --caller="${SCRIPT_NAME}"
          sleep 10
          break
        fi
        if [ "${count}" -gt 60 ]; then
          msg "$(s red)Error, failed to detect drop bear port ${C_DROP_BEAR_PORT} because the port is closed. Please inspect this manually (make sure firewall is not blocking this port)!$(e)" --caller="${SCRIPT_NAME}"
          _exit 1
        fi
      done
    fi

    update_remote "all"

    sleep 2

    if [ "${C_PRE_AUTORUN_SETUP}" == "false" ]; then
      msg "$(s yellow)Warning, C_PRE_AUTORUN_SETUP is not set in config file. Hence, remote auto installation script is now halt! $(e)" --caller="${SCRIPT_NAME}"
      echo ""
      msg "$(s yellow)Note: The server will be turned off, if you want to continue remote setup, trigger the following commands: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s magenta)1) Turn on the server: maxinet --start-server$(e)"
      msg "$(s magenta)2) Unlock server LUKS disk encrypted: maxinet --luks-unlock$(e)"
      msg "$(s magenta)3) Automatically execute setup action on remote server: maxinet --ssh-api push-script --server-port ${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT} --group-user root:${C_SSH_USERNAME} --push-maxinet-setup-script$(e)"
      echo ""
      msg "OR login into remote server and manually run setup action with the following command:" --caller="${SCRIPT_NAME}"
      msg "$(s magenta)1) Turn on server: maxinet ssh-login root$(e)"
      msg "$(s magenta)2) cd ~$(e)"
      msg "$(s magenta)3) ./${SCRIPT_NAME} setup 2>&1 | tee ${SCRIPT_NAME}.log ~$(e)"
      msg "$(s magenta)4) See ~/readme.txt for more information$(e)"
      maxipi linode shutdown-linode --for-linode-label "${C_BOX_HOSTNAME_FQHN}" --wait-for-busy-status --wait-until-linode-status offline
      get_status_message "$?"
      # linode_api_admin shutdown-linode --linode-label "${C_BOX_HOSTNAME_FQHN}"
      _exit 0
    fi

    msg "$(s cyan)Executing maxinet remote script and starting server installation ... (it might take some time)$(e)" --caller="${SCRIPT_NAME}"
    # ssh_api push-script --server ${C_BOX_HOSTNAME_FQHN} --port ${C_SSH_PORT} --group root --username ${C_ROOT_USERNAME} --local-script-path "${CODE_PATH}/ssh_scripts/maxinet_setup.sh"
    ssh_api push-script --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" --local-script-path "${CODE_PATH}/ssh_scripts/maxinet_setup.sh"
    # After installation above, the system must restart once, so we execute next script to reopen LUKS
    echo ""

    msg "$(s cyan)Waiting for linode to shutdown...$(e)" --caller="${SCRIPT_NAME}"
    # After the above script is executed, now we wait for it to shutdown (executed by the script installation) properly before booting

    maxipi linode get-status --for-linode "${C_BOX_HOSTNAME_FQHN}" --wait-until-linode-status offline
    get_status_message "$?"
    # linode_api_admin wait-linode-status --linode-label "${C_BOX_HOSTNAME_FQHN}" --until-status offline
    echo ""
    msg "$(s cyan)Booting into operating system (LUKS console will be unlocked automatically) ...$(e)" --caller="${SCRIPT_NAME}"
    maxipi linode reboot-linode --for-linode "${C_BOX_HOSTNAME_FQHN}" --for-config-label "${C_LINODE_BOOT_CONFIG_LABEL}" --wait-for-busy-status --wait-until-linode-status online
    get_status_message "$?"
    # linode_api_admin reboot-linode --linode-label "${C_BOX_HOSTNAME_FQHN}" --linode-config-label "${C_LINODE_OS_CONFIG_LABEL}"

    if [ "${C_DISK_ENCRYPTION}" == "true" ]; then
      # check server and port if available in order to auto unlock it
      msg "$(s cyan)Checking if dropbear port ${C_DROP_BEAR_PORT} is open from --server ${C_BOX_HOSTNAME_FQHN} ...$(e)" --caller="${SCRIPT_NAME}"
      count=0
      while :; do
        sleep 1
        ((count++))
        msg "$(s yellow) Waiting for dropbear port ${C_DROP_BEAR_PORT} to be available ...$(e)" --start-spin --caller="${SCRIPT_NAME}"
        if is_valid available_port "${C_BOX_HOSTNAME_FQHN}" "${C_DROP_BEAR_PORT}"; then
          msg "$(s green)OK, dropbear port ${C_DROP_BEAR_PORT} is now available. Unlocking encrypted LUKS disk on boot ...$(e)" --stop-spin --caller="${SCRIPT_NAME}"
          # Wait 5 seconds
          sleep 5
          ssh_api unlock-luks --port "${C_DROP_BEAR_PORT}" --password "${C_LUKS_PASS}"
          break
        fi
        if [ "${count}" -gt 60 ]; then
          msg "$(s red)Error, failed to detect drop bear port ${C_DROP_BEAR_PORT} because the port is closed. Please inspect this manually (make sure firewall is not blocking this port)!$(e)" --caller="${SCRIPT_NAME}"
          _exit 1
        fi
      done
    fi

    if [ "${C_PRE_AUTORUN_SETUP}" == "false" ]; then
      msg "$(s cyan) Notice, C_PRE_AUTORUN_SETUP variable is not set in config file. Hence, auto installation script is disabled! Please run setup action manually$(e)" --caller="${SCRIPT_NAME}"
    else
      msg "$(s cyan)Resuming server installation installation by executing ${SCRIPT_NAME} script on remote server...$(e)" --caller="${SCRIPT_NAME}"
      ssh_api push-script --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" --local-script-path "${CODE_PATH}/ssh_scripts/maxinet_setup.sh"
    fi

    echo ""
    msg "$(s green)======================== FINISH ========================$(e)"
  elif [ "${C_DNS_PROVIDER_NAME}" == "digitalocean" ]; then
    :
  elif [ "${C_DNS_PROVIDER_NAME}" == "amazonaws" ]; then
    :
  elif [ "${C_DNS_PROVIDER_NAME}" == "local" ]; then
    :
  fi

}
# This function is used to manage SSH key (create, get, copy)
# Usage: ssh_api create-key|create-key-with-putty| copy-pubkeys <group_name> <user> <comment>
# Note 1: create-key will create normal ssh key
# Note 2: create-key-with-putty will create ssh key with putty format
# eg: ssh_api create-key-with-putty --group-name admin --username maxi32 --comment "This is a comment"
# eg: ssh_api get-pubkey --group-name admin --username maxi32
# eg: ssh_api "copy-all-pubkeys"
# eg: ssh_api "clear-known-host"
# group_name = user, admin, root, rescue, backup, os, diradmin ...
ssh_api() {
  local action argnum options long_opts retval key_path group user comment server_label server port destination rsa_key \
    linode_label local_script_path remote_script_path remote_path local_path push_iso_write_script push_shutdown_script push_reboot_script \
    push_maxinet_setup_script password local_files silent_push silent options

  action="$1"
  argnum="$#"
  # We allow empty argument. For example for faster login use maxinet ssh-login (by default it will login as root)
  #echo "argnum: ${argnum}"
  #if [ ${argnum} -le 1 ]; then
  #  echo "Error, no option is supplied for action ${action}. Use [ ${SCRIPT_NAME} --iso --help ] to see the valid options"
  #  exit 1
  #fi
  long_opts="help,key-path:,group:,user:,comment:,server-label:,server:,port:,destination:,without-prompt,rsa-key:,linode-label:, \
  local-script-path:,remote-script-path:,remote-path:,local-path:,local-files:,push-iso-write-script,push-shutdown-script,push-reboot-script,push-maxinet-setup-script, \
  sp:,server-port:,gu:,group-user:,password:,silent-push,silent,options:"
  options=$(getopt -o '' --long "${long_opts}" -n "${FUNCNAME[0]} in ${SCRIPT_NAME}" -- "$@")
  retval=$?
  if [ ${retval} != 0 ]; then
    msg "$(s red)Error, invalid parse data. Terminating...$(e)" >&2
    exit 1
  fi

  # Must quote this option variable
  eval set -- "${options}"
  # Can change using --key-path option but this location is best practice
  key_path="${SCRIPT_PATH}/secure/ssh"
  group=""
  user=""
  comment=""
  server_label="${C_BOX_HOSTNAME_FQHN}" # If not specified, use the default value from config file sun.sofibox.com
  destination="/root/.ssh/"             # If not specified, the default location is /root/.ssh/
  without_prompt=false
  server="${C_LINODE_TERMINAL_SERVER}"  #If not specified default to the lish server from config file eg: singapore-lish.linode.com
  linode_label="${C_BOX_HOSTNAME_FQHN}" # If not specified, use the default value from config file sun.sofibox.com
  rsa_key=""
  local_script_path=""
  remote_script_path=""
  remote_path=""
  local_path=""
  local_files=""
  push_iso_write_script=false
  push_shutdown_script=false
  push_reboot_script=false
  push_maxinet_setup_script=false
  port="22" #If not specified the default is port 22
  password=""
  silent_push=false
  silent=false
  options=""
  while true; do
    case "$1" in
    --help)
      manual "${FUNCNAME[0]}"
      shift
      exit 0
      ;;
    --key-path)
      key_path="$2"
      shift 2
      ;;
    --group)
      group="$2"
      shift 2
      ;;
    --user)
      user="$2"
      shift 2
      ;;
    --comment)
      comment="$2"
      shift 2
      ;;
    --server)
      server="$2"
      # TODO implement check if server is not propagated, we use IP address instead for server
      shift 2
      ;;
    --port)
      port="$2"
      shift 2
      ;;
    --server-label)
      server_label="$2"
      shift 2
      ;;
    --rsa-key)
      rsa_key="$2"
      shift 2
      ;;
    --linode-label)
      linode_label="$2"
      shift 2
      ;;
    --local-script-path)
      local_script_path="$2"
      shift 2
      ;;
    --remote-script-path)
      remote_script_path="$2"
      echo "remote_script_path: ${remote_script_path}"
      shift 2
      ;;
    --remote-path)
      remote_path="$2"
      shift 2
      ;;
    --local-path)
      local_path="$2"
      shift 2
      ;;
    --local-files)
      local_files="$2"
      shift 2
      ;;
    # This one we can combine server:port
    --sp | --server-port)
      server_port="$2"
      server=$(echo "${server_port}" | awk -F':' '{ print $1 }')
      port=$(echo "${server_port}" | awk -F':' '{ print $2 }')
      shift 2
      ;;
    # This one we can combine group:user
    --gu | --group-user)
      group_user="$2"
      group=$(echo "${group_user}" | awk -F':' '{ print $1 }')
      user=$(echo "${group_user}" | awk -F':' '{ print $2 }')
      shift 2
      ;;
    --without-prompt)
      without_prompt=true
      shift
      ;;
    --push-iso-write-script)
      push_iso_write_script=true
      if [[ "${push_shutdown_script}" == "true" || "${push_reboot_script}" == "true" || "${push_maxinet_setup_script}" == "true" ]]; then
        msg "$(s red)Error, only one push script can be called at one time!$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi
      shift
      ;;
    --push-shutdown-script)
      push_shutdown_script=true
      if [[ "${push_iso_write_script}" == "true" || "${push_reboot_script}" == "true" || "${push_maxinet_setup_script}" == "true" ]]; then
        msg "$(s red)Error, only one push script can be called at one time!$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi
      shift
      ;;
    --push-reboot-script)
      push_reboot_script=true
      if [[ "${push_iso_write_script}" == "true" || "${push_shutdown_script}" == "true" || "${push_maxinet_setup_script}" == "true" ]]; then
        msg "$(s red)Error, only one push script can be called at one time!$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi
      shift
      ;;
    --push-maxinet-setup-script)
      push_maxinet_setup_script=true
      if [[ "${push_iso_write_script}" == "true" || "${push_shutdown_script}" == "true" || "${push_reboot_script}" == "true" ]]; then
        msg "$(s red)Error, only one push script can be called at one time!$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi
      shift
      ;;
    --password)
      password="$2"
      shift 2
      ;;
    --options)
      options="$2"
      shift 2
      ;;
    --silent-push)
      silent_push=true
      shift
      ;;
    --silent)
      silent=true
      shift
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
    esac
  done

  # Added required packages
  maxibuild --include "ssh netcat rsync"

  # ssh_api login --server sun.sofibox.com --port 893 --group root --user root
  # This is equivalent to the above:
  # ssh_api login -sp sun.sofibox.com:893 --gu root:root

  # Special login short form
  # ssh_api login root
  # ssh_api login my_ssh_user
  # ssh_api push-script
  # Example of downloading log file from the remote to local path/log
  # ssh_api file-download --server-port test.server.com:444 --group-user root:root --remote-path ~/maxinet.log --local-path "${SCRIPT_PATH}/log"
  if [[ "${action}" == "file-download" || "${action}" == "download-files" || "${action}" == "get-files" || "${action}" == "get-file" || "${action}" == "file-retrieve" || "${action}" == "files-retrieve" ]]; then
    local private_key_name private_key_file extra_options

    if [ -z "${rsa_key}" ]; then
      private_key_name="${group}_${user}_${server}.id_rsa"
      private_key_file="/root/.ssh/${private_key_name}"
      rsa_key="${private_key_file}"
    fi

    # Make default options if it is empty
    if [ "${options}" ]; then
      #-x, --one-file-system = do not cross filesystem boundaries
      #-v, --verbose increase verbosity
      #-a, --archive = archive mode; equals -rlptgoD (no -H,-A,-X)
      #--stats = give some file-transfer stats
      options="-avx --stats"
    fi

    # Do not quote local_path to enable multiple file transfers
    msg "$(s cyan)Getting remote files(s) from remote path ${remote_path} to ${local_path} via SSH ...$(e)" --caller="${SCRIPT_NAME}"
    rsync ${options} -e "ssh -q -o 'StrictHostKeyChecking no' -i '${rsa_key}' -p '${port}'" "${user}@${server}:${remote_path}" ${local_path}
    retval=$?
    echo "File download status is ${retval}"
    if [ "${retval}" -ne 0 ]; then
      # I do not like using SCP to download because it does not have incremental feature, comment it
      # scp -r -o "StrictHostKeyChecking no" -P "${port}" -i "${rsa_key}" "${user}@${server}:${remote_path}" ${local_path} 2> >(grep -v 'Permanently' 1>&2)
      # retval=$?
      msg "$(s cyan)Warning, failed to use rsync to download files from remote $(e)" --caller="${SCRIPT_NAME}"
      _exit "${retval}"
    fi

  elif [[ "${action}" == "file-upload" || "${action}" == "upload-files" || "${action}" == "transfer-files" || "${action}" == "transfer-file" || "${action}" == "file-transfer" || "${action}" == "files-transfer" ]]; then
    # ssh_api transfer-files/file-transfer/transfer-file --server-port ${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT} --group-user root:${C_ROOT_USERNAME}
    # --local-files "/tmp/file1 /var/file2" --remote-path ~/
    #ssh_api transfer-files/file-transfer/transfer-file --server ${C_BOX_HOSTNAME_FQHN} ---port ${C_SSH_PORT} --group root --user ${C_ROOT_USERNAME} --local-files "/tmp/file1 /var/file2" --remote-path ~/
    local private_key_name private_key_file

    if [ -z "${rsa_key}" ]; then
      private_key_name="${group}_${user}_${server}.id_rsa"
      private_key_file="/root/.ssh/${private_key_name}"
      rsa_key="${private_key_file}"
    fi

    # Do not quote local_path to enable multiple file transfers
    msg "$(s cyan)Transferring local files(s) [ ${local_files} ] into remote SSH ${remote_path} using rsync ...$(e)" --caller="${SCRIPT_NAME}"
    # Old method using scp
    #scp -o "StrictHostKeyChecking no" -P "${port}" -i "${rsa_key}" ${local_files} "${user}@${server}:${remote_path}" 2> >(grep -v 'Permanently' 1>&2)
    #retval=$?
    #echo "status is ${retval}"

    # New method using rsync (this method required the remote has rsync installed). Better use rsync because it has incremental feature
    # Important, I must use --chown=root:root to make sure that remote uploaded files have root permission by default (for security)
    rsync -og --chown=root:root -Pav --delete -e "ssh -q -o 'StrictHostKeyChecking no' -i '${rsa_key}' -p '${port}'" ${local_files} "${user}@${server}:${remote_path}"
    retval=$?

    # This is an alternative method if rsync failed
    if [ "${retval}" -ne 0 ]; then
      msg "$(s cyan)Warning, failed to use rsync to transfer file. Transferring using scp method ... $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s cyan)Transferring local files(s) [ ${local_files} ] into remote SSH ${remote_path} using scp ...$(e)" --caller="${SCRIPT_NAME}"
      # Old method using scp
      scp -o "StrictHostKeyChecking no" -P "${port}" -i "${rsa_key}" ${local_files} "${user}@${server}:${remote_path}" 2> >(grep -v 'Permanently' 1>&2)
      retval=$?
    fi

    echo "File transfer status is ${retval}"

    # ssh_api luks-unlock --port 8922 --password 1234
    # or without argument ssh_api luks-unlock (it will get the default values from config file)
    # This function is used to unlock LUKS disk encryption on boot via terminal
    # Usage: ssh_api luks-unlock --port <drop_bear_port> --password <disk_luks_password>
    # Note 1: The drop_bear_port is setup using dropbear-initramfs (This is set in OS preseed-file and config file)
    # Note 2: The disk_luks_password is the OS LUKS encryption password (This is set in OS preseed-file and config file)
    # Note 3: The unlock method required a port and a password. It will use a normal SSH with certificate (Certificate is set in OS preseed-file)
    # Note 4: After it has successfully logged into the system via SSH, we write the disk_luks_password using this code and the OS will automatically unlock it: "echo -ne \"${pass}\" > /lib/cryptsetup/passfifo"
    # eg calling within code: ssh_api luks-unlock --port 8922 --password 1234
    # eg calling outside code: <script_name> --ssh-luks-unlock --port 8922 --password 1234
    # Guide: https://www.arminpech.de/2019/12/23/debian-unlock-luks-root-partition-remotely-by-ssh-using-dropbear/
    # Guide 2: https://www.gandalfk7.it/posts/20200914_02_Debian_9_and_10_boot_luks_unlock/
  elif [[ "${action}" == "luks-unlock" || "${action}" == "ssh-luks-unlock" || "${action}" == "unlock-luks" ]]; then

    # This means if the argument is only 1 (with action argument)
    if [[ "${argnum}" -le 1 ]]; then
      linode_label="${C_BOX_HOSTNAME_FQHN}"
      port="${C_DROP_BEAR_PORT}"
      password="${C_LUKS_PASS}"
    fi

    if [ -z "${rsa_key}" ]; then
      private_key_name="root_${C_ROOT_USERNAME}_${linode_label}.id_rsa"
      private_key_file="/root/.ssh/${private_key_name}"
      rsa_key="${private_key_file}"
    fi

    msg "$(s cyan)Unlocking LUKS encrypted disk on boot via SSH port ${port} ...$(e)" --caller="${SCRIPT_NAME}"

    if [ -f "${rsa_key}" ]; then
      # Do not use -q, need verbose for this connection to debug error
      ssh -o "StrictHostKeyChecking no" -oAddressFamily=inet -p "${port}" -i "${rsa_key}" "${linode_label}" "echo -ne \"${password}\" > /lib/cryptsetup/passfifo" 2> >(grep -v 'Permanently added' 1>&2)
      retval=$?
      if [ ${retval} -eq 0 ]; then
        msg "$(s green)Success, LUKS disk unlocked with return code 0 $(e)" --caller="${SCRIPT_NAME}"
      else
        msg "$(s yellow)Warning, failed to unlock LUKS disk [return code ${retval}]$(e)" --caller="${SCRIPT_NAME}"
      fi
    else
      msg "$(s red)Error, private key ${rsa_key} does not exist!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

  elif [ "${action}" == "login" ]; then
    local option ssh_pid private_key_name private_key_file
    option="$2"
    # This is special login based on user from config file (for faster login)
    if [[ ${argnum} -le 1 || "${option}" == "${C_ROOT_USERNAME}" ]]; then
      private_key_name="root_${C_ROOT_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa"
      private_key_file="/root/.ssh/${private_key_name}"
      rsa_key="${private_key_file}"

      msg "$(s cyan)Checking whether ${C_BOX_HOSTNAME_FQHN}'s port ${C_SSH_PORT} is online ...$(e)" --caller="${SCRIPT_NAME}"
      if is_valid available_port "${C_BOX_HOSTNAME_FQHN}" "${C_SSH_PORT}"; then
        msg "$(s green)OK, the port ${C_SSH_PORT} is available at ${C_BOX_HOSTNAME_FQHN}$(e)" --caller="${SCRIPT_NAME}"
      else
        msg "$(s yellow)Warning, the --server-port ${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT} is not available!$(e)" --caller="${SCRIPT_NAME}"
        # This will check available port even if NO LUKS encrypted
        msg "$(s cyan)Checking server ${C_BOX_HOSTNAME_FQHN}'s online status ...$(e)" --caller="${SCRIPT_NAME}"
        linode_status=$(maxipi linode get-linode-status --for-linode-label "${C_BOX_HOSTNAME_FQHN}" --scripting)
        if [ "${linode_status}" == "offline" ]; then
          msg "$(s yellow)Warning, linode is offline!$(e)" --caller="${SCRIPT_NAME}"
          maxipi linode boot-linode --for-linode-label "${C_BOX_HOSTNAME_FQHN}" --for-linode-config-label "${C_LINODE_OS_CONFIG_LABEL}" --check-for-busy-status --wait-until-linode-status online
          get_status_message "$?"
        fi
        ssh_api luks-unlock --port "${C_DROP_BEAR_PORT}" --password "${C_LUKS_PASS}"

        sleep 7

        if is_valid available_port "${C_BOX_HOSTNAME_FQHN}" "${C_SSH_PORT}"; then
          msg "$(s green)OK, the port ${C_SSH_PORT} is available at ${C_BOX_HOSTNAME_FQHN} $(e)" --caller="${SCRIPT_NAME}"
        else
          msg "$(s red)Error, the --server-port ${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT} is not available (make sure server is online or port ${C_SSH_PORT} is available)$(e)" --caller="${SCRIPT_NAME}"
          # TODO can retry here with option --max-retry N
          #ssh_api login
          exit 1
        fi
      fi
      msg "$(s cyan)Logging into SSH server at ${C_ROOT_USERNAME}@${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}... $(e)" --caller="${SCRIPT_NAME}"
      ssh -o "StrictHostKeyChecking no" -i "${rsa_key}" -p "${C_SSH_PORT}" "${C_ROOT_USERNAME}@${C_BOX_HOSTNAME_FQHN}"
    elif [ "${option}" == "${C_SSH_USERNAME}" ]; then
      private_key_name="user_${C_SSH_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa"
      private_key_file="/root/.ssh/${private_key_name}"
      rsa_key="${private_key_file}"

      msg "$(s cyan)Checking whether ${C_BOX_HOSTNAME_FQHN}'s port ${C_SSH_PORT} is online ...$(e)" --caller="${SCRIPT_NAME}"
      # This will check available port even if NO LUKS encrypted
      if is_valid available_port "${C_BOX_HOSTNAME_FQHN}" "${C_SSH_PORT}"; then
        msg "$(s green)OK, the port ${C_SSH_PORT} is available at ${C_BOX_HOSTNAME_FQHN} $(e)" --caller="${SCRIPT_NAME}"
      else
        msg "$(s yellow)Warning, the --server-port ${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT} is not available!$(e)" --caller="${SCRIPT_NAME}"
        msg "$(s cyan)Checking server ${C_BOX_HOSTNAME_FQHN}'s online status ...$(e)" --caller="${SCRIPT_NAME}"
        linode_status=$(maxipi linode get-linode-status --for-linode-label "${C_BOX_HOSTNAME_FQHN}" --scripting)

        if [ "${linode_status}" == "offline" ]; then
          msg "$(s yellow)Warning, linode is offline!$(e)" --caller="${SCRIPT_NAME}"
          maxipi linode boot-linode --for-linode-label "${C_BOX_HOSTNAME_FQHN}" --for-linode-config-label "${C_LINODE_OS_CONFIG_LABEL}" --check-for-busy-status --wait-until-linode-status online
          get_status_message "$?"
        fi
        ssh_api luks-unlock --port "${C_DROP_BEAR_PORT}" --password "${C_LUKS_PASS}"
        sleep 7
        if is_valid available_port "${C_BOX_HOSTNAME_FQHN}" "${C_SSH_PORT}"; then
          msg "$(s green)OK, the port ${C_SSH_PORT} is available at ${C_BOX_HOSTNAME_FQHN} $(e)" --caller="${SCRIPT_NAME}"
        else
          msg "$(s red)Error, the --server-port ${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT} is not available (make sure server is online or port ${C_SSH_PORT} is available)$(e)" --caller="${SCRIPT_NAME}"
          exit 1
        fi
      fi
      msg "$(s cyan)Logging into SSH server at ${C_SSH_USERNAME}@${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}... $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s yellow)Note: After successfully logged in as non-root user, use command [ sudo su - ] to login as root user$(e)" --caller="${SCRIPT_NAME}"
      ssh -o "StrictHostKeyChecking no" -i "${rsa_key}" -p "${C_SSH_PORT}" "${C_SSH_USERNAME}@${C_BOX_HOSTNAME_FQHN}"
    else
      if [[ -z "${group}" ]]; then
        msg "$(s red)Error, the option --group is required to have value$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      elif [[ -z "${user}" ]]; then
        msg "$(s red)Error, the option --user is required to have value$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      elif [[ -z "${server}" ]]; then
        msg "$(s red)Error, the option --server is required to have value$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      elif [[ -z "${port}" ]]; then
        msg "$(s red)Error, the option --port is required to have value$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi

      # This will check available port even if NO LUKS encrypted
      msg "$(s cyan)Checking whether ${server}'s port ${port} is online ...$(e)" --caller="${SCRIPT_NAME}"
      if is_valid available_port "${server}" "${port}"; then
        msg "$(s green)OK, the port ${port} is available at ${server} $(e)" --caller="${SCRIPT_NAME}"
      else
        msg "$(s yellow)Warning, the --server-port ${server}:${port} is not available!$(e)" --caller="${SCRIPT_NAME}"
        msg "$(s cyan)Checking server ${server}'s online status ...$(e)" --caller="${SCRIPT_NAME}"
        linode_status=$(maxipi linode get-linode-status --for-linode-label "${server}" --scripting)
        if [ "${linode_status}" == "offline" ]; then
          msg "$(s yellow)Warning, linode is offline!$(e)" --caller="${SCRIPT_NAME}"
          maxipi linode boot-linode --for-linode-label "${server}" --for-config-label "${C_LINODE_OS_CONFIG_LABEL}" --check-for-busy-status --wait-until-linode-status online
          get_status_message "$?"
        fi
        ssh_api luks-unlock --port "${C_DROP_BEAR_PORT}" --password "${C_LUKS_PASS}"
        sleep 7
        if is_valid available_port "${server}" "${port}"; then
          msg "$(s green)OK, the port ${port} is available at ${server} $(e)" --caller="${SCRIPT_NAME}"
        else
          msg "$(s red)Error, the --server-port ${server}:${port} is not available (make sure server is online or port ${port} is available)$(e)" --caller="${SCRIPT_NAME}"
          exit 1
        fi
      fi

      if [ -z "${rsa_key}" ]; then
        private_key_name="${group}_${user}_${server}.id_rsa"
        private_key_file="/root/.ssh/${private_key_name}"
        rsa_key="${private_key_file}"
      fi

      if [ ! -f "${rsa_key}" ]; then
        msg "$(s red)Error, invalid public RSA key file at ${rsa_key}. Please make sure the file exist$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi

      msg "$(s cyan)Logging into SSH server at ${user}@${server}:${port}... $(e)" --caller="${SCRIPT_NAME}"
      ssh -o "StrictHostKeyChecking no" -i "${rsa_key}" -p "${port}" "${user}${server}"
      #ssh_pid=$?
      #{ kill -9 ${ssh_pid} && wait ${ssh_pid}; } 2>/dev/null
    fi
  # For linode LISH login
  # ssh_api lish-login --key /root/.ssh/linode_lish.id_rsa --user maxibi --server lish-singapore.linode.com --port 22 --linode-label sun.sofibox.com
  elif [ "${action}" == "lish-login" ]; then
    local ssh_pid
    # This is not a normal SSH (it uses Pseudo-TTY)
    # Normal: ssh_api lish-login
    if [ -z "${rsa_key}" ]; then
      rsa_key="/root/.ssh/linode_lish.id_rsa"
    fi

    if [ -z "${user}" ]; then
      user="${C_LINODE_API_USERNAME}"
    fi

    if [ ! -f "${rsa_key}" ]; then
      msg "$(s red)Error, invalid RSA key file at ${rsa_key}. Please make sure the file exist$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    msg "$(s cyan)Logging into lish console ${user}@${server}... $(e)" --caller="${SCRIPT_NAME}"
    # In Windows WSL linux, there will be error log saying: setsockopt IPV6_TCLASS 16: Operation not permitted: (this message can be ignored)
    # Note 2 linode lish requires to use -t option to login. -t option means pseudo-tty (some suggested to use double -tt)
    ssh -o "StrictHostKeyChecking no" -i "${rsa_key}" -p "${port}" -tt "${user}@${server}" "${linode_label}" 2> >(grep -v "Permanently added" 1>&2)
    ssh_pid=$?
    { kill -9 ${ssh_pid} && wait ${ssh_pid}; } 2>/dev/null

  # For SSH push script
  elif [ "${action}" == "push-script" ]; then
    local private_key_name private_key_file ssh_pid
    # ssh_api push-script --server ${C_BOX_HOSTNAME_FQHN} --port ${C_SSH_PORT} --group root --user ${C_ROOT_USERNAME} --local-script-path "${CODE_PATH}/ssh_scripts/maxinet_setup.sh"
    # The above is equivalent to below (shortest form)
    # ssh_api push-script --server-port sun.sofibox.com:893 --group-user root:root --push-maxinet-setup-script

    if [[ -z "${group}" ]]; then
      msg "$(s red)Error, the option --group is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    elif [[ -z "${user}" ]]; then
      msg "$(s red)Error, the option --user is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    elif [[ -z "${server}" ]]; then
      msg "$(s red)Error, the option --server is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    elif [[ -z "${port}" ]]; then
      msg "$(s red)Error, the option --port is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    if [ -z "${rsa_key}" ]; then
      private_key_name="${group}_${user}_${server}.id_rsa"
      private_key_file="/root/.ssh/${private_key_name}"
      rsa_key="${private_key_file}"
    fi

    if [ ! -f "${rsa_key}" ]; then
      msg "$(s red)Error, invalid public RSA key file at ${rsa_key}. Please make sure the file exist$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    # Shortest form
    if [ -z "${local_script_path}" ]; then
      if [ "${push_maxinet_setup_script}" == "true" ]; then
        local_script_path="${CODE_PATH}/ssh_scripts/maxinet_setup.sh"
      elif [ "${push_shutdown_script}" == "true" ]; then
        # This script can be used as normal SSH
        local_script_path="${CODE_PATH}/ssh_scripts/shutdown_command.sh"
      elif [ "${push_reboot_script}" == "true" ]; then
        # This script can be used as normal SSH
        local_script_path="${CODE_PATH}/ssh_scripts/reboot_command.sh"
      else
        msg "$(s red)Error. the option --local-script-path requires to have a valid script path to be pushed into SSH server or use predefined push script option such as --push-shutdown-script$(e)" --caller="${SCRIPT_NAME}"
      fi
    fi

    msg "$(s cyan)Pushing script ${local_script_path} into SSH console ${user}@${server}... $(e)" --caller="${SCRIPT_NAME}"

    if [ "${silent_push}" == "true" ]; then
      ssh -q -o "StrictHostKeyChecking no" -i "${rsa_key}" -p "${port}" "${user}@${server}" <"${local_script_path}" >/dev/null 2>&1 &
    else
      # Must pass the value -tt (else the terminal color won't work)
      ssh -o "StrictHostKeyChecking no" -i "${rsa_key}" -p "${port}" -tt "${user}@${server}" <"${local_script_path}"
    fi
    # Test kill after 10 seconds
    #sleep 10
    #ssh_pid=$?
    #{ kill -9 ${ssh_pid} && wait ${ssh_pid}; } 2>/dev/null
    # For linode LISH push script
    # Note that lish-push-script only can be used on recovery mode because in recovery mode, it doesn't have authentication.
  elif [ "${action}" == "lish-push-script" ]; then
    local ssh_pid

    if [ -z "${rsa_key}" ]; then
      rsa_key="/root/.ssh/linode_lish.id_rsa"
    fi

    if [ -z "${user}" ]; then
      user="${C_LINODE_API_USERNAME}"
    fi

    if [ ! -f "${rsa_key}" ]; then
      msg "$(s red)Error, invalid RSA key file at ${rsa_key}. Please make sure the file exist$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    #Shortest form
    # if dont specify local_script_path, i can specify option such as --push-os-write, --push-shutdown, --push-reboot
    if [ -z "${local_script_path}" ]; then
      if [ "${push_iso_write_script}" == "true" ]; then
        # This is dangerous script that can wipe partition
        local_script_path="${CODE_PATH}/ssh_scripts/os_write_ag.sh"
      elif [ "${push_shutdown_script}" == "true" ]; then
        local_script_path="${CODE_PATH}/ssh_scripts/shutdown_command.sh"
      elif [ "${push_reboot_script}" == "true" ]; then
        local_script_path="${CODE_PATH}/ssh_scripts/reboot_command.sh"
      else
        msg "$(s red)Error. the option --local-script-path requires to have a valid script path to be pushed into SSH server or use predefined push script option such as --push-shutdown-script$(e)" --caller="${SCRIPT_NAME}"
      fi
    fi

    msg "$(s cyan)Pushing script ${local_script_path} into lish console ${user}@${server}... $(e)" --caller="${SCRIPT_NAME}"

    #ssh -q -o "StrictHostKeyChecking no" -i /root/.ssh/linode_lish.id_rsa -tt "${C_LINODE_API_USERNAME}@${C_LINODE_TERMINAL_SERVER}" "${C_BOX_HOSTNAME_FQHN}" <"${SCRIPT_PATH}/dns/linode/os_write.sh" >/dev/null 2>&1 &

    # push script: ssh_api lish-push-script --key rsa_key.id.rsa --user maxibi --server member.linode.com --linode-label sun.sofibox.com --local-script-path /tmp/os_write.sh
    ssh -o "StrictHostKeyChecking no" -i "${rsa_key}" -p "${port}" -tt "${user}@${server}" "${linode_label}" <"${local_script_path}" >/dev/null 2>&1 &
    #ssh_pid=$?
    # Test kill after 10 seconds
    #sleep 10

    #{ kill -9 ${ssh_pid} && wait ${ssh_pid}; } 2>/dev/null
  elif [ "${action}" == "create-key" ]; then
    local private_key_name
    mkdir -p "${key_path}"
    if [[ -z "${group}" ]]; then
      msg "$(s red)Error, the option --group is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    elif [[ -z "${user}" ]]; then
      msg "$(s red)Error, the option --user is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    elif [[ -z "${server_label}" ]]; then
      msg "$(s red)Error, the option --server-label is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    else
      private_key_name="${group}_${user}_${server_label}.id_rsa"

    fi

    msg "$(s cyan)Creating private and public key RSA SSH key authentication at ${key_path}/${private_key_name} ...$(e)" --caller="${SCRIPT_NAME}"
    ssh-keygen -f "${key_path}/${private_key_name}" -t rsa -b 4096 -P "" -C "${comment}" <<<y

  elif [ "${action}" == "create-key-with-putty" ]; then
    local private_key_name private_key_putty_name
    mkdir -p "${key_path}"
    if [[ -z "${group}" ]]; then
      msg "$(s red)Error, the option --group is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    elif [[ -z "${user}" ]]; then
      msg "$(s red)Error, the option --user is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    elif [[ -z "${server_label}" ]]; then
      msg "$(s red)Error, the option --server-label is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    else
      private_key_name="${group}_${user}_${server_label}.id_rsa"
      private_key_putty_name="${group}_${user}_${server_label}.ppk"
    fi
    # This key will be stored in secure folder first not /root/.ssh

    msg "$(s cyan)Creating private and public key RSA SSH key authentication at ${key_path}/${private_key_name} ...$(e)" --caller="${SCRIPT_NAME}"
    ssh-keygen -f "${key_path}/${private_key_name}" -t rsa -b 4096 -P "" -C "${comment}" <<<y

    echo ""
    maxibuild --include "putty-tools"

    msg "$(s cyan)Creating RSA SSH key authentication for Putty at ${key_path}/${private_key_putty_name} ...$(e)" --caller="${SCRIPT_NAME}"
    puttygen "${key_path}/${private_key_name}" -o "${key_path}/${private_key_putty_name}"

  elif

    [[ "${action}" == "get-pubkey" || "${action}" == "get-public-key" ]]
  then
    local public_key_name public_key_file
    if [[ -z "${group}" ]]; then
      msg "$(s red)Error, the option --group is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    elif [[ -z "${user}" ]]; then
      msg "$(s red)Error, the option --user is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    elif [[ -z "${server_label}" ]]; then
      msg "$(s red)Error, the option --server-label is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    else
      public_key_name="${group}_${user}_${server_label}.id_rsa.pub"
      # Note. This one should be the location of the secure path of script not the root path of ssh in the system such as /root/.ssh
      public_key_file="${SECURE_PATH}/ssh/${public_key_name}"
    fi

    if [ -f "${public_key_file}" ]; then
      cat "${public_key_file}"
      return 0
    else
      msg "$(s red)Error, RSA public key does not exist in ${public_key_file}. Please create it first$(e)" --caller="${SCRIPT_NAME}"
      return 147
    fi
  elif [[ "${action}" == "get-prikey" || "${action}" == "get-private-key" ]]; then
    local private_key_name private_key_file
    if [[ -z "${group}" ]]; then
      msg "$(s red)Error, the option --group is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    elif [[ -z "${user}" ]]; then
      msg "$(s red)Error, the option --user is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    elif [[ -z "${server_label}" ]]; then
      msg "$(s red)Error, the option --server-label is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    else
      private_key_name="${group}_${user}_${server_label}.id_rsa"
      private_key_file="/root/.ssh/${private_key_name}"
    fi
    if [ -f "${private_key_file}" ]; then
      cat "${private_key_file}"
      return 0
    else
      msg "$(s red)Error, RSA private key does not exist in ${private_key_file}. Please create it first$(e)" --caller="${SCRIPT_NAME}"
      return 147
    fi

    # Warning this will replace existing key

    # ssh_api copy-public-keys --destination /root/.ssh/
    # Haven't implemented --destination (not so important) default should be /root/.ssh/
  elif [[ "${action}" == "copy-pubkeys" || "${action}" == "copy-publickeys" || "${action}" == "copy-public-keys" ]]; then
    local response retval
    mkdir -p /root/.ssh
    if [ "${without_prompt}" == "true" ]; then
      if [ -f /root/.ssh/known_hosts ]; then
        # No need to display this message if using with option --without-prompt
        #msg "$(s cyan)Resetting known_hosts and copying all public key to /root/.ssh/* ...$(e)" --caller="${SCRIPT_NAME}"
        echo >/root/.ssh/known_hosts
      fi

      # TODO silence this
      # msg "Copying rsa key from ${key_path}/*.id_rsa* into /root/.ssh/ ..."
      cp "${key_path}"/*.id_rsa* /root/.ssh/

      chmod -R 600 /root/.ssh/
    else
      read -r -p "Warning, this will replace existing public key files (except putty format) from ${key_path} into ${HOME}/.ssh. Are you sure? [Y/n]" response
      response=$(echo "${response}" | tr '[:upper:]' '[:lower:]')
      if [[ $response =~ ^(yes|y| ) ]] || [[ -z $response ]]; then
        msg "$(s cyan)Resetting known_hosts and copying all public key to /root/.ssh/* ...$(e)" --caller="${SCRIPT_NAME}"
        echo >/root/.ssh/known_hosts
        cp "${key_path}"/*.id_rsa* /root/.ssh/
        chmod -R 600 /root/.ssh/
      else
        msg "$(s red)Operation aborted by user!$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi
    fi

  elif [[ "${action}" == "clear-known-hosts" || "${action}" == "clear-known-host" ]]; then
    msg "$(s cyan)Resetting known_hosts and copying all public key .id_rsa from ${key_path}/ to /root/.ssh/* ...$(e)" --caller="${SCRIPT_NAME}"
    echo >/root/.ssh/known_hosts

  # ssh_api mkdir --server-port sun.sofibox.com:893 --group-user root:root --remote-path "~/dir_name"
  elif [[ "${action}" == "mkdir" || "${action}" == "create-dir" || "${action}" == "create-folder" ]]; then
    local private_key_name private_key_file retval

    if [[ -z "${group}" ]]; then
      msg "$(s red)Error, the option --group is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    elif [[ -z "${user}" ]]; then
      msg "$(s red)Error, the option --user is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    elif [[ -z "${server}" ]]; then
      msg "$(s red)Error, the option --server is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    elif [[ -z "${port}" ]]; then
      msg "$(s red)Error, the option --port is required to have value$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    if [ -z "${rsa_key}" ]; then
      private_key_name="${group}_${user}_${server}.id_rsa"
      private_key_file="/root/.ssh/${private_key_name}"
      rsa_key="${private_key_file}"
    fi

    if [ ! -f "${rsa_key}" ]; then
      msg "$(s red)Error, invalid public RSA key file at ${rsa_key}. Please make sure the file exist$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    ssh -o "StrictHostKeyChecking no" -i "${rsa_key}" -p "${port}" "${user}@${server}" "mkdir -p ${remote_path}"
    retval=$?

    if [ "${retval}" -ne 0 ]; then
      msg "$(s red)Error, directory creation failed$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    echo "Remote directory creation status is ${retval}"
  else
    msg "$(s red)Error, unknown action ${action} argument specified when calling ssh_api function!$(e)" --caller="${SCRIPT_NAME}"
    return 147
  fi
}
#maxinet lish-console <options>

#maxinet lish-console kill - kill stuck screen sessions
#maxinet lish-console exit - exit from lish
#maxinet lish-console help - this menu
#maxinet lish-console [return] - connect to console
#maxinet lish-console boot - boot last used (or the only) config profile
#maxinet lish-console boot N - boot the specified config profile. Where N is the profile number assigned as: N) Config Name
#maxinet lish-console reboot - shut down, then boot the last used config profile
#maxinet lish-console reboot N - shut down, then boot the specified config profile. Where N is the profile number assigned as: N) Config Name
#maxinet lish-console sysrq X - send SysRq X to your Linode. Where X is the sysrq code that can be found here: https://en.wikipedia.org/wiki/Magic_SysRq_key#Commands
#maxinet lish-console shutdown - shut down the Linode
#maxinet lish-console destroy - pulls the plug on a running Linode, no fs sync, no warning
#maxinet lish-console jobs - view the job queue for your Linode
#maxinet lish-console version - display running kernel version
#maxinet lish-console configs - view the configuration profiles for your Linode
#maxinet lish-console config N - view configuration profile details for profile N
#maxinet lish-console status - view the status of your Linode
#maxinet lish-console logview - view contents of console log

lish_console() {
  #exec_time start lish_console
  options="$*"
  # If we do not give value for option, it means we are using the return signal (means connect to console)
  if [ -z "${options}" ]; then
    msg "$(s cyan)Executing lish-console command [ RETURN - connect to console] ...$(e)" --caller="${SCRIPT_NAME}"
  else
    msg "$(s cyan)Executing lish-console command [ ${options} ] ...$(e)" --caller="${SCRIPT_NAME}"
  fi
  # Only run this in local machine
  # This will list out the number of lish config profile for OS_Config (currently this has bug in linode because it took longer to list out and has duplicated Rescue Mode entry)
  # Sent question to ticket waiting for answer to speedup this one
  #maxinet --lish configs 2>&1 | grep 'OS_Config' | awk -F')' '{ print $1 }' | xargs
  # I use 2>&1 to hide error output
  ssh -i "/root/.ssh/linode_lish.id_rsa" -o "StrictHostKeyChecking no" -oAddressFamily=inet -tt "${C_LINODE_API_USERNAME}@${C_LINODE_TERMINAL_SERVER}" "${C_BOX_HOSTNAME_FQHN}" ${options}
  #exec_time end lish_console
}

# This function will validate if config is valid, if one of the variables missing, it will complain and exit
# TODO update check with new variables
validate_config() {
  local count_user total_valid_user this_da_owner_name this_da_owner_uname this_da_owner_password this_da_owner_system_email
  total_valid_user=0
  msg "$(s cyan)Checking directadmin users' variables ...$(e)" --caller="${SCRIPT_NAME}"
  #--------------------#
  # Validate admin     #
  #--------------------#
  # Owner does not support multiple user creation. So checking is simple without loop
  typeset -n "this_da_owner_name=C_DA_OWNER_NAME1"
  typeset -n "this_da_owner_uname=C_DA_OWNER_USERNAME1"
  typeset -n "this_da_owner_password=C_DA_OWNER_USERPASS1"
  typeset -n "this_da_owner_system_email=C_DA_OWNER_SYSTEM_EMAIL1"

  if [[ "${#this_da_owner_uname}" -lt 2 ]]; then
    msg "[Skipped]: Warning owner username length is ${#this_da_owner_uname} but the it should be more or equal to 2. Please check configuration file"
    exit 1
  elif [[ "${#this_da_owner_uname}" -gt ${C_DA_MAX_USERNAME_LENGTH} ]]; then
    msg "[Skipped]: Warning owner username length is ${#this_da_owner_uname} but the it should be less or equal to ${C_DA_MAX_USERNAME_LENGTH}. Please check configuration file"
    exit 1
  elif [[ -z "${this_da_owner_name+x}" ]]; then
    msg "[Skipped]: Warning owner ${this_da_owner_uname} doesn't have name set in config file (missing or invalid variable). Please check configuration file"
    exit 1
  elif [[ -z "${this_da_owner_password+x}" ]]; then
    msg "[Skipped]: Warning owner ${this_da_owner_uname} doesn't have password set in config file (missing or invalid variable). Please check configuration file "
    exit 1
  elif [[ "${#this_da_owner_password}" -lt 6 ]]; then
    msg "[Skipped]: Warning owner ${this_da_owner_uname} has password set length of ${#C_DA_OWNER_USERPASS1} but the minimum is 6 characters. Please check configuration file"
    exit 1
  elif [[ "${#this_da_owner_password}" -gt 64 ]]; then
    msg "[Skipped]: Warning owner ${this_da_owner_uname} has password set length of ${#C_DA_OWNER_USERPASS1} but the maximum is 64 characters. Please check configuration file"
    exit 1
  elif [[ "${this_da_owner_password}" =~ ['&+'] ]]; then
    msg "[Skipped]: Warning owner ${this_da_owner_uname} has password set with forbidden special character [ &+ ] in config file. Please check configuration file"
    exit 1
  elif [[ -z "${this_da_owner_system_email+x}" ]]; then
    msg "[Skipped]: Warning owner ${this_da_owner_uname} doesn't have system email set in config file (missing or invalid variable). Please check configuration file "
    exit 1
  elif ! is_valid "email" "${this_da_owner_system_email}"; then
    msg "[Skipped]: Warning owner ${this_da_owner_uname} has invalid email [ ${this_da_owner_system_email} ] set in config file. Please check configuration file "
    exit 1
  else
    #msg "$(s green)OK, all variables for owner ${C_DA_OWNER_USERNAME1} are valid.$(e)" --caller="${SCRIPT_NAME}"
    ((total_valid_user++))
  fi

  #--------------------#
  # Validate admin     #
  #--------------------#
  local da_admin_unames this_da_admin_uname this_da_admin_password this_da_admin_name \
    this_da_admin_system_email count_user

  da_admin_unames="${!C_DA_ADMIN_USERNAME@}"
  count_user=1
  while [[ ${count_user} -le $(echo "${da_admin_unames}" | wc -w) ]]; do
    typeset -n "this_da_admin_uname=C_DA_ADMIN_USERNAME${count_user}"
    typeset -n "this_da_admin_password=C_DA_ADMIN_USERPASS${count_user}"
    typeset -n "this_da_admin_name=C_DA_ADMIN_NAME${count_user}"
    typeset -n "this_da_admin_system_email=C_DA_ADMIN_SYSTEM_EMAIL${count_user}"

    if [[ "${#this_da_admin_uname}" -lt 2 ]]; then
      msg "[Skipped]: Warning admin username length is ${#this_da_admin_uname} but the it should be more or equal to 2. Please check configuration file"
      exit 1
    elif [[ "${#this_da_admin_uname}" -gt ${C_DA_MAX_USERNAME_LENGTH} ]]; then
      msg "[Skipped]: Warning admin username length is ${#this_da_admin_uname} but the it should be less or equal to ${C_DA_MAX_USERNAME_LENGTH}. Please check configuration file"
      exit 1
    elif [[ -z "${this_da_admin_password+x}" ]]; then
      msg "[Skipped]: Warning admin ${this_da_admin_uname} doesn't have password set in config file (missing or invalid variable). Please check configuration file "
      exit 1
    elif [[ "${#this_da_admin_password}" -lt 6 ]]; then
      msg "[Skipped]: Warning admin ${this_da_admin_uname} has password set length of ${#this_da_admin_password} but the minimum is 6 characters. Please check configuration file"
      exit 1
    elif [[ "${#this_da_admin_password}" -gt 64 ]]; then
      msg "[Skipped]: Warning admin ${this_da_admin_uname} has password set length of ${#this_da_admin_password} but the maximum is 64 characters. Please check configuration file"
      exit 1
    elif [[ "${this_da_admin_password}" =~ ['&+'] ]]; then
      msg "[Skipped]: Warning admin ${this_da_admin_uname} has password set with forbidden special characters [ &+ ] in config file. Please check configuration file"
      exit 1
    elif [[ -z "${this_da_admin_name+x}" ]]; then
      msg "[Skipped]: Warning admin ${this_da_admin_uname} doesn't have name set in config file (missing or invalid variable). Please check configuration file "
      exit 1
    elif [[ -z "${this_da_admin_system_email+x}" ]]; then
      msg "[Skipped]: Warning admin ${this_da_admin_uname} doesn't have system email set in config file (missing or invalid variable). Please check configuration file "
      exit 1
    elif ! is_valid "email" "${this_da_admin_system_email}"; then
      msg "[Skipped]: Warning admin ${this_da_admin_uname} has invalid email [ ${this_da_admin_system_email} ] set in config file. Please check configuration file "
      exit 1
    else
      # msg "$(s green)OK, all variables for admin ${this_da_admin_uname} are valid.$(e)" --caller="${SCRIPT_NAME}"
      ((total_valid_user++))
    fi
    ((count_user++))
  done

  #--------------------#
  # Validate resellers #
  #--------------------#
  local this_da_reseller_uname this_da_reseller_password this_da_reseller_name this_da_reseller_system_email \
    this_da_reseller_package_name this_da_reseller_domains this_da_reseller_wildcard_domains \
    this_c_da_reseller_ip_type this_da_reseller_enable_domain_ssl this_da_reseller_ssl_subdomains this_da_reseller_mail_accounts this_da_reseller_db_accounts

  count_user=1

  while [[ ${count_user} -le $(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w) ]]; do

    typeset -n "this_da_reseller_uname=C_DA_RESELLER_USERNAME${count_user}"
    typeset -n "this_da_reseller_password=C_DA_RESELLER_USERPASS${count_user}"
    typeset -n "this_da_reseller_name=C_DA_RESELLER_NAME${count_user}"
    typeset -n "this_da_reseller_system_email=C_DA_RESELLER_SYSTEM_EMAIL${count_user}"
    typeset -n "this_da_reseller_package_name=C_DA_RESELLER_PACKAGE_NAME${count_user}"
    typeset -n "this_da_reseller_domains=C_DA_RESELLER_DOMAIN${count_user}"
    typeset -n "this_da_reseller_wildcard_domains=C_DA_RESELLER_WILDCARD_DOMAIN${count_user}"
    typeset -n "this_c_da_reseller_ip_type=C_DA_RESELLER_IP_TYPE${count_user}"
    typeset -n "this_da_reseller_enable_domain_ssl=C_DA_RESELLER_ENABLE_DOMAIN_SSL${count_user}"
    typeset -n "this_da_reseller_ssl_subdomains=C_DA_RESELLER_SSL_SUBDOMAIN${count_user}"
    typeset -n "this_da_reseller_mail_accounts=C_DA_RESELLER_MAIL_ACCOUNT${count_user}"
    typeset -n "this_da_reseller_db_accounts=C_DA_RESELLER_DB_ACCOUNT${count_user}"

    if [[ "${#this_da_reseller_uname}" -lt 2 ]]; then
      msg "[Skipped]: Warning reseller username length is ${#this_da_reseller_uname} but the it should be more or equal to 2. Please check configuration file"
      exit 1
    elif [[ "${#this_da_reseller_uname}" -gt ${C_DA_MAX_USERNAME_LENGTH} ]]; then
      msg "[Skipped]: Warning reseller username length is ${#this_da_reseller_uname} but the it should be less or equal to ${C_DA_MAX_USERNAME_LENGTH}. Please check configuration file"
      exit 1
    elif [[ -z "${this_da_reseller_password+x}" ]]; then
      msg "[Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have password set in config file (missing or invalid variable). Please check configuration file"
      exit 1
    elif [[ "${#this_da_reseller_password}" -lt 6 ]]; then
      msg "[Skipped]: Warning reseller ${this_da_reseller_uname} has password set length of ${#this_da_reseller_password} but the minimum is 6 characters. Please check configuration file"
      exit 1
    elif [[ "${#this_da_reseller_password}" -gt 64 ]]; then
      msg "[Skipped]: Warning reseller ${this_da_reseller_uname} has password set length of ${#this_da_reseller_password} but the maximum is 64 characters. Please check configuration file"
      exit 1
    elif [[ "${this_da_reseller_password}" =~ ['&+'] ]]; then
      msg "[Skipped]: Warning reseller ${this_da_reseller_uname} has password set with forbidden special characters [ &+ ] in config file. Please check configuration file"
      exit 1
    elif [[ -z "${this_da_reseller_name+x}" ]]; then
      msg "[Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have name set in config file (missing or invalid variable). Please check configuration file"
      exit 1
    elif [[ -z "${this_da_reseller_system_email+x}" ]]; then
      msg "[Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have system email set in config file (missing or invalid variable). Please check configuration file"
      exit 1
    elif [[ -z "${this_da_reseller_package_name+x}" ]]; then
      msg "[Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have package name set in config file. Please check configuration file "
      exit 1
    elif [[ -z "${this_da_reseller_mail_accounts+x}" ]]; then
      msg "[Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have email account set in config file (missing or invalid variable). Please check configuration file"
      exit 1
    elif [[ -n "${this_da_reseller_mail_accounts}" && $(echo "${#this_da_reseller_mail_accounts[@]}") -ne $(awk -F'\|\|\|' '{print NF-1}' <<<"${this_da_reseller_mail_accounts[@]}") ]]; then
      msg "[Skipped]: Warning reseller ${this_da_reseller_uname} has invalid email account format set in config file (invalid separator). Please check configuration file"
      exit 1
      # Just use a normal variable to check (even it is array)
    elif [[ -z "${this_da_reseller_domains+x}" ]]; then
      msg "[Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have domain set in config file (missing or invalid variable). Please check configuration file"
      exit 1
    elif [[ -z "${this_da_reseller_domains}" ]]; then
      msg "[Skipped]: Warning reseller ${this_da_reseller_uname} must have at least one domain set in config file (domain is empty). Please check configuration file"
      exit 1
    elif [[ -z "${this_da_reseller_wildcard_domains+x}" ]]; then
      msg "[Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have wildcard domain set in config file (missing or invalid variable). Please check configuration file"
      exit 1
    elif [[ -z "${this_c_da_reseller_ip_type+x}" ]]; then
      msg "[Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have ip type set in config file (missing or invalid variable). Please check configuration file"
      exit 1
    elif [[ -z "${this_da_reseller_enable_domain_ssl+x}" ]]; then
      msg "[Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have domain enable ssl set in config file (missing or invalid variable). Please check configuration file"
      exit 1
      # TODO check extra this_da_reseller_ssl_subdomains for format
    elif [[ -z "${this_da_reseller_ssl_subdomains+x}" ]]; then
      msg "[Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have ssl subdomains set in config file (missing or invalid variable). Please check configuration file"
      exit 1
    elif [[ -z "${this_da_reseller_db_accounts+x}" ]]; then
      msg "[Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have database account set in config file (missing or invalid variable). Please check configuration file "
      exit 1
    elif [[ -n ${this_da_reseller_db_accounts} && $(echo "${#this_da_reseller_db_accounts[@]}") -ne $(awk -F'\|\|\|' '{print NF-1}' <<<"${this_da_reseller_db_accounts[@]}") ]]; then
      msg "[Skipped]: Warning reseller ${this_da_reseller_uname} has invalid database account format set in config file (invalid separator). Please check configuration file"
      exit 1
    else
      # msg "$(s green)OK, all variables for reseller ${this_da_reseller_uname} are valid.$(e)" --caller="${SCRIPT_NAME}"
      ((total_valid_user++))
    fi
    ((count_user++))
  done

  local this_da_user_uname this_da_user_password this_da_user_name this_da_user_system_email \
    this_da_user_package_name this_da_user_domains this_da_user_wildcard_domains \
    this_da_user_enable_domain_ssl this_da_user_ssl_subdomains this_da_user_mail_accounts this_da_user_db_accounts

  count_user=1

  while [[ ${count_user} -le $(echo "${!C_DA_USER_USERNAME@}" | wc -w) ]]; do

    typeset -n "this_da_user_uname=C_DA_USER_USERNAME${count_user}"
    typeset -n "this_da_user_password=C_DA_USER_USERPASS${count_user}"
    typeset -n "this_da_user_name=C_DA_USER_NAME${count_user}"
    typeset -n "this_da_user_system_email=C_DA_USER_SYSTEM_EMAIL${count_user}"
    typeset -n "this_da_user_package_name=C_DA_USER_PACKAGE_NAME${count_user}"
    typeset -n "this_da_user_domains=C_DA_USER_DOMAIN${count_user}"
    typeset -n "this_da_user_wildcard_domains=C_DA_USER_WILDCARD_DOMAIN${count_user}"
    typeset -n "this_da_user_enable_domain_ssl=C_DA_USER_ENABLE_DOMAIN_SSL${count_user}"
    typeset -n "this_da_user_ssl_subdomains=C_DA_USER_SSL_SUBDOMAIN${count_user}"
    typeset -n "this_da_user_mail_accounts=C_DA_USER_MAIL_ACCOUNT${count_user}"
    typeset -n "this_da_user_db_accounts=C_DA_USER_DB_ACCOUNT${count_user}"

    if [[ "${#this_da_user_uname}" -lt 2 ]]; then
      msg "[Skipped]: Warning user username length is ${#this_da_user_uname} but the it should be more or equal to 2. Please check configuration file"
      exit 1
    elif [[ "${#this_da_user_uname}" -gt ${C_DA_MAX_USERNAME_LENGTH} ]]; then
      msg "[Skipped]: Warning user username length is ${#this_da_user_uname} but the it should be less or equal to ${C_DA_MAX_USERNAME_LENGTH}. Please check configuration file"
      exit 1
    elif [[ -z "${this_da_user_password+x}" ]]; then
      msg "[Skipped]: Warning user ${this_da_user_uname} doesn't have password set in config file (missing or invalid variable). Please check configuration file"
      exit 1
    elif [[ "${#this_da_user_password}" -lt 6 ]]; then
      msg "[Skipped]: Warning user ${this_da_user_uname} has password set length of ${#this_da_user_password} but the minimum is 6 characters. Please check configuration file"
      exit 1
    elif [[ "${#this_da_user_password}" -gt 64 ]]; then
      msg "[Skipped]: Warning user ${this_da_user_uname} has password set length of ${#this_da_user_password} but the maximum is 64 characters. Please check configuration file"
      exit 1
    elif [[ "${this_da_user_password}" =~ ['&+'] ]]; then
      msg "[Skipped]: Warning user ${this_da_user_uname} has password set with forbidden special characters [ &+ ] in config file. Please check configuration file"
      exit 1
    elif [[ -z "${this_da_user_name+x}" ]]; then
      msg "[Skipped]: Warning user ${this_da_user_uname} doesn't have name set in config file (missing or invalid variable). Please check configuration file"
      exit 1
    elif [[ -z "${this_da_user_system_email+x}" ]]; then
      msg "[Skipped]: Warning user ${this_da_user_uname} doesn't have system email set in config file (missing or invalid variable). Please check configuration file"
      exit 1
    elif [[ -z "${this_da_user_package_name+x}" ]]; then
      msg "[Skipped]: Warning user ${this_da_user_uname} doesn't have package name set in config file. Please check configuration file "
      exit 1
    elif [[ -z "${this_da_user_mail_accounts+x}" ]]; then
      msg "[Skipped]: Warning user ${this_da_user_uname} doesn't have email account set in config file (missing or invalid variable). Please check configuration file"
      exit 1
    elif [[ -n "${this_da_user_mail_accounts}" && $(echo "${#this_da_user_mail_accounts[@]}") -ne $(awk -F'\|\|\|' '{print NF-1}' <<<"${this_da_user_mail_accounts[@]}") ]]; then
      msg "[Skipped]: Warning user ${this_da_user_uname} has invalid email account format set in config file (invalid separator). Please check configuration file"
      exit 1
      # Just use a normal variable to check (even it is array)
    elif [[ -z "${this_da_user_domains+x}" ]]; then
      msg "[Skipped]: Warning user ${this_da_user_uname} doesn't have domain set in config file (missing or invalid variable). Please check configuration file"
      exit 1
    elif [[ -z "${this_da_user_domains}" ]]; then
      msg "[Skipped]: Warning user ${this_da_user_uname} must have at least one domain set in config file (domain is empty). Please check configuration file"
      exit 1
    elif [[ -z "${this_da_user_wildcard_domains+x}" ]]; then
      msg "[Skipped]: Warning user ${this_da_user_uname} doesn't have wildcard domain set in config file (missing or invalid variable). Please check configuration file"
      exit 1
    elif [[ -z "${this_da_user_enable_domain_ssl+x}" ]]; then
      msg "[Skipped]: Warning user ${this_da_user_uname} doesn't have domain enable ssl set in config file (missing or invalid variable). Please check configuration file"
      exit 1
      # TODO check extra this_da_user_ssl_subdomains for format
    elif [[ -z "${this_da_user_ssl_subdomains+x}" ]]; then
      msg "[Skipped]: Warning user ${this_da_user_uname} doesn't have ssl subdomains set in config file (missing or invalid variable). Please check configuration file"
      exit 1
    elif [[ -z "${this_da_user_db_accounts+x}" ]]; then
      msg "[Skipped]: Warning user ${this_da_user_uname} doesn't have database account set in config file (missing or invalid variable). Please check configuration file "
      exit 1
    elif [[ -n ${this_da_user_db_accounts} && $(echo "${#this_da_user_db_accounts[@]}") -ne $(awk -F'\|\|\|' '{print NF-1}' <<<"${this_da_user_db_accounts[@]}") ]]; then
      msg "[Skipped]: Warning user ${this_da_user_uname} has invalid database account format set in config file (invalid separator). Please check configuration file"
      exit 1
    else
      # msg "$(s green)OK, all variables for user ${this_da_user_uname} are valid.$(e)" --caller="${SCRIPT_NAME}"
      ((total_valid_user++))
    fi
    ((count_user++))
  done
  msg "$(s green)OK, total user with valid config is: ${total_valid_user}$(e)" --caller="${SCRIPT_NAME}"
}

# This function gets the operating system ID and version number
# syntax: get_linux_os <id|version>
# eg: get_linux_os id | sample output: centos
get_linux_os() {
  local arg distro_id distro_version distro_codename
  arg="$1"
  # any new Linux distribution must have this (it is a standard file os checking for linux)
  if [ -e /etc/os-release ]; then
    # get the distro ID from /etc/os-release and make sure it is in lowercase format without any double quotations
    distro_id=$(awk -F= '$1 == "ID" {print $2}' /etc/os-release | LC_ALL=C tr '[:upper:]' '[:lower:]' | tr -d "\"")
    distro_version=$(awk -F= '$1 == "VERSION_ID" {print $2}' /etc/os-release | tr -d "\"")
    distro_codename=$(awk -F= '$1 == "VERSION_CODENAME" {print $2}' /etc/os-release | tr -d "\"")

  # but just in case (a small case) if it doesn't have this then we can use lsb_release command
  elif type lsb_release >/dev/null 2>&1; then
    # get the distro id using lsb_release function.
    # if the ID has uppercase letter, cover it to lowercase
    distro_id=$(lsb_release -si | LC_ALL=C tr '[:upper:]' '[:lower:]')
    distro_version=$(lsb_release -sr)
    distro_codename=$(lsb_release -sc)
  # else if that doesn't exist at all, we can use the standard checking version format: "Linux <version>"
  else
    # this will not printout a single distribution ID that we want (it prints out the Generic Linux kernel version)
    # but using this we should terminate this script because we only need single distribution ID (eg: debian)
    distro_id=$(uname -s)
    distro_version=$(uname -r)
    distro_codename=""
  fi
  # return values here with echo
  if [ "${arg}" == "id" ]; then
    echo "${distro_id}"
  elif [ "${arg}" == "version" ]; then
    echo "${distro_version}"
  elif [ "${arg}" == "codename" ]; then
    echo "${distro_codename}"
  fi

}

# This is a random string that will return alphabet character (lower and uppercase)
# syntax: get_rnd_alpha <length>
# eg: get_rnd_alpha 10
get_rnd_alpha() {
  local length
  length="$1"
  tr -dc A-Za-z </dev/urandom | head -c "${length}"
  echo ''
}
# This function will transform a plain-text password into a hash encrypted password + salt generation which is more secure
# eg: test=$(get_hash_pwd "mypassword")
get_hash_pwd() {
  local password="$1" sha_pass
  sha_pass=$(mkpasswd -m sha-512 -S "$(pwgen -ns 16 1)" "$1")
  echo "${sha_pass}"
}

end() {
  tput sgr0
}

e() {
  tput sgr0
}

start() {
  txt "$@"
}
s() {
  txt "$@"
}

# This function is used to display color text
txt() {
  local mode="$1"
  shift
  if [[ "${mode^^}" == +(BLACK|RED|GREEN|YELLOW|BLUE|MAGENTA|CYAN) ]]; then
    if ! [[ ${mode} =~ ^[0-9]$ ]]; then
      case $(echo "${mode}" | tr '[:upper:]' '[:lower:]') in
      black) mode=0 ;;
      red) mode=1 ;;
      green) mode=2 ;;
      yellow) mode=3 ;;
      blue) mode=4 ;;
      magenta) mode=5 ;;
      cyan) mode=6 ;;
      end)
        tput sgr0
        return 0
        ;;
      # white or invalid color
      white | *) mode=7 ;;
      esac
    fi
    tput setaf ${mode}
  elif [[ "${mode^^}" == +(NEWLINE|LINE) ]]; then
    local count=$1 str=""
    if [[ -z "${count}" || "${count}" -eq 0 || "${count}" -eq 1 ]]; then
      return 0
    fi
    for ((i = 1; i <= count - 1; i++)); do
      str="${str}\n"
    done
    if [ "$$" -eq "${BASHPID}" ]; then
      for ((i = 1; i <= count - 2; i++)); do
        str="${str}\n"
      done
      echo -e "${str}"
    else
      for ((i = 1; i <= count - 1; i++)); do
        str="${str}\n"
      done
      # Using -e option here will not work if call inside string such as echo.
      echo "${str}"
    fi
  elif [[ "${mode^^}" == +(NEWTAB|TAB) ]]; then
    local count=$1 str=""
    if [[ -z "${count}" || "${count}" -eq 0 || "${count}" -eq 1 ]]; then
      return 0
    fi

    if [ "$$" -eq "${BASHPID}" ]; then
      for ((i = 1; i <= count - 2; i++)); do
        str="${str}\t"
      done
      echo -e "${str}"
    else
      for ((i = 1; i <= count - 1; i++)); do
        str="${str}\t"
      done
      # Using -e option here will not work if call inside string such as echo.
      echo "${str}"
    fi
  elif [[ "${mode^^}" == +(COLOR|COLOR|FOREGROUND|CLR|FG|C|F) ]]; then
    local color=$1
    if ! [[ $color =~ ^[0-9]$ ]]; then
      case $(echo "${color}" | tr '[:upper:]' '[:lower:]') in
      black) color=0 ;;
      red) color=1 ;;
      green) color=2 ;;
      yellow) color=3 ;;
      blue) color=4 ;;
      magenta) color=5 ;;
      cyan) color=6 ;;
      end)
        tput sgr0
        return 0
        ;;
      # white or invalid color
      white | *) color=7 ;;
      esac
    fi
    tput setaf ${color}
  # Set the background colour using ANSI escape
  elif [[ "${mode^^}" == +(BACKGROUND|BG|B) ]]; then
    local color=$1
    if ! [[ $color =~ ^[0-9]$ ]]; then
      case $(echo "${color}" | tr '[:upper:]' '[:lower:]') in
      black) color=0 ;;
      red) color=1 ;;
      green) color=2 ;;
      yellow) color=3 ;;
      blue) color=4 ;;
      magenta) color=5 ;;
      cyan) color=6 ;;
      end)
        tput sgr0
        return 0
        ;;
      # white or invalid color
      white | *) color=7 ;;
      esac
    fi
    tput setab ${color}

  elif [[ ${mode^^} == +(BOLD|DIM|INVI|BLINK|REVERSE|ULINE|UNDERLINE|XULINE|FOCUS|STANDOUT|XFOCUS|BELL|ALERT|CLEAR|CLR|END) ]]; then
    case $(echo "${mode}" | tr '[:upper:]' '[:lower:]') in
    bold) mode="bold" ;;
    dim) mode="dim" ;;
    invi) mode="invis" ;;
    blink) mode="blink" ;;
    reverse) mode="rev" ;;
    uline | underline) mode="smul" ;;
    xuline) mode="rmul" ;;
    focus | standout) mode="smso" ;;
    xfocus) mode="rmso" ;;
    bell | alert) mode="bel" ;;
    clear | clr | end) mode="sgr0" ;;
    *)
      echo "Error, invalid argument supplied for text mode: ${mode}!"
      exit 1
      ;;
    esac
    tput "${mode}"
    shopt -u nocasematch
  # Note: Not all modes work for every terminal especially, bold, dim, invi, blink
  elif [[ "${mode^^}" == +(MODE|M) ]]; then
    local mode=$1
    case $(echo "${mode}" | tr '[:upper:]' '[:lower:]') in
    bold) mode="bold" ;;
    dim) mode="dim" ;;
    invi) mode="invis" ;;
    blink) mode="blink" ;;
    reverse) mode="rev" ;;
    uline | underline) mode="smul" ;;
    xuline) mode="rmul" ;;
    focus | standout) mode="smso" ;;
    xfocus) mode="rmso" ;;
    bell | alert) mode="bel" ;;
    clear | clr | end) mode="sgr0" ;;
    *)
      echo "Error, invalid argument supplied for text mode: ${mode}!"
      exit 1
      ;;
    esac

    tput "${mode}"
  elif [[ "${mode^^}" == +(END|RESET|X|E) ]]; then
    tput sgr0
  fi
}
# This function is used to display a text in terminal. This is similar to echo() function excepts:
# 1. It can display color text using predefined options --msg-type: (eg: --msg-type=error or --msg-error)
# 2. It can make the text spinning with a tiny progress animation that can be customized using the option --progress-style: (eg: --progress-style="|/-\")
# 3. It can display an information about whose call this function by using the option --caller: (eg: --caller="my_function")
# 5. It can be run as a standalone spinning progress without defining a loop using the option --start-spin-loop: (eg: --start-spin-loop <duration>)
# 6. It can be used with txt() function to customize more color and mode options.

# Usage: msg <message> <options>
# Example 1: To display a normal message
# msg "This is a normal message"
# Example 2: To display a message with a spinning progress animation (this need to be run inside a loop to show the animation)
# msg "This is a message with a spinning progress animation" --start-spinning --progress-style="|/-\"
# Example 3: To display a message with a spinning progress animation and a caller information (this need to be run inside a loop to show the animation)
# msg "This is a message with a spinning progress animation and a caller information" --start-spinning --progress-style="|/-\" --caller="my_function"
# Example 4: To display a message with a spinning progress animation and a message type (this need to be run inside a loop to show the animation)
# msg "This is a message with a spinning progress animation and a caller information and a message type" --start-spinning --msg-type="error"
# Example 5: To display a standalone spinning progress animation (this does not need to be run inside a loop to show the animation)
# msg "Waiting ..." --start-spin-loop 10
# Example 6: To use with txt() function to display a message with a spinning progress animation and a message type (this need to be run inside a loop to show the animation)
# msg "$(s red)This is red$(end). $(s blue)This is blue$(end)$(s bold)This is bold$(end)" --start-spinning --msg-type="info"
# Example 7: To stop a spinning progress animation inside a loop use --stop-spinning or -stop-spinning-newline
# msg "Done" --stop-spinning (this will replace the previous message with 'Done')
# msg "Done" --stop-spinning-newline (this will not replace the previous message and the message 'Done' will be displayed in a new line)
# Requirement:
# This function requires a global variable PROGRESS_SPIN_COUNT=0 to be defined in the main script. This variable is used to keep track of the progress animation.
msg() {
  declare caller msg start_spin start_spin_loop stop_spin stop_spin_newline msg_info msg_warn msg_error msg_success msg_debug msg_type progress_style msg_caller push_notification push_notification_silent
  caller="$(basename -- "$0")->${FUNCNAME[0]}"
  msg="$1"
  start_spin=false
  start_spin_loop=""
  stop_spin=false
  stop_spin_newline=false
  msg_info=false
  msg_warn=false
  msg_error=false
  msg_success=false
  msg_debug=false
  msg_type=""
  progress_style=""
  msg_caller=""
  push_notification=false
  push_notification_silent=false
  shift
  while true; do
    case "$1" in
    --spin | --start-spin | --start-spinning)
      start_spin=true
      shift
      ;;
    --spin-loop | --start-spin-loop | --start-spinning-loop | --start-spin-until)
      start_spin_loop="$2"
      shift 2
      ;;
    --spin-loop=* | --start-spin-loop=* | --start-spinning-loop=* | --start-spin-until=*)
      start_spin_loop="${1#*=}"
      shift
      ;;
    --stop | --end-spin | --stop-spin | --stop-spinning)
      stop_spin=true
      shift
      ;;
    --stop-newline | --end-spin-newline | --stop-spin-newline | --stop-spinning-newline)
      stop_spin_newline=true
      shift
      ;;

    -i | --info | --msg-info)
      msg_info=true
      shift
      ;;
    -w | --warn | --warning | --msg-warn)
      msg_warn=true
      shift
      ;;
    -e | --error | --msg-error)
      msg_error=true
      shift
      ;;
    -s | --success | --msg-success)
      msg_success=true
      shift
      ;;
    -d | --debug | --msg-debug)
      msg_debug=true
      shift
      ;;
    -t | --type | --msg-type)
      msg_type="$2"
      shift 2
      ;;
    -t=* | --type=* | --msg-type=*)
      msg_type="${1#*=}"
      shift
      ;;
    -p | --progress | --progress-style)
      progress_style="$2"
      shift 2
      ;;
    -p=* | --progress=* | --progress-style=*)
      progress_style="${1#*=}"
      shift
      ;;
    -c | --caller | --show-caller | --msg-caller)
      msg_caller="$2"
      shift 2
      ;;
    -c=* | --caller=* | --show-caller=* | --msg-caller=*)
      msg_caller="${1#*=}"
      shift
      ;;
    --push-notification)
      push_notification=true
      shift
      ;;
    --push-notification-silent)
      push_notification_silent=true
      shift
      ;;

    --)
      shift
      break
      ;;
    -*)
      echo "[${caller}]: Error, unknown option: $1"
      exit 1
      ;;
    *)
      break
      ;;
    esac
  done

  if [[ ${start_spin} == "true" && ${stop_spin} == "true" ]]; then
    echo -e "\n$(tput setaf 1)[${caller}]: Error, the option --start-spin and --stop-spin cannot appear at the same time!$(tput sgr0)"
    exit 1
  fi

  if [[ "${start_spin}" == "true" && "${start_spin_loop}" != "" ]]; then
    echo -e "\n$(tput setaf 1)[${caller}]: Error, the option --start-spin and --start-spin-loop cannot appear at the same time!$(tput sgr0)"
    exit 1
  fi

  if [[ "${stop_spin}" == "true" && "${stop_spin_newline}" == "true" ]]; then
    echo -e "\n$(tput setaf 1)[${caller}]: Error, the option --stop-spin and --stop-spin-newline cannot appear at the same time!$(tput sgr0)"
    exit 1
  fi

  # Show caller if enable
  if [ -n "${msg_caller}" ]; then
    msg="[${msg_caller}]: ${msg}"
  fi

  if [[ -z "${progress_style}" ]]; then
    progress_style="/-\|"
  fi

  # info = blue, warn = yellow, error = red, success = green, debug = magenta
  if [[ "${msg_info}" == "true" || "${msg_type}" == "info" ]]; then
    msg="$(tput setaf 6)${msg}$(tput sgr0)"
  elif [[ "${msg_warn}" == "true" || "${msg_type}" == "warning" ]]; then
    msg="$(tput setaf 3)${msg}$(tput sgr0)"
  elif [[ "${msg_error}" == "true" || "${msg_type}" == "error" ]]; then
    msg="$(tput setaf 1)${msg}$(tput sgr0)"
  elif [[ "${msg_success}" == "true" || "${msg_type}" == "success" ]]; then
    msg="$(tput setaf 2)${msg}$(tput sgr0)"
  elif [[ "${msg_debug}" == "true" || "${msg_type}" == "debug" ]]; then
    msg="$(tput setaf 5)${msg}$(tput sgr0)"
  else
    msg="$(tput setaf 7)${msg}$(tput sgr0)"
  fi

  if [[ ${start_spin} == "true" ]]; then

    echo -ne "\r\e[0K${msg} [${progress_style:PROGRESS_SPIN_COUNT++:1}]"
    ((PROGRESS_SPIN_COUNT == ${#progress_style})) && PROGRESS_SPIN_COUNT=0
    tput civis
  elif [[ -n ${start_spin_loop} ]]; then
    for ((i = 0; i < start_spin_loop; i++)); do
      echo -ne "\r\e[0K${msg} [${progress_style:PROGRESS_SPIN_COUNT++:1}]"
      ((PROGRESS_SPIN_COUNT == ${#progress_style})) && PROGRESS_SPIN_COUNT=0
      tput civis
      sleep 1
    done
    echo ""
  elif [[ ${stop_spin} == "true" ]]; then
    echo -ne "\r\e[0K${msg}\n"
    tput cnorm
  elif [ "${stop_spin_newline}" == true ]; then
    echo -e "\n${msg}"
    tput cnorm
  elif [[ "${push_notification}" == "true" || "${push_notification_silent}" == "true" ]]; then
    # Only send notification if gotify is installed
    if command -v gotify &>/dev/null; then
      local push_msg retval
      push_msg=$(echo -e "${msg}" | gotify push -p "${C_GOTIFY_PUSH_PRIORITY}")
      retval=$?
      if [[ "${retval}" -eq 0 ]]; then
        if [[ "${push_notification_silent}" == "false" ]]; then
          echo -e "${msg} [PUSH NOTIFICATION SENT]"
        else
          echo -e "[PUSH NOTIFICATION SENT]"
        fi
        return 0
      else
        msg "Warning, failed to send push notification to gotify for the following text:"
        echo "${msg}"
        echo ""
        msg "Reason of failed:"
        echo "${push_msg}"
        echo ""
        return "${retval}"
      fi
    else
      msg "Warning, gotify is not installed. The option --push-notification does nothing"
    fi
  else
    echo -e "${msg}"
    tput cnorm
  fi

}

# This function display the current time spent for running this script.
# It uses the built-in bash SECONDS to get the real execution statement
script_time() {
  local spent_secs hrs mins secs
  spent_secs=${SECONDS}
  hrs=$((spent_secs / 3600))
  mins=$(((spent_secs - hrs * 3600) / 60))
  secs=$((spent_secs - hrs * 3600 - mins * 60))
  printf "[${SCRIPT_NAME}]: Time spent for total script execution: %02d H:%02d M :%02d S\n" ${hrs} ${mins} ${secs}
}

# This function convert seconds to time in format d h m s
show_time() {
  local num=$1
  local min=0
  local hour=0
  local day=0
  if ((num > 59)); then
    ((sec = num % 60))
    ((num = num / 60))
    if ((num > 59)); then
      ((min = num % 60))
      ((num = num / 60))
      if ((num > 23)); then
        ((hour = num % 24))
        ((day = num / 24))
      else
        ((hour = num))
      fi
    else
      ((min = num))
    fi
  else
    ((sec = num))
  fi
  echo "${day}"d "${hour}"h "${min}"m "${sec}"s
}

# This function display the execution time for a script individually
# Syntax exec_time <start/total> <optional_unique_variable>
# To start tracking use: exec_time start "da_installation"
# To get the global current total runtime from the start: exec_time total or exec_time end
# To get the total runtime for specific variable use: exec_time() total "da_installation"
# To reset total running time, run again exec_time start <optional_unique_variable>
# Note: When this script runs for the first time, the global variable EXEC_START is calculated as current timestamp. So, no need to call exec_time start for the first time
#exec_time() {
#  local option runtime days hours minutes seconds title
#  maxibuild --include "bc"
#  option=$1
#  title=$2
#  if [ "${option}" == "start" ]; then
#    # Reset starting execution time as the current date
#    if [ -n "${title}" ]; then
#      # Use verbose 7 (debug) because this time tracking only useful during debugging
#      msg "Tracking execution time for $(s red)[${title}]$(e) ..." --caller="${SCRIPT_NAME}"
#      variable_api create-variable --name "${title}" --value "$(date +%s.%N)"
#    else
#      EXEC_START=$(date +%s.%N)
#      msg "Tracking global execution time ..." --caller="${SCRIPT_NAME}"
#    fi
#  elif [[ "${option}" == "total" || "${option}" == "end" ]]; then
#    if [ -n "${title}" ]; then
#      runtime=$(echo "$(date +%s.%N) - $(variable_api get-variable-value --name "${title}")" | bc -l)
#    else
#      runtime=$(echo "$(date +%s.%N) - ${EXEC_START}" | bc -l)
#    fi
#    # Test runtime
#    #runtime=$(date --date='Sun Jun 20 17:07:39 2021' +"%s")
#    #end=$(date +%s.%N)
#    #runtime=$(echo "$end - $start" | bc)
#    days=$(echo "${runtime}/86400" | bc)
#    #rt2=$(echo "${runtime}-86400*${days}" | bc)
#    hours=$(echo "$(echo "${runtime}-86400*${days}" | bc)/3600" | bc)
#    #rt3=$(echo "$(echo "${runtime}-86400*${days}" | bc)-3600*$hours" | bc)
#    minutes=$(echo "$(echo "$(echo "${runtime}-86400*${days}" | bc)-3600*${hours}" | bc)/60" | bc)
#    seconds=$(echo "$(echo "$(echo "${runtime}-86400*${days}" | bc)-3600*${hours}" | bc)-60*${minutes}" | bc)
#    #msg blue "Total execution time: ${runtime} seconds"
#    if [ -n "${title}" ]; then
#      #msg blue "Total runtime executed for ${title} was: "
#      msg "$(printf "Total runtime executed for $(s red)[%s]$(e) was: %dd:%02dh:%02dm:%02.4fs\n" "${title}" "${days}" "${hours}" "${minutes}" "${seconds}")" --caller="${SCRIPT_NAME}"
#    else
#      #msg blue "Total runtime executed was: "
#      msg "$(printf "Total global runtime executed was: %dd:%02dh:%02dm:%02.4fs\n" "${days}" "${hours}" "${minutes}" "${seconds}")" --caller="${SCRIPT_NAME}"
#    fi
#    #msg blue "$(printf "Total runtime executed for %s was: %dd:%02dh:%02dm:%02.4fs\n" "${title}" "${days}" "${hours}" "${minutes}" "${seconds}")"
#
#  else
#    msg "Warning, invalid option specified for exec_time() function!" --caller="${SCRIPT_NAME}"
#    return 1
#  fi
#}
# syntax:
# check_path "path1" "path2" "path3"
check_path() {
  local paths
  paths="$*"
  for path in ${paths}; do
    if [ -f "${path}" ]; then
      msg "$(s green)OK, the file path [ ${path} ] exists$(e)"
    elif [ -d "${path}" ]; then
      msg "$(s green)OK, the directory path [ ${path} ] exists$(e)"
    elif [ -L "${path}" ]; then
      msg "$(s green)OK, the symlink path [ ${path} ] exists$(e)"
    elif [ -S "${path}" ]; then
      msg "$(s green)OK, the socket path [ ${path} ] exists$(e)"
    else
      msg "$(s red)Error, the path [ ${path} ] does not exist!$(e)"
      exit 1
    fi
  done
}

# This function is used to navigate to a given path and save the previous path to a variable
# You can use PREVIOUS to go back to the previous path
# Usage: navigate_to [path]
# Example: navigate_to /opt
# Example 2: navigate_to PREVIOUS
navigate_to() {
  local to_path="$1"
  if [[ "${to_path^^}" == +(PRE|PREVIOUS|OLDPATH|BACK|OLDPWD) ]]; then
    # OLD_PATH holds a previous path (see global variable of PREPATH in this script)
    msg "Navigating out into ${OLD_PATH} ..."
    to_path="${OLD_PATH}"
  else
    msg "Navigating into ${to_path} ..."
    OLD_PATH="${PWD}"
  fi

  cd "${to_path}" || {
    msg "Error, failed to enter into the directory ${to_path}"
    _exit 1
  }

}

# Store long file text creation in function to avoid duplication
# create_file "ssh-push-scripts"
# create_file <create_action> <optional_path>
create_file() {
  local create_actions path
  # Enable multiple create call. For eg: create_action "create1 create2 create3"
  create_actions="$1"
  path="$2"
  #create_file setup-readme

  for create_action in ${create_actions}; do

    if [[ "${create_action}" == "os-initialize" || "${create_action}" == "os_initialize" ]]; then
      {
        echo "#!/bin/bash"
        echo "# ==============================================="
        echo "# This script file was automatically generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# This is just a test script for os-initialize"
        echo "touch test_file1"
        echo "echo \"This is just a test file\" > test_file"
        echo "echo \"If you can read this, it means the test_script.sh script was running perfectly\" >> test_file"
        echo "# Put 2 times exit below to safely exit the script if the first exit is not executed"
        echo "exit"
        echo "exit"
      } >"${path}"
    elif [[ "${create_action}" == "setup-readme" ]]; then
      {
        echo "# ==============================================="
        echo "# This readme file was automatically generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# This is the remote setup readme file:"
        echo "Run installation with log output: ./${SCRIPT_NAME} setup 2>&1 | tee ${SCRIPT_NAME}.log"
        echo "Run installation with log output: ./${SCRIPT_NAME} setup --installation-type directadmin 2>&1 | tee ${SCRIPT_NAME}.log"
      } >"${SCRIPT_PATH}/readme.txt"
    # Remember all push scripts need to have return 0 at the end so that we can terminate the SSH from local call
    elif [[ ${create_action} == "ssh-push-scripts" ]]; then
      ssh_scripts_path="${CODE_PATH}/ssh_scripts"
      mkdir -p "${ssh_scripts_path}"

      #test_script.sh
      {
        echo "#!/bin/bash"
        echo "# ==============================================="
        echo "# This script file was automatically generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# This is just a test script"
        echo "touch test_file"
        echo "echo \"This is just a test file\" > test_file"
        echo "echo \"If you can read this, it means the test_script.sh script was running perfectly\" >> test_file"
        echo "# Put 2 times exit below to safely exit the script if the first exit is not executed"
        echo "exit"
        echo "exit"
      } >"${ssh_scripts_path}/test_script.sh"
      chmod +x "${ssh_scripts_path}/test_script.sh"
      # reboot_command.sh
      {
        echo "#!/bin/bash"
        echo "# ==============================================="
        echo "# This script file was automatically generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# Using --force to ignore any prompts when rebooting. Such as the prompt to eject DISK and waiting for user input"
        echo "reboot --force"
        echo "# Put 2 times exit below to safely exit the script if the first exit is not executed"
        echo "exit"
        echo "exit"
      } >"${ssh_scripts_path}/reboot_command.sh"
      chmod +x "${ssh_scripts_path}/reboot_command.sh"
      # shutdown_command.sh
      {
        echo "#!/bin/bash"
        echo "# ==============================================="
        echo "# This script file was automatically generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# Using --force to ignore any prompts when shutting down. Such as the prompt to eject DISK and waiting for user input"
        echo "reboot --poweroff --force"
        echo "# Put 2 times exit below to safely exit the script if the first exit is not executed"
        echo "exit"
        echo "exit"
      } >"${ssh_scripts_path}/shutdown_command.sh"
      chmod +x "${ssh_scripts_path}/shutdown_command.sh"
      #maxinet_setup.sh
      {
        echo "#!/bin/bash"
        echo "# ==============================================="
        echo "# This script file was automatically generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# Using setup will trigger setup script from ${SCRIPT_NAME}"
        echo "cd /root || exit 1"
        echo "chmod +x maxinet"
        echo "touch maxinet.log"
        echo "./maxinet setup 2>&1 | tee maxinet.log"
        echo "# Put 2 times exit below to safely exit the script if the first exit is not executed"
        echo "return 0"
        echo "return 0"
      } >"${ssh_scripts_path}/maxinet_setup.sh"
      chmod +x "${ssh_scripts_path}/maxinet_setup.sh"
    # SSH banner
    elif [[ ${create_action} == "ssh-banner1" || ${create_action} == "ssh_banner1" ]]; then
      {
        echo "Legal Authentication Banner:"
        echo "---------------------------"
        echo "=~=~=~=~=~=~=~=~=~=~=~=~=~00000~=~=~=~=~=~=~=~=~+~=~=~=~=~+~="
        echo "Welcome to ${C_COMPANY_ID^} CH. This is the ${C_BOX_HOSTNAME^^} Server"
        echo "The ${C_BOX_HOSTNAME^^} consists of ENERGY where it has been created"
        echo "perfectly with a certain EQUATIONS from NOTHING. Human"
        echo "beings have changed the original EQUATIONS to their own"
        echo "EQUATIONS. The ENERGY consists of TIME where TIME is MONEY"
        echo "and MONEY is part of the RESOURCES. If you need SOMETHING,"
        echo "the most ethical way in the world of humanity is asking"
        echo "for SOMETHING instead of manipulating the RESOURCES."
        echo "Disconnect now if you are not one of the team at Sofibox"
        echo "=~=~=~=~=~=~=~=~=~=~=~=~=~00000~=~=~=~=~=~=~=~=~+~=~=~=~=~+~="
        echo "Do not waste your RESOURCES for NOTHING - MaXi32, 2001"
        echo "=============== We turned on 1 LiGHT DaRK =============="
        echo ""
        echo "SECURE TAG: access, legal, law, connect, enforce, system"
      } >"${path}"

    elif [[ ${create_action} == "debian-preseed" ]]; then

      maxibuild --include "whois pwgen"
      touch "${path}"

      {
        # 1 Good reading: https://serverfault.com/questions/893483/what-means-3-numbers-in-manual-partitioning-of-hdd-in-preseed-for-ubuntu
        # 2 Useful setting for SSH: https://github.com/coreprocess/linux-unattended-installation/blob/master/ubuntu/20.04/custom/preseed.cfg
        # 3 This one contains setting for CD rom not in new documentation: https://images.validation.linaro.org/kvm/debian-8.3.0-cd1-preseed.cfg
        echo "# ==============================================="
        echo "# This debian configuration file was generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# Warning, this preseed configuration file contains sensitive information about a server. Do not share this file to public"
        echo "# ==============================================="
        if [ "${C_OS_SET_CODE_NAME}" == "buster" ]; then
          echo "#### Preseed preconfiguration file (for Debian buster)"
        elif [ "${C_OS_SET_CODE_NAME}" == "bullseye" ]; then
          echo "#### Preseed preconfiguration file (for Debian bullseye)"
        fi
        echo "### Partman early command"

        #echo "d-i partman/early_command \\"
        #echo "string sed -i.bak 's/-f \$id\/skip_erase/-d \$id/g' /lib/partman/lib/crypto-base.sh"

        echo "### Kernel parameter"
        echo "d-i debian-installer/add-kernel-opts string net.ifnames=0 biosdevname=0 console=ttyS0,19200n8"
        echo "### Localization"
        #echo "Test: Fixing no common CDROM on linode:"
        #=============================================
        #https://lists.debian.org/debian-boot/2011/01/msg00169.html
        #https://github.com/uweplonus/adia-install/blob/master/initrd/preseed.cfg#L3
        #https://serverfault.com/questions/685302/unattended-installation-of-ubuntu-from-usb-drive-not-mounted-correctly
        #echo "d-i partman/early_command string mount /dev/sdb /cdrom"
        #echo "d-i preseed/early_command string mount /dev/sdb /cdrom"
        #echo "d-i cdrom-detect/cdrom_device string /dev/sdb"
        #echo "d-i preseed/early_command string \\"
        #echo "umount /cdrom; \\"1
        #echo "mkdir -p /cdrom; \\"
        #echo "mount -t vfat /dev/sdb /cdrom;"
        # All above fixes are not working (left it as reference) because this ISO installer doesn't support booting from hard drive. Need to follow this:
        # https://www.debian.org/releases/buster/amd64/ch04s04.en.html (BOOTING WITH GRUB OR LILO)
        #================================================
        echo "d-i debian-installer/locale string ${C_BOX_LOCALE}"
        echo "d-i debian-installer/language string ${C_BOX_LANGUAGE_CODE}"
        echo "d-i debian-installer/country string ${C_BOX_COUNTRY_CODE}"
        echo ""
        echo "### Keyboard selection"
        echo "d-i keyboard-configuration/xkb-keymap select ${C_BOX_KEYBOARD}"
        echo ""
        echo "###  Network configuration"
        # This one has many bug reported in Debian forum, need to put in kernel parameter: netcfg/choose_interface eth0 (if not working)
        echo "d-i netcfg/choose_interface select eth0"
        echo "d-i netcfg/use_dhcp string false"
        # If I disable autoconfig, I will get mirror error if network is not configured correctly
        # Actually no need to set IP4 and IPv6 because I use late command is better.
        echo "d-i netcfg/disable_autoconfig boolean true"
        echo "d-i netcfg/dhcp_failed note"
        echo "d-i netcfg/dhcp_options select Configure network manually"
        echo "# IPv4 Static network configuration"
        echo "d-i netcfg/get_ipaddress string ${C_IPV4_ADD0}"
        echo "d-i netcfg/get_netmask string ${C_IPV4_NETMASK_IP0}"
        echo "d-i netcfg/get_gateway string ${C_IPV4_DEF_GATEWAY0}"
        echo "d-i netcfg/get_nameservers string ${C_NAME_SERVER1}"
        echo "d-i netcfg/confirm_static boolean true"
        echo ""
        # IPv6 will be set using late command below
        #echo "# IPv6 Static network configuration"
        #echo "d-i netcfg/get_ipaddress string ${C_IPV6_ADD0}"
        #echo "d-i netcfg/get_netmask string ${C_IPV6_NETMASK0}"
        #echo "d-i netcfg/get_gateway string ${C_IPV6_DEF_GATEWAY0}"
        #echo "d-i netcfg/get_nameservers string ${C_NAME_SERVER1}"
        #echo "d-i netcfg/confirm_static boolean true"
        #echo ""
        echo "# Set a hostname"
        echo "d-i netcfg/get_hostname string ${C_BOX_HOSTNAME_FQHN}"
        echo "d-i netcfg/get_domain string ${C_BOX_DOMAIN}"
        echo "# Force a hostname"
        echo "d-i netcfg/hostname string ${C_BOX_HOSTNAME_FQHN}"
        echo "# Disable that annoying WEP key dialog"
        echo "d-i netcfg/wireless_wep string"
        echo ""
        echo "### Mirror settings"
        echo "d-i mirror/country string manual"
        echo "d-i mirror/http/hostname string deb.debian.org"
        echo "d-i mirror/http/directory string /debian"
        echo "d-i mirror/http/proxy string"
        echo ""
        echo "### Account setup"
        echo "# Skip creation of a normal user account"
        echo "d-i passwd/make-user boolean false"

        echo "# Set root password"
        #echo "d-i passwd/root-password password ${C_INITIAL_ROOT_PASSWORD}"
        #echo "d-i passwd/root-password-again password ${C_INITIAL_ROOT_PASSWORD}"
        echo "# or encrypted using a crypt(3)  hash."
        # Using the secured get_hash_pwd to encrypt root password
        echo "d-i passwd/root-password-crypted password $(get_hash_pwd "${C_INITIAL_ROOT_PASSWORD}")"
        echo ""
        echo "### Clock and time zone setup"
        echo "# Set hardware clock to UTC"
        echo "d-i clock-setup/utc boolean true"
        echo "# Set timezone"
        echo "d-i time/zone string ${C_BOX_TIMEZONE}"
        echo "# Use NTP clock during installation"
        echo "d-i clock-setup/ntp boolean true"
        echo ""
        echo "### Partitioning"
        # This is for normal disk method (not LUKS)
        # Good reading :https://gist.github.com/chuckn246/ca24d26c048b3cc4ffa8188708f5dccf
        # Another good one: https://www.linuxjournal.com/content/preseeding-full-disk-encryption (it has a way to disable wipe disk)
        # Very nice info: https://secopsmonkey.com/custom-partioning-using-preseed.html
        # Useful maybe https://github.com/uweplonus/adia-install/blob/master/initrd/preseed.cfg#L3
        # Updated very nice: https://gist.github.com/chuckn246/ca24d26c048b3cc4ffa8188708f5dccf
      } >>"${path}"
      if [[ "${C_DISK_ENCRYPTION}" == "true" ]]; then
        {
          # This is the section to create a custom LUKS partition here
          echo "# LVM LUKS method"

          #echo "# method to use: regular, lvm or crypto"
          echo "d-i partman-auto/method string crypto"

          #echo "# remove existing LVM"
          echo "d-i partman-lvm/device_remove_lvm boolean true"
          #echo "# remove existing RAID"
          echo "d-i partman-md/device_remove_md boolean true"

          #echo "# Confirm to write LVM partition"
          echo "d-i partman-lvm/confirm boolean true"
          #echo "# amount space to use with LVM"
          echo "d-i partman-auto-lvm/guided_size string max"
          echo "d-i partman-auto-lvm/new_vg_name string ${C_LVM_GROUP_NAME}"
          #echo "#select root disk to use"
          echo "d-i partman-auto/disk string ${C_BOX_MAIN_DISK}"

          echo "d-i partman-auto/choose_recipe select boot-crypto"
          echo "d-i partman-lvm/confirm_nooverwrite boolean true"

          echo "d-i partman-crypto/passphrase string ${C_LUKS_PASS}"
          echo "d-i partman-crypto/passphrase-again string ${C_LUKS_PASS}"
          echo "d-i partman-crypto/weak_passphrase boolean true"
          echo "d-i partman-crypto/confirm boolean true"
          echo "# When disk encryption is enabled, skip wiping the partitions beforehand."
          echo "d-i partman-auto-crypto/erase_disks boolean false"

          echo "d-i partman-auto/expert_recipe string \\"
          echo "boot-crypto :: \\"
          echo "  ${C_BOX_BOOT_SIZE} ${C_BOX_BOOT_SIZE} ${C_BOX_BOOT_SIZE} ext4 \\"
          echo "          \$primary{ } \$bootable{ } \\"
          echo "          method{ format } format{ } \\"
          echo "          use_filesystem{ } filesystem{ ext4 } \\"
          echo "          mountpoint{ /boot } \\"
          echo "          label{ boot } \\"
          echo "  . \\"
          echo "  ${C_BOX_ROOT_SIZE} ${C_BOX_ROOT_SIZE} ${C_BOX_ROOT_SIZE}  ext4 \\"
          echo "          \$lvmok{ } lv_name{ root } \\"
          echo "          in_vg { ${C_LVM_GROUP_NAME} } \\"
          #echo "          \$primary{ } \\"
          echo "          method{ format } format{ } \\"
          echo "          use_filesystem{ } filesystem{ ext4 } \\"
          echo "          mountpoint{ / } \\"
          echo "          label{ root } \\"
          echo "  . \\"
          echo "  ${C_BOX_TMP_SIZE} ${C_BOX_TMP_SIZE} ${C_BOX_TMP_SIZE} ext4 \\"
          echo "          \$lvmok{ } lv_name{ tmp } \\"
          echo "          in_vg { ${C_LVM_GROUP_NAME} } \\"
          #echo "          \$primary{ } \\"
          echo "          method{ format } format{ } \\"
          echo "          use_filesystem{ } filesystem{ ext4 } \\"
          echo "          mountpoint{ /tmp } \\"
          echo "          options/nosuid{ nosuid } \\"
          echo "          options/noexec{ noexec } \\"
          echo "          label{ tmp } \\"
          echo "  . \\"
          echo "  ${C_BOX_SWAP_SIZE} ${C_BOX_SWAP_SIZE} ${C_BOX_SWAP_SIZE} linux-swap \\"
          echo "          \$lvmok{ } lv_name{ swap } \\"
          echo "          in_vg { ${C_LVM_GROUP_NAME} } \\"
          #echo "          \$primary{ } \\"
          echo "          method{ swap } format{ } \\"
          echo "          label{ swap } \\"
          echo "  . \\"
          # The rest of the space
          echo "  40960 61440 ${C_BOX_HOME_SIZE} ext4 \\"
          echo "          \$lvmok{ } lv_name{ home } \\"
          echo "          in_vg { ${C_LVM_GROUP_NAME} } \\"
          #echo "          \$primary{ } \\"
          echo "          method{ format } format{ } \\"
          echo "          use_filesystem{ } filesystem{ ext4 } \\"
          echo "          mountpoint{ /home } \\"
          echo "          options/nosuid{ nosuid } \\"
          echo "          label{ home } \\"
          echo "  ."
        } >>"${path}"

      else
        {
          echo "# Normal partition method"
          echo "d-i partman-auto/disk string ${C_BOX_MAIN_DISK}"
          echo "d-i partman-auto/method string lvm"
          echo "d-i partman-auto-lvm/guided_size string max"
          echo "d-i partman-lvm/device_remove_lvm boolean true"
          echo "d-i partman-md/device_remove_md boolean true"
          echo "d-i partman-lvm/confirm boolean true"
          echo "d-i partman-lvm/confirm_nooverwrite boolean true"
          echo "d-i partman-auto/choose_recipe select atomic"
          echo "d-i partman-partitioning/confirm_write_new_label boolean true"
          echo "d-i partman/choose_partition select finish"
          echo "d-i partman/confirm boolean true"
          echo "d-i partman/confirm_nooverwrite boolean true"
          echo "d-i partman-md/confirm boolean true"
          echo "d-i partman-partitioning/confirm_write_new_label boolean true"
          echo "d-i partman/choose_partition select finish"
          echo "d-i partman/confirm boolean true"
          echo "d-i partman/confirm_nooverwrite boolean true"
        } >>"${path}"

      fi
      {
        echo "d-i partman-basicfilesystems/no_mount_point boolean false"
        echo "d-i partman-partitioning/confirm_write_new_label boolean true"
        echo "d-i partman/choose_partition select finish"
        echo "d-i partman/confirm boolean true"
        echo "d-i partman/confirm_nooverwrite boolean true"

        echo ""
        echo "### Apt setup"
        # Disable mirror will cause problem with software selection
        #echo "#d-i apt-setup/use_mirror boolean false"
        echo "d-i apt-setup/cdrom/set-first boolean false"
        echo "d-i apt-setup/cdrom/set-next boolean false"
        echo "d-i apt-setup/cdrom/set-failed boolean false"
        echo "d-i apt-setup/services-select multiselect security, updates"
        echo "d-i apt-setup/security_host string security.debian.org"
        #echo ""
        echo "### Package selection"
        echo "tasksel tasksel/first multiselect standard"
        echo "# Individual additional packages to install"
        echo "d-i pkgsel/include string openssh-server"
        echo "popularity-contest popularity-contest/participate boolean false"
        echo ""
        echo "### Boot loader installation"
        echo "# Grub location"
        echo "d-i grub-installer/only_debian boolean true"
        echo "d-i grub-installer/with_other_os boolean true"
        echo "d-i grub-installer/bootdev string ${C_BOX_MAIN_DISK}"
        echo ""
        echo "# Grub password"
        echo "#d-i grub-installer/password password r00tme"
        echo "#d-i grub-installer/password-again password r00tme"
        echo "# or encrypted using an MD5 hash, see grub-md5-crypt(8)."
        echo "#d-i grub-installer/password-crypted password [MD5 hash]"
        echo ""
        echo "### Finishing up the installation"
        echo "# Avoid that last message about the install being complete."
        echo "# This will skip the dialog box after installation finished"
        echo "d-i finish-install/reboot_in_progress note"
        echo "# This will shutdown after install"
        # Make sure to disable linode shutdown watchdog to turn off linode after installed else it will auto boot:
        echo "d-i debian-installer/exit/poweroff boolean true"
        # At this point, I can use API to determine if the system s shut down, then it means installation is finished.
        # Then if the port 893 is available I can use that port to login.
        # Good reading for executing script or store: https://github.com/uweplonus/adia-install/blob/master/initrd/preseed.cfg#L3
        echo "### Execute final scripts "
        # To install other package using late_command
        # new line separated by \
        echo "d-i preseed/late_command string \\"
        echo "in-target apt-get -y install rsync htop wget git dropbear-initramfs resolvconf; \\"
        # For modifying fstab

        # Allow root login
        # For encryption https://stackoverflow.com/questions/33113363/debian-preseed-late-command-not-executed
        # Another tip: https://askubuntu.com/questions/364051/how-do-you-preseed-an-ssh-key
        # UNLOCK LUKS doc here: https://www.cyberciti.biz/security/how-to-unlock-luks-using-dropbear-ssh-keys-remotely-in-linux/
        #echo "in-target cp /cdrom/configure_box.sh /usr/local/bin/ ;\\"
        #echo "in-target chmod +x /usr/local/bin/configure.sh ;\\"
        #echo "in-target /usr/local/bin/configure_box.sh; \\"
        echo "mkdir -p /target/root/.ssh; \\"
        #echo "cat ${rsa_private_key} > /target/root/.ssh/authorized_keys; \\"
        echo "cp /cdrom/root_${C_ROOT_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub /target/root/.ssh/authorized_keys; \\"
        echo "cp /cdrom/user_${C_SSH_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub /target/root/user_${C_SSH_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub; \\"
        # Copy and run os_initialize.sh (this file contain initial script such as configuration of /etc/fstab)
        echo "cp /cdrom/os_initialize.sh /target/root/os_initialize.sh; \\"
        echo "in-target chmod +x /root/os_initialize.sh; \\"
        # TODO check this in-target file script. This is just a place holder at this moment and make sure it is executed for next release
        echo "in-target /root/os_initialize.sh; \\"
        # Configuring SSH
        echo "chmod -R go-rwx /target/root/.ssh; \\"
        echo "sed -i 's/^#PermitRootLogin.*/PermitRootLogin prohibit-password/g' /target/etc/ssh/sshd_config; \\"
        echo "sed -i 's/^#PubkeyAuthentication.*/PubkeyAuthentication yes/g' /target/etc/ssh/sshd_config; \\"
        echo "sed -i \"s/^#Port 22/Port ${C_SSH_PORT}/\" /target/etc/ssh/sshd_config; \\"
        # This fix error when message when client trying to send LOCAL to remote
        echo "sed -i \"s/^AcceptEnv LANG LC_*/#&/\" /target/etc/ssh/sshd_config; \\"
        # This will disable the interface name convention (just put in kernel line)
        #echo "in-target sed -i 's/GRUB_CMDLINE_LINUX=\"[^\"]*/&net.ifnames=0 biosdevname=0/' /etc/default/grub; \\"
        echo "echo \"GRUB_TERMINAL=serial\"  >> /target/etc/default/grub; \\"
        echo "echo \"GRUB_SERIAL_COMMAND=\\"\"serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1\\\"\" \>\> /target/etc/default/grub\; \\""
        echo "in-target update-grub; \\"
        # This will write a new static IP and use the default interface name from config file
        # This one fixed network issue with ipv6
        # echo "echo \"source /etc/network/interfaces.d/*\" > /target/etc/network/interfaces; \\"
        echo "echo \"# The loopback network interface\" > /target/etc/network/interfaces; \\"
        echo "echo \"auto lo\" >> /target/etc/network/interfaces; \\"
        echo "echo \"iface lo inet loopback\" >> /target/etc/network/interfaces; \\"
        echo "echo \"\" >> /target/etc/network/interfaces; \\"
        echo "echo \"# The primary network interface (IPv4)\" >> /target/etc/network/interfaces; \\"
        echo "echo \"auto ${C_NIC_INTERFACE_NAME}\" >> /target/etc/network/interfaces; \\"
        echo "echo \"iface ${C_NIC_INTERFACE_NAME} inet static\" >> /target/etc/network/interfaces; \\"
        echo "echo \"   address ${C_IPV4_ADD0}${C_IPV4_NETMASK0}\" >> /target/etc/network/interfaces; \\"
        echo "echo \"   gateway ${C_IPV4_DEF_GATEWAY0}\" >> /target/etc/network/interfaces; \\"
        echo "echo \"   dns-nameservers ${C_NAME_SERVER1} ${C_NAME_SERVER2}\" >> /target/etc/network/interfaces; \\"
        echo "echo \"\" >> /target/etc/network/interfaces; \\"
        echo "echo \"# The primary network interface (IPv6)\" >> /target/etc/network/interfaces; \\"
        echo "echo \"iface ${C_NIC_INTERFACE_NAME} inet6 static\" >> /target/etc/network/interfaces; \\"
        echo "echo \"   address ${C_IPV6_ADD0}${C_IPV6_NETMASK0}\" >> /target/etc/network/interfaces; \\"
        echo "echo \"   gateway ${C_IPV6_DEF_GATEWAY0}\" >> /target/etc/network/interfaces; \\"
        # This will write a new resolve at /etc/resolv.conf
        # If host is name server, this resolv.conf is needed
        # echo "echo \"search ${C_BOX_DOMAIN}\" > /target/etc/resolv.conf; \\"
        # The domain is for telling
        echo "echo \"domains ${C_BOX_HOSTNAME_FQHN}\" > /target/etc/resolvconf/resolv.conf.d/base; \\"
        #rotate lets resolver make use of all the name servers in resolv.conf
        echo "echo \"options rotate\" >> /target/etc/resolvconf/resolv.conf.d/base; \\"
        echo "echo \"nameserver ${C_NAME_SERVER1}\" >> /target/etc/resolvconf/resolv.conf.d/base; \\"
        echo "echo \"nameserver ${C_NAME_SERVER2}\" >> /target/etc/resolvconf/resolv.conf.d/base; \\"
        echo "echo \"nameserver ${C_NAME_SERVER3}\" >> /target/etc/resolvconf/resolv.conf.d/base; \\"
        echo "in-target resolvconf -u; \\"
        # For LUKS auto login
        echo "sed -i 's/^#DROPBEAR_OPTIONS=/DROPBEAR_OPTIONS=\"-I 180 -j -k -p ${C_DROP_BEAR_PORT} -s\"/' /target/etc/dropbear-initramfs/config; \\"
        echo "echo \"IP=${C_IPV4_ADD0}::${C_IPV4_DEF_GATEWAY0}:${C_IPV4_NETMASK_IP0}:${C_BOX_HOSTNAME}:${C_NIC_INTERFACE_NAME}:off\" >> /target/etc/initramfs-tools/initramfs.conf; \\"
        echo "cp /cdrom/root_${C_ROOT_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub /target/etc/dropbear-initramfs/authorized_keys; \\"
        echo "in-target update-initramfs -u;"
        # Installing some packages

      } >>"${path}"
    fi
  done
}

# iso_api <action> <required --iso-type> <required --iso-base> <optional --upload-to-dropbox> <optional --write-script> <optional --backup>
# iso_api create-os-iso --iso-type hdd-boot --iso-base local --upload-to-dropbox --write-script --backup
# Trigger --help for more information
iso_api() {

  local action argnum options retval iso_type iso_base upload_to_dropbox write_script backup
  action="$1"
  argnum="$#"
  if [ ${argnum} -eq 0 ]; then
    echo "Error, no argument is supplied. Use [ ${SCRIPT_NAME} --iso --help ] to see the valid options"
    exit 1
  fi
  short_opts=""
  long_opts="help,iso-type:,iso-base:,upload-to-dropbox,write-script,backup"
  options=$(getopt -o "${short_opts}" --long "${long_opts}" -n "${FUNCNAME[0]} in ${SCRIPT_NAME}" -- "$@")
  retval=$?
  if [ ${retval} != 0 ]; then
    echo "Error, invalid parse data. Terminating..." >&2
    exit 1
  fi

  # Must quote this option variable
  eval set -- "${options}"

  iso_type=""
  iso_base=""
  upload_to_dropbox=false
  write_script=false
  backup=false
  while true; do
    case "$1" in
    --help)
      manual "${FUNCNAME[0]}"
      shift
      exit 0
      ;;
    --iso-type)
      iso_type="$2"
      shift 2
      ;;
    --iso-base)
      iso_base="$2"
      shift 2
      ;;
    --upload-to-dropbox)
      upload_to_dropbox=true
      shift
      ;;
    --write-script)
      write_script=true
      shift
      ;;
    --backup)
      backup=true
      shift
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
    esac
  done

  if [[ "${action}" == "create-os-iso" ]]; then

    local iso_os date_time_random root_temp_path isomount_location isodir_write isodir_write_tmp preseed_file source_file \
      rsa_private_key rsa_private_key_ppk

    iso_os="${C_BOX_ISO_OS_NAME}"
    date_time_random="$(date '+%d_%m_%Y_%H_%M_%S').${RANDOM}"
    root_temp_path="/root/tmp_iso/${iso_os}"
    isomount_location="/mnt/mount_iso"
    isodir_write="${root_temp_path}/iso-rw"
    isodir_write_tmp="${root_temp_path}/iso-rw-tmp"
    preseed_file="${root_temp_path}/preseed.txt"
    source_file="${root_temp_path}/sources.list"

    if [ "${iso_os}" == "debian" ]; then
      local debian_name debian_release debian_select_version debian_latest_version debian_select_platform debian_image_type \
        debian_iso_installation_type debian_iso_url debian_initrd_gz_url debian_vmlinuz_url debian_isofile debian_isofile_final \
        debian_isofile_final_base_name

      debian_name="debian"
      debian_release="${C_OS_SET_CODE_NAME}" #use stable for latest version
      debian_select_version="${C_OS_SELECT_VERSION}"
      maxibuild --include "curl"
      debian_latest_version="$(curl -s "http://cdimage.debian.org/cdimage/release/current/amd64/iso-cd/" | grep -oP "href=\"debian-\K[0-9]+\.[0-9]+\.[0-9]+" | sort -t. -rn -k1,1 -k2,2 -k3,3 | head -1)"
      debian_select_platform="amd64"
      debian_image_type="iso-cd"
      debian_iso_installation_type="netinst"
      #checksum_selection="debian-${debian_select_version}-${debian_select_platform}-${debian_iso_installation_type}.iso"
      if [ "${C_USE_LATEST_ISO}" == "true" ]; then
        debian_select_version="${debian_latest_version}"
        # The stable is the latest
        debian_release="stable" #use stable for latest version
      else
        if [ "${debian_select_version}" == "${debian_latest_version}" ]; then
          msg "$(s green)The Latest version of Debian is up-to-date with the selected version of Debian: v${debian_select_version}! $(e)" --caller="${SCRIPT_NAME}"
        else
          msg "$(s yellow)Warning, the Latest version of Debian detected as ${debian_latest_version} but the selected version from config file is ${debian_select_version}!$(e)" --caller="${SCRIPT_NAME}"
          _confirm
        fi
      fi

      debian_iso_url="http://cdimage.debian.org/cdimage/release/current/${debian_select_platform}/${debian_image_type}/${debian_name}-${debian_select_version}-${debian_select_platform}-${debian_iso_installation_type}.iso"
      debian_initrd_gz_url="http://ftp.debian.org/debian/dists/${debian_release}/main/installer-amd64/current/images/hd-media/initrd.gz"
      debian_vmlinuz_url="http://ftp.debian.org/debian/dists/${debian_release}/main/installer-amd64/current/images/hd-media/vmlinuz"

      debian_base_iso_256sum_online_value=$(curl -s "https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/SHA256SUMS" | grep "debian-${debian_select_version}-${debian_select_platform}-${debian_iso_installation_type}.iso" | awk '{ print $1 }')

      debian_isofile="${root_temp_path}/${iso_os}_${debian_select_version}.iso"
      debian_isofile_final="${root_temp_path}/${iso_os}_${debian_select_version}_final.iso"
      debian_isofile_final_base_name="$(basename -- "${debian_isofile_final}")"
      # Modify this to have the output name as different name (This file is just a backup file of debian_isofile_final)

      debian_iso_complete_file="${ISO_PATH}/os/debian/${debian_name}_${debian_select_version}_complete.iso"

      rm -rf "${debian_isofile_final}"
      rm -rf "${isodir_write}"
      rm -rf "${isodir_write_tmp}"
      rm -rf "${preseed_file}"
      rm -rf "${source_file}"

      mkdir -p "${root_temp_path}"
      mkdir -p "${isomount_location}"
      mkdir -p "${isodir_write}"
      mkdir -p "${isodir_write_tmp}"
      mkdir -p "$(dirname "${debian_iso_complete_file}")"
      echo ""

      if [ "${backup}" == "true" ]; then
        if [ -f "${debian_iso_complete_file}" ]; then
          msg "$(s green)OK, previous ISO file ${debian_iso_complete_file} exist$(e)" --caller="${SCRIPT_NAME}"
          echo ""
          msg "$(s cyan)Checking if the ISO file ${debian_iso_complete_file} is valid (bootable) ..." --caller="${SCRIPT_NAME}"
          maxibuild --include "genisoimage"
          isoinfo -d -i "${debian_iso_complete_file}" 2>/dev/null | grep -q "bootable"
          retval=$?
          if [ ${retval} -eq 0 ]; then
            local backup_dir iso_backup_dir ssh_backup_dir
            msg "$(s green)OK, previous ISO file ${debian_iso_complete_file} is valid (bootable). Backing up ISO files and SSH keys ...$(e)" --caller="${SCRIPT_NAME}"
            backup_dir="${ISO_PATH}/backup/iso_backup_${date_time_random}"
            iso_backup_dir="${backup_dir}/iso"
            ssh_backup_dir="${backup_dir}/ssh"

            mkdir -p "${iso_backup_dir}"
            mkdir -p "${ssh_backup_dir}"
            cp -p "${debian_iso_complete_file}" "${iso_backup_dir}"
            cp -Rp "${SECURE_PATH}/ssh/" "${ssh_backup_dir}"
            echo "Backup location is at: ${iso_backup_dir}"
            echo ""
          else
            msg "$(s red)Error, the previous ISO file might be corrupted because it does not contain bootable record.$(e)" --caller="${SCRIPT_NAME}"
            exit 1
          fi
        else
          msg "$(s red)Error, backup failed because previous ISO file ${debian_iso_complete_file} was not found. Please inspect the location of the file$(e)" --caller="${SCRIPT_NAME}"
          msg "$(s red)If you want to continue without backup, omit the option --backup$(e)" --caller="${SCRIPT_NAME}"
          exit 1
        fi
      fi

      if [ "${iso_base}" == "web" ]; then
        if [ "${C_USE_LATEST_ISO}" == "true" ]; then
          msg "The Latest version of Debian detected is ${debian_latest_version} (auto selected version is ${debian_select_version})" --caller="${SCRIPT_NAME}"
          msg "Setup will download the most recent version of Debian regardless of the selected version because C_USE_LATEST_ISO is set to yes from the config file!" --caller="${SCRIPT_NAME}"
          _pause 5
        else
          if [ "${debian_latest_version}" != "${C_OS_SELECT_VERSION}" ]; then
            msg "$(s yellow)Warning, OS version mismatch. The Latest version of Debian detected is ${debian_latest_version} but the selected version is ${debian_select_version}$(e)" --caller="${SCRIPT_NAME}"
            msg "The installation might fail due to the new changes in latest version of Debian. Please inspect the current OS by assigning the C_OS_SELECT_VERSION to the latest version" --caller="${SCRIPT_NAME}"
            msg "You can re-run this script without --rebuild-all once you did that"
            exit 1
          fi
        fi
        msg "$(s cyan)Downloading ISO file from ${debian_iso_url} ...$(e)" --caller="${SCRIPT_NAME}"
        rm -rf "${debian_isofile}"
        wget -nc --no-verbose -O "${debian_isofile}" "${debian_iso_url}" || true
      elif [ "${iso_base}" == "local" ]; then
        msg "$(s cyan)Setup will use the local ISO file downloaded previously! Checking existing ISO file ${debian_isofile} ... $(e)" --caller="${SCRIPT_NAME}"
        # use the local ISO
        if [ -f "${debian_isofile}" ]; then
          # echo "ISO file exist"
          # Check here if ISO is corrupt based on online checksum
          if is_valid sha256sum "${debian_base_iso_256sum_online_value}" "${debian_isofile}"; then
            msg "$(s green)OK, the base ISO file content is valid sha256sum. Setup will create ISO file using existing ISO file$(e)" --caller="${SCRIPT_NAME}"
          else
            msg "$(s red)Error, the base ISO file content is corrupted (not valid sha256sum). Please download a new one with an option [ --iso-base web ]$(e)" --caller="${SCRIPT_NAME}"
            exit 1
          fi

        else
          msg "$(s red) Error, the base ISO file ${debian_isofile} does not exist. You may need to use the option [ --iso-base web ] to automatically download new ISO file from web$(e)" --caller="${SCRIPT_NAME}"
          exit 1
        fi
      else
        msg "$(s red)Error, unknown ISO base type$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi

      # For hard disk booting
      if [[ "${iso_type}" == "hdd-iso" || "${iso_type}" == "hdd-boot" || "${iso_type}" == "hdd" || "${iso_type}" == "isolinux" ]]; then

        maxibuild --include "debconf isolinux syslinux-utils xorriso wget"

        msg "$(s cyan)Creating new RSA Key for root ...$(e)" --caller="${SCRIPT_NAME}"
        # This will create 2 files one is private and another one with the extension .pub
        # For root
        ssh_api create-key-with-putty --group root --user "${C_ROOT_USERNAME}" --comment "${C_BOX_HOSTNAME_FQHN}_secure_auth"
        echo ""

        msg "$(s cyan)Creating new RSA Key for sudo [user] ...$(e)" --caller="${SCRIPT_NAME}"
        ssh_api create-key-with-putty --group user --user "${C_SSH_USERNAME}" --comment "${C_BOX_HOSTNAME_FQHN}_secure_auth"
        echo ""

        # Must copy the new keys to /root/.ssh with this command
        msg "$(s cyan)Updating the keys from ${SECURE_PATH}/ssh into /root/.ssh ...$(e)" --caller="${SCRIPT_NAME}"
        ssh_api copy-public-keys --without-prompt
        echo ""

        msg "$(s cyan)Building a custom ${iso_os} image file for server using HDD Booting method ...$(e)" --caller="${SCRIPT_NAME}"
        echo ""
        # Fixing
        navigate_to "${SCRIPT_PATH}"

        msg "$(s cyan)Writing new preseed file config ...$(e)" --caller="${SCRIPT_NAME}"
        # Writing new preseed.cfg
        create_file "debian-preseed" "${preseed_file}"
        echo ""
        msg "$(s cyan)Checking preseed syntax file ${preseed_file} ...$(e)" --caller="${SCRIPT_NAME}"
        if ! debconf-set-selections -c "${preseed_file}"; then
          msg "$(s red)Error, there there was a syntax error in the preseed.cfg. Check the syntax of the preconfiguration file.$(e)" --caller="${SCRIPT_NAME}"
          _exit 1
        else
          msg "$(s green)OK, the preseed file ${preseed_file} syntax is ok$(e)" --caller="${SCRIPT_NAME}"
        fi
        # exit 1
        echo ""
        msg "$(s cyan)Extracting the ISO file ${debian_isofile}'s contents into a temporary writeable directory at ${isodir_write_tmp} ...$(e)" --caller="${SCRIPT_NAME}"
        xorriso -osirrox on -indev "${debian_isofile}" -extract / "${isodir_write_tmp}/"
        echo ""

        # Do not remove existing ISO file because we want to reuse this without downloading new ISO using the option --iso-base=local
        #msg "$(s cyan)Removing existing ISO file ...$(e)" --caller="${SCRIPT_NAME}"
        #rm -rf "${debian_isofile}"

        #echo "Editing isolinux/isolinux.cfg to disable setup menu (straight to the first menu on startup) ..."
        #sed -i "s/timeout 0/timeout 1/" ${ISODIR_WRITE_TMP}/isolinux/isolinux.cfg
        echo ""
        msg "$(s cyan)Copying raw preseed file from ${preseed_file} into ${isodir_write_tmp}/preseed.cfg ...$(e)" --caller="${SCRIPT_NAME}"
        cp "${preseed_file}" "${isodir_write_tmp}/preseed.cfg"
        #chmod 555 ${ISODIR_WRITE}/preseed.cfg
        echo ""

        msg "$(s cyan)Writing rsa public key (root) file into ${isodir_write_tmp}/root_${C_ROOT_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub ...$(e)" --caller="${SCRIPT_NAME}"

        ssh_api get-public-key --group root --user "${C_ROOT_USERNAME}" --server "${C_BOX_HOSTNAME_FQHN}" >"${isodir_write_tmp}/root_${C_ROOT_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub"
        echo ""
        msg "$(s cyan)Writing rsa public key (user) file into ${isodir_write_tmp}/user_${C_SSH_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub ...$(e)" --caller="${SCRIPT_NAME}"
        ssh_api get-public-key --group user --user "${C_SSH_USERNAME}" --server "${C_BOX_HOSTNAME_FQHN}" >"${isodir_write_tmp}/user_${C_SSH_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub"
        echo ""

        msg "$(s cyan)Creating os_initialize.sh script file into ${isodir_write_tmp}/os_initialize.sh ...$(e)" --caller="${SCRIPT_NAME}"
        create_file os_initialize "${isodir_write_tmp}/os_initialize.sh"
        echo ""
        msg "$(s cyan)Changing permission of ${isodir_write_tmp}/preseed.cfg to own by root:root ...$(e)" --caller="${SCRIPT_NAME}"
        chown root:root "${isodir_write_tmp}/preseed.cfg"
        echo ""
        msg "$(s cyan)Lowering the files permission from ${isodir_write_tmp}/install.amd to +w ...$(e)" --caller="${SCRIPT_NAME}"
        chmod +w -R "${isodir_write_tmp}/install.amd"
        retval=$?
        if [ ${retval} -ne 0 ]; then
          msg warning "Something is wrong when trying to lower the file permission for ${isodir_write_tmp}/install.amd to +w"
          _exit 1
        fi
        echo ""
        msg "$(s cyan)Extracting initrd.gz ...$(e)" --caller="${SCRIPT_NAME}"
        gunzip "${isodir_write_tmp}/install.amd/initrd.gz"
        echo ""
        msg "$(s cyan)Writing preseed.cfg file into initrd ...$(e)" --caller="${SCRIPT_NAME}"
        echo "${isodir_write_tmp}/preseed.cfg" | cpio -H newc -o -A -F "${isodir_write_tmp}/install.amd/initrd"
        echo ""
        ##exit 1
        msg "$(s cyan)Compressing initrd as initrd.gz ...$(e)" --caller="${SCRIPT_NAME}"
        gzip "${isodir_write_tmp}/install.amd/initrd"
        echo ""
        msg "$(s cyan)Changing the folder permission of ${isodir_write_tmp}/install.amd/ to -w ...$(e)" --caller="${SCRIPT_NAME}"
        chmod -w -R "${isodir_write_tmp}/install.amd/"
        echo ""

        msg "$(s cyan)Writing and fixing md5sum checksum in ${isodir_write} ...$(e)" --caller="${SCRIPT_NAME}"
        navigate_to "${isodir_write_tmp}"

        # Alternative method:
        #pushd ${ISODIR_WRITE}
        #  md5sum $(find -type f) > md5sum.txt
        #popd

        # A warning will be issued because ./debian is a symlink to . :
        # find: File system loop detected; ‘./debian’ is part of the same file system loop as ‘.’ :
        chmod +w md5sum.txt
        #find -follow -type f ! -name md5sum.txt -print0 | xargs -0 md5sum >md5sum.txt
        find . -follow -type f ! -name md5sum.txt -print0 | xargs -0 md5sum >tmpfile && mv tmpfile md5sum.txt
        chmod -w md5sum.txt
        echo ""

        msg "$(s cyan)Creating standalone ISO installation inside ${isodir_write}/${debian_isofile_final} ...$(e)" --caller="${SCRIPT_NAME}"
        xorriso -as mkisofs \
          -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin \
          -c isolinux/boot.cat \
          -b isolinux/isolinux.bin \
          -no-emul-boot \
          -boot-load-size 4 \
          -boot-info-table \
          -eltorito-alt-boot \
          -e boot/grub/efi.img \
          -no-emul-boot \
          -isohybrid-gpt-basdat \
          -o "${isodir_write}/${debian_name}-${debian_release}-${debian_iso_installation_type}.iso" \
          "${isodir_write_tmp}"
        echo ""

        msg "$(s cyan)Copying ${isodir_write_tmp}/boot into ${isodir_write} ...$(e)" --caller="${SCRIPT_NAME}"
        cp -rp "${isodir_write_tmp}/boot" "${isodir_write}"
        echo ""
        msg "$(s cyan)Creating new boot installation directory at ${isodir_write}/boot/os ...$(e)" --caller="${SCRIPT_NAME}"
        mkdir -p "${isodir_write}/boot/os"
        echo ""
        navigate_to "${isodir_write}/boot/os"
        echo ""
        msg "$(s cyan)Downloading initrd.gz file into ${isodir_write}/boot/os ...$(e)" --caller="${SCRIPT_NAME}"
        wget --no-verbose -O initrd.gz ${debian_initrd_gz_url}
        echo ""
        msg "$(s cyan)Downloading vmlinuz file into ${isodir_write}/boot/os ...$(e)" --caller="${SCRIPT_NAME}"
        wget --no-verbose -O vmlinuz ${debian_vmlinuz_url}
        echo ""
        msg "$(s cyan)Copying ${isodir_write_tmp}/isolinux into ${isodir_write} ...$(e)" --caller="${SCRIPT_NAME}"
        cp -rp "${isodir_write_tmp}/isolinux" "${isodir_write}"
        echo ""

        msg "$(s cyan)Backing up isolinux.cfg file at ${isodir_write}/isolinux/isolinux.cfg as ${isodir_write}/isolinux/original_isolinux.cfg ...$(e)" --caller="${SCRIPT_NAME}"
        mv "${isodir_write}/isolinux/isolinux.cfg" "${isodir_write}/isolinux/original_isolinux.cfg"
        echo ""

        msg "$(s cyan)Modifying isolinux.cfg to create new operating system boot menu ...$(e)" --caller="${SCRIPT_NAME}"
        {

          ## Config reference: https://www.alteeve.com/an-repo/files/isolinux.cfg
          # Use high-color menu
          echo "UI vesamenu.c32"
          # Timeout unit is 1/10s, 100 means 10 seconds
          echo "TIMEOUT 100"
          echo "PROMPT 0"

          echo "DEFAULT Debian - Auto Installation"
          echo "# Console Prompt"
          echo "say **********************************************************************"
          echo "say Sofibox Cloud Sdn Bhd."
          echo "say TOSP, Cyberjaya Malaysia."
          echo "say sofibox.com, tosp.sofibox.com"
          echo "say OPERATING SYSTEM INSTALLER"
          echo "Copyright (C) Arafat Ali"
          echo "say Automatically booting: Debian - Auto Installation in 10 seconds ..."
          echo "say **********************************************************************"

          echo "# Allow client to edit the boot parameters"
          echo "ALLOWOPTIONS 1"

          # If don't set default would be 640x480
          #MENU RESOLUTION 1024 768

          # The background image
          #MENU BACKGROUND pxe_splash_1024_768.jpg

          echo "# Menu Title"
          echo "MENU TITLE Sofibox - Maxinet Rescue Mode"

          echo "MENU AUTOBOOT Will boot the next device as configured in your BIOS in # second{,s}."
          echo "MENU TABMSG   Press the <tab> key to edit the boot parameters of the highlighted option."
          echo "MENU NOTABMSG Editing of this option is disabled."

          #The color
          echo "# Format is: MENU COLOR <Item> <ANSI Seq.> <foreground> <background> <shadow type>"
          echo "MENU COLOR screen      0  #80ffffff #00000000 std      # background colour not covered by the splash image"
          echo "MENU COLOR border      0  #ffffffff #ee000000 std      # The wire-frame border"
          echo "MENU COLOR title       0  #ffff3f7f #ee000000 std      # Menu title text"
          echo "MENU COLOR sel         0  #ff00dfdf #ee000000 std      # Selected menu option"
          echo "MENU COLOR hotsel      0  #ff7f7fff #ee000000 std      # The selected hotkey (set with ^ in MENU LABEL)"
          echo "MENU COLOR unsel       0  #ffffffff #ee000000 std      # Unselected menu options"
          echo "MENU COLOR hotkey      0  #ff7f7fff #ee000000 std      # Unselected hotkeys (set with ^ in MENU LABEL)"
          echo "MENU COLOR tabmsg      0  #c07f7fff #00000000 std      # Tab text"
          echo "MENU COLOR timeout_msg 0  #8000dfdf #00000000 std      # Timout text"
          echo "MENU COLOR timeout     0  #c0ff3f7f #00000000 std      # Timout counter"
          echo "MENU COLOR disabled    0  #807f7f7f #ee000000 std      # Disabled menu options, including SEPARATORs"
          echo "MENU COLOR cmdmark     0  #c000ffff #ee000000 std      # Command line marker - The '> ' on the left when editing an option"
          echo "MENU COLOR cmdline     0  #c0ffffff #ee000000 std      # Command line - The text being edited"
          echo "# Options below haven't been tested, descriptions may be lacking."
          echo "MENU COLOR scrollbar   0  #40000000 #00000000 std      # Scroll bar"
          echo "MENU COLOR pwdborder   0  #80ffffff #20ffffff std      # Password box wire-frame border"
          echo "MENU COLOR pwdheader   0  #80ff8080 #20ffffff std      # Password box header"
          echo "MENU COLOR pwdentry    0  #80ffffff #20ffffff std      # Password entry field"
          echo "MENU COLOR help        0  #c0ffffff #00000000 std      # Help text, if set via 'TEXT HELP ... ENDTEXT'"

          echo "LABEL Debian - Auto Installation"
          echo "    MENU LABEL ^1) Auto install Debian"
          echo "    MENU DEFAULT"
          echo "    KERNEL /boot/os/vmlinuz"
          #important, preseed file location need to be cdrom/preseed.cfg"
          echo "    APPEND initrd=/boot/os/initrd.gz preseed/file=/cdrom/preseed.cfg locale=${C_BOX_LOCALE} keymap=${C_BOX_KEYBOARD} language=${C_BOX_LANGUAGE_CODE} country=${C_BOX_COUNTRY_CODE} --"
          echo "    TEXT HELP"
          echo "    * This is an auto installation"
          echo "    * WARNING: ALL DATA ON DISKS WILL BE OVERWRITTEN WITHOUT ANY QUESTIONS"
          echo "    ENDTEXT"
          echo "LABEL Debian - Manual installation"
          echo "   MENU LABEL ^2) Manual Debian Installation"
          echo "   KERNEL  /boot/os/vmlinuz"
          echo "   APPEND initrd=/boot/os/initrd.gz --"
          echo "    TEXT HELP"
          echo "    * This is a manual installation"
          echo "    * NOTE: USE THIS MENU IF YOU WANT TO INSTALL DEBIAN INTERACTIVELY"
          echo "    ENDTEXT"
          # Warning this System Backup menu is beta and will not do anything. Will update in the future for backup function
          echo "LABEL Debian - System Backup"
          echo "MENU LABEL ^3) Debian Full System Backup"
          echo "   KERNEL  /boot/os/vmlinuz"
          echo "   APPEND initrd=/boot/os/initrd.gz --"
          echo "    TEXT HELP"
          echo "    * This is an operating system full backup mode"
          echo "    * NOTE: USE THIS MENU IF YOU WANT TO MAKE FULL BACKUP (TESTING)"
          echo "    ENDTEXT"

        } >"${isodir_write}/isolinux/isolinux.cfg"

        msg "$(s cyan)Writing and fixing md5sum checksum in ${isodir_write} ...$(e)" --caller="${SCRIPT_NAME}"
        cp -p "${isodir_write_tmp}/md5sum.txt" "${isodir_write}"
        rm -rf "${isodir_write_tmp}"
        navigate_to "${isodir_write}"

        chmod +w md5sum.txt
        find . -follow -type f ! -name md5sum.txt -print0 | xargs -0 md5sum >tmpfile && mv tmpfile md5sum.txt
        chmod -w md5sum.txt
        echo ""

        msg "$(s cyan)Creating the final ISO file ...$(e)" --caller="${SCRIPT_NAME}"
        xorriso -as mkisofs \
          -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin \
          -c isolinux/boot.cat \
          -b isolinux/isolinux.bin \
          -no-emul-boot \
          -boot-load-size 4 \
          -boot-info-table \
          -eltorito-alt-boot \
          -e boot/grub/efi.img \
          -no-emul-boot \
          -isohybrid-gpt-basdat \
          -o "${debian_isofile_final}" \
          "${isodir_write}"
        echo ""

        # Copying to shared folder
        msg "$(s cyan)Creating a copy of ISO file from ${debian_isofile_final} as ${debian_iso_complete_file} ...$(e)" --caller="${SCRIPT_NAME}"
        cp "${debian_isofile_final}" "${debian_iso_complete_file}"
        echo ""
        if [[ "${upload_to_dropbox}" == "true" ]]; then
          # First check if the ISO file is bootable
          msg "$(s cyan)Checking whether ISO file ${debian_isofile_final} is valid (bootable) ...$(e)" --caller="${SCRIPT_NAME}"
          maxibuild --include "genisoimage"
          isoinfo -d -i "${debian_isofile_final}" 2>/dev/null | grep -q "bootable"
          retval=$?
          if [ ${retval} -eq 0 ]; then
            msg "$(s green)OK, ISO file ${debian_isofile_final} is valid (bootable)$(e)" --caller="${SCRIPT_NAME}"
          else
            msg "$(s red)Error, the ISO file ${debian_isofile_final} might be corrupted because it does not contain bootable record.$(e)" --caller="${SCRIPT_NAME}"
            exit 1
          fi
          echo ""
          msg "$(s cyan)Uploading local file ${debian_isofile_final} into dropbox remote location /files/${debian_isofile_final_base_name} ...$(e)" --caller="${SCRIPT_NAME}"

          # Uploading to dropbox and generating link
          # dropbox_api upload --source "${debian_isofile_final}" --destination "/files/$(basename -- "${debian_isofile_final}")"

          dbxcli -c 250 upload "${debian_isofile_final}" "/files/$(basename -- "${debian_isofile_final}")"

          echo ""
          msg "$(s cyan)Generating uploaded file link of ${debian_isofile_final} ...$(e)" --caller="${SCRIPT_NAME}"

          file_direct_link=$(dbxcli share "/files/$(basename -- "${debian_isofile_final}")" | awk '{ print $4}' | sed 's/0$/1/g')

          if [ -z "${file_direct_link}" ]; then
            msg "$(s red)Error, uploaded file direct link is empty. Please inspect why! $(e)" --caller="${SCRIPT_NAME}"
            exit 1
          fi

          msg "$(s cyan)ISO direct link is: $(s red)${file_direct_link}$(e)" --caller="${SCRIPT_NAME}"

          echo ""

          msg "$(s cyan)Creating automation script for installing operating system remotely into ${CODE_PATH}/ssh_scripts/os_write_ag.sh ...$(e)" --caller="${SCRIPT_NAME}"
          {
            echo "#!/bin/bash"
            echo "# ==============================================="
            echo "# This script file was generated by ${SCRIPT_NAME}"
            echo "# This script is used to write OS into /dev/sda"
            echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
            echo "# ==============================================="
            echo "wget -O mini.iso ${file_direct_link}"
            echo "dd if=mini.iso of=/dev/sda"
            # This is needed to force reboot especially for rescue mode.
            echo "reboot --poweroff --force"
            echo "# Put 2 times exit below to safely exit the script if the first exit is not executed"
            echo "exit"
            echo "exit"
          } >"${CODE_PATH}/ssh_scripts/os_write_ag.sh"
          echo ""
          msg "$(s cyan)Generating rescue disk command for manual installation at $(dirname "${debian_iso_complete_file}")/install.txt ...$(e)" --caller="${SCRIPT_NAME}"
          {
            echo "# ==============================================="
            echo "# This manual file was generated by ${SCRIPT_NAME}"
            echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
            echo "# ==============================================="
            echo "# Download link available at:"
            echo "wget -O mini.iso \"${file_direct_link}\""
            echo "# Operating system installation script available at:"
            echo "${CODE_PATH}/ssh_scripts/os_write_ag.sh"
            echo "dd if=mini.iso of=/dev/sda"
          } >"$(dirname "${debian_iso_complete_file}")/install.txt"
          echo ""

          if [ ${write_script} == "true" ]; then
            msg "$(s red)==================================$(e)"
            msg "$(s newline)"
            msg "$(s green)wget -O mini.iso \"${file_direct_link}\"$(e)"
            msg "$(s green)dd if=mini.iso of=/dev/sda$(e)"
            msg "$(s green)mkdir /mnt/iso$(e)"
            msg "$(s green)mount mini.iso /mnt/iso$(e)"
            msg "$(s green)echo \"\"$(e)"
            msg "$(s newline)"
            msg "$(s red)==================================$(e)"
            msg "$(s newline)"
          fi
          echo ""
        fi

        msg "$(s cyan)Removing current working directories ...$(e)" --caller="${SCRIPT_NAME}"
        rm -rf "${isodir_write}"
        echo ""
        msg "$(s cyan)Removing current preseed configuration file ...$(e)" --caller="${SCRIPT_NAME}"
        rm -rf "${preseed_file}"
        echo ""
        # Back to the original script path as the above path was deleted and can cause issue on rsync transfer later
        msg "$(s cyan)Navigating back to script path ...$(e)" --caller="${SCRIPT_NAME}"
        navigate_to "${SCRIPT_PATH}"
        echo ""
      # My custom method
      else
        msg "$(s red)Error, unknown type or method for creating ISO file ${iso_type}!$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi
    fi

    # This action is deprecated (this is used to create custom rescue disk for finnix before but we dont need it anymore, just use the improve version of linode finnix rescue disk)
  elif [[ "${action}" == "create-rescue-iso" ]]; then

    maxibuild --include "genisoimage wget pwgen whois xorriso debconf isolinux syslinux-utils squashfs-tools putty-tools"

    # dbx_cli="${SCRIPT_PATH}/storage/os/debian/usr/local/maxicode/maxicloud/dropbox/dbx"
    if [[ "${C_HOST_MAX_PROCESSOR}" -lt 2 ]]; then
      msg "Warning, this process will run slower when using compression tool because C_HOST_MAX_PROCESSOR is set less than 2"
      echo ""
    fi
    echo "Creating a new RSA Key for rescue root login ..."
    ssh_api "create-key-with-putty" "rescue" "root" "${C_BOX_HOSTNAME_FQHN}_secure_auth"

    # Good guide : https://www.dotpointer.ga/?section=notes&view=note&id_notes=164
    # Good guide 2: https://rmprepusb.com/tutorials/011-make-an-image-recovery-usb-drive-using-finnix/
    local action="$1"
    local retval=0
    local method="$1"
    local option="$2"
    local root_temp_path isofile isofile_final isomount_location finnix_select_version isodir_write iso_url isofile_final_base_name file_direct_link

    if [ $# -gt 3 ]; then
      echo "Argument shouldn't be more than 3 for now. See --help for more information"
      _exit 1
    fi
    root_temp_path="/root/tmp_iso/debian"
    isofile="${root_temp_path}/finnix-122.iso"
    isofile_final="${root_temp_path}/finnix_mod.iso"
    isofile_final_base_name="$(basename -- ${isofile_final})"
    iso_output_path="/mnt/c/Users/Maxibi/IdeaProjects/maxinet/storage/os/debian/finnixmod.iso"
    isomount_location="/mnt/mount_riso"
    isodir_write="${root_temp_path}/riso-rw"

    #https://www.finnix.org/releases/122/finnix-122.iso
    finnix_select_version="122"

    iso_url="https://www.finnix.org/releases/${finnix_select_version}/finnix-${finnix_select_version}.iso"

    msg "$(s cyan)Removing previous file ${isofile_final} ...$(e)" --caller="${SCRIPT_NAME}"
    rm -rf "${isofile_final}"

    echo ""
    echo "$(s cyan)Removing previous file ${isodir_write} ...$(e)" --caller="${SCRIPT_NAME}"
    rm -rf "${isodir_write}"

    mkdir -p "${root_temp_path}"
    mkdir -p "${isomount_location}"
    mkdir -p "${isodir_write}"
    echo ""

    echo "Creating a custom Finnix rescue disk for hard disk booting ..."
    echo ""
    if [[ "${option}" == "--update-iso" || -z "${option}" ]]; then
      if [ -f "${isofile}" ]; then
        rm -rf "${isofile}"
        echo "Re-downloading system image ..."
      else
        echo "Downloading new system image ..."
      fi

      wget --no-verbose -nc -O "${isofile}" "${iso_url}" || true
    elif [[ "${option}" == "--no-update-iso" ]]; then
      if [ -f "${isofile}" ]; then
        echo "Using the existing ISO file ..."
      else
        echo "Warning, existing ISO file is missing! Use --update-iso option to download new file"
        _exit 1
      fi
      # Do nothing
    else
      echo "Invalid option supplied: ${option} on ${FUNCNAME[0]}"
      echo "${SCRIPT_NAME} ${action} --update-iso , to download the new ISO file where --update-iso is a default command if not specified"
      echo "${SCRIPT_NAME} ${action} --no-update-iso , to use existing ISO file"
      _exit 1
    fi
    echo ""
    echo "Copying ISO file content into writeable directory ${isodir_write} ..."
    xorriso -osirrox on -indev ${isofile} -extract / ${isodir_write}/
    echo ""
    echo "Removing initial ISO file ..."
    rm -rf "${isofile}"
    echo ""
    echo "Disabling startup timer menu (straight boot to the default menu) ..."
    sed -i "s/timeout .*/timeout 1/" ${isodir_write}/isolinux/isolinux.cfg
    echo ""
    #echo "Adding noeject and noprompt boot parameter at grub.cfg ..."
    #{
    #  echo "source /boot/grub/config.cfg"
    #  echo "# Live boot"
    #  echo "menuentry \"Live system\" --hotkey=l {"
    #  echo "    linux	/live/vmlinuz-5.10.0-3-amd64 quiet"
    #  echo "    initrd	/live/initrd.img-5.10.0-3-amd64"
    #  echo "}"
    #} >${isodir_write}/boot/grub/grub.cfg
    echo ""
    echo "Creating startup script on startup ..."
    #Guide here: https://www.finnix.org/Overlays (Startup shell scripts)
    mkdir -p "${isodir_write}/finnix/arch/indep/rc"
    echo "#!/bin/bash" >"${isodir_write}/finnix/arch/indep/rc/initial.sh"
    echo "#any startup script here" >>"${isodir_write}/finnix/arch/indep/rc/initial.sh"
    chmod +x "${isodir_write}/finnix/arch/indep/rc/initial.sh"
    echo ""
    echo "Creating working directory ${isodir_write}/live/workdir"
    mkdir -p "${isodir_write}/live/workdir"
    echo ""
    echo "Moving ${isodir_write}/live/filesystem.squashfs into ${isodir_write}/live/workdir ..."
    mv "${isodir_write}/live/filesystem.squashfs" "${isodir_write}/live/workdir"
    echo ""
    navigate_to "${isodir_write}/live/workdir"
    echo "Extracting squashfs file filesystem.squashfs ..."
    unsquashfs -processors "${C_HOST_MAX_PROCESSOR}" filesystem.squashfs
    echo ""
    echo "Removing the old filesystem.squashfs file ..."
    rm -rf filesystem.squashfs
    echo ""
    #exit 1
    # Now we have all file in here: isodir_write/live/workdir/squashfs-root/*
    echo "Creating .ssh directory in ${isodir_write}/live/workdir/squashfs-root/root/.ssh ..."
    mkdir -p "${isodir_write}/live/workdir/squashfs-root/root/.ssh"
    echo ""
    echo "Copying RSA certificate in ${isodir_write}/live/workdir/squashfs-root/root/.ssh/authorized_keys ..."

    #cp "${SCRIPT_PATH}/secure/rescue_root_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub" "${isodir_write}/live/workdir/squashfs-root/root/.ssh/authorized_keys"
    ssh_api "get-pubkey" "rescue" "root" >"${isodir_write}/live/workdir/squashfs-root/root/.ssh/authorized_keys"

    echo ""
    echo "Raising permission of .ssh folder ..."
    chmod -R go-rwx "${isodir_write}/live/workdir/squashfs-root/root/.ssh"
    echo ""
    echo "Disabling SSH root login in sshd_config ..."
    sed -i 's/^.*PermitRootLogin.*/PermitRootLogin no/g' "${isodir_write}/live/workdir/squashfs-root/etc/ssh/sshd_config"
    echo ""

    echo "Changing SSH login port to ${C_RESCUE_SSH_PORT} ..."
    sed -i "s/#Port 22/Port ${C_RESCUE_SSH_PORT}/" "${isodir_write}/live/workdir/squashfs-root/etc/ssh/sshd_config"
    echo ""

    echo "Creating startup script at .profile to restart ssh on startup ..."
    echo "systemctl restart ssh" >>"${isodir_write}/live/workdir/squashfs-root/root/.profile"
    #chmod +x "${isodir_write}/live/workdir/squashfs-root/etc/rc.local"
    echo ""

    echo "Recreating the squashfs	filesystem from filesystem.squashfs ..."
    mksquashfs squashfs-root filesystem.squashfs -b 1024k -comp xz -Xbcj x86 -e boot -processors "${C_HOST_MAX_PROCESSOR}"
    echo ""

    echo "Moving filesystem.squashfs into ${isodir_write}/live/filesystem.squashfs ..."
    mv filesystem.squashfs ${isodir_write}/live/filesystem.squashfs
    echo ""
    echo "Removing working directory ..."
    rm -rf ${isodir_write}/live/workdir
    echo ""
    navigate_to "${isodir_write}"
    echo "Creating new sha256sum checksum for sha256sum.txt ..."
    chmod +w sha256sum.txt
    find "${isodir_write}" -follow -type f ! -name sha256sum.txt -print0 | xargs -0 sha256sum >sha256sum_tmp.txt
    mv -f sha256sum_tmp.txt sha256sum.txt
    chmod -w sha256sum.txt
    echo ""
    echo "Creating standalone ISO installation inside ${isofile_final} ..."
    xorriso -as mkisofs \
      -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin \
      -c isolinux/boot.cat \
      -b isolinux/isolinux.bin \
      -no-emul-boot \
      -boot-load-size 4 \
      -boot-info-table \
      -eltorito-alt-boot \
      -isohybrid-gpt-basdat \
      -o ${isofile_final} \
      ${isodir_write}

    # Do not quote the path. If quote it will become redundant path: '/root/tmp_iso/debian/riso-rw/~/tmp_iso/debian/riso-rw'
    echo ""

    # Copying to shared folder
    echo "Creating installation disk at ${iso_output_path} ..."
    cp "${isofile_final}" "${iso_output_path}"
    echo ""
    echo "Copying RSA private (with putty) keys inside ISO output ..."
    cp "${rsa_private_key}" "$(dirname "${iso_output_path}")/"
    cp "${rsa_private_key_ppk}" "$(dirname "${iso_output_path}")/"
    # Uploading to dropbox
    echo ""
    echo "Uploading ${isofile_final} into dropbox /files/${isofile_final_base_name} ..."
    dbxcli upload "${isofile_final}" "/files"

    echo "Creating download link ..."
    file_direct_link=$(dbxcli share "/files/${isofile_final_base_name}" | awk '{ print $4}' | sed 's/0$/1/g')
    echo "File direct link is: ${file_direct_link}"
    echo ""
    echo "Creating rescue disk script ..."
    msg "$(s red)==================================$(e)"
    echo ""
    echo "wget -O mini.iso \"${file_direct_link}\"" >"$(dirname "${iso_output_path}")/install.txt"
    echo "dd if=mini.iso of=/dev/sda" >>"$(dirname "${iso_output_path}")/install.txt"
    msg "$(s green)wget -O mini.iso \"${file_direct_link}\"$(e)"
    msg "$(s green)dd if=mini.iso of=/dev/sda$(e)"
    msg "$(s green)mkdir /mnt/iso$(e)"
    msg "$(s green)mount mini.iso /mnt/iso$(e)"
    msg "$(s green)echo \"\"$(e)"
    echo ""
    msg "$(s red)==================================$(e)"
    echo ""

    echo "Copying script into linode script ${SCRIPT_PATH}/dns/linode... "
    {
      echo "#!/bin/bash"
      echo "wget -O mini.iso ${file_direct_link}"
      echo "dd if=mini.iso of=/dev/sda"
      # Need this option to reboot when reboot check
      echo "reboot -f"
      echo "exit 0"
    } >"${SCRIPT_PATH}/dns/linode/rescue_write.sh"

    echo "Removing working directory ..."
    rm -rf "${isodir_write}"

  else

    msg "$(s red)Error, unknown action passed for iso_api ${action}$(e)" --caller="${SCRIPT_NAME}"
    exit 1
  fi

}

copy_local_dns_to_external_dns() {
  local domain a_records aaaa_records cname_records txt_records ns_records mx_records
  domain="$1"
  if [ "${C_AUTO_CREATE_EXTERNAL_DNS_RECORD}" == "true" ]; then
    if [ "${C_DNS_PROVIDER_NAME}" == "linode" ]; then
      msg "$(s cyan)Creating domain ${domain} in linode with --rebuild option ...$(e)" --caller="${SCRIPT_NAME}"
      maxipi linode create-domain --domain-type "master" --domain "${domain}" --domain-email "webmaster@${domain}" --domain-ttl 30 --rebuild
      get_status_message "$?"
      echo ""

      # Here we can create DNS records (we should scan all the records exists in test.domain.com and add them one by one into external DNS)
      # Important notes, this NS record is special in directadmin it does not show up in directadmin DNS management as A or AAAA records,
      # but if you query using API, you will get NS record at A and AAAA records.
      # NS record also can be found in ns_records call below with NS record type
      a_records=$(da_api_admin get-dns-records --domain "${domain}" --special-type "a" --scripting)
      aaaa_records=$(da_api_admin get-dns-records --domain "${domain}" --special-type "aaaa" --scripting)
      cname_records=$(da_api_admin get-dns-records --domain "${domain}" --special-type "cname" --scripting)
      txt_records=$(da_api_admin get-dns-records --domain "${domain}" --special-type "txt" --scripting)
      ns_records=$(da_api_admin get-dns-records --domain "${domain}" --special-type "ns" --scripting)
      mx_records=$(da_api_admin get-dns-records --domain "${domain}" --special-type "mx" --scripting)
      # We are not interested with this record yet
      #  srv_records=$(da_api_admin get-dns-records --domain "${domain}" --special-type "srv" --scripting)
      #  caa_records=$(da_api_admin get-dns-records --domain "${domain}" --special-type "caa" --scripting)
      #  ptr_records=$(da_api_admin get-dns-records --domain "${domain}" --special-type "ptr" --scripting)

      echo ""
      # For A record
      if [ -n "${a_records}" ]; then
        msg "$(s cyan)Adding all A records in linode ...$(e)" --caller="${SCRIPT_NAME}"

        #echo "A record not empty"
        #echo "a record: "
        #echo "${a_records}"
        #echo "record length: "
        # total_record=$(echo "${a_records}" | jq -r ".type" | wc -w)
        # For record name
        readarray -t record <<<$(echo "${a_records}" | jq -r ".name")
        # For record value
        readarray -t record2 <<<$(echo "${a_records}" | jq -r ".value")

        msg ""
        msg "record name:"
        msg "${record[@]}"
        msg ""
        msg "record value:"
        msg "${record2[@]}"
        msg ""

        for i in "${!record[@]}"; do
          local record_name record_value
          record_name="${record[i]}"
          # This one fixed the dot character of the ending domain
          if [[ "$(echo "${record_name: -1}")" == "." ]]; then
            echo "Fixing record[$i] that contains dot character: ${record[$i]} ..."
            record_name=$(echo "${record_name}" | sed 's/.$//')
            echo "Record record[$i] is now set as ${record_name}"
            echo ""
          fi
          record_value="${record2[i]}"

          echo "record_name is ${record_name}"
          echo "record_value is ${record_value}"
          echo ""
          maxipi linode add-dns-record --for-domain "${domain}" --record-type "A" --record-name "${record_name}" --record-value "${record_value}" --record-ttl 30
          get_status_message "$?"
          echo ""
        done
      else
        msg "$(s yellow)Notice, no A record is found$(e)" --caller="${SCRIPT_NAME}"

      fi

      echo ""
      # For AAAA record
      if [ -n "${aaaa_records}" ]; then
        msg "$(s cyan)Adding all AAAA records in linode ...$(e)" --caller="${SCRIPT_NAME}"
        # For record name
        readarray -t record <<<"$(echo "${aaaa_records}" | jq -r ".name")"
        # For record value
        readarray -t record2 <<<"$(echo "${aaaa_records}" | jq -r ".value")"

        msg ""
        msg "record name:"
        msg "${record[@]}"
        msg ""
        msg "record value:"
        msg "${record2[@]}"
        msg ""

        for i in "${!record[@]}"; do
          local record_name record_value
          record_name="${record[i]}"
          # This one fixed the dot character of the ending domain
          if [[ "$(echo "${record_name: -1}")" == "." ]]; then
            echo "Fixing record[$i] that contains dot character: ${record[$i]} ..."
            record_name=$(echo "${record_name}" | sed 's/.$//')
            echo "Record record[$i] is now set as ${record_name}"
            echo ""
          fi
          record_value="${record2[i]}"
          maxipi linode add-dns-record --for-domain "${domain}" --record-type "AAAA" --record-name "${record_name}" --record-value "${record_value}" --record-ttl 30
          get_status_message "$?"
          echo ""
        done
      else
        msg "$(s yellow)Notice, no AAAA record is found$(e)" --caller="${SCRIPT_NAME}"

      fi

      echo ""

      # For CNAME record
      if [ -n "${cname_records}" ]; then
        msg "$(s cyan)Adding all CNAME records in linode ...$(e)" --caller="${SCRIPT_NAME}"
        # For record name
        readarray -t record <<<"$(echo "${cname_records}" | jq -r ".name")"
        # For record value
        readarray -t record2 <<<"$(echo "${cname_records}" | jq -r ".value")"

        msg ""
        msg "record name:"
        msg "${record[@]}"
        msg ""
        msg "record value:"
        msg "${record2[@]}"
        msg ""

        for i in "${!record[@]}"; do
          local record_name record_value
          record_name="${record[i]}"
          # This one fixed the dot character of the ending domain
          if [[ "$(echo "${record_name: -1}")" == "." ]]; then
            echo "Fixing record[$i] that contains dot character: ${record[$i]} ..."
            record_name=$(echo "${record_name}" | sed 's/.$//')
            echo "Record record[$i] is now set as ${record_name}"
            echo ""
          fi
          record_value="${record2[i]}"
          maxipi linode add-dns-record --for-domain "${domain}" --record-type "CNAME" --record-name "${record_name}" --record-value "${record_value}" --record-ttl 30
          get_status_message "$?"
          echo ""
        done
      else
        msg "$(s cyan)Notice, no CNAME record is found$(e)" --caller="${SCRIPT_NAME}"

      fi
      echo ""
      # For TXT record
      if [ -n "${txt_records}" ]; then
        msg "$(s cyan)Adding all TXT records in linode ...$(e)" --caller="${SCRIPT_NAME}"
        # For record name
        readarray -t record <<<$(echo "${txt_records}" | jq -r ".name")
        # For record value
        readarray -t record2 <<<$(echo "${txt_records}" | jq -r ".value")

        msg ""
        msg "record name:"
        msg "${record[@]}"
        msg ""
        msg "record value:"
        msg "${record2[@]}"
        msg ""
        #exit 1
        for i in "${!record[@]}"; do
          local record_name record_value
          record_name="${record[i]}"
          # This one fixed the dot character of the ending domain
          if [[ "$(echo "${record_name: -1}")" == "." ]]; then
            echo "Fixing record[$i] that contains dot character: ${record[$i]} ..."
            record_name=$(echo "${record_name}" | sed 's/.$//')
            echo "Record record[$i] is now set as ${record_name}"
            echo ""
          fi
          # Important must remove double quote for TXT record value because linode does not accept double quote as valid record
          record_value=$(echo "${record2[i]}" | sed -e 's/^"//' -e 's/"$//')
          echo "record_name is ${record_name}"
          echo "record_value is ${record_value}"
          echo ""
          maxipi linode add-dns-record --for-domain "${domain}" --record-type "TXT" --record-name "${record_name}" --record-value "${record_value}" --record-ttl 30
          get_status_message "$?"

          echo ""
        done
      else
        msg "$(s yellow)Notice, no TXT record is found$(e)" --caller="${SCRIPT_NAME}"

      fi

      echo ""

      # For NS record
      if [ -n "${ns_records}" ]; then

        msg "$(s cyan)Adding all NS records in linode ...$(e)" --caller="${SCRIPT_NAME}"
        # For record name
        readarray -t record <<<$(echo "${ns_records}" | jq -r ".name")
        # For record value
        readarray -t record2 <<<$(echo "${ns_records}" | jq -r ".value")

        msg ""
        msg "record name:"
        msg "${record[@]}"
        msg ""
        msg "record value:"
        msg "${record2[@]}"
        msg ""

        for i in "${!record[@]}"; do
          local record_name record_value
          record_name="${record[i]}"
          record_value="${record2[i]}"
          # This one fixed the dot character of the ending domain
          if [[ "$(echo "${record_name: -1}")" == "." ]]; then
            echo "Fixing record[$i] that contains dot character: ${record[$i]} ..."
            record_name=$(echo "${record_name}" | sed 's/.$//')
            echo "Record record[$i] is now set as ${record_name}"
            echo ""

          fi
          if [[ "$(echo "${record_value: -1}")" == "." ]]; then
            echo "Fixing record2[$i] that contains dot character: ${record2[$i]} ..."
            record_value=$(echo "${record_value}" | sed 's/.$//')
            echo "Record record2[$i] is now set as ${record_value}"
            echo ""
          fi

          maxipi linode add-dns-record --for-domain "${domain}" --record-type "NS" --record-name "${record_name}" --record-value "${record_value}" --record-ttl 30
          get_status_message "$?"
          echo ""
        done
      else
        msg "$(s yellow)Notice, no NS record is found$(e)" --caller="${SCRIPT_NAME}"

      fi

      echo ""
      echo "${mx_records}"
      if [ -n "${mx_records}" ]; then
        msg "$(s cyan)Adding all MX records in linode ...$(e)" --caller="${SCRIPT_NAME}"
        # For record name
        readarray -t record <<<$(echo "${mx_records}" | jq -r ".name")
        # For record value
        readarray -t record2 <<<$(echo "${mx_records}" | jq -r ".value")

        msg ""
        msg "record name:"
        msg "${record[@]}"
        msg ""
        msg "record value (priority):"
        msg "${record2[@]}"
        msg ""

        for i in "${!record[@]}"; do
          local record_value record_name record_priority
          record_value="${record[i]}"
          # record_name="${record2[i]}"

          if [[ "$(echo "${record_value: -1}")" == "." ]]; then

            echo "Fixing record[$i] that contains dot character: ${record_value} ..."
            record_value=$(echo "${record_value}" | sed 's/.$//')
            echo "Record record[$i] is now set as ${record_value}"

          fi

          record_name="$(echo "${record2[i]}" | awk '{ print $2 }')"

          if [[ "$(echo "${record_name: -1}")" == "." ]]; then
            echo "Fixing record_name that contains dot character: ${record_name} ..."
            record_name=$(echo "${record_name}" | sed 's/.$//')
            echo "Record record_name is now set as ${record_name}"
          fi

          record_priority="$(echo "${record2[i]}" | awk '{ print $1 }')"

          echo "record_name ${record_name}"
          echo "record_value ${record_value}"
          echo "record priority ${record_priority}"

          maxipi linode add-dns-record --for-domain "${domain}" --record-type "MX" --record-name "${record_name}" --record-value "${record_value}" --record-priority "${record_priority}" --record-ttl 30
          get_status_message "$?"
        done
      else
        msg "$(s yellow)Notice, no MX record is found$(e)" --caller="${SCRIPT_NAME}"
      fi
      echo ""

    elif
      [ "${C_DNS_PROVIDER_NAME}" == "digitalocean" ]
    then
      msg "External DNS provider for domain ${domain} is set to digitalocean [Using digitalocean API ...]"
      #Call digitalocean_api_admin
    #elif other provider
    elif [ "${C_DNS_PROVIDER_NAME}" == "local" ]; then
      msg "External DNS provider for domain ${domain} is set to local"
    # Do nothing because it's local DNS managed by Directadmin or using bind
    fi
  else
    msg "$(s yellow)[Skipped]: Warning skipped copying local DNS into external DNS because C_AUTO_CREATE_EXTERNAL_DNS_RECORD is not set to true$(e)" --caller="${SCRIPT_NAME}"
    echo ""
  fi
}

digitalocean_api_admin() {
  :
}

amazonaws_api_admin() {
  :
}

# da_api_admin <action> <action-option-arguments>
# For curl do not use --max-time or decrease time out because letsencrypt API will need more time to request cert
da_api_admin() {
  local action argnum short_opts long_opts options retval sign_as username password \
    ip_address netmask \
    email name nameserver1 nameserver2 where_username_is \
    package_name \
    domain subdomain ip_type \
    record_type record_name record_value record_domain record_priority record_subdomain record_ttl affect_pointers \
    special_type \
    skin_name logo_mode logo_file \
    answer question \
    text_output recommend_values \
    mail_domain mail_user mail_password mail_quota mail_limit \
    db_domain db_name db_user db_password db_existing_user \
    ssl_provider ssl_root_domain ssl_subdomains_query \
    backup_ip backup_path backup_file_name backup_password \
    php_version \
    api_username api_password \
    scripting
  action="$1"
  argnum="$#"

  #echo "${action}"
  short_opts="h"

  long_opts="help,sign-as:,username:,password:,ip-address:,netmask:,email:,name:,nameserver1:,nameserver2:,where-username-is:,text-output:,package-name:, \
  mail-domain:,mail-user:,mail-password:, mail-quota:, mail-limit:, db-domain:, db-name:, db-user:, db-password:, db-existing-user:,\
  recommend-values,domain:,hostname:,subdomain:,ip-type:, record-type:, record-name:, record-value:, record-domain:, record-priority:, record-subdomain:, record-ttl:, affect-pointers:, special-type:, skin-name:, \
  backup-ip:,backup-path:,backup-file-name:,backup-password:,php-version:,logo-mode:,logo-file:,question:,answer:,api-username:,api-password:,scripting"
  options=$(getopt -o "${short_opts}" --long "${long_opts}" -n "${FUNCNAME[0]}@${action} in ${SCRIPT_NAME}" -- "$@")
  retval=$?
  if [ ${retval} != 0 ]; then
    msg "$(s red)Error, invalid parsed data. Terminating...$(e)" >&2
    exit 1
  fi

  eval set -- "${options}"
  sign_as="owner1"     # specify by role such as: owner1, admin1, reseller1, user1 OR specify by username such as: arafatx, maxi32. Default is owner1 (the first owner).
  username=""          # arafatx
  password=""          # 1234x
  ip_address=""        # Can be ipv4 or ipv6 address
  netmask=""           # eg: 255.255.255.0 or /24, /64
  email=""             # arafat@test.com
  name=""              # Arafat Ali
  nameserver1=""       # ns1.test.com
  nameserver2=""       # ns2.test.com
  where_username_is="" # admin
  text_output=""       # post
  mail_domain=""       # sofibox.com
  mail_user=""         # webmaster
  mail_password=""     # 12321
  mail_quota=""        # 0
  mail_limit=""        # 200
  db_domain=""         # abc.com
  db_name=""           # abc
  db_user=""           # dbuser123
  db_password=""       # 12321aa
  db_existing_user=""  # dbuser123
  package_name=""      # UNLIMITED_PACKAGE
  recommend_values=false
  domain=""               # sofibox.com
  hostname=""             # sun.sofibox.com
  subdomain=""            # abc (don not specify full domain)
  ip_type=""              # shared, server etc
  api_username=""         # arafatx
  api_password=""         # 1234x
  record_type=""          # txt,a,aaaa etc
  record_name=""          # _domainkey
  record_value=""         # value
  record_domain=""        # abc.com
  record_priority=""      # 10
  record_subdomain=""     # change
  record_ttl=""           # 36000
  affect_pointers=""      #yes or no
  special_type=""         # dkim, dmarc, spf, dkim-policy
  skin_name=""            # evolution, enhanced etc
  logo_mode=""            # default-logo, dark-logo, favicon
  logo_file=""            # /tmp/logo.png
  question=""             # Kau dah lama hidup?
  answer=""               # Belum
  ssl_provider=""         # letsencrypt, amazonaws, digitalocean
  ssl_root_domain=""      # test.com
  ssl_subdomains_query="" # the subdomain query in directadmin
  scripting=false
  backup_ip=""        # 1.2.3.4
  backup_path=""      # /root/backup_admin/
  backup_file_name="" # backup.tar.gz
  backup_password=""  # abc123
  php_version=""
  while true; do
    case "$1" in
    -h | --help)
      manual "${FUNCNAME[0]}"
      shift
      exit 0
      ;;
    --sign-as)
      sign_as="$2"
      shift 2
      ;;
    --username)
      username="$2"
      shift 2
      ;;
    --password)
      password="$2"
      shift 2
      ;;
    --ip-address)
      ip_address="$2"
      shift 2
      ;;
    --netmask)
      netmask="$2"
      shift 2
      ;;
    --email)
      email="$2"
      shift 2
      ;;
    --name)
      name="$2"
      shift 2
      ;;
    --nameserver1)
      nameserver1="$2"
      shift 2
      ;;
    --nameserver2)
      nameserver2="$2"
      shift 2
      ;;
    --where-username-is)
      where_username_is="$2"
      shift 2
      ;;
    --text-output)
      text_output="$2"
      shift 2
      ;;
    --mail-domain)
      mail_domain="$2"
      shift 2
      ;;
    --mail-user)
      mail_user="$2"
      shift 2
      ;;
    --mail-password)
      mail_password="$2"
      shift 2
      ;;
    --mail-quota)
      mail_quota="$2"
      shift 2
      ;;
    --mail-limit)
      mail_limit="$2"
      shift 2
      ;;
    --db-domain)
      db_domain="$2"
      shift 2
      ;;
    --db-name)
      db_name="$2"
      shift 2
      ;;
    --db-user)
      db_user="$2"
      shift 2
      ;;
    --db-password)
      db_password="$2"
      shift 2
      ;;
    --db-existing-user)
      db_existing_user="$2"
      shift 2
      ;;
    --package-name)
      package_name="$2"
      shift 2
      ;;
    --recommend-values)
      recommend_values=true
      shift
      ;;
    --domain)
      domain="$2"
      shift 2
      ;;
    --hostname)
      hostname="$2"
      shift 2
      ;;
    --subdomain)
      subdomain="$2"
      shift 2
      ;;
    --ip-type)
      ip_type="$2"
      shift 2
      ;;
    --record-type)
      record_type="$2"
      shift 2
      ;;
    --record-name)
      record_name="$2"
      shift 2
      ;;
    --record-value)
      record_value="$2"
      shift 2
      ;;
    --record-ttl)
      record_ttl="$2"
      shift 2
      ;;
    --record-domain)
      record_domain="$2"
      shift 2
      ;;
    --record-priority)
      record_priority="$2"
      shift 2
      ;;
    --record-subdomain)
      record_subdomain="$2"
      shift 2
      ;;
    --affect-pointers)
      affect_pointers="$2"
      shift 2
      ;;
    --special-type)
      special_type="$2"
      shift 2
      ;;
    --skin-name)
      skin_name="$2"
      shift 2
      ;;
    --logo-mode)
      logo_mode="$2"
      shift 2
      ;;
    --logo-file)
      logo_file="$2"
      shift 2
      ;;
    --question)
      question="$2"
      shift 2
      ;;
    --answer)
      answer="$2"
      shift 2
      ;;
    # This is not used but for reference, api_username will be automatically
    --api-username)
      # API use --sign-as, --signas
      api_username="$2"
      shift 2
      ;;
    --api-password)
      api_password="$2"
      shift 2
      ;;
    --scripting)
      scripting=true
      shift
      ;;
    --ssl-provider)
      ssl_provider="$2"
      shift 2
      ;;
    --ssl-root-domain)
      ssl_root_domain="$2"
      shift 2
      ;;
    --ssl-subdomains-query)
      ssl_subdomains_query="$2"
      shift 2
      ;;
    --backup-ip)
      backup_ip="$2"
      shift 2
      ;;
    --backup-path)
      backup_path="$2"
      shift 2
      ;;
    --backup-file-name)
      backup_file_name="$2"
      shift 2
      ;;
    --backup-password)
      backup_password="$2"
      shift 2
      ;;
    --php-version)
      php_version="$2"
      shift 2
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
    esac
  done

  maxibuild --include "jq"

  # da_api_admin debug --text-output "test"
  if [[ "${action}" == "debug" ]]; then
    local da_bin
    da_bin="/usr/local/directadmin/directadmin"
    if [[ -f "${da_bin}" ]]; then
      :
    else
      msg "$(s red)Error, directadmin binary does not exist!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi
    # This trap function is used to restore directadmin service back to normal once this debugging status is terminated
    traps da_debug_exit INT
    killall -9 directadmin
    if [ -n "${text_output}" ]; then
      echo ""
      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
      echo "                            **STARTING DIRECTADMIN DEBUG MODE**                       "
      echo ""
      echo "Running directadmin debug mode with filtered output ..."
      echo "FILTERED OUTPUT:"
      echo "${text_output}"
      echo ""
      echo "Press CTRL+C to exit debug mode"
      echo ""
      ${da_bin} b2000 | grep "${text_output}"
    else
      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
      echo "                            **STARTING DIRECTADMIN DEBUG MODE**                       "
      echo ""
      echo "Running directadmin debug mode with full output ..."
      echo ""
      echo "Press CTRL+C to exit debug mode"
      echo ""
      ${da_bin} b2000
    fi

    _exit 0
  fi

  local da_api_username da_api_password admin_original_auth_file
  local user_list_path da_user

  #local owner_main_auth admin_main_auth reseller_main_auth user_main_auth user_extra_auth
  local ssl_protocol port

  # This folder contains list of directadmin users as folder name
  user_list_path="/usr/local/directadmin/data/users/"
  admin_original_auth_file="/usr/local/directadmin/scripts/setup.txt"

  port="$(cat /usr/local/directadmin/conf/directadmin.conf | grep '^port=' | cut -d= -f2)"

  if [ -z "${port}" ]; then
    [[ "${scripting}" == "false" ]] && msg "$(s red)Error, directadmin.conf should contain port option!$(e)" --caller="${SCRIPT_NAME}"
    # or set default
    # port=2222
    exit 1
  fi

  if [ "${C_DA_AUTO_SELECT_API_PROTOCOL}" == "true" ]; then
    if is_valid ssl_site "${C_BOX_HOSTNAME_FQHN}"; then
      [[ "${scripting}" == "false" ]] && msg "OK, ${C_BOX_HOSTNAME_FQHN} is a valid SSL/https site"
      ssl_protocol="https"
    else
      [[ "${scripting}" == "false" ]] && msg "$(s yellow)Warning, using unsecured connection for directadmin API because ${C_BOX_HOSTNAME_FQHN} is currently not a valid SSL/https site$(e)" --caller="${SCRIPT_NAME}"
      ssl_protocol="http"
    fi
  else
    [[ "${scripting}" == "false" ]] && msg "$(s yellow)Warning, using unsecured connection for directadmin API because ${C_BOX_HOSTNAME_FQHN} is currently not a valid SSL/https site$(e)" --caller="${SCRIPT_NAME}"
    ssl_protocol="http"
  fi

  # TODO this one contains sensitive information, hide later or suggesting to use  --verbose less than 7
  if [[ "${scripting}" == "false" ]]; then
    msg "$(s newline)"
    msg "API_DETAILS:" --caller="${SCRIPT_NAME}"
    msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"
    msg "ALL ARGS: $*" --caller="${SCRIPT_NAME}"
    msg "ACTION: ${action}" --caller="${SCRIPT_NAME}"
    msg "SIGN_AS or EXECUTE_AS: ${sign_as}" --caller="${SCRIPT_NAME}"
    msg "$(s newline)"
  fi

  if [ "${C_DA_LOGIN_METHOD}" == "sign-as" ]; then

    if [ "${sign_as}" == "owner1" ]; then
      sign_as="${C_DA_OWNER_USERNAME1}"
    elif [ "${sign_as}" == "admin1" ]; then
      sign_as="${C_DA_ADMIN_USERNAME1}"
    elif [ "${sign_as}" == "reseller1" ]; then
      sign_as="${C_DA_RESELLER_USERNAME1}"
    elif [ "${sign_as}" == "user1" ]; then
      sign_as="${C_DA_USER_USERNAME1}"
    fi

    if [[ -n "${api_username}" && -z "${api_password}" ]]; then
      msg "$(s red)Error need option --api-password when supplying option --api-username or use --sign-as instead for automatic authentication!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    elif [[ -n "${api_password}" && -z "${api_username}" ]]; then
      msg "$(s red)Error need option --api-username when supplying option --api-password or use --sign-as instead for automatic authentication!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    da_user="$(basename "$(find ${user_list_path} -name "${sign_as}" -type d | tail -n 1)")"

    if [[ -n "${api_username}" && -n "${api_password}" ]]; then
      da_user="$(basename "$(find ${user_list_path} -name "${api_username}" -type d | tail -n 1)")"
      if [[ -n "${da_user}" ]]; then
        da_api_username="${api_username}"
        da_api_password="${api_password}"
        [[ "${scripting}" == "false" ]] && msg "DA_API_USERNAME: ${da_api_username}" --caller="${SCRIPT_NAME}"
      else
        msg "$(s red)Error, user ${api_username} does not exist in directadmin system!$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi
    # if sign_as == the first owner username and it exist in system use that first owner
    elif [[ "${sign_as}" == "${C_DA_OWNER_USERNAME1}" && -n "${da_user}" ]]; then
      da_api_username="${C_DA_OWNER_USERNAME1}"
      da_api_password="${C_DA_OWNER_USERPASS1}"
      [[ "${scripting}" == "false" ]] && msg "DA_API_USERNAME: ${da_api_username}" --caller="${SCRIPT_NAME}"
    else # For other users other than owner but it must exist in the system
      if [[ -n "${da_user}" ]]; then
        da_api_username="${C_DA_OWNER_USERNAME1}|${da_user}"
        da_api_password="${C_DA_OWNER_USERPASS1}"
        [[ "${scripting}" == "false" ]] && msg "DA_API_USERNAME: ${da_api_username} (Login-as)" --caller="${SCRIPT_NAME}"
      else # If it does not exist in the system, we use default admin
        # If the above authentication does not exist, we try to use old admin from setup.txt (first check if old admin exist)
        da_user="$(basename "$(find ${user_list_path} -name "admin" -type d | tail -n 1)")"
        if [[ -n "${da_user}" ]]; then
          da_api_username=$(grep "^adminname" "${admin_original_auth_file}" | cut -d= -f2)
          da_api_password=$(grep "^adminpass" "${admin_original_auth_file}" | cut -d= -f2)
          [[ "${scripting}" == "false" ]] && msg "DA_API_USERNAME: ${da_api_username} (from original admin setup.txt)" --caller="${SCRIPT_NAME}"
        else
          msg "$(s red)Error, user ${sign_as} does not exist in directadmin system!$(e)" --caller="${SCRIPT_NAME}"
          exit 1
        fi
      fi
    fi
  else
    msg "$(s red)Error, directadmin login method [ ${C_DA_LOGIN_METHOD} ] is not recognized$(e)" --caller="${SCRIPT_NAME}"
    exit 1
  fi

  [[ "${scripting}" == "false" ]] && msg "DA_API_PASSWORD: ${da_api_password}" --caller="${SCRIPT_NAME}"
  [[ "${scripting}" == "false" ]] && msg "API PROTOCOL SELECTED: ${ssl_protocol}" --caller="${SCRIPT_NAME}"
  [[ "${scripting}" == "false" ]] && msg "API PORT SELECTED: ${port}" --caller="${SCRIPT_NAME}"
  [[ "${scripting}" == "false" ]] && msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"
  [[ "${scripting}" == "false" ]] && msg "$(s newline)"

  if [[ "${action}" == "get-user-package" ]]; then
    local cmd_api data method da_api_exec has_success
    cmd_api="CMD_API_PACKAGES_USER"
    data="package=${package_name}"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi

  # da_api_admin test-login --username username_to_check
  # it will return exist=1 if found or exist=0 if not found
  elif [[ "${action}" == "test-login" || "${action}" == "login" ]]; then
    local cmd_api data method retval da_api_exec has_success
    cmd_api="CMD_API_USER_EXISTS"
    data="user=${username}"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi
    # eg: for ipv4 -> maxinet --da-api add-ip --sign-as owner1 --ip-address 1.1.1.1 --netmask 255.255.255.0
  # eg: for ipv6 -> maxinet --da-api add-ip --ip-address 2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b --netmask /64 for ipv4 -> maxinet --da-api add-ip --sign-as owner1 --ip-address 1.1.1.1 --netmask 255.255.255.0
  # eg: for ipv6 -> maxinet --da-api add-ip --ip-address 2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b --netmask /64
  elif [[ "${action}" == "add-ip" ]]; then
    local cmd_api data method retval da_api_exec has_success
    if is_valid ipv6 "${ip_address}"; then
      #echo "${netmask}" | grep -qE "(^(\/)((?:[0-9])|(?:[0-9][0-9][0-9])|(?:3[0-2])))$"
      # Remember for IPv6, netmask must be using subnet prefix notation. This will check that:
      #/1 - /64
      if ! is_valid ipv6_prefix "${netmask}"; then
        msg "$(s red)Error, IPv6 address requires netmask in subnet prefix notation. eg: /0 - /128$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi
    fi

    #echo "Adding IP"
    #echo "Sign as: ${sign_as}"
    #echo "API username: ${da_api_username}"
    #echo "API password: ${da_api_password}"
    #echo "IP address is: ${ip_address}"
    #echo "Netmask is: ${netmask_ip}"
    # API configs
    cmd_api="CMD_API_IP_MANAGER"
    # the add_to_device_aware is needed if want to use device=yes or device=no (https://www.directadmin.com/features.php?id=2080)
    data="action=add&ip=${ip_address}&netmask=${netmask}&device=yes&add_to_device_aware=yes"
    method="POST"
    # API call
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi
    # This is deprecated (as the real API has not released yet for CMD_API_ADMIN_SETTINGS)
    #da_api_admin set-da-admin-settings --recommend-values
  elif [[ "${action}" == "set-da-admin-settings" ]]; then
    # Big NOTE! directadmin does not have CMD_API_ADMIN_SETTINGS
    local cmd_api data method retval da_api_exec has_success has_cmd_api
    has_cmd_api="false"
    msg "$(s yellow)Note, directadmin does not have CMD_API_ADMIN_SETTINGS for this call (https://forum.directadmin.com/threads/api-set-server-hostname.37872/post-188426). Using CMD_ADMIN_SETTINGS ...$(e)" --caller="${SCRIPT_NAME}"
    #error=1&text=You%20cannot%20execute%20that%20command&details=The%20request%20you%27ve%20made%20cannot%20be%20executed%20because%20it%20does%20not%20exist%20in%20your%20authority%20level
    # Note this CMD_API_ADMIN_SETTINGS have not been released. So, we need to use json and ignore error checking
    # If the API is released, just put has_cmd_api=true, this will automatically use the new API
    method="POST"
    # This API includes security settings and email settings (DA combined this)
    if [ "${has_cmd_api}" == "false" ]; then
      cmd_api="CMD_ADMIN_SETTINGS"
      if [ "${recommend_values}" == "true" ]; then
        # TODO: Note the auto_update=yes here might be part of custombuild setting (check that)
        # Remember to use json=yes, if not no output or weird output because API has not released
        data="auto_update=yes&backup_threshold=90&demo_admin=no&demo_reseller=no&demo_user=no&oversell=yes&service_email_active=yes&suspend=yes&user_backup=yes&action=save&json=yes"
      else
        msg "$(s red)Error, please temporarily use the option --recommend-values for this action ${action} $(e)" --caller="${SCRIPT_NAME}"
        # Add single values here
        exit 1
      fi
      curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}"
    else # If API released true
      cmd_api="CMD_API_ADMIN_SETTINGS"
      if [ "${recommend_values}" == "true" ]; then
        data="auto_update=yes&backup_threshold=90&demo_admin=no&demo_reseller=no&demo_user=no&oversell=yes&service_email_active=yes&suspend=yes&user_backup=yes&action=save"
      else
        msg "$(s red)Error, please temporarily use the option --recommend-values for this action ${action} $(e)" --caller="${SCRIPT_NAME}"
        # Add single values here
        exit 1
      fi

      da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
      has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

      if [ -z "${has_success}" ]; then
        msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
        msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
      #exit 1
      else
        msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
        msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
      fi
    fi
  elif [[ "${action}" == "set-da-server-settings" ]]; then
    local cmd_api data method retval da_api_exec has_success has_cmd_api
    has_cmd_api=false
    cmd_api="CMD_ADMIN_SETTINGS"
    msg "$(s yellow)Note, directadmin does not have CMD_API_ADMIN_SETTINGS for this call (https://forum.directadmin.com/threads/api-set-server-hostname.37872/post-188426). Using CMD_ADMIN_SETTINGS ...$(e)" --caller="${SCRIPT_NAME}"

    if [ "${recommend_values}" == "true" ]; then
      # Recommend values
      # Remember to use json=yes, if not no output or weird output because API has not released
      #data="per_email_limit=200&rbl_enabled=yes&session_minutes=${C_DA_SESSION_MINUTES}&virtual_limit=1000&action=config&json=yes"
      # Important the parameter maxfilesize, servername, ns1, ns2, timeout are needed, without them this API will fail. The rest parameter are not included in directadmin.conf
      if [ "${C_DA_RBL_ENABLED}" == "1" ]; then
        C_DA_RBL_ENABLED="yes"
      else
        C_DA_RBL_ENABLED="no"
      fi
      data="maxfilesize=${C_DA_MAXFILESIZE}&servername=${C_BOX_HOSTNAME_FQHN}&ns1=${C_BOX_NS1}&ns2=${C_BOX_NS2} \
      &per_email_limit=${C_DA_PER_EMAIL_LIMIT}&rbl_enabled=${C_DA_RBL_ENABLED}&timeout=${C_DA_TIMEOUT}&virtual_limit=${C_DA_VIRTUAL_LIMIT}&json=yes&action=config"

    else
      msg "$(s red)Error, please temporarily use the option --recommend-values for this action ${action} $(e)" --caller="${SCRIPT_NAME}"
      # Add single values here
      exit 1
    fi
    method="POST"
    if [ "${has_cmd_api}" == "false" ]; then
      curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}"
    else
      da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
      has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
      if [ -z "${has_success}" ]; then
        msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
        msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
      #exit 1
      else
        msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
        msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
      fi
    fi
    # da_api_admin modify-user --sign-as owner1 --where-username-is admin --email abc@dsaa.com --name Arafat Ali --nameserver1 ns1.test.com --nameserver2 ns2.test.com
  elif [[ "${action}" == "modify-user" || "${action}" == "change-user" || "${action}" == "update-user" ]]; then
    local cmd_api method retval da_api_exec has_success data data1 data2 data3 data4
    cmd_api="CMD_API_MODIFY_USER"
    method="POST"
    # If email option is provided, we check the email
    if [ -n "${email}" ]; then
      if is_valid "email" "${domain_email}"; then
        [[ ${scripting} == "false" ]] && msg "$(s green)OK, the given --email $(s red)${email}$(s green) is valid$(e)" --caller="${SCRIPT_NAME}"
      else
        msg "$(s yellow)Warning, the given --email $(s red)${email}$(s green) is not valid$(e)" --caller="${SCRIPT_NAME}"
        return 147
      fi
      data1="user=${where_username_is}&evalue=${email}&action=single&email=yes"
    fi

    if [ -n "${name}" ]; then
      data2="user=${where_username_is}&nvalue=${name}&action=single&name=yes"
    fi

    if [ -n "${nameserver1}" ]; then
      data3="user=${where_username_is}&ns1=${nameserver1}&action=single&ns=yes"
    fi

    if [ -n "${nameserver2}" ]; then
      data4="user=${where_username_is}&ns2=${nameserver2}&action=single&ns=yes"
    fi

    for data in "${data1}" "${data2}" "${data3}" "${data4}"; do

      #echo "data-------------------------: ${data}"
      if [ -n "${data}" ]; then
        da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
        has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

        if [ -z "${has_success}" ]; then
          msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
          msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
        #exit 1
        else
          msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
          msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
        fi
      fi
    done
    # da_api_admin create-admin-account --username admin2 --email admin2@test.com --password abc12321
  elif [ "${action}" == "create-admin-account" ]; then
    local cmd_api data method retval da_api_exec has_success
    cmd_api="CMD_API_ACCOUNT_ADMIN"
    data="action=create&add=submit&username=${username}&email=${email}&passwd=${password}&passwd2=${password}&notify=no"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi
  # da_api_admin create-reseller-account --sign-as admin1 --username reseller2 --email reseller2@test.com --password abc1231aa --domain test.com --package-name "RESELLER_UNLIMITED" --ip-type "shared"
  elif [ "${action}" == "create-reseller-account" ]; then
    local cmd_api data method retval da_api_exec has_success
    cmd_api="CMD_API_ACCOUNT_RESELLER" # CMD_ACCOUNT_RESELLER is not working
    data="username=${username}&email=${email}&passwd=${password}&passwd2=${password}&domain=${domain}&package=${package_name}&notify=no&ip=${ip_type}&action=create&add=yes"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi
  # da_api_admin create-reseller-package --package-name "RESELLER_UNLIMITED" --recommend-values
  elif [ "${action}" == "create-reseller-package" ]; then
    local cmd_api data method retval da_api_exec has_success
    cmd_api="CMD_API_MANAGE_RESELLER_PACKAGES"
    if [ "${recommend_values}" == "true" ]; then
      # This is unlimited RESELLER package recommend values:
      data="bandwidth=5000&ubandwidth=yes&quota=1000&uquota=yes&inode=&uinode=yes&vdomains=10&uvdomains=yes&nsubdomains=10 \
    &unsubdomains=yes&nemails=100&unemails=yes&nemailf=100&unemailf=yes&nemailml=10&unemailml=yes&nemailr=100&unemailr=yes \
    &mysql=0&umysql=yes&domainptr=0&udomainptr=yes&ftp=10&uftp=yes&cgi=ON&php=ON&spam=ON&catchall=ON&ssl=ON&oversell=ON&cron=ON \
    &sysinfo=ON&login_keys=ON&dnscontrol=ON&dns=OFF&serverip=ON&packagename=${package_name}&nusers=&unusers=yes&add=save&ips=0"
    else
      msg "$(s red)Error, please temporarily use the option --recommend-values for this action ${action} $(e)" --caller="${SCRIPT_NAME}"
      # Add single values here
      exit 1
    fi
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")

    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi
    # da_api_admin create-user-package --package-name "USER_UNLIMITED" --recommend-values
  elif [ "${action}" == "create-user-package" ]; then
    local cmd_api data method retval da_api_exec has_success
    cmd_api="CMD_API_MANAGE_USER_PACKAGES"
    if [ "${recommend_values}" == "true" ]; then
      # This is unlimited USER package recommend values: (this API has changed because of new feature)
      data="bandwidth=1000&ubandwidth=yes&quota=100&uquota=yes&inode=&uinode=yes&vdomains=1&uvdomains=yes&nsubdomains=10 \
    &unsubdomains=yes&nemails=10&unemails=yes&unemailf=yes&nemailml=0&unemailml=yes&nemailr=10&unemailr=yes \
    &mysql=5&umysql=yes&domainptr=0&udomainptr=yes&ftp=1&uftp=yes&php=ON&spam=ON&catchall=ON&ssl=ON&cron=ON \
    &sysinfo=ON&login_keys=ON&dnscontrol=ON&suspend_at_limit=ON&language=en&skin=evolution&packagename=${package_name}&add=save"
    else
      msg "$(s red)Error, please temporarily use the option --recommend-values for this action ${action} $(e)" --caller="${SCRIPT_NAME}"
      # Add single values here
      exit 1
    fi
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi

  elif [[ "${action}" == "enable-domain-dkim" || "${action}" == "enable-email-dkim" ]]; then
    local cmd_api data method retval da_api_exec has_success
    cmd_api="CMD_API_EMAIL_POP"
    data="action=set_dkim&domain=${domain}&enable=yes"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi
    # da_api_admin create-admin-dns-record--domain test.com --record-type TXT --record-name name11 --record-value value1 --record-ttl 30 --affect-pointers yes
  elif [[ "${action}" == "create-admin-dns-record" || "${action}" == "add-admin-dns-record" ]]; then
    local cmd_api data method retval da_api_exec has_success record_value
    cmd_api="CMD_API_DNS_ADMIN"
    # TODO inspect what the affect_pointers do, if important, we put another option --affect-pointers
    affect_pointers=yes
    data="domain=${domain}&type=${record_type}&name=${record_name}&value=${record_value}&ttl=${record_ttl}&affect_pointers=${affect_pointers}&action=add"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi
    # Other DNS record:
    # da_api_admin create-dns-record --domain test.com --record-type TXT --record-name name11 --record-value value1 --record-ttl 30 --affect-pointers yes
    # MX RECORD:
  elif [[ "${action}" == "create-dns-record" || "${action}" == "add-dns-record" ]]; then
    local cmd_api data method retval da_api_exec has_success record_value
    cmd_api="CMD_API_DNS_CONTROL"
    # TODO inspect what the affect_pointers do, if important, we put another option --affect-pointers
    affect_pointers=yes
    if [[ "${record_type^^}" == "MX" ]]; then
      # for mx record, record name is the domain, record value is priority, record subdomain is mx_value
      data="domain=${domain}&type=${record_type}&name=${record_domain}&value=${record_priority}&mx_value=${record_subdomain}&ttl=${record_ttl}&affect_pointers=${affect_pointers}&action=add"
    else
      data="domain=${domain}&type=${record_type}&name=${record_name}&value=${record_value}&ttl=${record_ttl}&affect_pointers=${affect_pointers}&action=add"
    fi
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi
    # da_api_admin get-dns-special-record-type-value --where-domain-name-is test.com --special-type 'dkim'
    # special-type dkim, dkim-policy, spf, dmarc
    # This can return many records, to return only one record use with this | tail -n 1
  elif [ "${action}" == "get-dns-special-record-type-value" ]; then
    local cmd_api data method has_record
    cmd_api="CMD_API_DNS_CONTROL"
    data="domain=${domain}&json=yes"
    method="POST"

    if [ "${special_type}" == "dkim" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select((.type==\"TXT\") and (.name==\"x._domainkey\") and (.value | contains(\"v=DKIM1\"))) \
        | .value" |
        sed -e 's/^"//' -e 's/"$//')
    elif [ "${special_type}" == "dkim-policy" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select((.type==\"TXT\") and (.name==\"_domainkey\") and (.value | contains(\"o=\"))) \
        | .value" |
        sed -e 's/^"//' -e 's/"$//')
    elif [ "${special_type}" == "spf" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select((.type==\"TXT\") and (.name==\"${domain}.\") and (.value | contains(\"v=spf1\"))) \
        | .value" |
        sed -e 's/^"//' -e 's/"$//')
    elif [ "${special_type}" == "dmarc" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select((.type==\"TXT\") and (.name==\"_dmarc\") and (.value | contains(\"v=DMARC1\"))) \
        | .value" |
        sed -e 's/^"//' -e 's/"$//')
    fi

    if [ -z "${has_record}" ]; then
      msg "$(s red)Warning, no record found for the dns special record ${special_type} $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${has_record}$(e)" | urldecode | awksep '&'
      exit 1
    else
      echo "${has_record}"
      return 0
    fi

  elif [[ "${action}" == "get-dns-zone" || "${action}" == "get-dns-records" ]]; then
    local cmd_api data method da_api_exec has_success
    cmd_api="CMD_API_DNS_ADMIN"
    # Need to pass full_max_records to display full list of mx records
    data="domain=${domain}&json=yes&full_mx_records=yes"
    method="POST"

    if [ "${special_type^^}" == "A" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select(.type==\"A\")")
    elif [ "${special_type^^}" == "AAAA" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select(.type==\"AAAA\")")
    elif [ "${special_type^^}" == "CNAME" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select(.type==\"CNAME\")")
      # This wil list all TXT record
    elif [ "${special_type^^}" == "TXT" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select(.type==\"TXT\")")
    elif [ "${special_type^^}" == "NS" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select(.type==\"NS\")")
    elif [ "${special_type^^}" == "MX" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select(.type==\"MX\")")
    elif [ "${special_type^^}" == "SRV" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select(.type==\"SRV\")")
    elif [ "${special_type^^}" == "CAA" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select(.type==\"CAA\")")
    elif [ "${special_type^^}" == "PTR" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select(.type==\"PTR\")")
    fi

    if [ -z "${has_record}" ]; then
      [[ "${scripting}" == "false" ]] && msg "$(s red)Warning, no record found for the dns special record ${special_type} $(e)" --caller="${SCRIPT_NAME}"
      return 147
    else
      echo "${has_record}"
      return 0
    fi

  # da_api_admin create-domain --domain test.com --recommend-values
  elif [ "${action}" == "create-domain" ]; then
    local cmd_api data method da_api_exec has_success
    cmd_api="CMD_API_DOMAIN"
    if [ "${recommend_values}" == "true" ]; then
      data="domain=${domain}&uquota=unlimited&ssl=ON&php=ON&action=create&ubandwidth=unlimited"
    else
      msg "$(s red)Error, please temporarily use the option --recommend-values for this action ${action} $(e)" --caller="${SCRIPT_NAME}"
      # Add single values here
      exit 1
    fi
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi
    # da_api_admin set-da-skin-settings --skin-name="evolution"
  elif [[ "${action}" == "set-da-skin-settings" || "${action}" == "set-da-skin-setting" ]]; then
    local cmd_api data method retval da_api_exec has_success
    cmd_api="CMD_API_SKINS"
    #config will be stored in: username/skin_customizations/evolution/config.json
    db_route_name=$(echo "${C_PHPMYADMIN_LOGIN_ROUTE}" | sed 's/^\///')
    rc_route_name=$(echo "${C_ROUNDCUBE_LOGIN_ROUTE}" | sed 's/^\///')
    # This value I got from da-debug, removed the json=yes inside that json, validate that json file online, then add extra json=yes&name=evolution&action=save_config_json&config.json=
    if [ "${recommend_values}" == "true" ]; then
      # TODO shorten this long json
      if [ "${skin_name}" == "evolution" ]; then
        data="name=${skin_name}&action=save_config_json&config.json=%7B%22menu%22%3A%7B%22user%22%3A%5B%7B%22name%22%3A%22Account%20Manager%22%2C%22icon%22%3A%22account-manager%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Fuser%2Fdomains%22%2C%22name%22%3A%22Domain%20Setup%22%2C%22icon%22%3A%22domain-setup%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fsubdomains%22%2C%22name%22%3A%22Subdomain%20Management%22%2C%22icon%22%3A%22subdomain-management%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fdns%22%2C%22name%22%3A%22DNS%20Management%22%2C%22icon%22%3A%22dns-management%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fssl%22%2C%22name%22%3A%22SSL%20Certificates%22%2C%22icon%22%3A%22ssl%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fftp-accounts%22%2C%22name%22%3A%22FTP%20Management%22%2C%22icon%22%3A%22ftp-management%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fdatabase%22%2C%22name%22%3A%22MySQL%20Management%22%2C%22icon%22%3A%22mysql-management%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fdomain-pointers%22%2C%22name%22%3A%22Domain%20Pointers%22%2C%22icon%22%3A%22domain-pointers%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fredirects%22%2C%22name%22%3A%22Site%20Redirection%22%2C%22icon%22%3A%22site-redirection%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fhotlinks%22%2C%22name%22%3A%22Hotlinks%20Protection%22%2C%22icon%22%3A%22hotlinks%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fphp-settings%22%2C%22name%22%3A%22PHP%20Settings%22%2C%22icon%22%3A%22php-configuration%22%2C%22enabled%22%3Atrue%7D%5D%7D%2C%7B%22name%22%3A%22E-mail%20Manager%22%2C%22icon%22%3A%22email-manager%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Fuser%2Femail%2Faccounts%22%2C%22name%22%3A%22E-mail%20Accounts%22%2C%22icon%22%3A%22email-accounts%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Fforwarders%22%2C%22name%22%3A%22Forwarders%22%2C%22icon%22%3A%22forwarders%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Fautoresponders%22%2C%22name%22%3A%22Autoresponders%22%2C%22icon%22%3A%22autoresponders%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Fvacations%22%2C%22name%22%3A%22Vacation%20Messages%22%2C%22icon%22%3A%22vacation-messages%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Fspamassassin%22%2C%22name%22%3A%22Spamassassin%20Setup%22%2C%22icon%22%3A%22spamassassin%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Ffilters%22%2C%22name%22%3A%22SPAM%20Filters%22%2C%22icon%22%3A%22spam-filters%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Flists%22%2C%22name%22%3A%22Mailing%20Lists%22%2C%22icon%22%3A%22mailing-lists%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fdns%2Fmx-records%22%2C%22name%22%3A%22MX%20Records%22%2C%22icon%22%3A%22mx-records%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Ftracking%22%2C%22name%22%3A%22E-mail%20Tracking%22%2C%22icon%22%3A%22email-tracking%22%2C%22enabled%22%3Atrue%7D%5D%7D%2C%7B%22icon%22%3A%22advanced-features%22%2C%22name%22%3A%22Advanced%20Features%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Fuser%2Fhandlers%22%2C%22name%22%3A%22Apache%20Handlers%22%2C%22icon%22%3A%22apache-handlers%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Fcatch-all%22%2C%22name%22%3A%22Catch-All%20E-mail%22%2C%22icon%22%3A%22catch-all-email%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fbackup%22%2C%22name%22%3A%22Create%2FRestore%20Backups%22%2C%22icon%22%3A%22create-restore-backup%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fcronjobs%22%2C%22name%22%3A%22Cron%20Jobs%22%2C%22icon%22%3A%22cron-jobs%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Ferror-pages%22%2C%22name%22%3A%22Custom%20Error%20Pages%22%2C%22icon%22%3A%22custom-error-pages%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fmimetypes%22%2C%22name%22%3A%22Mime%20Types%22%2C%22icon%22%3A%22mime-types%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fsecurity-questions%22%2C%22name%22%3A%22Security%20Questions%22%2C%22icon%22%3A%22security-questions%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Ftwo-step-auth%22%2C%22name%22%3A%22Two-Step%20Authentication%22%2C%22icon%22%3A%22two-step-auth%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fprotected-directories%22%2C%22name%22%3A%22Password%20Protected%20Directories%22%2C%22icon%22%3A%22password-protected-directories%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fssh-keys%22%2C%22name%22%3A%22SSH%20Keys%22%2C%22icon%22%3A%22ssh-keys%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fmodsecurity%22%2C%22name%22%3A%22ModSecurity%22%2C%22icon%22%3A%22mod-security%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Funit%22%2C%22name%22%3A%22Nginx%20Unit%22%2C%22icon%22%3A%22nginx-unit%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fnginx-templates%22%2C%22name%22%3A%22Nginx%20URL%20Rewrites%22%2C%22icon%22%3A%22nginx-templates%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fredis%22%2C%22name%22%3A%22Redis%22%2C%22icon%22%3A%22redis%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fgit%22%2C%22name%22%3A%22Git%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22resource-limits%22%7D%5D%7D%2C%7B%22icon%22%3A%22system-information%22%2C%22name%22%3A%22System%20Info%20%26%20Files%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%2FCMD_FILE_MANAGER%22%2C%22newTab%22%3Atrue%2C%22name%22%3A%22File%20Manager%22%2C%22icon%22%3A%22file-manager%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fperl-modules%22%2C%22name%22%3A%22Installed%20Perl%20Modules%22%2C%22icon%22%3A%22installed-perl-modules%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fsystem-info%22%2C%22name%22%3A%22System%20Information%22%2C%22icon%22%3A%22server-information%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fstats%22%2C%22name%22%3A%22Site%20Summary%20%2F%20Statistics%20%2F%20Logs%22%2C%22icon%22%3A%22site-summary%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fresource-limits%22%2C%22name%22%3A%22Resource%20Limits%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22resource-limits%22%7D%5D%7D%2C%7B%22icon%22%3A%22extra-features%22%2C%22name%22%3A%22Extra%20Features%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2Fsquirrelmail%22%2C%22name%22%3A%22Webmail%3A%20Squirrelmail%22%2C%22enabled%22%3Afalse%2C%22newTab%22%3Atrue%2C%22slug%22%3A%22squirrelmail%22%2C%22icon%22%3A%22squirellmail%22%7D%2C%7B%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2F${rc_route_name}%22%2C%22name%22%3A%22Webmail%3A%20${C_ROUNDCUBE_CUSTOM_NAME}%22%2C%22enabled%22%3Atrue%2C%22newTab%22%3Atrue%2C%22slug%22%3A%22roundcube%22%2C%22icon%22%3A%22roundcube%22%7D%2C%7B%22route%22%3A%22phpmyadmin%22%2C%22name%22%3A%22phpMyAdmin%22%2C%22enabled%22%3Afalse%2C%22icon%22%3A%22phpmyadmin%22%7D%2C%7B%22route%22%3A%22plugins%22%2C%22name%22%3A%22Plugins%20will%20be%20inserted%20after%20this%20entry%22%2C%22enabled%22%3Afalse%7D%2C%7B%22name%22%3A%22Database%3A%20${C_PHPMYADMIN_CUSTOM_NAME}%22%2C%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2F${db_route_name}%22%2C%22newTab%22%3Atrue%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22phpmyadmin%22%7D%5D%7D%2C%7B%22icon%22%3A%22support-help%22%2C%22name%22%3A%22Support%20%26%20Help%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%7B%7Bhelp%7D%7D%22%2C%22name%22%3A%22Help%22%2C%22enabled%22%3Atrue%2C%22newTab%22%3Atrue%2C%22icon%22%3A%22help%22%7D%2C%7B%22route%22%3A%22%2Fuser%2Fcreate-ticket%22%2C%22name%22%3A%22Create%20Ticket%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22create-ticket%22%7D%2C%7B%22route%22%3A%22%2Fuser%2Fmessages%22%2C%22name%22%3A%22Support%20Center%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22support-center%22%7D%5D%7D%5D%2C%22reseller%22%3A%5B%7B%22name%22%3A%22Account%20Manager%22%2C%22icon%22%3A%22account-manager%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A3%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Freseller%2Fcreate-user%22%2C%22name%22%3A%22Add%20New%20User%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22add-new-user%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fusers%22%2C%22name%22%3A%22List%20Users%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22list-users%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fuser-packages%22%2C%22name%22%3A%22Manage%20User%20Packages%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22manage-user-packages%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fpasswords%22%2C%22name%22%3A%22Change%20Passwords%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22change-passwords%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fedit-user-message%22%2C%22name%22%3A%22Edit%20User%20Message%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22edit-user-message%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fsuspension-message%22%2C%22name%22%3A%22Suspension%20Message%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22edit-user-message%22%7D%5D%7D%2C%7B%22name%22%3A%22Server%20Manager%22%2C%22icon%22%3A%22server-manager%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Freseller%2Fip-config%22%2C%22name%22%3A%22IP%20Management%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22ip-management%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fnameservers%22%2C%22name%22%3A%22Name%20Servers%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22name-servers%22%7D%2C%7B%22route%22%3A%22%2Fuser%2Fssh-keys%22%2C%22name%22%3A%22SSH%20Keys%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22ssh-keys%22%7D%5D%7D%2C%7B%22name%22%3A%22Reseller%20Tools%22%2C%22icon%22%3A%22admin-tools%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Freseller%2Fbackups%22%2C%22name%22%3A%22Manage%20User%20Backups%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22manage-user-backups%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fmessage-users%22%2C%22name%22%3A%22Message%20All%20Users%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22message-all-users%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fskins%22%2C%22name%22%3A%22Skin%20Manager%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22skin-manager%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fcustomize-skin%22%2C%22name%22%3A%22Customize%20Evolution%20Skin%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22customize-evolution-skin%22%7D%5D%7D%2C%7B%22name%22%3A%22System%20Info%20%26%20Files%22%2C%22icon%22%3A%22system-information%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%2FCMD_FILE_MANAGER%22%2C%22newTab%22%3Atrue%2C%22name%22%3A%22File%20Manager%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22file-manager%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fsystem-info%22%2C%22name%22%3A%22System%20Information%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22system-info%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fstats%22%2C%22name%22%3A%22Reseller%20Statistics%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22reseller-statistics%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fresource-limits%22%2C%22name%22%3A%22Resource%20Limits%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22resource-limits%22%7D%5D%7D%2C%7B%22name%22%3A%22Extra%20Features%22%2C%22icon%22%3A%22extra-features%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2Fsquirrelmail%22%2C%22name%22%3A%22Webmail%3A%20Squirrelmail%22%2C%22enabled%22%3Afalse%2C%22newTab%22%3Atrue%2C%22slug%22%3A%22squirrelmail%22%2C%22icon%22%3A%22squirellmail%22%7D%2C%7B%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2Fwebmail%22%2C%22name%22%3A%22Webmail%3A%20UebiMiau%22%2C%22enabled%22%3Afalse%2C%22newTab%22%3Atrue%2C%22slug%22%3A%22uebimiau%22%2C%22icon%22%3A%22uebimiau%22%7D%2C%7B%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2F${rc_route_name}%22%2C%22name%22%3A%22Webmail%3A%20${C_ROUNDCUBE_CUSTOM_NAME}%22%2C%22enabled%22%3Atrue%2C%22newTab%22%3Atrue%2C%22slug%22%3A%22roundcube%22%2C%22icon%22%3A%22roundcube%22%7D%2C%7B%22route%22%3A%22phpmyadmin%22%2C%22name%22%3A%22phpMyAdmin%22%2C%22enabled%22%3Afalse%2C%22icon%22%3A%22phpmyadmin%22%7D%2C%7B%22route%22%3A%22plugins%22%2C%22name%22%3A%22Plugins%20will%20be%20inserted%20after%20this%20entry%22%2C%22enabled%22%3Afalse%7D%2C%7B%22name%22%3A%22Database%3A%20${C_PHPMYADMIN_CUSTOM_NAME}%22%2C%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2F${db_route_name}%22%2C%22newTab%22%3Atrue%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22phpmyadmin%22%7D%5D%7D%2C%7B%22name%22%3A%22Support%20%26%20Help%22%2C%22icon%22%3A%22support-help%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%7B%7Bhelp%7D%7D%22%2C%22name%22%3A%22Help%22%2C%22enabled%22%3Atrue%2C%22newTab%22%3Atrue%2C%22icon%22%3A%22help%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Ftickets%22%2C%22name%22%3A%22Manage%20Tickets%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22manage-tickets%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Ftickets%2Fcreate%22%2C%22name%22%3A%22Create%20Ticket%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22create-ticket%22%7D%5D%7D%5D%2C%22admin%22%3A%5B%7B%22name%22%3A%22Account%20Manager%22%2C%22icon%22%3A%22account-manager%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A4%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Freseller%2Fcreate-user%22%2C%22name%22%3A%22Add%20New%20User%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22add-new-user%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fusers%22%2C%22name%22%3A%22Show%20All%20Users%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22show-all-users%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fusers%22%2C%22name%22%3A%22My%20Users%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22list-users%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fuser-packages%22%2C%22name%22%3A%22Manage%20User%20Packages%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22manage-user-packages%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fusers%2Fmove%22%2C%22name%22%3A%22Move%20Users%20between%20Resellers%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22move-users-between-resellers%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fedit-user-message%22%2C%22name%22%3A%22Edit%20User%20Message%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22edit-user-message%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fpasswords%22%2C%22name%22%3A%22Change%20Passwords%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22change-passwords%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fusers%2Fresellers%2Fcreate%22%2C%22name%22%3A%22Create%20Reseller%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22create-reseller%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fusers%2Fresellers%22%2C%22name%22%3A%22List%20Resellers%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22list-resellers%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Freseller-packages%22%2C%22name%22%3A%22Manage%20Reseller%20Packages%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22manage-reseller-packages%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fusers%2Fadmins%2Fcreate%22%2C%22name%22%3A%22Create%20Administrator%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22create-administrator%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fusers%2Fadmins%22%2C%22name%22%3A%22List%20Administrators%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22list-administrators%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fsuspension-message%22%2C%22name%22%3A%22Suspension%20Message%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22edit-user-message%22%7D%5D%7D%2C%7B%22name%22%3A%22Server%20Manager%22%2C%22icon%22%3A%22server-manager%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A3%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Fadmin%2Fsettings%22%2C%22name%22%3A%22Administrator%20Settings%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22administrator-settings%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fcustom-httpd%22%2C%22name%22%3A%22Custom%20HTTPD%20Configurations%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22custom-httpd-configuration%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fdns%22%2C%22name%22%3A%22DNS%20Administration%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22dns-administration%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fip-manager%22%2C%22name%22%3A%22IP%20Management%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22ip-management%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fnameservers%22%2C%22name%22%3A%22Name%20Servers%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22name-servers%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fmulti-server%22%2C%22name%22%3A%22Multi%20Server%20Setup%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22multi-server-setup%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fphp-safe-mode%22%2C%22name%22%3A%22PHP%20Configuration%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22php-configuration%22%7D%2C%7B%22route%22%3A%22%2Fuser%2Fssh-keys%22%2C%22name%22%3A%22SSH%20Keys%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22ssh-keys%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fssl%22%2C%22name%22%3A%22Admin%20SSL%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22admin-ssl%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fmodsecurity%22%2C%22name%22%3A%22ModSecurity%22%2C%22enabled%22%3Atrue%7D%5D%7D%2C%7B%22name%22%3A%22Admin%20Tools%22%2C%22icon%22%3A%22admin-tools%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A3%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Fadmin%2Fbackups%22%2C%22name%22%3A%22Admin%20Backup%2FTransfer%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22admin-backup-transfer%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fbrute-force-monitor%22%2C%22name%22%3A%22Brute%20Force%20Monitor%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22brute-force-monitor%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fprocess-monitor%22%2C%22name%22%3A%22Process%20Monitor%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22process-monitor%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fmail-queue%22%2C%22name%22%3A%22Mail%20Queue%20Administration%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22mail-queue-administration%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Femail-tracking%22%2C%22name%22%3A%22E-mail%20Tracking%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22email-tracking%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fservices%22%2C%22name%22%3A%22Service%20Monitor%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22service-monitor%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fsystem-backup%22%2C%22name%22%3A%22System%20Backup%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22system-backup%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fmessage-users%22%2C%22name%22%3A%22Message%20All%20Users%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22message-all-users%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fskins%22%2C%22name%22%3A%22Skin%20Manager%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22skin-manager%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fcustomize-skin%22%2C%22name%22%3A%22Customize%20Evolution%20Skin%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22customize-evolution-skin%22%7D%2C%7B%22slug%22%3A%22rspamd%22%2C%22href%22%3A%22%2FCMD_RSPAMD_SOCK%2F%22%2C%22name%22%3A%22Rspamd%20spam%20filtering%20system%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22spam-metrics%22%2C%22newTab%22%3Atrue%7D%2C%7B%22slug%22%3A%22netdata%22%2C%22href%22%3A%22%2FCMD_NETDATA_SOCK%2F%22%2C%22name%22%3A%22Netdata%20server%20metrics%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22netdata%22%2C%22newTab%22%3Atrue%7D%5D%7D%2C%7B%22name%22%3A%22System%20Info%20%26%20Files%22%2C%22icon%22%3A%22system-information%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A3%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Fadmin%2Fcron-jobs%22%2C%22name%22%3A%22All%20User%20Cron%20Jobs%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22all-user-cron-jobs%22%7D%2C%7B%22href%22%3A%22%2FCMD_FILE_MANAGER%22%2C%22newTab%22%3Atrue%2C%22name%22%3A%22File%20Manager%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22file-manager%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Ffile-editor%22%2C%22name%22%3A%22File%20Editor%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22file-editor%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fsystem-info%22%2C%22name%22%3A%22System%20Information%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22system-info%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Flog-viewer%22%2C%22name%22%3A%22Log%20Viewer%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22log-viewer%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fstats%22%2C%22name%22%3A%22Complete%20Usage%20Statistics%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22complete-usage-statistics%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fresource-limits%22%2C%22name%22%3A%22Resource%20Limits%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22resource-limits%22%7D%5D%7D%2C%7B%22name%22%3A%22Extra%20Features%22%2C%22icon%22%3A%22extra-features%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22slug%22%3A%22squirrelmail%22%2C%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2Fsquirrelmail%22%2C%22name%22%3A%22Webmail%3A%20Squirrelmail%22%2C%22enabled%22%3Afalse%2C%22newTab%22%3Atrue%2C%22icon%22%3A%22squirellmail%22%7D%2C%7B%22slug%22%3A%22uebimiau%22%2C%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2Fwebmail%22%2C%22name%22%3A%22Webmail%3A%20UebiMiau%22%2C%22enabled%22%3Afalse%2C%22newTab%22%3Atrue%2C%22icon%22%3A%22uebimiau%22%7D%2C%7B%22slug%22%3A%22roundcube%22%2C%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2F${rc_route_name}%22%2C%22name%22%3A%22Webmail%3A%20${C_ROUNDCUBE_CUSTOM_NAME}%22%2C%22enabled%22%3Atrue%2C%22newTab%22%3Atrue%2C%22icon%22%3A%22roundcube%22%7D%2C%7B%22route%22%3A%22phpmyadmin%22%2C%22name%22%3A%22phpMyAdmin%22%2C%22enabled%22%3Afalse%2C%22icon%22%3A%22phpmyadmin%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fplugin-manager%22%2C%22name%22%3A%22Plugin%20Manager%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22plugin-manager%22%7D%2C%7B%22route%22%3A%22plugins%22%2C%22name%22%3A%22Plugins%20will%20be%20inserted%20after%20this%20entry%22%2C%22enabled%22%3Afalse%7D%2C%7B%22name%22%3A%22Database%3A%20${C_PHPMYADMIN_CUSTOM_NAME}%22%2C%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2F${db_route_name}%22%2C%22newTab%22%3Atrue%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22phpmyadmin%22%7D%5D%7D%2C%7B%22name%22%3A%22Support%20%26%20Help%22%2C%22icon%22%3A%22support-help%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%7B%7Bhelp%7D%7D%22%2C%22name%22%3A%22Help%22%2C%22enabled%22%3Atrue%2C%22newTab%22%3Atrue%2C%22icon%22%3A%22help%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Ftickets%22%2C%22name%22%3A%22Manage%20Tickets%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22manage-tickets%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Flicense%22%2C%22name%22%3A%22Licensing%20%2F%20Updates%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22licensing-updates%22%7D%5D%7D%5D%7D%2C%22colors%22%3A%7B%22primary-dark%22%3A%7B%22hue%22%3A196%2C%22saturation%22%3A99%2C%22lightness%22%3A23.078751857348%2C%22alpha%22%3A100%7D%2C%22safe%22%3A%7B%22hue%22%3A140%2C%22saturation%22%3A41%2C%22lightness%22%3A56%7D%2C%22danger%22%3A%7B%22hue%22%3A20%2C%22saturation%22%3A76%2C%22lightness%22%3A47%7D%2C%22neutral%22%3A%7B%22hue%22%3A180%2C%22saturation%22%3A0.448430493273541%2C%22lightness%22%3A43.72549019607843%7D%7D%2C%22dateFormats%22%3A%7B%22datetime%22%3A%22dd-MMM-yyy%20HH%3Amm%20a%22%2C%22date%22%3A%22dd-MM-yyy%22%2C%22weekStart%22%3A%22monday%22%7D%2C%22theme%22%3A%22%22%2C%22adsense%22%3A%7B%22enabled%22%3Atrue%2C%22client%22%3A%22%22%2C%22slot%22%3A%22%22%2C%22css%22%3A%22display%3A%20block%3B%22%7D%2C%22mergedMenu%22%3Atrue%7D" method="POST"
      else
        msg "$(s red)Error, only --skin-name evolution is supported at this moment${action} $(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi
    else
      msg "$(s red)Error, please temporarily use the option --recommend-values for this action ${action} $(e)" --caller="${SCRIPT_NAME}"
      # Add single values here
      exit 1
    fi
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi
    # da_api_admin set-da-logo --skin-name "evolution" --logo-mode "default-logo" --logo-file "/tmp/logo.png"
  # --logo-mode with version 1.62 is default-logo, dark-logo, favicon
  # This is my own unofficial method to set logo because there is no documentation how to set this in directadmin
  # https://forum.directadmin.com/threads/cmd_api_skins-upload-skin-logo-via-curl-issue.63127/
  elif [[ "${action}" == "set-da-logo" ]]; then
    local cmd_api data method retval da_api_exec has_success logo_file_temp
    if [ ! -f "${logo_file}" ]; then
      msg "$(s red)Error, logo file does not exist! Please make sure the file exist!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi
    # Reference: https://www.directadmin.com/features.php?id=2923
    if [[ "${logo_mode}" == "default-logo" || -z "${logo_mode}" ]]; then
      logo_mode="1"
      # The upload file need to have random string append to it else it won't work:
      # I use random length of 6 because I saw directadmin always generated length of 6 when append this random string to a file
      logo_file_temp="${da_temp_dir}/logo.png$(get_rnd_alpha 6)"
    elif [ "${logo_mode}" == "dark-logo" ]; then
      logo_mode="2"
      logo_file_temp="${da_temp_dir}/logo2.png$(get_rnd_alpha 6)"
    elif [ "${logo_mode}" == "favicon" ]; then
      logo_mode="3"
      logo_file_temp="${da_temp_dir}/favicon.png$(get_rnd_alpha 6)"
    elif [ "${logo_mode}" == "default-symbol" ]; then
      logo_mode="4"
      logo_file_temp="${da_temp_dir}/symbol.png$(get_rnd_alpha 6)"
    elif [ "${logo_mode}" == "dark-symbol" ]; then
      logo_mode="5"
      logo_file_temp="${da_temp_dir}/symbol2.png$(get_rnd_alpha 6)"
    else
      msg "$(s red)Error, invalid logo mode$(e)" --caller="${SCRIPT_NAME}"
    fi
    msg "Current logo mode is :${logo_mode}" --caller="${SCRIPT_NAME}"
    msg "Current logo file is :${logo_file}" --caller="${SCRIPT_NAME}"
    msg "Current logo_file_temp is :${logo_file_temp}" --caller="${SCRIPT_NAME}"
    # Copy the logo files (with extra string) from storage data to the temporary home directory
    cp "${logo_file}" "${logo_file_temp}"
    # Now assign the temporary logo as the logo_file
    logo_file="${logo_file_temp}"
    # The files that need to be uploaded from the temporary folder need to have nobody permission (else it wont work)
    chown nobody:nogroup "${logo_file}"
    msg "Now the logo file is :${logo_file}" --caller="${SCRIPT_NAME}"

    cmd_api="CMD_API_SKINS"
    data="action=upload_logo&file=${logo_file}&name=${skin_name}&which=${logo_mode}"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi
    rm -f "${logo_file}"
  # da_api_admin set-security-question --question "Awak suka makan budu tak?" --answer "suka"
  elif [[ "${action}" == "set-security-qna" || "${action}" == "set-security-question" ]]; then
    local cmd_api data method retval da_api_exec has_success has_cmd_api
    has_cmd_api=false
    # Note this CMD_API_SECURITY_QUESTIONS have not been released. So, we need to use json and ignore error checking
    # If the API is released, just put has_cmd_api=true
    method="POST"
    if [ "${has_cmd_api}" == "false" ]; then
      cmd_api="CMD_SECURITY_QUESTIONS"
      msg "$(s yellow)Note, directadmin does not have CMD_API_SECURITY_QUESTIONS call. Using CMD_SECURITY_QUESTIONS ...$(e)" --caller="${SCRIPT_NAME}"
      # Note This does not work. Posted here: https://forum.directadmin.com/threads/bug-in-api-cmd_security_questions-bug-with-parameter-order.64318/
      #data="type=custom&value=${answer}&action=add&custom_question=${question}&json=yes"
      # This work
      data="type=custom&value=${answer}&json=yes&action=add&custom_question=${question}"
      curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}"
    else
      cmd_api="CMD_API_SECURITY_QUESTIONS"
      data="type=custom&value=${answer}&action=add&custom_question=${question}"
      da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
      has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
      if [ -z "${has_success}" ]; then
        msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
        msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
      #exit 1
      else
        msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
        msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
      fi
    fi
    # da_api_admin create-user-subdomain --domain "maxibi.com" --subdomain "sales"
  elif [[ "${action}" == "create-user-subdomain" || "${action}" == "create-subdomain" ]]; then
    local cmd_api data method retval da_api_exec has_success
    # Special note: CMD_API_SUBDOMAIN AND CMD_API_SUBDOMAINS are the same thing: https://www.directadmin.com/features.php?id=1589
    cmd_api="CMD_API_SUBDOMAIN"
    data="domain=${domain}&subdomain=${subdomain}&action=create"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi
    #da_api_admin reset-dns-record --domain test.domain.com
  elif [[ "${action}" == "reset-dns-record" || "${action}" == "restore-dns-record" ]]; then
    local cmd_api data method retval da_api_exec has_success
    cmd_api="CMD_API_DNS_ADMIN"
    data="domain=${domain}&action=select&reset=yes"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi
  # da_api_admin create-user-email --mail-domain "maxibi.com" --mail-user "webmaster" --mail-password "1232123" --mail-quota "0" --mail-limit "200"
  elif [ "${action}" == "create-user-email" ]; then
    local cmd_api data method da_api_exec has_success
    cmd_api="CMD_API_EMAIL_POP"
    #https://www.directadmin.com/features.php?id=2587 not sure if this useful
    data="user=${mail_user}&passwd=${mail_password}&passwd2=${mail_password}&quota=${mail_quota}&limit=${mail_limit}&domain=${mail_domain}&action=create"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi
  #da_api_admin create-user-database --db-domain "maxibi.com" --db-name abc --db-user maxibi --db-password 12321aa (create new user database)
  #da_api_admin --db-domain "maxibi.com" create-user-database --db-name abc --existing-user maxibi  (create database with existing user)
  elif [ "${action}" == "create-user-database" ]; then
    local cmd_api data method retval da_api_exec has_success has_cmd_api
    has_cmd_api=false
    msg "$(s yellow)Note, directadmin does not have CMD_API_DB (https://forum.directadmin.com/threads/api-set-server-hostname.37872/post-188426). Using CMD_DB ...$(e)" --caller="${SCRIPT_NAME}"
    # Note this CMD_API_DB have not been released. So, we need to use json and ignore error checking
    # If the API is released, just put has_cmd_api=true, this will automatically use the new API
    method="POST"
    # This API includes security settings and email settings (DA combined this)
    if [ "${has_cmd_api}" == "false" ]; then
      # CMD_API_DB not working but CMD_DB is working
      cmd_api="CMD_DB"
      if [ -n "${db_existing_user}" ]; then
        # This will select existing user to create database
        data="name=${db_name}&user=${db_existing_user}&domain=${db_domain}&userlist=${db_existing_user}&action=create&json=yes"
      else
        data="name=${db_name}&user=${db_user}&passwd=${db_password}&passwd2=${db_password}&domain=${db_domain}&userlist=...&action=create&json=yes"
      fi
      curl --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}"
      echo "status is: $?"

    else
      cmd_api="CMD_API_DB"
      if [ -n "${db_existing_user}" ]; then
        # This will select existing user to create database
        data="name=${db_name}&user=${db_existing_user}&domain=${db_domain}&userlist=${db_existing_user}&action=create"
      else
        data="name=${db_name}&user=${db_user}&passwd=${db_password}&passwd2=${db_password}&domain=${db_domain}&userlist=...&action=create"
      fi
      da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
      has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

      if [ -z "${has_success}" ]; then
        msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
        msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
      #exit 1
      else
        msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
        msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
      fi
    fi
    # da_api_admin create-user-account --username abc --email abc@dsa.com --password 12321aa --domain maxibi.com --package_name USER_UNLIMITED --ip-address "${C_IPV4_ADD0}"
  elif [ "${action}" == "create-user-account" ]; then
    # da_api_admin "create-reseller-account" "user1" "user1@maxibi.com" "x1231aax" "maxibi.com" "USER_UNLIMITED"
    local cmd_api data method da_api_exec has_success
    cmd_api="CMD_API_ACCOUNT_USER"
    data="username=${username}&email=${email}&passwd=${password}&passwd2=${password}&domain=${domain}&package=${package_name}&notify=no&ip=${ip_address}&action=create&add=yes"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi

  elif [ "${action}" == "delete-users" ]; then
    # da_api_admin "delete-users" "admin2"
    shift
    username="$1"
    command="CMD_API_SELECT_USERS"
    data="confirmed=Confirm&delete=yes&select0=${username}"
    method="POST"
    echo "Now, executing API with action name: ${action}"
    # Deprecated syntax:
    # da_api_admin "request-domain-ssl" <provider> <root_domain> <keysize> <encryption> <ssl_sub_domains_query>
    # da_api_admin "request-domain-ssl" letsencrypt codegix.com secp521r1 sha256 "le_select0=codegix.com&le_select1=www.codegix.com&le_select2=ftp.codegix.com \
    # &le_select3=mail.codegix.com&le_select4=pop.codegix.com&le_select5=smtp.codegix.com&le_select6=dashboard.codegix.com&le_select7=secure.codegix.com"
    # New syntax:
    # da_api_admin requst-domain-ssl --ssl-provider letsencrypt --ssl-root-domain test.com --ssl-subdomain-query <query_string>

  elif [ "${action}" == "request-domain-ssl" ]; then
    local cmd_api data method da_api_exec has_success
    # CMD_API_SUBDOMAIN AND CMD_API_SUBDOMAINS are the same thing: https://www.directadmin.com/features.php?id=1589
    cmd_api="CMD_API_SSL"
    method="POST"
    if [ "${ssl_provider}" == "letsencrypt" ]; then
      data="type=create&request=letsencrypt&name=${ssl_root_domain}&keysize=${C_DA_CERTIFICATE_SIZE}&encryption=${C_DA_CERTIFICATE_ENCRYPTION_ALGORITHM} \
      &wildcard=no&domain=${ssl_root_domain}&action=save&background=auto&${ssl_subdomains_query}"
    else
      # Give error because we focus on letsencrypt first
      msg "$(s red) Error, this provider ${ssl_provider} has no API yet to request domain for SSL$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi
    # Note this API will delete list of tickets, because I need to read message from ticket about restore-user-backup properly
    # It is alright, because we are using initial setup, ticket should not have anything important at this point.
  elif [ "${action}" == "restore-user-backup" ]; then
    local cmd_api data method da_api_exec has_success has_error max_wait_restore
    cmd_api="CMD_API_ADMIN_BACKUP"
    data="where=local&when=now&ftp_ip=&ftp_username=&ftp_password=&ftp_path=%2F&ftp_port=21&ftp_secure=no&local_path=${backup_path}&ip_choice=file&ip=${backup_ip}&action=restore&create_user_home_override=&encryption_password=${backup_password}&select0=${backup_file_name}&type=sse"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'

      cmd_api="CMD_API_TICKET"
      data="action=view&type=message"

      # https://forum.directadmin.com/threads/delete-all-message-system-via-ssh.47646/post-244515
      # The first 1) is not valid anymore because of this: https://www.directadmin.com/features.php?id=1696 (read at bottom)
      # We do not need to remove the tickets.list, just need to remove the file 000, 001 etc but for this purpose, I just remove it for safety reason

      # Remove ticket list
      msg "$(s cyan)Clearing admin ticket list from tickets.list ...$(e)" --caller="${SCRIPT_NAME}"
      echo -n "" >/usr/local/directadmin/data/admin/tickets.list
      get_status_message "$?"
      echo ""
      msg "$(s cyan)Removing admin ticket files ...$(e)" --caller="${SCRIPT_NAME}"
      rm -rf /usr/local/directadmin/data/tickets/*
      get_status_message "$?"
      echo ""
      max_wait_restore=0
      while :; do
        sleep 1
        msg "$(s cyan)Detecting user backup restoration status based on the directadmin ticket's subject ...$(e)" --caller="${SCRIPT_NAME}" --start-spin
        ((max_wait_restore++))
        # Only owner will handle the restoration, so the API use authentication from owner
        # Just make sure the backup has the same authentication in config file to get correct status
        da_api_exec=$(curl --silent --request "${method}" --user "${C_DA_OWNER_USERNAME1}":"${C_DA_OWNER_USERPASS1}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
        has_success=$(echo "${da_api_exec}" | urldecode | awksep '&' | grep -w "subject=Your User files have been restored")
        has_error=$(echo "${da_api_exec}" | urldecode | awksep '&' | grep -w "subject=An error occurred during the restore")

        if [ -n "${has_success}" ]; then
          msg "$(s green)OK, file ${backup_file_name} has been successfully restored based on the directadmin ticket's subject$(e)" --caller="${SCRIPT_NAME}" --stop-spin
          break
        elif [ -n "${has_error}" ]; then
          msg "$(s red)Error, could not restore the backup file ${backup_file_name}$(e)" --caller="${SCRIPT_NAME}" --stop-spin
          msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
          exit 1
          break
        elif [ "${max_wait_restore}" -gt 120 ]; then
          msg "$(s red)Error, it took a very long period to obtain the restoration success message (restoration might be failed). Please inspect error below:$(e)" --caller="${SCRIPT_NAME}"
          msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
          exit 1
        fi
      done
    fi

    #TODO This required process ID and I'm not sure know what is this https://forum.directadmin.com/threads/restore-not-working-in-directadmin.67215/#post-353686
  elif [ "${action}" == "monitor-user-backup" ]; then
    local cmd_api data method da_api_exec has_success has_error max_wait_restore
    cmd_api="CMD_ADMIN_BACKUP"
    data="action=monitor&get=tracking_data&type=sse"
    method="POST"
    curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}"

    exit 1
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi

  # da_api_admin change-user-password --username user1 --password 123
  elif [ "${action}" == "change-user-password" ]; then
    local cmd_api data method retval da_api_exec has_success
    cmd_api="CMD_API_USER_PASSWD"
    data="username=${username}&passwd=${password}&passwd2=${password}&action=create&referer=CMD_API_USER_PASSWD"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi
  # da_api_admin add-hostname --hostname server.domain.com --ip-address 123.123.123.123 --nameserver1 ns1.domain.com --nameserver2 ns2.domain.com
  elif [[ "${action}" == "add-hostname" || "${action}" == "create-hostname" ]]; then
    local cmd_api data method retval da_api_exec has_success
    cmd_api="CMD_API_DNS_ADMIN"
    data="domain=${hostname}&ip=${ip_address}&ns1=${nameserver1}&ns2=${nameserver2}&reverse=no&action=create"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi

  elif [ "${action}" == "change-php-version" ]; then
    local cmd_api data method retval da_api_exec has_success
    cmd_api="CMD_API_DOMAIN"
    php_compatible_select_number=$(cat /usr/local/directadmin/custombuild/options.conf | grep "php[0-4]_release=${php_version}" | cut -c4)
    if [ -z "${php_compatible_select_number}" ]; then
      :
      # No need to display this error, the API also has its own error checking for this
      # msg "$(s red)Error, the supplied PHP version does not exist in directadmin system$(e)" --caller="${SCRIPT_NAME}"
    else
      msg "$(s green)OK, the supplied PHP version found and has selector number of ${php_compatible_select_number}$(e)" --caller="${SCRIPT_NAME}"
    fi
    data="php1_select=${php_compatible_select_number}&domain=${domain}&action=php_selector&save=yes&json=yes"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w "\"success\":")
    if [ -z "${has_success}" ]; then
      msg "$(s red)Error, API with action ${action} executed with the following error: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${da_api_exec}$(e)" | urldecode | awksep '&'
    #exit 1
    else
      msg "$(s green)OK, API with action ${action} executed with the following status: $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)${da_api_exec}$(e)" | urldecode | awksep '&'
    fi

    #
  else
    msg "$(s red)The Directadmin API action ${action} does not exist!$(e)" --caller="${SCRIPT_NAME}"
    exit 1
  fi

}

# This will check if system needs to reboot based on /var/run/reboot-required file
# This function also will make sure if a caller function has finished executed, then we won't run that function again.
check_finish_reboot() {
  local func_name="$1"
  cat /dev/null >"${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed"
  if [ -f /var/run/reboot-required ]; then
    if [ "${C_ENABLE_SETUP_REBOOT}" == "auto" ]; then
      msg "[Notice]: *** System reboot required. Rebooting in 30 seconds (ctrl+c to cancel) ..."
      sleep 30
      _reboot
    elif [ "${C_ENABLE_SETUP_REBOOT}" == "interactive" ]; then
      read -r -s -n 1 -p "[${SCRIPT_NAME}]: [Notice]: *** System reboot required. Press any key to reboot (ctrl+c to cancel) ..."
      _reboot
    elif [ "${C_ENABLE_SETUP_REBOOT}" == "disabled" ]; then
      read -r -s -n 1 -p "[${SCRIPT_NAME}]: [Notice]: *** Warning, system reboot required, but C_ENABLE_SETUP_REBOOT setting is disabled!"
    fi
    echo ""
  else
    msg "$(s green)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
    msg "$(s green)[OK]: $(s magenta)${func_name}$(e) $(s green)has been executed$(e)" --caller="${SCRIPT_NAME}"
    if command -v gotify &>/dev/null; then
      # Send alert to push notification if gotify is installed (we dont use color here) because color will not display in terminal
      msg "[OK]: ${func_name}() has been executed" --caller="${SCRIPT_NAME}" --push-notification-silent
    fi
    # This sleep is for debugging, when finish developing this script, I should remove this sleep to speed up the script
    #sleep 1
  fi
  return 0
}

# This function will check service error and try to repair it using common solutions like log error information
# repair_services "<service_name1>" "<service_name2>" ... "<service_nameN>"
# This function is a standalone service
repair_services() {
  local service_name service_names gc retval lfd_service csf_service
  service_names="$*"
  for service_name in ${service_names}; do
    msg "$(s cyan)Checking ${service_name} status ...$(e)" --caller="${SCRIPT_NAME}"
    sleep 2
    if [ "${service_name}" == "csf" ]; then
      # Fix that here
      csf_service=$(systemctl is-active csf)
      if [ "${csf_service}" == "active" ]; then
        msg "$(s green)OK, ${service_name} service is running$(e)" --caller="${SCRIPT_NAME}"
      else
        # CSF fix 1 - restarting
        msg "$(s yellow)Warning, unable to start CSF service properly. Restarting CSF and giving extra 3 seconds wait time ...$(e)" --caller="${SCRIPT_NAME}"
        systemctl restart csf
        sleep 3
        csf_service=$(systemctl is-active csf)
        if [ "${csf_service}" == "active" ]; then
          msg "$(s green)OK, CSF service is running$(e)" --caller="${SCRIPT_NAME}"
        else
          msg "$(s red)Error, unable to start CSF service properly. Please check the log file for more hints$(e)" --caller="${SCRIPT_NAME}"
          exit 1
        fi
        # CSF fix 2 - pending if any
      fi
    fi

    if [ "${service_name}" == "lfd" ]; then
      lfd_service=$(systemctl is-active lfd)
      if [ "${lfd_service}" == "active" ]; then
        msg "$(s green)OK, ${service_name} has started$(e)" --caller="${SCRIPT_NAME}"
      else
        msg "$(s yellow)Warning, unable to start LFD service properly. Trying to solve this based on common problems ...$(e)" --caller="${SCRIPT_NAME}"
        sleep 1
        # Start lfd to generate log file because first it had no log
        msg "$(s cyan)Starting lfd to generate lfd log file ...$(e)" --caller="${SCRIPT_NAME}"
        systemctl start lfd
        # lfd known fix 1
        msg "$(s cyan)Applying fix 1 to fix ${service_name} ...$(e)" --caller="${SCRIPT_NAME}"
        msg "$(s cyan)Giving 10 seconds for ${service_name} to start properly$(e)" --caller="${SCRIPT_NAME}"
        sleep 10
        lfd_service=$(systemctl is-active lfd)
        if [ "${lfd_service}" == "active" ]; then
          msg "$(s green)OK, ${service_name} has started$(e)" --caller="${SCRIPT_NAME}"
        else
          # lfd known fix 2
          msg "$(s cyan)Applying fix 2 to fix ${service_name} ...$(e)" --caller="${SCRIPT_NAME}"
          msg "$(s cyan)Clearing lfd log entry at /var/log/lfd.log ...$(e)" --caller="${SCRIPT_NAME}"
          cat /dev/null >/var/log/lfd.log
          msg "$(s cyan)Restarting lfd and giving 10 seconds extra wait time ...$(e)" --caller="${SCRIPT_NAME}"
          systemctl restart lfd
          # Waiting at least 10 seconds (so that the lfd process is up and it generates a log file for the first time)
          sleep 10
          if [ -f /var/log/lfd.log ]; then
            gc=$(grep -ic 'you may need to install the IO::Socket::INET6 module' /var/log/lfd.log)
            if [ "${gc}" -ne 0 ]; then
              msg "$(s yellow)Warning, found missing perl IO::Socket::INET6 module. Installing libio-socket-inet6-perl for Debian$(e)" --caller="${SCRIPT_NAME}"
              # Use this function for best compatibility with other DISTRO
              maxibuild --include "libio-socket-inet6-perl"
              msg "$(s cyan)Restarting lfd and giving 10 seconds extra wait time ...$(e)" --caller="${SCRIPT_NAME}"
              systemctl restart lfd
              sleep 10
            fi
          else
            # This is just in case if log file not appear
            msg "$(s red)Error, lfd log file not generated. It should generated after given sometime. Please inspect why the lfd log file at /var/log/lfd.log is not generated!$(e)" --caller="${SCRIPT_NAME}"
            exit 1
          fi
          msg "$(s cyan)Rechecking lfd status ...$(e)" --caller="${SCRIPT_NAME}"
          lfd_service=$(systemctl is-active lfd)
          if [ "${lfd_service}" == "active" ]; then
            msg "$(s green)OK, ${service_name} has started$(e)" --caller="${SCRIPT_NAME}"
          else
            msg "$(s red)Error, unable to understand why ${service_name} cannot be started. Please check the lfd log file at /var/log/lfd.log for more hints$(e)" --caller="${SCRIPT_NAME}"
            exit 1
          fi
        fi
        # ----
        # lfd known fix 3 and more
      fi
    fi
  done
  # more services error to fix goes here ...
}

# This function is a standalone function
# It restarts software server based on the installation string provided
restart_da_web_server() {
  echo ""
  if [ "${C_DA_CB_WEBSERVER_SOFTWARE}" == "nginx_apache" ]; then
    msg "$(s magenta)Restarting httpd and nginx for new httpd config ...$(e)" --caller="${SCRIPT_NAME}"
    systemctl restart httpd
    sudo pkill -f nginx &
    wait $!
    systemctl restart nginx
  elif [ "${C_DA_CB_WEBSERVER_SOFTWARE}" == "nginx" ]; then
    msg "$(s magenta)Restarting nginx  ...$(e)" --caller="${SCRIPT_NAME}"
    sudo pkill -f nginx &
    wait $!
    systemctl restart nginx
  elif [ "${C_DA_CB_WEBSERVER_SOFTWARE}" == "apache" ]; then
    msg "$(s magenta)Restarting httpd for new httpd config ...$(e)" --caller="${SCRIPT_NAME}"
    systemctl restart httpd
  elif [ "${C_DA_CB_WEBSERVER_SOFTWARE}" == "openlitespeed" ]; then
    :
  else
    :
  fi
}

# start_execute_options <option> <label or function_name>
start_execute_options() {
  local option func_name executed_function
  option="$1"
  func_name="$2"
  executed_function="${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed"
  #echo "executed_function ::: ${executed_function}"
  FUNCTION_RUN=false
  SKIP_RUN=false
  if [[ "${option}" == "--skip-mark" || "${option}" == "--skip-mark-exit" ]]; then
    cat /dev/null >"${executed_function}"
    SKIP_RUN=true
  elif [[ "${option}" == "--skip" || "${option}" == "--skip-exit" ]]; then
    SKIP_RUN=true
  elif [[ "${option}" == "--run-force" || "${option}" == "--run-force-exit" ]]; then
    rm -rf "${executed_function}"
    FUNCTION_RUN=true
  elif [[ -z "${option}" || "${option}" == "--run" || "${option}" == "--run-exit" ]]; then
    FUNCTION_RUN=true
  fi

  if [[ "${FUNCTION_RUN}" == "true" && "${SKIP_RUN}" == "false" ]]; then
    # exec_time start "${func_name}"
    if [ ! -f "${executed_function}" ]; then
      msg "$(s green)Executing $(s magenta)${func_name}$(e) $(s cyan)with option ${option} ...$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s green)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
      echo ""
    fi
  elif [[ "${SKIP_RUN}" == "true" ]]; then
    msg "$(s yellow)[Skipped by user]: $(s magenta)${func_name}$(e) $(s yellow)has skip option: ${option} ...$(e)" --caller="${SCRIPT_NAME}"
    msg "$(s red)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
    echo ""
  fi

}

# end_execute_options <option> <label or function_name>
end_execute_options() {
  local run_mode func_name
  run_mode="$1"
  func_name="$2"
  if [[ "$(echo "${run_mode}" | awk -F'-' '{ print $NF}')" == "exit" ]]; then
    echo ""
    msg "$(s red)[Terminated]: $(s magenta)${func_name} $(s red)has exit option: ${run_mode} ...$(e)" --caller="${SCRIPT_NAME}"
    exit 0
  fi
  # exec_time total "${func_name}"
  echo ""
  echo ""
}

# This will run pre installation for local os
update_local_os() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    # Run update for local OS
    _confirm "Hello, it seems like this is your first time running this script. It is necessary to update your OS and install required components in order to deploy a new server remotely. Continue? [Y/y]: "
    msg "$(s cyan)Updating and upgrading ${DISTRO_ID^} OS ...$(e)" --caller="${SCRIPT_NAME}"
    if [[ "${DISTRO_ID}" == +(centos|almalinux|rockylinux) ]]; then
      dnf -y update
      dnf -y upgrade
    elif [[ "${DISTRO_ID}" == +(debian|ubuntu) ]]; then

      apt-get -y update
      apt-get -y upgrade
    else
      msg "$(s red)Error, unknown value for distribution ID ${DISTRO_ID}. This distribution ID is not supported!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    echo ""

    check_finish_reboot "${func_name}"
  fi
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This is the setup pre function for remote setup
# This function will install all required packages for remote server
# Remember that this required packages must be present even it is not in used
# To only install specific package, use required() function
setup_pre() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    if [ "${DISTRO_ID}" == "centos" ]; then
      msg "$(s magenta)Disabling SELinux policy on CentOS...$(e)" --caller="${SCRIPT_NAME}"
      setenforce 0
      if [ -e /etc/selinux/config ]; then
        sed -i s/^SELINUX=.*$/SELINUX=disabled/ /etc/selinux/config
      fi
      if [ -e /usr/sbin/setenforce ]; then
        /usr/sbin/setenforce 0
      fi
    elif [ "${DISTRO_ID}" == "debian" ]; then
      # Known usability bug from Debian installer with old grub-pc
      # This only show when you have kernel set to GRUB 2
      # Fixed grub-pc appear interactive GUI when running dist-upgrade https://github.com/hashicorp/vagrant/issues/289
      # This is the Debian usability bug for grub as explained in here:
      # https://askubuntu.com/questions/23418/what-do-i-select-for-grub-install-devices-after-an-update#comment837055_23418

      msg "$(s cyan)Updating and upgrading ${DISTRO_ID^} OS ...$(e)" --caller="${SCRIPT_NAME}"
      apt-get -y update
      apt-get -y upgrade
      echo ""

      # Note 1: By default sudo is not installed in custom distribution. It's needed for new OS
      # Note 2: psmisc is a pstree utils (needed by maxigpg script from maxicode)
      # Note 3: dnsutils contains dig command is used to find public IP
      # Note 4: net-tools for using with netstat (port troubleshooting)
      # Note 5: rsync for file transfer and backup (better than scp)
      # Note 6: dos2unix is for conversion clrf to unix format (needed by maxiaide script from maxicode)
      # Note 7: ncdu is for file management
      # Note 8: gcc is needed to compile program from source. (eg meson build need gcc to compile ipcalc c code)
      # Note 9: curl is needed on most system (for directadmin, we will use custombuild, so this will be removed before installation)
      # Note 10: wget is needed on most system
      # Note 11: ipvc6calc is used by directadmin API, maxiwall and other scripts (important to have)
      # Note 12: bsd-mailx for mail (AIDE will install this too)
      msg "$(s cyan)Installing pre-requisite components for ${DISTRO_ID^} OS ...$(e)" --caller="${SCRIPT_NAME}"
      apt-get -y install git sudo nmap psmisc unzip zip dnsutils net-tools rsync dos2unix ncdu meson htop gcc curl wget ipv6calc bsd-mailx
      echo ""

      # Another build here

    elif

      [ "${DISTRO_ID}" == "ubuntu" ]
    then
      :
    elif [ "${DISTRO_ID}" == "almalinux" ]; then
      :
    else
      msg "$(s red)Error, unknown value for distribution ID ${DISTRO_ID}. This distribution ID is not supported!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Install missing os requirement, such as sendmail
upgrade_os() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    # General OS upgrade
    if [[ "${DISTRO_ID}" == "centos" ]]; then
      msg "$(s cyan)Updating operating CentOS system ...$(e)" --caller="${SCRIPT_NAME}"
      sudo dnf -y update
      sudo dnf -y install epel-release
      # Remember now use powertools not PowerTools. This is bug found in CentOS repo 2 days ago: https://bugs.centos.org/view.php?id=17920
      dnf config-manager --set-enabled powertools
    elif [ "${DISTRO_ID}" == "debian" ]; then
      # Known usability bug from Debian installer with old grub-pc
      # Fixed grub-pc appear interactive GUI when running dist-upgrade https://github.com/hashicorp/vagrant/issues/289
      # This is the Debian usability bug for grub as explained in here:
      # https://askubuntu.com/questions/23418/what-do-i-select-for-grub-install-devices-after-an-update#comment837055_23418
      # This only show when you have kernel set to GRUB 2
      msg "$(s cyan)Updating Debian operating system ...$(e)" --caller="${SCRIPT_NAME}"
      apt-get -y update
      apt-get -y dist-upgrade
      apt-get -y autoremove
      apt clean
    else
      msg "$(s red)Error, unknown value for distribution ID ${DISTRO_ID}. This distribution ID is not supported!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    # Install other components based on installation type and distribution:
    if [ "${C_SERVER_TYPE}" == "general" ]; then
      if [ "${DISTRO_ID}" == "centos" ]; then
        msg "$(s cyan)Installing system required components for CentOS General setup ...$(e)" --caller="${SCRIPT_NAME}"
        # Separate this installation because they are categorized in requirement
        sudo dnf -y install sendmail tar bind-utils git curl gcc make libevent-devel zlib-devel openssl-devel pcre2-devel wget
        sudo dnf -y install bc htop ncdu
        echo ""
        msg "$(s cyan)Installing perl dependencies ...$(e)" --caller="${SCRIPT_NAME}"
        sudo dnf -y install @perl perl-libwww-perl net-tools perl-LWP-Protocol-https
      elif [ "${DISTRO_ID}" == "debian" ]; then
        msg "$(s cyan)Installing system required components for Debian General setup ...$(e)" --caller="${SCRIPT_NAME}"
        # Separate this installation because they are categorized in requirement
        # curl is needed especially to download lynis latest version
        apt-get -y install curl
      else
        msg "$(s red)Error, unknown value for distribution ID ${DISTRO_ID}. The distribution ID is not supported!$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi
    elif [ "${C_SERVER_TYPE}" == "directadmin" ]; then
      if [ "${DISTRO_ID}" == "centos" ]; then
        #msg "$(s cyan)Installing system required components for CentOS Directadmin setup ...$(e)" --caller="${SCRIPT_NAME}"
        : # will determine (but RIP CentOS)
      elif [ "${DISTRO_ID}" == "debian" ]; then
        msg "$(s cyan)Installing system required components for Debian Directadmin setup ...$(e)" --caller="${SCRIPT_NAME}"
        # Separate this installation because they are categorized in requirement
        apt-get -y install ipv6calc
      else
        msg "$(s red)Error, unknown value for distribution ID ${DISTRO_ID}. The distribution ID is not supported!$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi
    elif [ "${C_SERVER_TYPE}" == "laravel" ]; then
      :
      # install laravel requirement here
    elif [ "${C_SERVER_TYPE}" == "magento" ]; then
      :
      # install magento requirement here
    elif [ "${C_SERVER_TYPE}" == "joomla" ]; then
      :
      # install joomla requirement here
    elif [ "${C_SERVER_TYPE}" == "odoo" ]; then
      :
      # install odoo requirement here
    elif [ "${C_SERVER_TYPE}" == "prestashop" ]; then
      :
      # install prestashop requirement here
    else
      msg "$(s red)Error, unknown server installation type ${C_SERVER_TYPE}. The server installation type is not supported!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# For managing notification (eg. pushover, gotify)
# Note 1: This is for push notification (eg: to receive notification via android phone)
# TODO 1 put httpd layer password
# TODO 2 Find a way to add 2 step authentication
# TODO 3 change default admin to something else that is secure
# TODO need to use https
configure_gotify() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    if [ "${C_GOTIFY_INSTALLATION}" == "true" ]; then

      local script_install_path gotify_http_port gotify_https_port gotify_server_config

      script_install_path="/usr/local/opencode/gotify"
      gotify_server_config="${script_install_path}/server/config.yml"

      msg "$(s cyan)Installing Gotify and required components ...$(e)" --caller="${SCRIPT_NAME}"

      maxibuild --include "gotify-server,gotify-client,jq"
      echo ""

      gotify_http_port=$(yq eval '.server.port' ${gotify_server_config})
      gotify_https_port=$(yq eval '.server.ssl.port' ${gotify_server_config})

      msg "$(s cyan)Gotify http port is ${gotify_http_port}$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s cyan)Gotify https port is ${gotify_https_port}$(e)" --caller="${SCRIPT_NAME}"

      msg "$(s cyan)Changing the gotify current http port ${gotify_http_port} to ${C_GOTIFY_PORT} ... $(e)" --caller="${SCRIPT_NAME}"
      GOTIFY_PORT="${C_GOTIFY_PORT}" yq -i eval '.server.port = env(GOTIFY_PORT)' "${gotify_server_config}"

      msg "$(s cyan)Changing the gotify current https port ${gotify_https_port} to ${C_GOTIFY_SSL_PORT} ... $(e)" --caller="${SCRIPT_NAME}"
      GOTIFY_SSL_PORT="${C_GOTIFY_SSL_PORT}" yq -i eval '.server.ssl.port = env(GOTIFY_SSL_PORT)' "${gotify_server_config}"

      msg "$(s cyan)Changing the gotify current admin username to ${C_GOTIFY_ADMIN_USERNAME} ... $(e)" --caller="${SCRIPT_NAME}"
      GOTIFY_ADMIN_USERNAME="${C_GOTIFY_ADMIN_USERNAME}" yq -i eval '.defaultuser.name = env(GOTIFY_ADMIN_USERNAME)' "${gotify_server_config}"

      msg "$(s cyan)Changing the gotify current admin password to ${C_GOTIFY_ADMIN_PASSWORD} ... $(e)" --caller="${SCRIPT_NAME}"
      GOTIFY_ADMIN_PASSWORD="${C_GOTIFY_ADMIN_PASSWORD}" yq -i eval '.defaultuser.pass = env(GOTIFY_ADMIN_PASSWORD)' "${gotify_server_config}"

      exit 1

      msg "$(s cyan)Starting ${gotify_service_name}.service and giving 5 seconds extra wait time ...$(e)" --caller="${SCRIPT_NAME}"
      systemctl start ${gotify_service_name}
      sleep 5
      echo ""
      msg "$(s cyan)Testing gotify login using new user credential ...$(e)" --caller="${SCRIPT_NAME}"
      response=$(curl -sSf --user "${C_GOTIFY_ADMIN_USERNAME}:${C_GOTIFY_ADMIN_PASSWORD}" "http://${C_BOX_HOSTNAME_FQHN}:${C_GOTIFY_PORT}/current/user" || echo "$?")
      # Number of response if have 3 digit: that means, this is error. eg 403 411
      if ((${#response} < 4)); then
        msg "$(s red)Error, login failed! Please inspect why and re-run this script to continue$(e)" --caller="${SCRIPT_NAME}"
        #echo "response: ${response}"
        #echo "#response: ${#response}"
        exit 1
      else
        msg "$(s green)OK, login success!$(e)" --caller="${SCRIPT_NAME}"
        msg "$(s green)You can install gotify client application from Google Play store and put the following credentials:$(e)" --caller="${SCRIPT_NAME}"
        msg "$(s magenta)==================================$(e)"
        msg "URL: http://${C_BOX_HOSTNAME_FQHN}:${C_GOTIFY_PORT}"
        msg "Username: ${C_GOTIFY_USERNAME}"
        msg "Password: ${C_GOTIFY_PASSWORD}"
        msg "$(s magenta)==================================$(e)"
        _pause 10
        #echo "response: ${response}"
        #echo "#response: ${#response}"
      fi
      echo ""
      msg "$(s cyan)Creating gotify application token ...$(e)" --caller="${SCRIPT_NAME}"
      response=$(curl -sSf -X POST -H "Content-Type: application/json" --user "${C_GOTIFY_USERNAME}:${C_GOTIFY_PASSWORD}" "http://${C_BOX_HOSTNAME_FQHN}:${C_GOTIFY_PORT}/application" --data "{\"description\": \"${C_GOTIFY_APP_DESCRIPTION}\",  \"name\": \"${C_GOTIFY_APP_NAME}\"}")
      app_token=$(echo "${response}" | awk 'BEGIN { FS="\""; RS="," }; { if($2 == "token") {print $4} }')
      #echo "${app_token}"
      if ((${#response} < 4)); then
        msg "$(s red)Error, token creation failed! Please inspect why and re-run this script to continue$(e)" --caller="${SCRIPT_NAME}"

        exit 1
      else
        msg "$(s green)OK, token created!$(e)" --caller="${SCRIPT_NAME}"
      fi
      echo ""

      msg "$(s cyan)Testing gotify push using application token created ...$(e)" --caller="${SCRIPT_NAME}"
      response=$(curl -sSf -X POST -H "Content-Type: application/json" -H "X-Gotify-Key: ${app_token}" "http://${C_BOX_HOSTNAME_FQHN}:${C_GOTIFY_PORT}/message" -d "{  \"message\": \"testMessage\",  \"priority\": 0,  \"title\": \"gotify@${C_BOX_HOSTNAME_FQHN}\"}" || echo "$?")
      if ((${#response} < 4)); then
        msg "$(s red)Error, test gotify push using application token failed! Please inspect why and re-run this script to continue$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      else
        msg "$(s green)OK, test gotify push using application token success!$(e)" --caller="${SCRIPT_NAME}"
      fi
      echo ""

      msg "$(s cyan)Downloading gotify-cli v${C_GOTIFY_CLI_VERSION} into /usr/local/bin/gotify... $(e)" --caller="${SCRIPT_NAME}"
      curl -Lo /usr/local/bin/gotify https://github.com/gotify/cli/releases/download/v${C_GOTIFY_CLI_VERSION}/gotify-cli-linux-amd64
      echo ""
      msg "$(s cyan)Correcting gotify-cli permission for execution ... $(e)" --caller="${SCRIPT_NAME}"
      chmod +x /usr/local/bin/gotify
      echo ""
      msg "$(s cyan)Writing gotify-cli config file to use token ... $(e)" --caller="${SCRIPT_NAME}"
      mkdir -p "/etc/gotify"
      echo -e "{\n\t\"token\": \"${app_token}\",\n\t\"url\": \"http://${C_BOX_HOSTNAME_FQHN}:${C_GOTIFY_PORT}\",\n\t\"defaultPriority\": 0\n}" >"${gotify_config_cli}"
      echo ""
      msg "$(s cyan)Testing gotify-cli to push simple message ... $(e)" --caller="${SCRIPT_NAME}"
      gotify push -t "${SCRIPT_NAME}@${C_BOX_HOSTNAME_FQHN}" -p 10 "If you can read this notification, it means gotify has been successfully installed"
      retval=$?
      if [ ${retval} -eq 0 ]; then
        msg "$(s green)OK, gotify-cli push using application token is success!$(e)" --caller="${SCRIPT_NAME}"
      else
        msg "$(s red)Error, gotify-cli push using application token has error!$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi

      msg "$(s yellow)[Skipped], C_GOTIFY_INSTALLATION is not set to true. Gotify will not be installed! If you want to install later, run this function again with option --run-force$(e)" --caller="${SCRIPT_NAME}"
    fi

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"

  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_yq() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    if [[ "${C_YQ_VERSION}" != "false" ]]; then
      maxibuild --include yq

      echo ""
      msg "$(s cyan)Testing yq ...$(e)" --caller="${SCRIPT_NAME}"

      yq --version
      retval=$?
      if [ ${retval} -eq 0 ]; then
        msg "$(s green)OK, yq has been successfully installed$(e)" --caller="${SCRIPT_NAME}"
      else
        msg "$(s red)Error, yq has error!$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi
    else
      msg "$(s yellow)[Skipped]: Warning, YQ installation is disabled from config file!$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"

  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_aipdb() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local script_install_path
    script_install_path="/usr/local/opencode/aipdb"

    msg "Installing aipdb ..."
    maxibuild --include aipdb
    echo ""

    msg "Copying sample config file ..."
    cp "${script_install_path}/aipdb.conf.sample" "${script_install_path}/aipdb.conf"
    get_status_message "$?"
    echo ""

    msg "Configuring API authentication ..."
    sed -i "s|^ABUSEIPDB_REPORT_THRESHOLD\=.*|ABUSEIPDB_REPORT_THRESHOLD=\"${C_ABUSEIPDB_REPORT_THRESHOLD}\"|" "${script_install_path}/aipdb.conf"
    sed -i "s|^ABUSEIPDB_OUTPUT_MAX_LIMIT\=.*|ABUSEIPDB_OUTPUT_MAX_LIMIT=\"${C_ABUSEIPDB_OUTPUT_MAX_LIMIT}\"|" "${script_install_path}/aipdb.conf"
    sed -i "s|^ABUSEIPDB_API_CHECK_URL\=.*|ABUSEIPDB_API_CHECK_URL=\"${C_ABUSEIPDB_API_CHECK_URL}\"|" "${script_install_path}/aipdb.conf"
    sed -i "s|^ABUSEIPDB_API_REPORT_URL\=.*|ABUSEIPDB_API_REPORT_URL=\"${C_ABUSEIPDB_API_REPORT_URL}\"|" "${script_install_path}/aipdb.conf"
    sed -i "s|^ABUSEIPDB_API_KEY\=.*|ABUSEIPDB_API_KEY=\"${C_ABUSEIPDB_API_KEY}\"|" "${script_install_path}/aipdb.conf"
    get_status_message "$?"
    echo ""

    msg "$(s cyan)Testing aipdb ...$(e)" --caller="${SCRIPT_NAME}"
    aipdb --version
    retval=$?

    if [ ${retval} -eq 0 ]; then
      msg "$(s green)OK, aipdb has been successfully installed!$(e)" --caller="${SCRIPT_NAME}"
    else
      msg "$(s red)Error, aipdb has error!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"

  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_greynoise() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local script_install_path
    script_install_path="/usr/local/opencode/greynoise"

    msg "Installing greynoise ..."
    maxibuild --include greynoise
    echo ""

    msg "Copying sample config file ..."
    cp "${script_install_path}/greynoise.conf.sample" "${script_install_path}/greynoise.conf"
    get_status_message "$?"
    echo ""

    msg "Configuring API authentication ..."
    sed -i "s|^GREYNOISE_OUTPUT_MAX_LIMIT\=.*|GREYNOISE_OUTPUT_MAX_LIMIT=\"${C_GREYNOISE_OUTPUT_MAX_LIMIT}\"|" "${script_install_path}/greynoise.conf"
    sed -i "s|^GREYNOISE_API_CHECK_URL\=.*|GREYNOISE_API_CHECK_URL=\"${C_GREYNOISE_API_CHECK_URL}\"|" "${script_install_path}/greynoise.conf"
    sed -i "s|^GREYNOISE_API_KEY\=.*|GREYNOISE_API_KEY=\"${C_GREYNOISE_API_KEY}\"|" "${script_install_path}/greynoise.conf"
    get_status_message "$?"
    echo ""

    msg "$(s cyan)Testing greynoise ...$(e)" --caller="${SCRIPT_NAME}"
    greynoise --version
    retval=$?

    if [ ${retval} -eq 0 ]; then
      msg "$(s green)OK, greynoise has been successfully installed!$(e)" --caller="${SCRIPT_NAME}"
    else
      msg "$(s red)Error, greynoise has error!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"

  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_virustotal() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local script_install_path

    script_install_path="/usr/local/opencode/virustotal"

    msg "Installing virustotal ..."
    maxibuild --include virustotal
    echo ""

    msg "Copying sample config file ..."
    cp "${script_install_path}/virustotal.conf.sample" "${script_install_path}/virustotal.conf"
    get_status_message "$?"
    echo ""

    msg "Configuring API authentication ..."
    sed -i "s|^VIRUSTOTAL_OUTPUT_MAX_LIMIT\=.*|VIRUSTOTAL_OUTPUT_MAX_LIMIT=\"${C_VIRUSTOTAL_OUTPUT_MAX_LIMIT}\"|" "${script_install_path}/virustotal.conf"
    sed -i "s|^VIRUSTOTAL_API_CHECK_URL\=.*|VIRUSTOTAL_API_CHECK_URL=\"${C_VIRUSTOTAL_API_CHECK_URL}\"|" "${script_install_path}/virustotal.conf"
    sed -i "s|^VIRUSTOTAL_API_KEY\=.*|VIRUSTOTAL_API_KEY=\"${C_VIRUSTOTAL_API_KEY}\"|" "${script_install_path}/virustotal.conf"
    get_status_message "$?"
    echo ""

    msg "$(s cyan)Testing virustotal ...$(e)" --caller="${SCRIPT_NAME}"
    virustotal --version
    retval=$?

    if [ ${retval} -eq 0 ]; then
      msg "$(s green)OK, virustotal has been successfully installed!$(e)" --caller="${SCRIPT_NAME}"
    else
      msg "$(s red)Error, virustotal has error!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"

  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Get the latest scripts (temporarily using git which needs to have private token defined in config)
# This private repo contains lots of security scripts for Linux (c) by Arafat Ali (aka MaXi32)
# can re-run this with option get_latest_code --run-force to force re-clone and update to latest codes
# This function also store 3rd party scripts such as dropbox_uploader
get_latest_code() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local latest_code_version current_code_version
    maxibuild --include "git"
    if ! command -v git &>/dev/null; then
      msg "$(s red)Error, git binary is missing or not installed properly$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi
    # This one work for both CentOS and Debian
    msg "$(s cyan)Configuring git authentication ...$(e)" --caller="${SCRIPT_NAME}"
    echo ""
    cat /dev/null >"${HOME}/.git-askpass"
    echo "#!/bin/bash" >>"${HOME}/.git-askpass"
    echo "echo ${C_GIT_TOKEN}" >>"${HOME}/.git-askpass"
    chmod +x "${HOME}/.git-askpass"
    export GIT_ASKPASS="${HOME}/.git-askpass"

    msg "$(s cyan)Removing ${SCRIPT_NAME} existing repository from ${LATEST_CODE_PATH} ...$(e)" --caller="${SCRIPT_NAME}"
    rm -rf "${LATEST_CODE_PATH}"
    mkdir -p "${LATEST_CODE_PATH}"
    echo ""
    msg "$(s cyan)Cloning new ${SCRIPT_NAME} repository from ${C_SETUP_GIT_URL} ... $(e)" --caller="${SCRIPT_NAME}"
    echo ""
    git clone "${C_SETUP_GIT_URL}" "${LATEST_CODE_PATH}"
    echo ""
    msg "$(s cyan)Checking code version ...$(e)" --caller="${SCRIPT_NAME}"
    current_code_version=$(grep -w "^_APP_VERSION" "${SCRIPT_PATH}/${SCRIPT_NAME}" | cut -d "=" -f 2- | sed -e 's/"//' -e 's/"$//')
    latest_code_version=$(grep -w "^_APP_VERSION" "${LATEST_CODE_PATH}/${SCRIPT_NAME}" | cut -d "=" -f 2- | sed -e 's/"//' -e 's/"$//')
    if [ -n "${latest_code_version}" ]; then
      msg "$(s cyan)Current code version is $(s magenta)v${current_code_version}$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s cyan)Latest code version is $(s magenta)v${latest_code_version}$(e)" --caller="${SCRIPT_NAME}"
    else
      msg "$(s red)Error, could not determine the latest code version! The latest code is needed for this script to work properly$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi
    echo ""
    # After we have the latest source code folder, now we can delete these sensitive files for security
    msg "$(s cyan)Removing current git authentication ...$(e)" --caller="${SCRIPT_NAME}"
    rm -f "${HOME}/.git-askpass"
    unset GIT_ASKPASS
    echo ""

    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi

}

# This function contains the security hardening for Linux
secure_os() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local latest_code_version find_au find_ar user_rsa_public_key
    # This file should exist in the root file after OS has finished installation (preseed file put this file)
    user_rsa_public_key="/root/user_${C_SSH_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub"
    if [ ! -f "${user_rsa_public_key}" ]; then

      msg "$(s yellow)Warning, the RSA public key file ${user_rsa_public_key} not found inside operating system!$(e)" --caller="${SCRIPT_NAME}"

      msg "$(s yellow)Note: ${_APP_SPECIFIC_NAME} will use the user_rsa_public_key from config file. Please make sure this key is up to date$(e)" --caller="${SCRIPT_NAME}"
      _pause 15
      user_rsa_public_key="${C_SSH_PUBLIC_KEY}"
    else
      msg "$(s cyan)Note: ${_APP_SPECIFIC_NAME} will use user RSA public key from /root/user_${C_SSH_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub for ${C_SSH_USERNAME} SSH login ..."
      # Reassign C_SSH_PUBLIC_KEY to the latest SSH key
      user_rsa_public_key=$(cat "${user_rsa_public_key}")
    fi
    echo ""
    msg "$(s cyan)Changing operating system main root password ...$(e)" --caller="${SCRIPT_NAME}"
    if [[ "${DISTRO_ID}" == "centos" || "${DISTRO_ID}" == "almalinux" ]]; then
      echo "${C_ROOT_USERPASS}" | passwd --stdin "${C_ROOT_USERNAME}"
    elif [[ "${DISTRO_ID}" == "debian" ]]; then
      echo "${C_ROOT_USERNAME}:${C_ROOT_USERPASS}" | chpasswd
    else
      msg "$(s red)Error, unknown value for distribution ID ${DISTRO_ID}. This distribution ID is not supported!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi
    echo ""
    msg "$(s cyan)Setting up server hostname to full qualified hostname (FQHN): ${C_BOX_HOSTNAME_FQHN} ...$(e)" --caller="${SCRIPT_NAME}"
    hostnamectl set-hostname "${C_BOX_HOSTNAME_FQHN}"
    msg "$(s magenta)[Testing]: current hostname is $(hostname)$(e)" --caller="${SCRIPT_NAME}"
    echo ""
    msg "$(s cyan)Setting up server timezone to ${C_BOX_TIMEZONE} ...$(e)" --caller="${SCRIPT_NAME}"
    timedatectl set-timezone "${C_BOX_TIMEZONE}"
    msg "$(s magenta)[Testing]: Current date is $(date)$(e)" --caller="${SCRIPT_NAME}"
    echo ""
    if [[ "${DISTRO_ID}" == "centos" || "${DISTRO_ID}" == "almalinux" ]]; then
      msg "$(s cyan)Creating a non-sudo username ${C_SSH_USERNAME} ...$(e)" --caller="${SCRIPT_NAME}"
      adduser "${C_SSH_USERNAME}"
      echo ""
      msg "$(s cyan)Setting up password for non-sudo username ${C_SSH_USERNAME} ...$(e)" --caller="${SCRIPT_NAME}"
      echo "${C_SSH_USERPASS}" | passwd --stdin "${C_SSH_USERNAME}"
      echo ""
      msg "$(s cyan)Adding a non-sudo user ${C_SSH_USERNAME} to the highest privilege group ...$(e)" --caller="${SCRIPT_NAME}"
      gpasswd -a "${C_SSH_USERNAME}" wheel
      echo ""
    elif [ "${DISTRO_ID}" == "debian" ]; then
      msg "$(s cyan)Creating a non-sudo username ${C_SSH_USERNAME} ...$(e)" --caller="${SCRIPT_NAME}"
      useradd "${C_SSH_USERNAME}" -s /bin/bash -m
      echo ""
      msg "$(s cyan)Setting up password for a non-sudo username for ${C_SSH_USERNAME} ...$(e)" --caller="${SCRIPT_NAME}"
      echo "${C_SSH_USERNAME}:${C_SSH_USERPASS}" | chpasswd
      echo ""
      msg "$(s cyan)Adding a non-sudo user ${C_SSH_USERNAME} to the highest privilege group ...$(e)" --caller="${SCRIPT_NAME}"
      usermod -aG sudo "${C_SSH_USERNAME}"
      echo ""
    else
      msg "$(s red)Error, unknown value for distribution ID ${DISTRO_ID}. This distribution ID is not supported$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    # These works with ubuntu, debian, centos (will check more with other distro)
    msg "$(s cyan) Testing login a non-sudo user ${C_SSH_USERNAME} ...$(e)" --caller="${SCRIPT_NAME}"

    msg "$(s magenta) =~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"
    sudo -H -u "${C_SSH_USERNAME}" bash -c 'echo "[Testing]: Hello, I am ${USER}, with uid ${UID}"'
    msg "$(s magenta) =~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"

    # TIP: To remove this non-sudo user we can do this:
    # userdel -r "${C_SSH_USERNAME}" , where -r will also delete his home directory
    msg "$(s cyan)Creating .ssh home directory for a non-sudo user ${C_SSH_USERNAME} to store SSH public key files ...$(e)" --caller="${SCRIPT_NAME}"

    sudo -H -u "${C_SSH_USERNAME}" bash -c "mkdir -p ~/.ssh"
    msg "$(s cyan)Creating an authorized key file ~/.ssh/authorized_keys ...$(e)" --caller="${SCRIPT_NAME}"
    sudo -H -u "${C_SSH_USERNAME}" bash -c "touch ~/.ssh/authorized_keys"
    msg "$(s cyan)Writing an RSA public key into ~/.ssh/authorized_keys ...$(e)" --caller="${SCRIPT_NAME}"
    sudo -H -u "${C_SSH_USERNAME}" bash -c "echo ${user_rsa_public_key} >~/.ssh/authorized_keys"
    msg "$(s cyan) Changing ~/.ssh/authorized_keys permission to chmod 700  ...$(e)" --caller="${SCRIPT_NAME}"
    sudo -H -u "${C_SSH_USERNAME}" bash -c "chmod 700 ~/.ssh/authorized_keys"

    #sed -i "/AllowUsers/c\AllowUsers ${C_SSH_USERNAME}" /etc/ssh/sshd_config
    # For non-sudo user
    find_au=$(grep -w "AllowUsers ${C_SSH_USERNAME}" /etc/ssh/sshd_config)
    if [[ -n "${find_au}" ]]; then
      msg "$(s yellow)[Skipped] the non-sudo user ${C_SSH_USERNAME} is already set as AllowUsers list in sshd_config ...$(e)" --caller="${SCRIPT_NAME}"
    else
      msg "$(s yellow)Adding a non-sudo user ${C_SSH_USERNAME} to AllowUsers list in sshd_config ...$(e)" --caller="${SCRIPT_NAME}"
      echo "AllowUsers ${C_SSH_USERNAME}" >>/etc/ssh/sshd_config
    fi
    echo ""
    # For root user
    find_ar=$(grep -w "AllowUsers ${C_ROOT_USERNAME}" /etc/ssh/sshd_config)
    if [[ -n "${find_ar}" ]]; then
      msg "$(s yellow)[Skipped] root user ${C_ROOT_USERNAME} is already set as AllowUsers list in sshd_config ...$(e)" --caller="${SCRIPT_NAME}"

    else
      # Put at the bottom
      msg "$(s cyan)Adding root user ${C_ROOT_USERNAME} to AllowUsers list in sshd_config ...$(e)" --caller="${SCRIPT_NAME}"

      echo "AllowUsers ${C_ROOT_USERNAME}" >>/etc/ssh/sshd_config
    fi
    echo ""
    # Note: Temporarily allow root login only with cert and with the setting of PermitRootLogin to prohibited-password in sshd_config during installation.
    # Note: The operating system installation might have included the setting PermitRootLogin prohibited-password
    # Note: After finished installation set PermitRootLogin to no
    # This command is left for reference:
    # msg "Disabling root login via sshd_config ..."
    # sed -i '/^PermitRootLogin/s/yes/no/' /etc/ssh/sshd_config
    msg "$(s cyan)Disabling Password authentication via sshd_config ...$(e)" --caller="${SCRIPT_NAME}"
    sed -i "s/^#PasswordAuthentication.*/PasswordAuthentication no/" /etc/ssh/sshd_config
    echo ""
    msg "$(s cyan)Disabling empty password login via sshd_config ...$(e)" --caller="${SCRIPT_NAME}"
    sed -i "s/^#PermitEmptyPasswords.*/PermitEmptyPasswords no/" /etc/ssh/sshd_config
    echo ""
    msg "$(s cyan)Changing SSH default port from 22 to ${C_SSH_PORT} ...$(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)Note, CSF will automatically add this port in allowed list during installation ...$(e)" --caller="${SCRIPT_NAME}"
    sed -i "s/#Port 22/Port ${C_SSH_PORT}/" /etc/ssh/sshd_config
    echo ""
    msg "$(s cyan)Changing SSH to only listen to IPv4 (disable IPv6 SSH login) ...$(e)" --caller="${SCRIPT_NAME}"
    sed -i "s/^#AddressFamily.*/AddressFamily inet/" /etc/ssh/sshd_config
    echo ""
    # Adding login banner
    msg "Setting login banner for issue and issue.net ..."
    create_file "ssh-banner1" "/etc/issue"
    echo ""
    create_file "ssh-banner1" "/etc/issue.net"
    echo ""
    msg "$(s cyan)Enabling login banner in sshd_config ...$(e)" --caller="${SCRIPT_NAME}"
    sed -i "s/^#Banner none/Banner \/etc\/issue/" /etc/ssh/sshd_config
    echo ""
    # Initial firewall configuration
    if [[ "${DISTRO_ID}" == "centos" || "${DISTRO_ID}" == "almalinux" ]]; then
      msg "$(s cyan)Adding SSH port ${C_SSH_PORT}/tcp to firewalld ...$(e)" --caller="${SCRIPT_NAME}"

      sudo firewall-cmd --permanent --zone=public --add-port="${C_SSH_PORT}/tcp"

      echo ""
      msg "$(s cyan)Adding an IP address ${C_HOST_PUBLIC_IP} from config file in firewalld to prevent locked out during setup$(e)" --caller="${SCRIPT_NAME}"

      sudo firewall-cmd --quiet --permanent --add-source="${C_HOST_PUBLIC_IP}"
      msg "$(s cyan)Reloading firewall-cmd ...$(e)" --caller="${SCRIPT_NAME}"
      firewall-cmd --reload

      echo ""
    elif [ "${DISTRO_ID}" == "debian" ]; then
      msg "$(s yellow)Warning, the default debian installation doesn't include any firewalls. UFW for Debian will be installed automatically if it does not exist ...$(e)" --caller="${SCRIPT_NAME}"
      maxibuild --include "ufw"
      echo ""
      msg "$(s cyan)Adding https port (443) to ufw ...$(e)" --caller="${SCRIPT_NAME}"
      sudo ufw allow "https"
      echo ""
      msg "$(s cyan)Adding http port (80) to ufw ...$(e)" --caller="${SCRIPT_NAME}"
      sudo ufw allow "http"
      echo ""
      msg "$(s cyan)Adding SSH port ${C_SSH_PORT}/tcp to ufw ...$(e)" --caller="${SCRIPT_NAME}"
      sudo ufw allow "${C_SSH_PORT}/tcp"
      echo ""
      if [ "${C_GOTIFY_INSTALLATION}" == "true" ]; then
        msg "$(s cyan)Adding gotify port ${C_GOTIFY_PORT}/tcp to ufw ...$(e)" --caller="${SCRIPT_NAME}"
        sudo ufw allow "${C_GOTIFY_PORT}/tcp"
      fi
      echo ""
      msg "$(s cyan)Adding an IP address ${C_HOST_PUBLIC_IP} from config file in ufw to prevent locked out during setup$(e)" --caller="${SCRIPT_NAME}"
      sudo ufw allow from "${C_HOST_PUBLIC_IP}"
      echo ""
      msg "$(s cyan)Enabling ufw firewall ...$(e)" --caller="${SCRIPT_NAME}"
      sudo ufw --force enable
      echo ""
      msg "$(s cyan)Reloading ufw firewall ...$(e)" --caller="${SCRIPT_NAME}"
      sudo ufw reload
      echo ""

    else
      msg "$(s red)Error, unknown value for distribution ID ${DISTRO_ID}. This distribution ID is not supported!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    # Hardening other settings for SSHD_CONFIG
    # Recommended by lynis
    msg "$(s cyan)Setting SSH LogLevel variable in sshd_config to VERBOSE ...$(e)" --caller="${SCRIPT_NAME}"
    sed -i "s/^#LogLevel.*/LogLevel VERBOSE/" /etc/ssh/sshd_config
    echo ""
    # Recommended by lynis
    msg "$(s cyan)Setting SSH MaxAuthTries variable in sshd_config to 5 ...$(e)" --caller="${SCRIPT_NAME}"
    sed -i "s/^#MaxAuthTries.*/MaxAuthTries 5/" /etc/ssh/sshd_config
    echo ""
    # Recommended by lynis
    msg "$(s cyan)Setting SSH MaxSessions variable in sshd_config to 10 ...$(e)" --caller="${SCRIPT_NAME}"
    sed -i "s/^#MaxSessions.*/MaxSessions 10/" /etc/ssh/sshd_config
    echo ""
    # This one recommended by CSF security page:
    msg "$(s cyan)Setting SSH UseDNS variable in sshd_config to no ...$(e)" --caller="${SCRIPT_NAME}"
    sed -i "s/^#UseDNS.*/UseDNS no/" /etc/ssh/sshd_config
    echo ""
    # Restart SSHD
    msg "$(s cyan)Restarting sshd service to apply new settings ...$(e)" --caller="${SCRIPT_NAME}"
    # This works with debian, ubuntu and centos
    systemctl reload sshd
    echo ""
    msg "$(s cyan)Removing public key ${user_rsa_public_key} ...$(e)" --caller="${SCRIPT_NAME}"
    rm -f "${user_rsa_public_key}"
    echo ""
    msg "$(s green)[OK]: The host ${C_BOX_HOSTNAME_FQHN} is now secured with basic security hardening protection$(e)" --caller="${SCRIPT_NAME}"
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_grub() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local grep_existing grub_hash_password grub_make_pass_bin retval

    if [ "${C_SECURE_GRUB}" == "true" ]; then
      msg "$(s cyan)Notice, C_SECURE_GRUB is set in config file. Configuring Grub password protection bootloader ...$(e)" --caller="${SCRIPT_NAME}"
      grub_make_pass_bin=$(command -v grub-mkpasswd-pbkdf2)
      grub_hash_password=$(echo -e "${C_GRUB_PASS}\n${C_GRUB_PASS}" | ${grub_make_pass_bin} | awk '/grub.pbkdf/{print$NF}')
      grep_existing=$(grep -i "password_pbkdf2" /etc/grub.d/00_header)
      if [[ -z "${grep_existing}" ]]; then
        msg "$(s cyan)Writing grub username and password inside /etc/grub.d/00_header ...$(e)" --caller="${SCRIPT_NAME}"
        {
          echo "cat << EOF"
          echo "set superusers=\"${C_GRUB_UNAME}\""
          echo "password_pbkdf2 ${C_GRUB_UNAME} ${grub_hash_password}"
          echo "EOF"
        } >>/etc/grub.d/00_header
        echo ""
        msg "$(s cyan)Updating grub loader ...$(e)" --caller="${SCRIPT_NAME}"
        grub-mkconfig -o /boot/grub/grub.cfg
        retval=$?
        if [ "${retval}" -ne 0 ]; then
          msg "$(s red)Error, there was a problem when compiling new grub config$(e)" --caller="${SCRIPT_NAME}"
          exit 1
        fi
        #or use this: sudo update-grub
      else
        msg "$(s yellow)Warning, failed to configure grub password because there is already a grub password setting configured in /etc/grub.d/00_header.$(e)" --caller="${SCRIPT_NAME}"
      fi
    else
      msg "$(s yellow)[Skipped]: Notice, grub password protection C_SECURE_GRUB is not set, setup will skip enabling GRUB bootloader password protection!$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This one configuration hostname, network etc.
configure_net() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local current_active_lan grub_search
    msg "$(s cyan)Obtaining current active LAN interface ...$(e)" --caller="${SCRIPT_NAME}"
    # LAN can have one or more
    current_active_lan=$(ip route get 1.1.1.1 | grep -Po '(?<=dev\s)\w+' | cut -f1 -d ' ')
    # ip addr | awk '/state UP/ {print $2}' | sed 's/.$//'
    if [ "${current_active_lan}" == "${C_NIC_INTERFACE_NAME}" ]; then
      msg "$(s cyan)[Skipped]: OK, the current LAN interface name is equal with the value of C_NIC_INTERFACE_NAME from config file$(e)" --caller="${SCRIPT_NAME}"
    else
      msg "$(s yellow)Warning, the current LAN interface is emulated with ${current_active_lan} but the config variable C_NIC_INTERFACE_NAME is set to use interface ${C_NIC_INTERFACE_NAME}$(e)" --caller="${SCRIPT_NAME}"
      if [[ "${C_NIC_INTERFACE_NAME}" == "eth0" ]]; then
        msg "$(s cyan)Modifying grub file to disable interface name convention (revert to default name as eth0) ...$(e)" --caller="${SCRIPT_NAME}"
        # sed -i 's/rhgb quiet/net.ifnames=0 biosdevname=0/' /etc/default/grub
        grub_search=$(grep -Ec 'GRUB_CMDLINE_LINUX=.*net.ifnames|GRUB_CMDLINE_LINUX_DEFAULT=.*net.ifnames' /etc/default/grub)
        if [ "${grub_search}" -eq 0 ]; then
          grub_search=$(grep -Ec 'GRUB_CMDLINE_LINUX=""' /etc/default/grub)
          if [ "${grub_search}" -eq 0 ]; then
            msg "$(s cyan)Appending net.ifnames=0 for GRUB_CMDLINE_LINUX in /etc/default/grub ...$(e)" --caller="${SCRIPT_NAME}"
            sed -i 's/GRUB_CMDLINE_LINUX="[^"]*/& net.ifnames=0/' /etc/default/grub
          else
            # Adding new value (not appending)
            msg "$(s cyan)Adding new value net.ifnames=0 for GRUB_CMDLINE_LINUX in /etc/default/grub ...$(e)" --caller="${SCRIPT_NAME}"
            sed -i 's/GRUB_CMDLINE_LINUX=""/GRUB_CMDLINE_LINUX="net.ifnames=0"/g' /etc/default/grub
          fi
        else
          msg "$(s yellow)[Skipped]: The value 'biosdevname' has been set previously for GRUB_CMDLINE_LINUX or GRUB_CMDLINE_LINUX_DEFAULT in /etc/default/grub ...$(e)" --caller="${SCRIPT_NAME}"
        fi

        grub_search=$(grep -Ec 'GRUB_CMDLINE_LINUX=.*biosdevname|GRUB_CMDLINE_LINUX_DEFAULT=.*biosdevname' /etc/default/grub)
        if [ "${grub_search}" -eq 0 ]; then
          grub_search=$(grep -Ec 'GRUB_CMDLINE_LINUX=""' /etc/default/grub)
          if [ "${grub_search}" -eq 0 ]; then
            msg "$(s cyan)Appending biosdevname=0 for GRUB_CMDLINE_LINUX in /etc/default/grub ...$(e)" --caller="${SCRIPT_NAME}"
            sed -i 's/GRUB_CMDLINE_LINUX="[^"]*/& biosdevname=0/' /etc/default/grub
          else
            # Adding new value (not appending)
            msg "$(s cyan)Adding new value biosdevname=0 for GRUB_CMDLINE_LINUX in /etc/default/grub ...$(e)" --caller="${SCRIPT_NAME}"
            sed -i 's/GRUB_CMDLINE_LINUX=""/GRUB_CMDLINE_LINUX="biosdevname=0"/g' /etc/default/grub
          fi
        else
          msg "$(s yellow)[Skipped]: The value 'biosdevname' has been set previously for GRUB_CMDLINE_LINUX or GRUB_CMDLINE_LINUX_DEFAULT in /etc/default/grub ...$(e)" --caller="${SCRIPT_NAME}"
        fi

        # Enabling serial terminal
        grub_search=$(grep -Ec 'GRUB_CMDLINE_LINUX=.*console|GRUB_CMDLINE_LINUX_DEFAULT=.*console' /etc/default/grub)
        if [ "${grub_search}" -eq 0 ]; then
          grub_search=$(grep -Ec 'GRUB_CMDLINE_LINUX=""' /etc/default/grub)
          if [ "${grub_search}" -eq 0 ]; then
            msg "$(s cyan)Appending console=ttyS0,19200n8 for GRUB_CMDLINE_LINUX in /etc/default/grub ...$(e)" --caller="${SCRIPT_NAME}"
            sed -i 's/GRUB_CMDLINE_LINUX="[^"]*/& console=ttyS0,19200n8/' /etc/default/grub
          else
            # Adding new value (not appending)
            msg "$(s cyan)Adding new value console=ttyS0,19200n8 for GRUB_CMDLINE_LINUX in /etc/default/grub ...$(e)" --caller="${SCRIPT_NAME}"
            sed -i 's/GRUB_CMDLINE_LINUX=""/GRUB_CMDLINE_LINUX="console=ttyS0,19200n8"/g' /etc/default/grub
          fi
        else
          msg "$(s yellow)[Skipped]: The value 'console' has been set previously for GRUB_CMDLINE_LINUX or GRUB_CMDLINE_LINUX_DEFAULT in /etc/default/grub ...$(e)" --caller="${SCRIPT_NAME}"
        fi

        echo ""

        # Enabling serial terminal 1
        msg "$(s cyan)Enabling GRUB serial terminal 1 ...$(e)" --caller="${SCRIPT_NAME}"
        grub_search=$(grep -Ec '^GRUB_SERIAL_COMMAND=' /etc/default/grub)
        if [ "${grub_search}" -eq 0 ]; then
          msg "$(s cyan)Creating empty variable GRUB_SERIAL_COMMAND= ...$(e)" --caller="${SCRIPT_NAME}"
          echo "GRUB_SERIAL_COMMAND=\"\"" >>/etc/default/grub
        fi
        grub_search=$(grep -Ec 'GRUB_SERIAL_COMMAND=.*serial' /etc/default/grub)
        if [ "${grub_search}" -eq 0 ]; then
          grub_search=$(grep -Ec 'GRUB_SERIAL_COMMAND=""' /etc/default/grub)
          if [ "${grub_search}" -eq 0 ]; then
            # In case if this option need appending
            msg "$(s cyan)Appending serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1 for GRUB_SERIAL_COMMAND in /etc/default/grub ...$(e)" --caller="${SCRIPT_NAME}"
            sed -i 's/GRUB_SERIAL_COMMAND="[^"]*/& serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1/' /etc/default/grub
          else
            # Adding new value (not appending)
            msg "$(s cyan)Adding new value serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1 for GRUB_SERIAL_COMMAND in /etc/default/grub ...$(e)" --caller="${SCRIPT_NAME}"
            sed -i 's/GRUB_SERIAL_COMMAND=""/GRUB_SERIAL_COMMAND="serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1"/g' /etc/default/grub
          fi
        else
          msg "$(s yellow)[Skipped]: The value 'serial' has been set previously for GRUB_SERIAL_COMMAND in /etc/default/grub ...$(e)" --caller="${SCRIPT_NAME}"
        fi

        echo ""
        # Enabling serial terminal 2
        msg "$(s cyan)Enabling GRUB serial terminal 2 ...$(e)" --caller="${SCRIPT_NAME}"
        grub_search=$(grep -Ec '^GRUB_TERMINAL=' /etc/default/grub)
        if [ "${grub_search}" -eq 0 ]; then
          echo "$(s cyan)Creating empty variable GRUB_TERMINAL= ...$(e)" --caller="${SCRIPT_NAME}"
          echo "GRUB_TERMINAL=" >>/etc/default/grub
        fi
        grub_search=$(grep -Ec 'GRUB_TERMINAL=serial' /etc/default/grub)
        if [ "${grub_search}" -eq 0 ]; then
          # Adding new value (not appending)
          msg "$(s cyan)Adding new value GRUB_TERMINAL=serial for GRUB_TERMINAL in /etc/default/grub ...$(e)" --caller="${SCRIPT_NAME}"
          sed -i 's/GRUB_TERMINAL=/GRUB_TERMINAL=serial/g' /etc/default/grub
        else
          msg "$(s yellow)[Skipped]: The value 'serial' has been set previously for GRUB_TERMINAL in /etc/default/grub ...$(e)" --caller="${SCRIPT_NAME}"
        fi
        echo ""
        msg "$(s cyan)Recompiling grub boot loader for new config ...$(e)" --caller="${SCRIPT_NAME}"
        if [[ "${DISTRO_ID}" == "centos" || "${DISTRO_ID}" == "almalinux" ]]; then
          # Recompile grub centos command
          grub2-mkconfig -o /boot/grub2/grub.cfg
          # Need to reboot here
        elif [ "${DISTRO_ID}" == "debian" ]; then
          # Recompile grub debian command
          grub-mkconfig -o /boot/grub/grub.cfg
        else
          msg "$(s red)Error, unknown value for distribution ID ${DISTRO_ID}. This distribution ID is not supported$(e)" --caller="${SCRIPT_NAME}"
          exit 1
        fi
      else
        # Rename interface other than eth0
        msg "$(s yellow)Notice, the new LAN interface is set to ${C_NIC_INTERFACE_NAME} in config file$(e)" --caller="${SCRIPT_NAME}"
        # Or recommend to use screen
        msg "$(s cyan)Executing configure_net2 with --run-force option to setup system network interface to ${C_NIC_INTERFACE_NAME} before rebooting to prevent locked out ...$(e)" --caller="${SCRIPT_NAME}"
        configure_net2 --run-force
        echo ""
        msg "$(s cyan)Creating background script ${CODE_PATH}/ssh_scripts/lan_interface_rename.sh to rename LAN interface when the SSH disconnected ...$(e)" --caller="${SCRIPT_NAME}"
        mkdir -p "${CODE_PATH}/ssh_scripts"
        {
          echo "#!/bin/bash"
          echo "echo \"Turning off current LAN ${current_active_lan} interface ...\""
          echo "ip link set \"${current_active_lan}\" down"
          echo "echo \"Renaming ${current_active_lan} to ${C_NIC_INTERFACE_NAME} ...\""
          echo "ip link set \"${current_active_lan}\" name \"${C_NIC_INTERFACE_NAME}\""
          echo "echo \"Renaming interface file ifcfg-${current_active_lan} to ifcfg-${C_NIC_INTERFACE_NAME} ...\""
          echo "mv /etc/sysconfig/network-scripts/ifcfg-{\"${current_active_lan}\",\"${C_NIC_INTERFACE_NAME}\"}"
          echo "echo \"Turning on the new LAN interface ${C_NIC_INTERFACE_NAME} ...\""
          echo "ip link set \"${C_NIC_INTERFACE_NAME}\" up"
          echo "echo \"Rebooting ...\""
          echo "reboot --force"
          echo ""
        } >"${CODE_PATH}/ssh_scripts/lan_interface_rename.sh"
        echo ""
        msg "$(s cyan)Allowing execution permission for background script ${CODE_PATH}/ssh_scripts/lan_interface_rename.sh ...$(e)" --caller="${SCRIPT_NAME}"
        chmod +x "${CODE_PATH}/ssh_scripts/lan_interface_rename.sh"
        echo ""
        msg "$(s red)*Warning$(s yellow), background script will be executed to rename network interface to ${C_NIC_INTERFACE_NAME} ...$(e)" --caller="${SCRIPT_NAME}"
        msg "$(s red)**Warning$(s yellow), active LAN interface ${current_active_lan} will be disconnected ...$(e)" --caller="${SCRIPT_NAME}"
        msg "$(s red)***Warning$(s yellow), the current active network needs to be turned off in order to be able to rename a new LAN interface$(e)" --caller="${SCRIPT_NAME}"
        sleep 2
        msg "$(s red)****Warning$(s yellow), If you are on SSH connection, you will be disconnected from SSH but the background script will run$(e)" --caller="${SCRIPT_NAME}"
        sleep 2
        msg "$(s red)*****Warning$(s yellow), you will not see any output of the background process, but when it has finished running, the system will reboot automatically.$(e)" --caller="${SCRIPT_NAME}"
        msg "$(s yellow)You can re-run this script again with action setup to recheck whether the interface is configured correctly before proceeding to the next step$(e)" --caller="${SCRIPT_NAME}"
        # Because the script reboot, we need to re-run this function to check if interface is already set like in the config file
        _pause 30
        msg "$(s cyan)Executing background script ${CODE_PATH}/ssh_scripts/lan_interface_rename.sh to rename interface via ip link command and rebooting system automatically ...$(e)" --caller="${SCRIPT_NAME}"
        nohup sh "${CODE_PATH}/ssh_scripts/lan_interface_rename.sh" >/dev/null 2>&1 &
        while :; do
          # This will display until it reboots itself,
          sleep 1
          msg "$(s yellow)Waiting for the system to reboot itself [Do not turn off the server] ...$(e)" --start-spin --caller="${SCRIPT_NAME}"
        done
        # Use return to stop other statements because we only want the script to manage the reboot and other stuff
        return 0
      fi
      echo ""
      msg "$(s yellow)Creating required reboot flag for network interface to revert back to eth0 automatically after reboot ...$(e)" --caller="${SCRIPT_NAME}"
      cat /dev/null >/var/run/reboot-required
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This would change like static IP, resolv.conf etc ...
# I prefer to use eth0 than a strange name like epn${x} but now this script can rename whatever interface you want
configure_net2() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local current_host host_count clean_host
    # So, at this stage we know our LAN would be ${C_NIC_INTERFACE_NAME} then we can insert network information directly into ${C_NIC_INTERFACE_NAME}
    if [[ "${DISTRO_ID}" == "centos" || "${DISTRO_ID}" == "almalinux" ]]; then
      # Create network static IP configuration
      msg "$(s cyan)Inserting static IP information for ${C_NIC_INTERFACE_NAME} at /etc/sysconfig/network-scripts/ifcfg-${C_NIC_INTERFACE_NAME} ...$(e)" --caller="${SCRIPT_NAME}"
      {
        echo "# ==============================================="
        echo "# This configuration file was generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# GENERAL DEVICE CONFIGURATION "
        echo 'TYPE="Ethernet"'
        echo "DEVICE=\"${C_NIC_INTERFACE_NAME}\""
        echo "NAME=\"${C_NIC_INTERFACE_NAME}\""
        echo 'ONBOOT="yes"'
        echo 'BOOTPROTO="none"'
        echo 'PEERDNS="no"'
        # This will generate new UUID for "${C_NIC_INTERFACE_NAME}"
        echo "UUID=$(uuidgen "${C_NIC_INTERFACE_NAME}")"
        echo "DOMAIN=${C_BOX_DOMAIN}"
        echo ""
        echo "# IPv4 Configuration (Public)"
        echo 'IPV4_FAILURE_FATAL="no"'
        echo 'DEFROUTE="yes"'
        echo "IPADDR0=${C_IPV4_ADD0}"
        echo "GATEWAY0=${C_IPV4_DEF_GATEWAY0}"
        echo "PREFIX0=24"
        echo ""
        echo "# IPv4 Configuration (Private)"
        echo '# IPADDR2=""'
        echo "# PREFIX2=17"
        echo ""
        echo "# IPv6 Configuration (Public)"
        echo 'IPV6INIT="yes"'
        echo 'IPV6_AUTOCONF="yes"'
        echo 'IPV6_DEFROUTE="yes"'
        echo 'IPV6_FAILURE_FATAL="no"'
        echo 'IPV6_ADDR_GEN_MODE="stable-privacy"'
        echo '#IPV6_ADDR_GEN_MODE="eui64"'
        echo "IPV6ADDR=${C_IPV6_ADD0}/64"
        echo "IPV6_DEFAULTGW=${C_IPV6_DEF_GATEWAY0}"
        echo 'IPV6_PRIVACY="no"'
        echo ""
        echo "# resolvconf - doesn't recognize more than 3 nameservers. (IPv4 & IPv6)"
        echo "DNS1=${C_NAME_SERVER1}"
        echo "DNS2=${C_NAME_SERVER2}"
        echo "DNS3=${C_NAME_SERVER3}"
      } >"/etc/sysconfig/network-scripts/ifcfg-${C_NIC_INTERFACE_NAME}"
    elif [ "${DISTRO_ID}" == "debian" ]; then
      msg "$(s cyan)Inserting static IP information for ${C_NIC_INTERFACE_NAME} at /etc/network/interfaces ...$(e)" --caller="${SCRIPT_NAME}"
      {
        echo "# ==============================================="
        echo "# This configuration file was generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# This file describes the network interfaces available on your system"
        echo "# and how to activate them. For more information, see interfaces(5)."
        echo ""
        # This is not needed, it can cause bug network raised error reported from various sites
        #echo "source /etc/network/interfaces.d/*"
        #echo ""
        echo "# The loopback network interface"
        echo "auto lo"
        echo "iface lo inet loopback"
        echo ""
        echo "# auto ${C_NIC_INTERFACE_NAME} is needed to configure static IP for both IPv4 and IPv6"
        echo "auto ${C_NIC_INTERFACE_NAME}"
        echo ""
        echo "# The primary IPv4 network interface"
        echo "iface ${C_NIC_INTERFACE_NAME} inet static"
        echo "   address ${C_IPV4_ADD0}/24"
        echo "   gateway ${C_IPV4_DEF_GATEWAY0}"
        echo "   dns-nameservers ${C_NAME_SERVER1} ${C_NAME_SERVER2}"
        echo ""
        echo "# The primary IPv6 network interface"
        echo "iface ${C_NIC_INTERFACE_NAME} inet6 static"
        echo "   address ${C_IPV6_ADD0}/64"
        echo "   gateway ${C_IPV6_DEF_GATEWAY0}"
      } >/etc/network/interfaces
      msg "$(s cyan)Disabling IPv6 Duplicate Address Detection ...$(e)" --caller="${SCRIPT_NAME}"
      # Disabling Ipv6 DAD: https://www.agwa.name/blog/post/beware_the_ipv6_dad_race_condition
      # Another way is to use this sysctl -w net.ipv6.conf.eth0.dad_transmits=0 or put in /etc/sysctl for permanent
      # Why disable? Because nginx sometimes cannot start with ipv6 unless system is restarted
      if [ -f "/proc/sys/net/ipv6/conf/${C_NIC_INTERFACE_NAME}/accept_dad" ]; then
        {
          echo "# Disable IPv6 Duplicate Address Detection"
          echo "pre-up echo 0 > /proc/sys/net/ipv6/conf/${C_NIC_INTERFACE_NAME}/accept_dad"
        } >>/etc/network/interfaces
      fi
    else
      msg "$(s red)Error, unknown value for distribution ID ${DISTRO_ID}. This distribution ID is not supported$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi
    # resolvconf already installed in Debian preseed file
    # Note use /etc/resolvconf/resolv.conf.d/base instead of /etc/resolv.conf because the base file will not be overwritten
    # This insertion works for both centos, almalinux, debian and ubuntu so there is no need to put OS condition
    msg "$(s cyan)Inserting name server information in /etc/resolvconf/resolv.conf.d/base ...$(e)" --caller="${SCRIPT_NAME}"
    {
      echo "# ==============================================="
      echo "# This configuration file was generated by ${SCRIPT_NAME}"
      echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
      echo "# ==============================================="
      #echo "search ${C_BOX_DOMAIN}"
      echo "domains ${C_BOX_HOSTNAME_FQHN}"
      echo "options rotate"
      # Only up to 3 name servers are allowed in /etc/resolv.conf: https://linux.die.net/man/5/resolv.conf
      echo "nameserver ${C_NAME_SERVER1}"
      echo "nameserver ${C_NAME_SERVER2}"
      echo "nameserver ${C_NAME_SERVER3}"
    } >/etc/resolvconf/resolv.conf.d/base
    echo ""
    # Compiling
    msg "$(s cyan)Updating resolvconf ...$(e)" --caller="${SCRIPT_NAME}"
    sudo resolvconf -u
    get_status_message "$?"
    echo ""
    msg "$(s cyan)Getting the current hostname ...$(e)" --caller="${SCRIPT_NAME}"
    # if it is empty, put a placeholder as old.host.com
    current_host=$(hostname --fqdn)
    # Set hostname to ${C_BOX_HOSTNAME_FQHN}
    msg "$(s cyan)Setting hostname to ${C_BOX_HOSTNAME_FQHN} ...$(e)" --caller="${SCRIPT_NAME}"
    hostname "${C_BOX_HOSTNAME_FQHN}"
    #echo "current_hostname: ${current_host}"
    if [ -z "${current_host}" ]; then
      current_host=old.host.com
      msg "$(s yellow)Warning, the current hostname was blank and is now set to ${current_host}$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""
    #Copy everything from /etc/hosts except domain.com and current hostname and comments and store in /etc/hosts.tmp
    msg "$(s cyan)Removing previous domain C_BOX_HOSTNAME hostnames and store in /etc/hosts.tmp ...$(e)" --caller="${SCRIPT_NAME}"
    clean_host=$(grep -wv "${C_BOX_HOSTNAME_FQHN}" /etc/hosts | grep -wv ${current_host} | grep -v '#')
    echo "${clean_host}" >/etc/hosts.tmp
    echo ""
    msg "$(s cyan)Rewrite a new host contents based on /etc/hosts.tmp ...$(e)" --caller="${SCRIPT_NAME}"
    # start a new host template:
    {
      echo "# ==============================================="
      echo "# This configuration file was generated by ${SCRIPT_NAME}"
      echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
      echo "# ==============================================="
      # This was a standard warning message from previous distro
      echo "# Do not remove the following line, or various programs"
      echo "# that require network functionality will fail."
    } >/etc/hosts

    host_count_tmp=$(grep -c "localhost" /etc/hosts.tmp)

    if [ "${host_count_tmp}" -lt 1 ]; then
      echo -e "127.0.0.1\t\t localhost.localdomain localhost" >>/etc/hosts
    fi
    echo ""
    msg "$(s cyan)Adding IP (IPv4) and (IPv6) and entries in /etc/hosts ...$(e)" --caller="${SCRIPT_NAME}"
    {
      cat /etc/hosts.tmp
      echo ""
      echo "# IP information for ${C_BOX_HOSTNAME_FQHN}:"
      printf '%s\t%s\t%s\n' "${C_IPV4_ADD0}" "${C_BOX_HOSTNAME_FQHN}" "${C_BOX_HOSTNAME}"
      printf '%s\t%s\t%s\n' "${C_IPV6_ADD0}" "${C_BOX_HOSTNAME_FQHN}" "${C_BOX_HOSTNAME}"
    } >>/etc/hosts
    chmod 644 /etc/hosts
    msg "$(s cyan)Preventing /etc/hosts from being modified by other processes using chattr +i immutable$(e)" --caller="${SCRIPT_NAME}"
    # When using a VPS, managed dedicated server that use auto network manager provided by registrar, it will keep replacing this hosts file.
    # So, we don't want anyone to disturb this beautiful written host file by using chattr +i on this file
    # Note directadmin setup also trying to modify this /etc/hosts file during setup using its script called: /usr/local/directadmin/scripts/hostname.sh
    # It will get an error operation not permitted but do not worry because /etc/hosts is correctly configured now.
    # Another reason why I don't want directadmin to modify this host file is because directadmin will not write IPv6 value automatically (it will mess up the /etc/hosts).
    # The file is perfect and should be readonly mode
    chattr +i /etc/hosts
    get_status_message "$?"
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This might need to set on OS level not here because it might required restart (pending write to os_initialize.sh)
# Note: Note for quota this script only support ext4 at this moment
configure_fstab() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local is_encrypted disk_uuid_boot has_home_partition can_switch_jquota quotaoff_bin quotacheck_bin quotaon_bin
    maxibuild --include "quota"
    quotaoff_bin="$(command -v quotaoff)"
    quotacheck_bin="$(command -v quotacheck)"
    quotaon_bin="$(command -v quotaon)"

    msg "$(s cyan)Turning off system quota ...$(e)" --caller="${SCRIPT_NAME}"
    ${quotaoff_bin} -a
    echo ""
    msg "$(s cyan)Checking if quota supports journaled  quota ...$(e)" --caller="${SCRIPT_NAME}"
    can_switch_jquota="$(${quotacheck_bin} -avugm &> >(grep -w 'Consider switching to journaled quota'))"

    # if C_DISK_ENCRYPTION is set, we must have this value crypt
    is_encrypted=$(lsblk | grep 'crypt')
    if [ -n "${is_encrypted}" ]; then
      local root_file_system_type home_file_system_type tmp_file_system_type boot_file_system_type
      root_file_system_type=$(df --print-type | awk -v pattern="\/dev\/mapper\/${C_LVM_GROUP_NAME}-root" '$0 ~ pattern{print $2}')
      home_file_system_type=$(df --print-type | awk -v pattern="\/dev\/mapper\/${C_LVM_GROUP_NAME}-home" '$0 ~ pattern{print $2}')
      tmp_file_system_type=$(df --print-type | awk -v pattern="\/dev\/mapper\/${C_LVM_GROUP_NAME}-tmp" '$0 ~ pattern{print $2}')
      # Boot disk always be sda 1 (beginning of the drive)
      boot_file_system_type=$(df --print-type | awk -v pattern="\/dev\/sda1" '$0 ~ pattern{print $2}')
      # Boot must always be sda 1 (beginning of the drive)
      disk_uuid_boot=$(blkid -o value -s UUID "/dev/sda1")
      msg "$(s cyan)Found disk encryption is set: ${is_encrypted}. Writing new fstab contents at /etc/fstab ...$(e)" --caller="${SCRIPT_NAME}"
      {
        echo "# ==============================================="
        echo "# This configuration file was generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# /etc/fstab: static file system information."
        echo "#"
        echo "# Use 'blkid' to print the universally unique identifier for a"
        echo "# device; this may be used with UUID= as a more robust way to name devices"
        echo "# that works even if disks are added and removed. See fstab(5)."
        echo "#"
        echo "# <file system> <mount point>   <type>  <options>       <dump>  <pass>"
        # Boot mount option
        # If home partition exist, the quota should be specify in home else it should be specify in \
        printf "UUID=%s\t/boot\t%s\tdefaults\t0\t2\n" "${disk_uuid_boot}" "${boot_file_system_type}"
        # Set quota based on this quide: https://help.directadmin.com/item.php?id=42
        has_home_partition=$(lsblk --output MOUNTPOINT | grep -w '/home')
        if [ -n "${has_home_partition}" ]; then
          # only enable quota on home partition if detected home partition (ignore the root partition quota setting)
          printf "/dev/mapper/%s-root\t/\t%s\terrors=remount-ro,x-systemd.device-timeout=0\t0\t1\n" "${C_LVM_GROUP_NAME}" "${root_file_system_type}"
          if [ "${C_ENABLE_DISK_QUOTA}" == "true" ]; then
            if [ -n "${can_switch_jquota}" ]; then
              # Use journaled quota if it is able to do that
              if [[ ${DISTRO_ID} == "debian" ]]; then
                printf "/dev/mapper/%s-home\t/home\t%s\tnosuid,usrjquota=aquota.user,grpjquota=aquota.group,jqfmt=vfsv0,x-systemd.device-timeout=0\t0\t2\n" "${C_LVM_GROUP_NAME}" "${home_file_system_type}"
              fi
            else
              # Use normal quota
              printf "/dev/mapper/%s-home\t/home\t%s\tnosuid,usrquota,grpquota,x-systemd.device-timeout=0\t0\t2\n" "${C_LVM_GROUP_NAME}" "${home_file_system_type}"
            fi
          else
            # Disable quota based on setting C_ENABLE_DISK_QUOTA (no quota entry)
            # TODO untested C_ENABLE_DISK_QUOTA = false
            printf "/dev/mapper/%s-home\t/home\t%s\tnosuid,x-systemd.device-timeout=0\t0\t2\n" "${C_LVM_GROUP_NAME}" "${home_file_system_type}"
          fi
        else
          if [ "${C_ENABLE_DISK_QUOTA}" == "true" ]; then
            # Only enable quota on root partition if /home does not exist
            if [ -n "${can_switch_jquota}" ]; then
              # Use journaled quota if it is able to do that
              printf "/dev/mapper/%s-root\t/\t%s\terrors=remount-ro,usrjquota=aquota.user,grpjquota=aquota.group,jqfmt=vfsv0,x-systemd.device-timeout=0\t0\t1\n" "${C_LVM_GROUP_NAME}" "${root_file_system_type}"
            else
              # Use normal quota
              printf "/dev/mapper/%s-root\t/\t%s\terrors=remount-ro,usrquota,grpquota,x-systemd.device-timeout=0\t0\t1\n" "${C_LVM_GROUP_NAME}" "${root_file_system_type}"
            fi
          else
            # Disable quota based on setting C_ENABLE_DISK_QUOTA (no quota entry)
            # TODO untested C_ENABLE_DISK_QUOTA = false
            printf "/dev/mapper/%s-root\t/\t%s\terrors=remount-ro,x-systemd.device-timeout=0\t0\t1\n" "${C_LVM_GROUP_NAME}" "${root_file_system_type}"
          fi
        fi
        printf "/dev/mapper/%s-tmp\t/tmp\t%s\tnodev,nosuid,noexec,x-systemd.device-timeout=0\t0\t2\n" "${C_LVM_GROUP_NAME}" "${tmp_file_system_type}"
        printf "/dev/mapper/%s-swap\tnone\tswap\tsw,x-systemd.device-timeout=0\t0\t0\n" "${C_LVM_GROUP_NAME}"
      } >/etc/fstab
      echo ""
      msg "$(s cyan)Turning on system quota ...$(e)" --caller="${SCRIPT_NAME}"

      # Turn back quota
      ${quotaon_bin} -a
    else
      msg "$(s yellow)[Skipped]: Warning, no disk partition encryption is found$(e)" --caller="${SCRIPT_NAME}"
      # TODO: add the same fstab configuration above but for non-encrypted volume
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Tweaking swap for production
configure_kernel_swap() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    msg "$(s cyan)Writing disk swap information in /etc/sysctl.conf ...$(e)" --caller="${SCRIPT_NAME}"
    # Swap configuration
    {
      echo "vm.swappiness = 10"
      echo "vm.vfs_cache_pressure = 50"
    } >>/etc/sysctl.conf
    echo ""
    msg "$(s cyan)Compiling sysctl config /etc/sysctl.conf ...$(e)" --caller="${SCRIPT_NAME}"
    sysctl -p /etc/sysctl.conf
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi

}

configure_kernel_filesystem() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    msg "$(s cyan)Writing kernel and file system information in /etc/sysctl.conf ...$(e)" --caller="${SCRIPT_NAME}"
    {
      # Disable core dumps
      # This code will ensure not to make any core dumps by setuid programs in future.
      echo "fs.suid_dumpable = 0"
      # Disable System Request debugging functionality
      echo "kernel.sysrq = 0"
      # Hide kernel pointers
      echo "kernel.kptr_restrict = 2"
    } >>/etc/sysctl.conf
    echo ""
    msg "$(s cyan)Compiling sysctl config /etc/sysctl.conf ...$(e)" --caller="${SCRIPT_NAME}"
    sysctl -p /etc/sysctl.conf
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_kernel_ips() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    msg "$(s cyan)Writing ipv4 and ipv6 information in /etc/sysctl.conf ..." --caller="${SCRIPT_NAME}"
    {
      echo "# IPV4 & IPv6 configuration"
      echo "# IPV6"
      echo "net.ipv6.conf.all.disable_ipv6 = 0"
      echo "net.ipv6.conf.default.disable_ipv6 = 0"
      echo "#net.ipv6.conf.lo.disable_ipv6 = 0"
      echo "#net.ipv6.bindv6only = 1"
      echo "net.ipv6.conf.default.accept_redirects = 0"
      echo "net.ipv6.conf.all.accept_redirects = 0"
      # This net.ipv6.ip_nonlocal_bind fixed the issue with nginx could not started because it could not listen to newly added IPv6
      # nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
      # nginx[32309]: nginx: [emerg] bind() to [IPV6]:80 failed (99: Cannot assign requested address)
      # nginx[32309]: nginx: configuration file /etc/nginx/nginx.conf test failed
      # nginx[32309]: t:none,t:urlDecode
      # systemd[1]: nginx.service: Control process exited, code=exited, status=1/FAILURE
      # nginx.service: Failed with result 'exit-code'.
      # systemd[1]: Failed to start The nginx HTTP and reverse proxy server.
      echo "net.ipv6.ip_nonlocal_bind = 1"
      # Disable IPv6 DAD in kernel
      echo "net.ipv6.conf.${C_NIC_INTERFACE_NAME}.dad_transmits = 0"
      echo "#IPV4"
      echo "net.ipv4.conf.all.accept_redirects = 0"
      echo "net.ipv4.conf.all.log_martians = 1"
      echo "net.ipv4.conf.all.send_redirects = 0"
      echo "net.ipv4.conf.default.accept_redirects = 0"
      echo "net.ipv4.conf.default.log_martians = 1"
      echo "#net.ipv6.tcp_timestamps = 0"

      echo "#Enable TCP SYN cookie protection"
      echo "net.ipv4.tcp_syncookies = 1"

      echo "#Turn off the tcp_sack"
      echo "#net.ipv4.tcp_sack = 0"

      echo "#Turn off the tcp_window_scaling"
      echo "#net.ipv4.tcp_window_scaling = 0"

      echo "### Enable this when DDOS attack occur ###"
      echo "# Decrease the time default value for tcp_fin_timeout connection"
      echo "#net.ipv4.tcp_fin_timeout = 3"

      echo "net.ipv4.ip_nonlocal_bind = 1"

    } >>/etc/sysctl.conf
    echo ""
    msg "$(s cyan)Compiling sysctl config /etc/sysctl.conf ...$(e)" --caller="${SCRIPT_NAME}"
    sysctl -p /etc/sysctl.conf
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

## Start Directadmin related function ###
# This function allows Directadmin to restart quickly but we don't take it as high priority because we need to finish directadmin pending tasks.
# Better to restart DA with task.queue (this is what most documentation do) because DA needs to respect task.queue process
# Without using task.queue, we can restart directadmin using systemctl restart directadmin
restart_da() {
  local wait_count max_wait wait_duration task_queue_file
  # Directadmin recommends 60 seconds (or 1 minute). Longer than this something wrong with the task.queue
  wait_count=0
  max_wait=70
  wait_duration=1
  task_queue_file="/usr/local/directadmin/data/task.queue"
  while :; do
    ((wait_count = wait_count + 1))
    sleep ${wait_duration}
    if [[ -s "${task_queue_file}" && -f "${task_queue_file}" ]]; then
      msg "$(s cyan)Waiting for pending task(s) to finish executed. Maximum wait of ${wait_count}/${max_wait} seconds ...$(e)" --start-spin --caller="${SCRIPT_NAME}"
      if [ "${wait_count}" -gt ${max_wait} ]; then
        # Force restart if waiting time is longer than max_wait. The maximum task.queue execution time is only 1 minute based on directadmin documentation
        # Another condition that can be force to restart is, if the task.queue contains more than 2 lines, it means it is not running. So we can force restart it.
        # https://docs.directadmin.com/directadmin/general-usage/task-queue-processor/
        msg "$(s yellow)Warning, task.queue has not finished executing task(s) for more than ${max_wait} seconds. Forcing directadmin to restart ...$(e)" --stop-spin --caller="${SCRIPT_NAME}"
        echo "action=directadmin&value=restart" >>/usr/local/directadmin/data/task.queue
        /usr/local/directadmin/dataskq d2000 >/dev/null
        break
      fi
    else
      msg "$(s cyan)Restarting Directadmin using task.queue mode ...$(e)" --stop-spin --caller="${SCRIPT_NAME}"
      # Writing restart query in task.queue to restart directadmin in queue mode
      echo "action=directadmin&value=restart" >>/usr/local/directadmin/data/task.queue
      # Force restart with debugging level d2000
      # this option force reboot if we still have pending tasks. This is optional because at this condition we know there must be no other pending tasks.
      /usr/local/directadmin/dataskq d2000 >/dev/null
      break
    fi
  done

}
# This function will get the current directadmin original / owner username
# Only execute this after directadmin has successfully installed (we know we got an admin account)
get_current_da_owner_username() {
  local admin_list da_admins da_admin current_da_owner_username
  admin_list="/usr/local/directadmin/data/admin/admin.list"
  readarray -t da_admins <"${admin_list}"
  for da_admin in "${da_admins[@]}"; do
    # There must be 1 creator in directadmin, so this one must always have value
    current_da_owner_username=$(grep -rl "^creator=root" "/usr/local/directadmin/data/users/${da_admin}/user.conf" | cut -d'/' -f7 | tail -n 1)
    if [ -n "${current_da_owner_username}" ]; then
      echo "${current_da_owner_username}"
      break
    fi
  done
  unset da_admins
  # It might be impossible that this will return empty, so just in case we add the condition
  if [ -z "${current_da_owner_username}" ]; then
    msg "$(s yellow)Error, there is no admin created by root exist in directadmin user data! Please make sure it exist!$(e)" --caller="${SCRIPT_NAME}"
    exit 1
  fi
}

# This function is used to setup options.conf or do something before executing directadmin installation
install_da_pre() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local db_custom_version_txt da_latest_version da_cb_options_conf da_sql_type da_sql_version da_php_mode_v1 da_php_mode_v2 da_php_mode_v3 da_php_mode_v4 count
    # This file is use to customize directadmin package version
    db_custom_version_txt="/usr/local/directadmin/custombuild/custom_versions.txt"
    da_latest_version=$(dig +short -t txt "${C_DA_VERSION_CHANNEL}-version.directadmin.com" | sed 's|.*v=\([0-9.]*\).*|\1|')
    da_cb_options_conf="/usr/local/directadmin/custombuild/options.conf"
    # Make sure to create custombuild folder
    msg "Creating custombuild folder ..." --caller="${SCRIPT_NAME}" --msg-type=info
    mkdir -p "/usr/local/directadmin/custombuild"
    get_status_message "$?"

    msg "Creating custom_versions.txt ..." --caller="${SCRIPT_NAME}" --msg-type=info
    # Make sure to create custom_versions.txt file
    touch "${db_custom_version_txt}"
    get_status_message "$?"

    msg "Notice, the latest version of Directadmin ${C_DA_VERSION_CHANNEL} is ${da_latest_version}" --caller="${SCRIPT_NAME}" --msg-type=info
    _pause 5

    msg "Writing directadmin custombuild version ${C_DA_CB_VERSION} into /root/.custombuild ..." --caller="${SCRIPT_NAME}" --msg-type=info
    echo "${C_DA_CB_VERSION}" >/root/.custombuild
    get_status_message "$?"

    msg "Writing email ${C_ROOT_EMAIL} into /root/.email.txt to override system email ..." --caller="${SCRIPT_NAME}" --msg-type=info
    # This also belongs to root email
    echo "${C_ROOT_EMAIL}" >/root/.email.txt
    get_status_message "$?"

    msg "$(s cyan)Writing email ${C_ADMIN_EMAIL} into /root/.forward to override directadmin admin email ...$(e)" --caller="${SCRIPT_NAME}"
    # Forward all email to admin (webmaster)
    echo "${C_ADMIN_EMAIL}" >/root/.forward
    get_status_message "$?"

    # This will make sure preinstall command is going to be executed when starting DA installation
    msg "Configuring directadmin to to run pre-install command ..." --caller="${SCRIPT_NAME}" --msg-type=info
    echo 1 >/root/.preinstall
    get_status_message "$?"

    if [ "${C_DA_INSTALL_TYPE}" == "custom" ]; then
      msg "Directadmin installation type is set to custom. The installation will use previous custom configs from options.conf and php_extensions.conf without questions" --caller="${SCRIPT_NAME}" --msg-type=info

      msg "Creating a new custombuild custom options.conf into /usr/local/directadmin/custombuild/options.conf (as a template) ..." --caller="${SCRIPT_NAME}" --msg-type=info

      {
        echo "php1_release=7.4"
        echo "php1_mode=php-fpm"
        echo "php2_release=no"
        echo "php2_mode=php-fpm"
        echo "php3_release=no"
        echo "php3_mode=php-fpm"
        echo "php4_release=no"
        echo "php4_mode=php-fpm"
        echo "secure_php=yes"
        echo "php_ini=yes"
        echo "php_timezone=Asia/Kuala_Lumpur"
        echo "php_ini_type=production"
        echo "x_mail_header=yes"
        echo ""
        echo "#MySQL Settings"
        echo "mysql=5.7"
        echo "mariadb=10.6"
        echo "mysql_inst=mariadb"
        echo "mysql_backup=yes"
        echo "mysql_backup_gzip=yes"
        echo "mysql_backup_dir=/usr/local/directadmin/custombuild/mysql_backups"
        echo "mysql_force_compile=no"
        echo ""
        echo "#WEB Server Settings"
        echo "unit=no"
        echo "webserver=nginx_apache"
        echo "http_methods=ALL"
        echo "litespeed_serialno=trial"
        echo "modsecurity=no"
        echo "modsecurity_ruleset=owasp"
        echo "apache_ver=2.4"
        echo "apache_mpm=auto"
        echo "mod_ruid2=no"
        echo "# This is a security feature, disable user directory access"
        echo "userdir_access=no"
        echo "# This is a security feature to disable FollowSymLinks and replace with SymLinksIfOwnerMatch"
        echo "harden_symlinks_patch=yes"
        echo "# Set is to redirect everyone to hostname. We set to no, and enable later in script"
        echo "use_hostname_for_alias=no"
        echo "# Place holder, change later in script"
        echo "redirect_host=\"host.domain.com\""
        echo "# This is to redirect hostname automatically to https. We set to no, and enable later in script"
        echo "redirect_host_https=no"
        echo ""
        echo "#WEB Applications Settings"
        echo "phpmyadmin=yes"
        echo "phpmyadmin_public=yes"
        echo "squirrelmail=no"
        echo "roundcube=yes"
        echo "webapps_inbox_prefix=no"
        echo ""
        echo "#ClamAV-related Settings"
        echo "clamav=no"
        echo "clamav_exim=yes"
        echo "modsecurity_uploadscan=no"
        echo "proftpd_uploadscan=no"
        echo "pureftpd_uploadscan=no"
        echo "suhosin_php_uploadscan=no"
        echo ""
        echo "#Mail Settings"
        echo "exim=no"
        echo "eximconf=no"
        echo "blockcracking=no"
        echo "easy_spam_fighter=no"
        echo "spamd=rspamd"
        echo "sa_update=daily"
        echo "dovecot=yes"
        echo "dovecot_conf=no"
        echo "mail_compress=yes"
        echo "pigeonhole=yes"
        echo ""
        echo "#FTP Settings"
        echo "ftpd=pureftpd"
        echo ""
        echo "# Statistics Settings"
        echo "# We do not need this enabled (speed up server)"
        echo "awstats=no"
        echo "webalizer=no"
        echo ""
        echo "#CustomBuild Settings"
        echo "bold=yes"
        echo "clean=yes"
        echo "clean_old_tarballs=yes"
        echo "clean_old_webapps=yes"
        echo ""
        echo "#Cronjob Settings"
        echo "cron=no"
        echo "cron_frequency=daily"
        echo "email=webmaster@sofibox.com"
        echo "notifications=yes"
        echo ""
        echo "#Updating Settings"
        echo "da_autoupdate=no"
        echo "updates=no"
        echo "webapps_updates=yes"
        echo ""
        echo "#CloudLinux Settings"
        echo "cloudlinux=no"
        echo "cloudlinux_beta=no"
        echo "cagefs=no"
        echo ""
        echo "#Advanced Settings"
        echo "# This option is used to install curl by directadmin. We will install curl by system first"
        echo "ssl_configuration=intermediate"
        echo ""
        echo "#Other packages"
        echo "csf=no"
        echo "redis=yes"
        echo "#PHP extensions can be found in php_extensions.conf"
      } >"${da_cb_options_conf}"
      get_status_message "$?"
      echo ""

      msg "Changing the value redirect_host= into redirect_host=${C_BOX_HOSTNAME_FQHN} from options.conf ..." --caller="${SCRIPT_NAME}" --msg-type=info
      sed -i "s|^redirect_host=.*|redirect_host=${C_BOX_HOSTNAME_FQHN}|" "${da_cb_options_conf}"
      get_status_message "$?"

      msg "Changing the value email= into email=${C_ADMIN_EMAIL} from options.conf ..." --caller="${SCRIPT_NAME}" --msg-type=info
      sed -i "s|^email=.*|email=${C_ADMIN_EMAIL}|" "${da_cb_options_conf}"
      get_status_message "$?"
      echo ""

      msg "Changing the value php_timezone= into php_timezone=${C_BOX_TIMEZONE} from options.conf ..." --caller="${SCRIPT_NAME}" --msg-type=info
      sed -i "s|^php_timezone=.*|php_timezone=${C_BOX_TIMEZONE}|" "${da_cb_options_conf}"
      get_status_message "$?"

      msg "Getting SQL databases info from config file ..." --caller="${SCRIPT_NAME}" --msg-type=info
      da_sql_type=$(echo "${C_DA_CB_SQL_VERSION}" | awk -F'-' '{ print $1 }')
      da_sql_version=$(echo "${C_DA_CB_SQL_VERSION}" | awk -F'-' '{ print $2 }')
      get_status_message "$?"

      # This will change the sql info in options.conf based on the value from config file C_DA_CB_SQL_VERSION

      msg "Changing mysql_inst=${da_sql_type} into options.conf ..." --caller="${SCRIPT_NAME}" --msg-type=info
      sed -i "s|^mysql_inst=.*|mysql_inst=${da_sql_type}|" "${da_cb_options_conf}"
      get_status_message "$?"

      msg "Changing ${da_sql_type}=${da_sql_version} into options.conf ..." --caller="${SCRIPT_NAME}" --msg-type=info
      sed -i "s|^${da_sql_type}=.*|${da_sql_type}=${da_sql_version}|" "${da_cb_options_conf}"
      get_status_message "$?"
      echo ""

      # This will setup PHP version
      msg "$(s cyan)Configuring PHP multiple versions ...$(e)" --caller="${SCRIPT_NAME}"
      da_php_mode_v1="$(echo "${C_DA_CB_PHP_VERSION}" | awk -F',' '{ print $1 }')"
      da_php_mode_v2="$(echo "${C_DA_CB_PHP_VERSION}" | awk -F',' '{ print $2 }')"
      da_php_mode_v3="$(echo "${C_DA_CB_PHP_VERSION}" | awk -F',' '{ print $3 }')"
      da_php_mode_v4="$(echo "${C_DA_CB_PHP_VERSION}" | awk -F',' '{ print $4 }')"

      count=1
      for php_mode_v in ${da_php_mode_v1} ${da_php_mode_v2} ${da_php_mode_v3} ${da_php_mode_v4}; do
        local php_version php_mode
        php_version=$(echo "${php_mode_v}" | awk -F':' '{ print $1}')
        php_mode=$(echo "${php_mode_v}" | awk -F':' '{ print $2}')

        # Use default value of php_version if empty
        if [ -z "${php_version}" ]; then
          php_version="no"
        fi

        # Use default value of php_mode if empty
        if [ -z "${php_mode}" ]; then
          php_mode="php-fpm"
        fi

        #echo "PHP version is ${php_version}"
        #echo "PHP mod is ${php_mode}"
        echo "Changing php${count}_release to ${php_version} ..."
        sed -i "s|^php${count}_release=.*|php${count}_release=${php_version}|" "${da_cb_options_conf}"
        echo ""
        echo "Changing php${count}_mod to ${php_mode} ..."
        sed -i "s|^php${count}_mod=.*|php${count}_mod=${php_mode}|" "${da_cb_options_conf}"
        echo ""
        ((count++))
      done
      msg "$(s cyan)Changing modsecurity enabled option to ${C_DA_CB_INSTALL_MODSECURITY} ...$(e)" --caller="${SCRIPT_NAME}"
      sed -i "s|^modsecurity=.*|modsecurity=${C_DA_CB_INSTALL_MODSECURITY}|" "${da_cb_options_conf}"
      echo ""

      msg "$(s cyan)Changing modsecurity ruleset option to ${C_DA_CB_MODSECURITY_RULESET} ...$(e)" --caller="${SCRIPT_NAME}"
      sed -i "s|^modsecurity_ruleset=.*|modsecurity_ruleset=${C_DA_CB_MODSECURITY_RULESET}|" "${da_cb_options_conf}"
      echo ""

      msg "$(s cyan)Changing clamav enabled option to ${C_DA_CB_INSTALL_CLAMAV} ...$(e)" --caller="${SCRIPT_NAME}"
      sed -i "s|^clamav=.*|clamav=${C_DA_CB_INSTALL_CLAMAV}|" "${da_cb_options_conf}"
      echo ""

      if [ "${C_DA_CB_DOWNLOADSERVER}" == "fastest" ]; then
        :
      else
        msg "$(s cyan)Changing downloadserver option to ${C_DA_CB_DOWNLOADSERVER} ...$(e)" --caller="${SCRIPT_NAME}"
        sed -i "s|^downloadserver=.*|downloadserver=${C_DA_CB_DOWNLOADSERVER}|" "${da_cb_options_conf}"
        echo ""
      fi
      msg "$(s cyan)Creating new custombuild custom php_extensions.conf into /usr/local/directadmin/custombuild/php_extensions.conf ...$(e)" --caller="${SCRIPT_NAME}"
      {
        echo "#PHP Extension Settings"
        echo "bz2=no"
        echo "gmp=no"
        echo "htscanner=yes"
        echo "imagick=yes"
        echo "imap=yes"
        echo "ioncube=no"
        echo "ldap=no"
        echo "opcache=yes"
        echo "phalcon=no"
        echo "redis=no"
        echo "snuffleupagus=no"
        echo "suhosin=no"
        echo "xmlrpc=no"
        echo "zend=no"
      } >"/usr/local/directadmin/custombuild/php_extensions.conf"

      echo ""
      ###### Below are some fixes
      if [ "${C_DA_CB_CLAMAV_VERSION}" != "latest" ]; then
        msg "$(s cyan)Configuring clamav to use version ${C_DA_CB_CLAMAV_VERSION} before installation ...$(e)" --caller="${SCRIPT_NAME}"
        echo "clamav:${C_DA_CB_CLAMAV_VERSION}:" >>"${db_custom_version_txt}"
        get_status_message "$?"
        echo ""
      fi

      if [ "${C_DA_ENABLE_PRE_INSTALL_TEMP_FIX}" == "true" ]; then
        msg "$(s cyan)Applying fixes for known issue ...$(e)" --caller="${SCRIPT_NAME}"
        if [ "${DISTRO_ID}" == "debian" ]; then
          msg "$(s cyan)Installing required package for clamav ...$(e)" --caller="${SCRIPT_NAME}"
          apt-get -y install libbz2-dev
          # https://forum.directadmin.com/threads/clamav-0-104-0-nginx-1-21-3.64522/post-335560
        fi
        echo ""
      fi

      # Switch FTP version here
      echo ""
      msg "$(s cyan)Changing the value ftpd= into ftpd=${C_DA_CB_FTP_SOFTWARE} from options.conf ...$(e)" --caller="${SCRIPT_NAME}"
      sed -i "s|^ftpd=.*|ftpd=${C_DA_CB_FTP_SOFTWARE}|" "${da_cb_options_conf}"
      echo ""

      # Install lua5.1 first before install directadmin to fix modsecurity issue using custombuild. Also reinstall lua (as latest version) to make sure that its binary can be triggered
      maxibuild install "lua5.1 lua5.4" --force

      # Note do not enable csf installation here.

    elif
      [[ "${C_DA_INSTALL_TYPE}" == "ori" || "${C_DA_INSTALL_TYPE}" == "original" ]]
    then
      msg "$(s cyan)Directadmin installation type C_DA_INSTALL_TYPE is set to ori or original. This will make the installation of directadmin using its default options might have few questions$(e)" --caller="${SCRIPT_NAME}"
      C_DA_INSTALL_TYPE="original"
    elif [[ "${C_DA_INSTALL_TYPE}" == "int" || "${C_DA_INSTALL_TYPE}" == "interactive" ]]; then
      msg "$(s cyan)Directadmin installation type C_DA_INSTALL_TYPE is set to int or interactive. This will make the installation of directadmin using more questions$(e)" --caller="${SCRIPT_NAME}"
      C_DA_INSTALL_TYPE="interactive"
    elif [[ "${C_DA_INSTALL_TYPE}" == "auto" || "${C_DA_INSTALL_TYPE}" == "automatic" ]]; then
      msg "$(s cyan)Directadmin installation type C_DA_INSTALL_TYPE is set to auto or automatic. This will make the installation of directadmin using its common default components including CSF without any questions$(e)" --caller="${SCRIPT_NAME}"
      C_DA_INSTALL_TYPE="automatic"
    elif [[ "${C_DA_INSTALL_TYPE}" == "auto-option" || "${C_DA_INSTALL_TYPE}" == "automatic-option" ]]; then
      # TODO add pre options
      msg "$(s cyan)Directadmin installation type C_DA_INSTALL_TYPE is set to ${C_DA_INSTALL_TYPE}$(e)" --caller="${SCRIPT_NAME}"
      C_DA_INSTALL_TYPE="automatic-option"
    elif [[ "${C_DA_INSTALL_TYPE}" == "auto-custom" || "${C_DA_INSTALL_TYPE}" == "automatic-custom" ]]; then
      # TODO add pre options
      msg "$(s cyan)Directadmin installation type C_DA_INSTALL_TYPE is set to ${C_DA_INSTALL_TYPE}$(e)" --caller="${SCRIPT_NAME}"
      C_DA_INSTALL_TYPE="automatic-custom"
    else
      msg "$(s red)Error, invalid installation type C_DA_INSTALL_TYPE set for directadmin in config file.$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# After executing this function, to enter into directadmin temporarily do the following:
# Disable firewall
# Clear cache browser, login using setup.txt
# Note DA custom installation right now has duration of 01 H:21 M :26 S
install_da() {
  # After da is installed, we still need to open the port for default firewall. To achieve this, we can run install_da_post() function
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_install_log da_bin da_cb_bin da_conf da_script_path retval
    da_install_log="${LOG_PATH}/da-install.log"
    da_script_path="/usr/local/directadmin/scripts"
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    touch "${da_install_log}"
    msg "$(s cyan)Downloading directadmin setup script ...$(e)" --caller="${SCRIPT_NAME}"
    navigate_to "${INST_TEMP_DIR}"
    wget -O setup.sh http://www.directadmin.com/setup.sh
    echo ""
    msg "$(s cyan)Setting execution permission for setup.sh ...$(e)" --caller="${SCRIPT_NAME}"
    chmod 755 setup.sh
    get_status_message $?
    echo ""
    # da_latest_version=$(curl -s https://www.directadmin.com/version.php | grep -Eo "[0-9]+\.[0-9]+")
    da_latest_version=$(dig +short -t txt ${C_DA_VERSION_CHANNEL}-version.directadmin.com | sed 's|.*v=\([0-9.]*\).*|\1|')
    msg "$(s magenta)=======================================================================$(e)"
    msg "$(s yellow)Setup will install Directadmin ${da_latest_version}-${C_DA_VERSION_CHANNEL} within 30 seconds. $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)This would take a long time depending on the package selection or directadmin installation type, so please be patient$(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)If you don't want to install Directadmin now, press (CTRL+C) to exit$(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)Remember that you can always re-run this script to resume or restart installation (even it is halt due to error)$(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)In order to view full directadmin installation log in realtime, execute this command in another local terminal: $(e)" --caller="${SCRIPT_NAME}"
    echo ""
    msg "$(s yellow)${SCRIPT_NAME} login and then, tail -f ${da_install_log}$(e)"
    msg "$(s magenta)=======================================================================$(e)"
    _pause 30
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    echo ""

    # Temporary fix this issue, the new installer does not allow chattr +i /etc/hosts to be enabled
    echo "Allowing DA installer to modify /etc/hosts temporarily ..."
    chattr -i /etc/hosts
    get_status_message $?
    echo ""
    # https://forum.directadmin.com/threads/prevent-directadmin-to-modify-etc-hosts-during-installation.67200/

    msg "$(s cyan)Note: Directadmin ${da_latest_version} will be installed on ${C_BOX_HOSTNAME_FQHN} using ${C_DA_INSTALL_TYPE} mode$(e)"
    echo ""
    if [[ "${C_DA_INSTALL_TYPE}" == "custom" || "${C_DA_INSTALL_TYPE}" == "original" ]]; then
      # If provided options.conf, it means we use custom else we use original
      (
        # Update new command to setup directadmin:
        # This will show custombuild progress on the terminal after DA is installed (required and recommended to check error during installation)
        DA_FOREGROUND_CUSTOMBUILD="yes" DA_CHANNEL="${C_DA_VERSION_CHANNEL}" DA_EMAIL="${C_DA_OWNER_SYSTEM_EMAIL1}" DA_HOSTNAME="${C_BOX_HOSTNAME_FQHN}" DA_NS1="${C_BOX_NS1}" DA_NS2="${C_BOX_NS2}" DA_SKIP_CSF=true ./setup.sh "${C_DA_LICENSE_KEY}" &>"${da_install_log}"
        exit $?
      ) &
      ## This will obtain the installation return status
      my_pid=$!
      # Deprecated condition
    elif [[ "${C_DA_INSTALL_TYPE}" == "interactive" ]]; then
      echo "The option interactive does not work with the newest setup.sh. Exiting ..."
      exit 1
      # This will ask questions (so do not put in background)
      #bash <(curl -Ss https://www.directadmin.com/setup.sh) | tee -a "${da_install_log}"
      #retval=$?
      #echo ""
      #msg "Installation return code is ${retval}"
    elif [[ "${C_DA_INSTALL_TYPE}" == "automatic" || "${C_DA_INSTALL_TYPE}" == "auto" ]]; then
      # This will not ask question and everything will be installed as default including CSF
      (
        # ./setup.sh auto ${C_DA_VERSION_CHANNEL} &>"${da_install_log}"
        # Note it seems like we need to supply email argument else it doesn't work (support team told that)
        DA_CHANNEL="${C_DA_VERSION_CHANNEL}" DA_HOSTNAME="${C_BOX_HOSTNAME_FQHN}" DA_EMAIL="${C_DA_OWNER_SYSTEM_EMAIL1}" ./setup.sh auto &>"${da_install_log}"
        # bash <(curl -Ss https://www.directadmin.com/setup.sh) auto &>"${da_install_log}"
        exit $?
      ) &
      my_pid=$!
    elif [[ "${C_DA_INSTALL_TYPE}" == "automatic-option" || "${C_DA_INSTALL_TYPE}" == "auto-option" ]]; then
      (
        # TODO include options.conf or use export setting before installing
        # https://forum.directadmin.com/threads/da-1-63-1-after-a-new-da-installation-with-auto-mode-apache-is-not-running-httpd-syntax-error-on-line-222-of-etc-httpd-conf-httpd-conf.64921/post-338076
        DA_CHANNEL="${C_DA_VERSION_CHANNEL}" DA_HOSTNAME="${C_BOX_HOSTNAME_FQHN}" DA_EMAIL="${C_DA_OWNER_SYSTEM_EMAIL1}" ./setup.sh auto &>"${da_install_log}"
        # bash <(curl -Ss https://www.directadmin.com/setup.sh) auto &>"${da_install_log}"

        exit $?
      ) &
      my_pid=$!
    elif [[ "${C_DA_INSTALL_TYPE}" == "automatic-custom" || "${C_DA_INSTALL_TYPE}" == "auto-custom" ]]; then
      (
        #./setup.sh auto ${C_DA_VERSION_CHANNEL} &>"${da_install_log}"
        DA_CHANNEL="${C_DA_VERSION_CHANNEL}" DA_HOSTNAME="${C_BOX_HOSTNAME_FQHN}" DA_EMAIL="${C_DA_OWNER_SYSTEM_EMAIL1}" ./setup.sh auto &>"${da_install_log}"
        # TODO after install using automatic-custom, we rebuild or add packages based on config file
        # bash <(curl -Ss https://www.directadmin.com/setup.sh) auto &>"${da_install_log}"
        exit $?
      ) &
      my_pid=$!

    fi

    if [ -n "${my_pid}" ]; then
      msg "$(s cyan)Installing directadmin ${da_latest_version} [ PID: ${my_pid} ] for the $(get_ordinal "${INSTALL_COUNT}") time(s) ... $(e)" --caller="${SCRIPT_NAME}"
      echo ""
      while ps | grep -q " $my_pid "; do
        local progress_text memory_usage_percentage
        ((count++))
        memory_usage_percentage="$(free -m | grep Mem | awk '{printf("%.2f" ,($3/$2)*100)}')"
        progress_text="$(tail -n 1 "${da_install_log}")"
        msg "$(s yellow)Memory: ${memory_usage_percentage}% | Elapsed time: $(show_time "${count}") | ${progress_text:0:47} ... $(e)" --start-spin --progress-style=".oO@*"
        sleep 1
      done
      wait $my_pid
      retval=$?
    fi
    echo ""
    msg "Installation return code is ${retval}"

    ((INSTALL_COUNT++))
    # If installation contains success status:
    local install_complete_line
    # This line shows that the installation has completed (including custombuild) for the latest installer script

    install_complete_line=$(grep '^*   All parts have been installed' "${da_install_log}")

    if [[ "${retval}" -eq 0 ]] && [[ -n "${install_complete_line}" ]]; then
      local port
      msg "$(s cyan)Installation completed!$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s cyan)Checking if directadmin binary, custombuild and directadmin.conf are presents ...$(e)" --caller="${SCRIPT_NAME}"
      check_path "${da_bin}" "${da_cb_bin}" "${da_conf}"
      echo ""
      port="$(grep '^port=' /usr/local/directadmin/conf/directadmin.conf | cut -d= -f2)"
      msg "$(s green)${install_complete_line}$(e)"
      msg "$(s red) ================================== $(e)"

      grep "^Admin username:  " "${da_install_log}"
      grep "^Admin password:  " "${da_install_log}"
      grep "^Admin email:  " "${da_install_log}"
      echo "URL:    http://${C_BOX_HOSTNAME_FQHN}:${port}"

      echo "If the above information is hidden. You can always view this from:"
      echo "cat /usr/local/directadmin/scripts/setup.txt"
      msg "$(s red) ================================== $(e)"
      echo ""

      echo "Making /etc/hosts file read-only..."
      chattr +i /etc/hosts
    else
      # if it return other than success
      local error_msg total_error_line
      # How many line of errors to show:
      total_error_line=20
      msg "$(s red)Error, directadmin installation contains error. Please inspect the last ${total_error_line} lines of the installation log below:$(e)" --caller="${SCRIPT_NAME}"
      error_msg=$(tail -n ${total_error_line} "${da_install_log}")
      echo ""
      echo "============================================"
      echo ""
      msg "$(s red)${error_msg}$(e)"
      echo ""
      echo "============================================"
      # msg "$(s yellow)Please fix the error and re-run this setup again to restart the installation$(e)" --caller="${SCRIPT_NAME}"
      # exit 1
      msg "$(s yellow)Performing backup log file from ${da_install_log} as ${da_install_log}.${DATE_TIME_NOW} ...$(e)" --caller="${SCRIPT_NAME}"
      cp -f "${da_install_log}" "${da_install_log}.${DATE_TIME_NOW}"
      sleep 10
      echo ""

      if [ "${C_DA_ENABLE_PRE_INSTALL_TEMP_FIX}" == "true" ]; then
        msg "$(s yellow)Re-executing install_da_pre ...$(e)" --caller="${SCRIPT_NAME}"
        install_da_pre --run-force
        echo ""
      fi
      msg "$(s yellow)Reinstalling directadmin within 10 seconds for the $(get_ordinal ${INSTALL_COUNT})...$(e)" --caller="${SCRIPT_NAME}"
      install_da --run
      echo ""
    fi

    echo ""
    msg "$(s cyan)Checking directadmin file path ... $(e)" --caller="${SCRIPT_NAME}"
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}"
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi

}
# This post rebuild some da packages to fix issues
install_da_post() {
  # Here I can rebuild any missing or change package in DA
  # This to rebuild DA package that cause error like nginx_apache wont start for new install (bug)
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_conf da_sql_type da_sql_version da_install_log da_bin da_cb_bin da_script_path grep_count
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_script_path="/usr/local/directadmin/scripts"
    da_install_log="${LOG_PATH}/da-install.log"
    touch "${da_install_log}"

    msg "$(s cyan)Checking directadmin path ... $(e)" --caller="${SCRIPT_NAME}"
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}" "${da_script_path}"

    echo ""

    # SpamBlocker install and extra modules
    # TODO This resolved this issue (had to disable this first and rebuild here): https://forum.directadmin.com/threads/bug-new-installation-halt-for-the-second-time-regarding-to-exim-version-that-is-not-compatible.67957/#post-358733
    msg "$(s cyan)Installing SpamBlocker ... $(e)" --caller="${SCRIPT_NAME}"
    "${da_cb_bin}" update
    "${da_cb_bin}" set eximconf yes
    "${da_cb_bin}" set eximconf_release 4.5
    "${da_cb_bin}" set blockcracking yes
    "${da_cb_bin}" set easy_spam_fighter yes
    "${da_cb_bin}" set spamd rspamd
    "${da_cb_bin}" set exim yes
    "${da_cb_bin}" exim
    "${da_cb_bin}" set dovecot_conf yes
    "${da_cb_bin}" dovecot_conf
    "${da_cb_bin}" rspamd
    "${da_cb_bin}" update
    "${da_cb_bin}" exim_conf
    echo ""

    # I add this here because this needs exim to be installed first after da has been installed
    grep_count=$(grep -ic "diradmin: :blackhole:" /etc/aliases)
    if [ "${grep_count}" -eq 0 ]; then
      msg "$(s cyan)Writing new email aliases 'diradmin: :blackhole:' at /etc/aliases ...$(e)" --caller="${SCRIPT_NAME}"
      echo "diradmin: :blackhole:" >>/etc/aliases
    else
      msg "$(s yellow)[Skipped]: The diradmin: :blackhole: value was previously set in /etc/aliases!$(e)" --caller="${SCRIPT_NAME}"
    fi

    echo ""

    grep_count=$(grep -ic "root:${C_ROOT_EMAIL}" /etc/aliases)
    if [ "${grep_count}" -eq 0 ]; then
      msg "$(s cyan)Writing new email aliases root:${C_ROOT_EMAIL} at /etc/aliases ...$(e)" --caller="${SCRIPT_NAME}"
      #Root email will use this one
      echo "root:${C_ROOT_EMAIL}" >>/etc/aliases
    else
      msg "$(s yellow)[Skipped]: The root:${C_ROOT_EMAIL} value was previously set in /etc/aliases!$(e)" --caller="${SCRIPT_NAME}"
    fi

    get_status_message $?
    msg "$(s cyan)Running newaliases command ... $(e)" --caller="${SCRIPT_NAME}"
    newaliases
    get_status_message "$?"
    echo ""

    # This fixed the binary or symlink mail did not create after s-nail being installed
    # bsd-mailx should contain mail command
    msg "$(s cyan)Checking mail command ...$(e)" --caller="${SCRIPT_NAME}"
    if ! command -v mail &>/dev/null; then
      msg "$(s yellow)Error, required mail command/binary. You may need to manually install this mail package!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    echo ""
    # Now we can setup SMTP using s-nail
    msg "$(s cyan)Creating mail SMTP file at /root/.mailrc ...$(e)" --caller="${SCRIPT_NAME}"
    {
      echo "# ==============================================="
      echo "# This configuration file was generated by ${SCRIPT_NAME}"
      echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
      echo "# ==============================================="

      echo "# This configuration is taken from https://manpages.debian.org/stretch/s-nail/s-nail.1.en.html"
      echo ""
      echo "# To test mail configuration, use the following syntax to send mail:"
      echo "# echo \"Test\" | mail -s \"My test...\" address@whatever.com"
      echo ""
      echo "# This set v15.0 compatibility mode"
      echo "set v15-compat"
      echo ""
      echo "# See the whole process, especially for troubleshooting:"
      echo "# set verbose"
      echo ""
      echo "# Essential setting: select allowed character sets"
      echo "set sendcharsets=utf-8,iso-8859-1"
      echo "# when replying to a message, first try to use the same encoding that the original poster used herself!"
      echo "set reply-in-same-charset"
      echo ""
      echo "# Default directory where we act in (relative to \$HOME)"
      echo "set folder=mail"
      echo ""
      echo "# Request strict TLS transport layer security checks"
      echo "set tls-verify=strict"
      echo "set tls-ca-file=/etc/ssl/certs/ca-certificates.crt"
      echo "set tls-ca-no-defaults"
      echo "set smtp-use-starttls"
      echo "set smtp-auth=login"
      echo ""
      echo "# When sending a message wait until the MTA (including the builtin SMTP one) exits before accepting further commands."
      echo "# Only with this variable set errors reported by the MTA will be recognizable!"
      echo "# If the MTA returns a non-zero exit status, the exit status of s-nail will also be non-zero"
      echo "set sendwait"
      echo ""
      echo "# set from=\"Your Name <youremail@domain>\""
      echo "set from=\"${C_SMTP_SYSTEM_MAIL_FROM}\""
      echo "#Put authentication information here from config file"
      echo "set mta=smtp://${C_SMTP_SYSTEM_MAIL_USER}:${C_SMTP_SYSTEM_MAIL_PASSWORD}@${C_SMTP_SYSTEM_MAIL_SMTP_URL}:${C_SMTP_SYSTEM_MAIL_PORT}"

    } >/root/.mailrc
    get_status_message "$?"

    echo ""
    msg "$(s cyan)Correcting permission file of /root/.mailrc ...$(e)" --caller="${SCRIPT_NAME}"
    chmod 600 /root/.mailrc
    get_status_message "$?"
    echo ""

    # Restart exim if exim binary is found
    if command -v exim &>/dev/null; then
      msg "$(s cyan)Restarting exim ... $(e)" --caller="${SCRIPT_NAME}"
      systemctl restart exim
      echo ""
    fi
    # Restart postfix if postfix binary is found
    if command -v postfix &>/dev/null; then
      msg "$(s cyan)Restarting postfix ... $(e)" --caller="${SCRIPT_NAME}"
      systemctl restart postfix
      echo ""
    fi

    msg "$(s cyan)Testing sending mail...$(e)" --caller="${SCRIPT_NAME}"
    echo "If you can read this, that means the SMTP mail for ${C_BOX_HOSTNAME_FQHN} has been configured successfully for the following user: ${C_SMTP_SYSTEM_MAIL_USER}@${C_SMTP_SYSTEM_MAIL_DOMAIN}" | mail -s "SMTP mail testing from ${C_BOX_HOSTNAME_FQHN}" ${C_SMTP_SYSTEM_MAIL_USER}@${C_SMTP_SYSTEM_MAIL_DOMAIN}
    get_status_message "$?"

    echo ""
    # Rebuilding DA packages to fix some issues .
    msg "$(s cyan)Updating directadmin custombuild to the new version...$(e)" --caller="${SCRIPT_NAME}"
    ${da_cb_bin} update
    echo ""

    if [ "${C_DA_CB_INSTALL_SANDBOX}" == "yes" ]; then
      # Installing bubble wrap (jailshell)
      msg "$(s cyan)Installing bubble wrap (jailshell) ...$(e)" --caller="${SCRIPT_NAME}"
      # The command bubblewrap is not required anymore (jailshell will take care):
      # ${da_cb_bin} bubblewrap https://forum.directadmin.com/threads/directadmin-v1-645-has-been-released.67373/post-354947
      ${da_cb_bin} jailshell
      get_status_message "$?"
      echo ""
    fi

    # Install maldetect only if clamav is set to install
    # clamav is installed through custombuild command
    if [ "${C_DA_CB_INSTALL_CLAMAV}" == "yes" ]; then
      local maldet_version
      msg "$(s cyan)Removing existing maldetect installation ...$(e)" --caller="${SCRIPT_NAME}"
      # This is based on the uninstall.sh from maldet (but without interaction)
      if [ "$OSTYPE" != "FreeBSD" ]; then
        if test $(cat /proc/1/comm) = "systemd"; then
          systemctl disable maldet.service
          systemctl stop maldet.service
          rm -f /usr/lib/systemd/system/maldet.service
          systemctl daemon-reload
        else
          maldet -k
          if [ -f /etc/redhat-release ]; then
            /sbin/chkconfig maldet off
            /sbin/chkconfig maldet --del
          elif [ -f /etc/debian_version ] || [ -f /etc/lsb-release ]; then
            update-rc.d -f maldet remove
          elif [ -f /etc/gentoo-release ]; then
            rc-update del maldet default
          elif [ -f /etc/slackware-version ]; then
            rm -f /etc/rc.d/rc3.d/S70maldet
            rm -f /etc/rc.d/rc4.d/S70maldet
            rm -f /etc/rc.d/rc5.d/S70maldet
          else
            /sbin/chkconfig maldet off
            /sbin/chkconfig maldet --del
          fi
          rm -f /etc/init.d/maldet
        fi
      fi
      rm -rf /usr/local/maldetect* /etc/cron.d/maldet_pub /etc/cron.daily/maldet /usr/local/sbin/maldet /usr/local/sbin/lmd
      clamav_paths="/usr/local/cpanel/3rdparty/share/clamav/ /var/lib/clamav/ /var/clamav/ /usr/share/clamav/ /usr/local/share/clamav"
      for cpath in $clamav_paths; do
        rm -f $cpath/rfxn.* $cpath/lmd.user.*
      done
      echo "Linux Malware Detect has been uninstalled."
      # End of maldet uninstall.sh script

      echo ""
      msg "Removing previous downloaded file ..."
      rm -fv "${INST_TEMP_DIR}/maldetect-current.tar.gz"
      navigate_to "${INST_TEMP_DIR}"
      msg "Downloading and extracting maldetect file in ${INST_TEMP_DIR} ..."
      curl -SL http://www.rfxn.com/downloads/maldetect-current.tar.gz | tar -xzf -
      echo ""
      # Now after extracted we have csf folder, let's enter to this path
      cd "${INST_TEMP_DIR}"/maldetect-* || exit 0
      msg "$(s cyan)Installing maldetect from official website ...$(e)" --caller="${SCRIPT_NAME}"
      bash ./install.sh
      echo ""

      if ! command -v maldet &>/dev/null; then
        msg "$(s red)Error, maldet was not successfully installed because the binary file is missing!$(e)" --caller="${SCRIPT_NAME}"
        exit 147
      fi

      if [ -f /etc/cron.daily/maldet ]; then
        msg "$(s cyan)Removing maldet daily cronjob at /etc/cron.daily/maldet ...$(e)" --caller="${SCRIPT_NAME}"
        rm -fv /etc/cron.daily/maldet
      fi
      # This is a temporary patch for maldet service that does not run properly. This patch only work with maldet 1.6.4:
      # https://serverfault.com/questions/1077310/update-from-debian-10-to-debian-11-gone-wrong
      # Note this patch will be overwritten if maldet is updated with the same version or never version
      # To keep applying the patch if maldet is updated, see this:
      # https://github.com/rfxn/linux-malware-detect/issues/395
      maldet_version=$(maldet -V | head -1 | cut -d" " -f 4)
      msg "$(s cyan)Maldet version is: ${maldet_version}$(e)" --caller="${SCRIPT_NAME}"
      if [[ "${maldet_version}" == "v1.6.4" && "${DISTRO_ID}" == "debian" && "${DISTRO_CODENAME}" == "bullseye" ]]; then
        if ! command -v inotifywait &>/dev/null; then
          msg "$(s cyan)Installing required package(s) ...$(e)" --caller="${SCRIPT_NAME}"
          apt-get -y install inotify-tools
        fi
        msg "$(s cyan)Patching known bug for maldet 1.6.4 service to run on Debian 11 properly ...$(e)" --caller="${SCRIPT_NAME}"
        sed -i 's#/boot/System.map#/lib/debug/boot/System.map#' /usr/local/maldetect/internals/functions
        get_status_message "$?"
        echo ""
        msg "$(s cyan)Restarting maldet service ...$(e)" --caller="${SCRIPT_NAME}"
        systemctl restart maldet
        get_status_message "$?"
        echo ""
        msg "$(s cyan)Checking maldet running status ...$(e)" --caller="${SCRIPT_NAME}"
        systemctl is-active --quiet maldet
        get_status_message "$?"
      fi
      echo ""
      msg "$(s cyan)Running maldet -V command ...$(e)" --caller="${SCRIPT_NAME}"
      maldet -V
      get_status_message "$?"
    fi

    # Since clamAV and maldet are installed, we can now configure the exclusion list

    echo ""
    # Check all the excluded rules for clamav and maldet (make sure they exist)
    msg "$(s cyan)Checking if clamav and maldet excluded signatures file exist in maxiclam folder ...$(e)" --caller="${SCRIPT_NAME}"
    clamav_exclude_file_list="${SCRIPT_PATH}/maxiclam/clamav_exclude_file_list"
    clamav_exclude_directory_list="${SCRIPT_PATH}/maxiclam/clamav_exclude_directory_list"
    clamav_exclude_extension_list="${SCRIPT_PATH}/maxiclam/clamav_exclude_extension_list"
    clamav_exclude_signature_list="${SCRIPT_PATH}/maxiclam/clamav_exclude_signature_list"

    maldet_exclude_path_list="${SCRIPT_PATH}/maxiclam/maldet_exclude_path_list"
    maldet_exclude_extension_list="${SCRIPT_PATH}/maxiclam/maldet_exclude_extension_list"
    maldet_exclude_signature_list="${SCRIPT_PATH}/maxiclam/maldet_exclude_signature_list"
    maldet_exclude_inotify_list="${SCRIPT_PATH}/maxiclam/maldet_exclude_inotify_list"

    check_path "${clamav_exclude_file_list}" "${clamav_exclude_directory_list}" "${clamav_exclude_extension_list}" "${clamav_exclude_signature_list}" \
      "${maldet_exclude_path_list}" "${maldet_exclude_extension_list}" "${maldet_exclude_signature_list}" "${maldet_exclude_inotify_list}"

    echo ""

    # Copy clamav exclude file list from secure folder:
    msg "$(s cyan)Copying clamav exclude file list from secure folder into /usr/local/maxicode/maxiclam/conf/file.ign ...$(e)" --caller="${SCRIPT_NAME}"
    cp "${clamav_exclude_file_list}" "/usr/local/maxicode/maxiclam/conf/file.ign"
    get_status_message $?
    echo ""

    # Copy clamav exclude directory list from secure folder:
    msg "$(s cyan)Copying clamav exclude directory list from secure folder into /usr/local/maxicode/maxiclam/conf/dir.ign ...$(e)" --caller="${SCRIPT_NAME}"
    cp "${clamav_exclude_directory_list}" "/usr/local/maxicode/maxiclam/conf/directory.ign"
    get_status_message $?
    echo ""

    # Copy clamav exclude extension list from secure folder:
    msg "$(s cyan)Copying clamav exclude extension list from secure folder into /usr/local/maxicode/maxiclam/conf/ext.ign ...$(e)" --caller="${SCRIPT_NAME}"
    cp "${clamav_exclude_extension_list}" "/usr/local/maxicode/maxiclam/conf/ext.ign"
    get_status_message $?
    echo ""

    # Copy clamav exclude signature list from secure folder:
    msg "$(s cyan)Copying clamav signature extension list from secure folder into /usr/local/maxicode/maxiclam/conf/sign.ign ...$(e)" --caller="${SCRIPT_NAME}"
    cp "${clamav_exclude_signature_list}" "/usr/local/maxicode/maxiclam/conf/sign.ign"
    get_status_message $?
    echo ""

    # Special command to update signature list for clamav
    maxiclam signature-list --update-clamav-signature

    echo ""

    # Copy maldet exclude path list from secure folder:
    msg "$(s cyan)Copying maldet exclude path list from secure folder into /usr/local/maldetect/ignore_paths ...$(e)" --caller="${SCRIPT_NAME}"
    cp "${maldet_exclude_path_list}" /usr/local/maldetect/ignore_paths
    get_status_message $?
    echo ""

    # Copy maldet exclude extension list from secure folder:
    msg "$(s cyan)Copying maldet exclude extension list from secure folder into /usr/local/maldetect/ignore_file_ext ...$(e)" --caller="${SCRIPT_NAME}"
    cp "${maldet_exclude_extension_list}" /usr/local/maldetect/ignore_file_ext
    get_status_message $?
    echo ""

    # Copy maldet exclude signature list from secure folder:
    msg "$(s cyan)Copying maldet exclude signature list from secure folder into /usr/local/maldetect/ignore_sigs ...$(e)" --caller="${SCRIPT_NAME}"
    cp "${maldet_exclude_signature_list}" /usr/local/maldetect/ignore_sigs
    get_status_message $?
    echo ""
    # Copy maldet exclude inotify list from secure folder:
    msg "$(s cyan)Copying maldet exclude inotify list from secure folder into /usr/local/maldetect/ignore_inotify ...$(e)" --caller="${SCRIPT_NAME}"
    cp "${maldet_exclude_inotify_list}" /usr/local/maldetect/ignore_inotify
    get_status_message $?
    echo ""

    # ClamAV and exim rebuild
    #msg "$(s cyan)Configuring directadmin custombuild to install ClamAV, rspamd, exim and enabling DKIM ...$(e)" --caller="${SCRIPT_NAME}"

    # Antivirus
    #${da_cb_bin} set clamav yes
    #${da_cb_bin} set clamav_exim yes

    # Rspamd
    #${da_cb_bin} set blockcracking yes
    #${da_cb_bin} set easy_spam_fighter yes
    #${da_cb_bin} set spamd rspamd

    # Exim
    #${da_cb_bin} set exim yes
    #${da_cb_bin} set eximconf yes
    #${da_cb_bin} set eximconf_release "${C_DA_CB_EXIMCONF_RELEASE}"

    # Dkim
    # Enable DKIM for all domain (need to rebuild exim and exim_conf as stated somewhere)
    #${da_bin} set dkim "${C_DA_DKIM}"
    #echo ""
    #msg "$(s cyan)Rebuilding ClamAV, rspamd and exim ...$(e)" --caller="${SCRIPT_NAME}"
    #{
    #  ${da_cb_bin} clamav
    #  ${da_cb_bin} rspamd
    #  ${da_cb_bin} exim
    #  ${da_cb_bin} exim_conf
    #} >>"${da_install_log}" 2> >(grep -v '.......... .......... .......... .......... ..........' 1>&2)
    # Mod security rebuild
    # msg "$(s cyan)Configuring custombuild to rebuild modsecurity with ruleset of ${C_DA_CB_MODSECURITY_RULESET} ...$(e)" --caller="${SCRIPT_NAME}"
    # ${da_cb_bin} set modsecurity yes
    # ${da_cb_bin} set modsecurity_ruleset "${C_DA_CB_MODSECURITY_RULESET}"
    #echo ""
    #msg "$(s cyan)Rebuilding modsecurity with ruleset of ${C_DA_CB_MODSECURITY_RULESET} ...$(e)" --caller="${SCRIPT_NAME}"
    #{
    #  ${da_cb_bin} modsecurity
    #  ${da_cb_bin} modsecurity_rules
    #  ${da_cb_bin} rewrite_confs
    #} >>"${da_install_log}" 2> >(grep -v '.......... .......... .......... .......... ..........' 1>&2)
    #echo ""
    # If I install modsecurity, I need to rebuild nginx_apache because it cannot be started due to modsecurity directive issue. See this:
    # https://forum.directadmin.com/threads/nginx-and-apache-nginix-wont-start-due-to-mod_security.61427/
    # Web server setting rebuild
    #msg "$(s cyan)Configuring custombuild to rebuild ${C_DA_CB_WEBSERVER_SOFTWARE} web server ...$(e)" --caller="${SCRIPT_NAME}"
    #${da_cb_bin} set webserver "${C_DA_CB_WEBSERVER_SOFTWARE}"
    #echo ""
    #msg "$(s cyan)Rebuilding ${C_DA_CB_WEBSERVER_SOFTWARE} web server ...$(e)" --caller="${SCRIPT_NAME}"
    #{
    #  ${da_cb_bin} "${C_DA_CB_WEBSERVER_SOFTWARE}"
    #  ${da_cb_bin} rewrite_confs
    #} >>"${da_install_log}" 2> >(grep -v '.......... .......... .......... .......... ..........' 1>&2)
    #echo ""
    # No need to rebuild because first initial installation already did this (put this value in options.conf instead)
    # msg "$(s cyan)Configuring custombuild to rebuild ${da_sql_type} web server to version ${da_sql_version} ...$(e)" --caller="${SCRIPT_NAME}"
    # da_sql_type=$(echo "${C_DA_CB_SQL_VERSION}" | awk -F'-' '{ print $1 }')
    # da_sql_version=$(echo "${C_DA_CB_SQL_VERSION}" | awk -F'-' '{ print $2 }')
    # msg "$(s magenta)SQL type is set to: ${da_sql_type} from config file$(e)" --caller="${SCRIPT_NAME}"
    # msg "$(s magenta)SQL version is set to: ${da_sql_version} from config file$(e)" --caller="${SCRIPT_NAME}"
    # ${da_cb_bin} set "${da_sql_type}" "${da_sql_version}"
    # ${da_cb_bin} set mysql_inst "${da_sql_type}"
    # ${da_cb_bin} set mysql_backup yes
    # echo ""
    #msg "$(s cyan)Rebuilding ${da_sql_type} web server to version ${da_sql_version} ...$(e)" --caller="${SCRIPT_NAME}"
    #{
    #  ${da_cb_bin} "${da_sql_type}"
    #  ${da_cb_bin} rewrite_confs
    #} >>"${da_install_log}" 2> >(grep -v '.......... .......... .......... .......... ..........' 1>&2)
    #echo ""

    # DA port should be secure don't use 2222 unless you have reason.
    # At this point, we haven't allowed da port 2222 to be connected (blocked by firewall)
    # Below, we just enable the new da port in firewall and set the port to open later using da binary
    #echo ""
    #msg "$(s cyan)Changing directadmin login page redirection port from default port 2222 to port ${C_DA_PORT}$(e)" --caller="${SCRIPT_NAME}"
    #{
    #  echo "<?php"
    #  echo "header(\"Location: http://\".\$_SERVER['HTTP_HOST'].\":${C_DA_PORT}\");"
    #  echo "?>"
    #} >/var/www/html/redirect.php
    #echo ""

    if [ "${DISTRO_ID}" == "centos" ]; then
      if command -v firewall-cmd &>/dev/null; then
        msg "$(s cyan)Adding directadmin new port ${C_DA_PORT}/tcp to firewalld ...$(e)" --caller="${SCRIPT_NAME}"

        sudo firewall-cmd --permanent --zone=public --add-port="${C_DA_PORT}/tcp"

      fi
    elif [ "${DISTRO_ID}" == "debian" ]; then
      if command -v ufw &>/dev/null; then
        msg "$(s cyan)Adding directadmin new port ${C_DA_PORT}/tcp to ufw ...$(e)" --caller="${SCRIPT_NAME}"
        sudo ufw allow "${C_DA_PORT}/tcp"
      fi
    fi

    msg "$(s cyan)Changing directadmin login page redirection port from default port 2222 to port ${C_DA_PORT}$(e)" --caller="${SCRIPT_NAME}"
    {
      echo "<?php"
      echo "header(\"Location: http://\".\$_SERVER['HTTP_HOST'].\":${C_DA_PORT}\");"
      echo "?>"
    } >/var/www/html/redirect.php
    echo ""

    msg "$(s cyan)Setting the redirect.php permission to webapps $(e)" --caller="${SCRIPT_NAME}"
    chown webapps:webapps /var/www/html/redirect.php
    echo ""

    msg "$(s cyan)Setting directadmin port to ${C_DA_PORT} ...$(e)" --caller="${SCRIPT_NAME}"
    ${da_bin} set port "${C_DA_PORT}" restart
    echo ""

    # This fixed workaround Directadmin BFM did not block: https://forum.directadmin.com/threads/no-automatic-block-on-directadmin-interface-login.65837/post-344532
    # The workaround is needed only if we are running DA 1.63.7 and older. I'm using newest version so this is not needed:
    # msg "$(s cyan)Creating ip_whitelist file in /usr/local/directadmin/data/admin/ip_whitelist ...$(e)" --caller="${SCRIPT_NAME}"
    #touch /usr/local/directadmin/data/admin/ip_whitelist
    #echo ""
    # msg "$(s cyan)Fixing file permission of /usr/local/directadmin/data/admin/ip_whitelist ...$(e)" --caller="${SCRIPT_NAME}"
    # chown diradmin.diradmin /usr/local/directadmin/data/admin/ip_whitelist
    #echo ""

    msg "$(s cyan)Requesting directadmin to restart ...$(e)" --caller="${SCRIPT_NAME}"
    restart_da
    echo ""

    # This is optional
    msg "$(s cyan)Rewriting virtual host files ... $(e)" --caller="${SCRIPT_NAME}"
    ${da_cb_bin} rewrite_confs
    echo ""
    # Optional end

    # At this moment directadmin can be login using a new port ${C_DA_PORT}"
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This will create directadmin custom scripts
configure_da_scripts() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_conf da_sql_type da_sql_version da_install_log da_bin da_cb_bin da_script_path grep_count
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_script_path="/usr/local/directadmin/scripts"
    da_custom_script_path="/usr/local/directadmin/scripts/custom"
    aa_scripts_path="/usr/local/directadmin/scripts/custom/aa_hook_scripts"
    aa_da_scripts_path="${aa_scripts_path}/scripts"
    aa_main_script_options_conf="${aa_scripts_path}/aa_options.conf"
    aa_main_script_template="${aa_scripts_path}/templates/aa_main.sh"

    # Add da hook script name here to install automatically
    if [ -n "${C_AA_INSTALL_DA_HOOKS}" ]; then
      # Get it from config file
      da_setup_hook_scripts="${C_AA_INSTALL_DA_HOOKS[@]}"
    else
      # If config file does not exist, use this default hook script (all are defined here as on 6th December 2022):
      da_setup_hook_scripts=("all_backups_post" "all_backups_pre" "all_pre" "all_post" "all_restores_post" "autoresponder_delete_pre" "autoresponder_set_post"
        "autoresponder_set_pre" "backup_save_pre" "brute_force_notify_pre" "check_letsencrypt_expiries_post" "check_partitions_notice_post" "cmd_site_backup_pre"
        "cmd_user_backup_pre" "connection_info_post" "cron_set_post" "cron_set_pre" "database_create_post" "database_create_pre" "database_delete_post" "database_delete_pre"
        "database_destroy_user_post" "database_user_create_post" "database_user_password_change_post" "database_user_password_change_pre" "dkim_create_post" "dns_create_post"
        "dns_delete_post" "dns_raw_save_post" "dns_write_post" "dnssec_sign_post" "domain_change_post" "domain_change_pre" "domain_create_post" "domain_create_pre" "domain_destroy_post"
        "domain_destroy_pre" "domain_modify_post" "domain_modify_pre" "domain_pointer_create_post" "domain_pointer_create_pre" "domain_pointer_destroy_post" "domain_pointer_destroy_pre"
        "email_change_pass_post" "email_change_pass_pre" "email_create_post" "email_create_pre" "email_destroy_post" "email_destroy_pre" "email_filter_write_post" "email_filter_write_pre"
        "file_manage_upload_post" "filemanager_pre" "forwarder_create_post" "forwarder_create_pre" "forwarder_delete_post" "forwarder_delete_pre" "ftp_change_pass_post" "ftp_change_pass_pre"
        "ftp_create_post" "ftp_delete_post" "ftp_modify_post" "ip_change_post" "ip_change_pre" "ipsconf_write_post" "lestencrypt_post" "letsencrypt_pre" "load_spike_notice_post" "load_spike_notice_pre"
        "login_key_create_post" "login_key_modify_post" "lost_password_pre" "mailing_list_save_post" "named_action_post" "notifyAdmins_post" "one_click_pma_login_post" "other_disk_usage" "overusage_notice_post"
        "overusage_notice_pre" "package_copy_post" "package_copy_pre" "package_delete_post" "package_delete_pre" "package_rename_post" "package_rename_pre" "package_write_post" "package_write_pre"
        "public_html_link_set_post" "public_html_link_set_pre" "reseller_destroy_pre" "reseller_modify_post" "reseller_modify_pre" "rotate_log_post" "rspamd_destroy_pre" "rspamd_edit_post" "rspamd_edit_pre"
        "sendmail_pre" "sendSystemMessage_post" "sendSystemMessage_pre" "service_down_notice" "session_create_pre" "session_destroy_pre" "spam_script_chmod_0_post" "spamassassin_destroy_pre" "spamassassin_edit_post"
        "spamassassin_edit_pre" "ssl_save_post" "ssl_save_pre" "subdomain_create_post" "subdomain_create_pre" "subdomain_destroy_post" "subdomain_destroy_pre" "tally_post" "tally_pre" "tally_rotation_post" "tally_user_post"
        "taskq_dns_post" "update_post" "user_activate_post" "user_activate_pre" "user_backup_compress_pre" "user_backup_failed" "user_backup_post" "user_backup_pre" "user_backup_success" "user_create_post" "user_create_post_confirmed"
        "user_create_pre" "user_destroy_post" "user_destroy_pre" "user_httpd_write_post" "user_httpd_write_pre" "user_info_modify_post" "user_modify_post" "user_modify_pre" "user_password_change_post" "user_password_change_pre"
        "user_restore_fail_post" "user_restore_post" "user_restore_post_pre_cleanup" "user_restore_pre" "user_suspend_post" "user_suspend_pre" "vacation_set_post" "vacation_set_pre")
    fi
    msg "$(s cyan)Checking directadmin path ... $(e)" --caller="${SCRIPT_NAME}"
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}" "${da_script_path}" "${da_custom_script_path}"

    if [ ! -d "${SCRIPT_PATH}/directadmin" ]; then
      msg "$(s red)Error, directadmin folder is missing from ${SCRIPT_PATH}/directadmin. The folder should exist!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    echo ""

    # This will copy the main template into custom hook script
    msg "$(s cyan)Removing custom hook script scripts from ${da_custom_script_path}/aa_hook_scripts ...$(e)" --caller="${SCRIPT_NAME}"
    rm -rf "${da_custom_script_path}/aa_hook_scripts"
    get_status_message "$?"
    echo ""
    msg "$(s cyan)Copying all aa custom hook scripts data from ${SCRIPT_PATH}/directadmin/custom_scripts/aa_hook_scripts into ${da_custom_script_path}/ ...$(e)" --caller="${SCRIPT_NAME}"
    cp -r "${SCRIPT_PATH}/directadmin/custom_scripts/aa_hook_scripts" ${da_custom_script_path}/
    get_status_message "$?"
    echo ""

    msg "$(s cyan)Configuring custom hook script logging at ${aa_main_script_options_conf} based on config file ...$(e)" --caller="${SCRIPT_NAME}"
    sed -i "s|^AA_ENABLE_HOOK_LOG\=.*|AA_ENABLE_HOOK_LOG=${C_AA_ENABLE_DA_HOOK_SCRIPT_LOG}|" ${aa_main_script_options_conf}
    get_status_message "$?"
    echo ""

    msg "$(s cyan)Configuring global custom hook script logging at ${aa_main_script_options_conf} based on config file ...$(e)" --caller="${SCRIPT_NAME}"
    sed -i "s|^AA_ENABLE_GLOBAL_HOOK_LOG\=.*|AA_ENABLE_GLOBAL_HOOK_LOG=${C_AA_ENABLE_GLOBAL_HOOK_LOG}|" ${aa_main_script_options_conf}
    get_status_message "$?"
    echo ""

    msg "$(s cyan)Enabling individual da hook script at ${aa_main_script_options_conf} based on config file ...$(e)" --caller="${SCRIPT_NAME}"
    sed -i "s|^AA_ENABLE_HOOKS\=.*|AA_ENABLE_HOOKS=($(printf "\"%s\" " "${C_AA_ENABLE_DA_HOOKS[@]}" | sed -e 's/\ *$//g'))|" ${aa_main_script_options_conf}
    get_status_message "$?"
    echo ""

    msg "$(s cyan)Configuring notification log for disabled hook script at ${aa_main_script_options_conf} based on config file ...$(e)" --caller="${SCRIPT_NAME}"
    sed -i "s|^AA_ENABLE_LOG_FOR_DISABLED_DA_HOOK\=.*|AA_ENABLE_LOG_FOR_DISABLED_DA_HOOK=${C_DA_AA_ENABLE_LOG_FOR_DISABLED_DA_HOOK}|" ${aa_main_script_options_conf}
    get_status_message "$?"
    echo ""

    # Make sure the main hook script template exist
    check_path "${aa_main_script_template}"

    echo ""

    for da_setup_hook_script in ${da_setup_hook_scripts[*]}; do
      msg "$(s cyan)Removing existing custom hook script ${da_setup_hook_script} ...$(e)" --caller="${SCRIPT_NAME}"
      rm -rf "${da_custom_script_path}/${da_setup_hook_script}"
      get_status_message "$?"
      echo ""

      # This create hook_script at /usr/local/directadmin/scripts/custom/aa_hook_scripts/scripts/<hook_scripts_list>
      # This is to make sure that the folders matched inside directadmin custom hook script
      msg "$(s cyan)Creating aa custom hook script ${da_setup_hook_script} in ${aa_da_scripts_path}/${da_setup_hook_script}... $(e)" --caller="${SCRIPT_NAME}"
      mkdir -p "${aa_da_scripts_path}/${da_setup_hook_script}"
      get_status_message "$?"
      echo ""

      # If options.conf file does not exist in the hook script folder, we create that file
      if [ ! -f "${aa_da_scripts_path}/${da_setup_hook_script}/options.conf" ]; then
        msg "$(s cyan)Creating aa custom hook script ${da_setup_hook_script} in ${aa_da_scripts_path}/${da_setup_hook_script}... $(e)" --caller="${SCRIPT_NAME}"
        echo "RUN_HOOK_SCRIPT_LIST=(\"\")" >"${aa_da_scripts_path}/${da_setup_hook_script}/options.conf"
        get_status_message "$?"
        echo ""
      fi

      # This will create hook_script at /usr/local/directadmin/scripts/custom/<hook_scripts_list>
      msg "$(s cyan)Creating da custom hook script ${da_setup_hook_script} in ${da_custom_script_path}/${da_setup_hook_script} ... $(e)" --caller="${SCRIPT_NAME}"
      mkdir -p "${da_custom_script_path}/${da_setup_hook_script}"
      get_status_message "$?"
      echo ""

      msg "$(s cyan)Copying aa_main.sh template into custom hook script ${da_setup_hook_script} in ${da_custom_script_path}/${da_setup_hook_script}/aa_main.sh ... $(e)" --caller="${SCRIPT_NAME}"
      cp "${aa_main_script_template}" "${da_custom_script_path}/${da_setup_hook_script}/aa_main.sh"
      get_status_message "$?"
      echo ""

      msg "$(s cyan)Making the main hook script aa_main.sh inside ${da_setup_hook_script} executable in ${da_custom_script_path}/${da_setup_hook_script}/aa_main.sh ... $(e)" --caller="${SCRIPT_NAME}"
      chmod +x "${da_custom_script_path}/${da_setup_hook_script}/aa_main.sh"
      get_status_message "$?"
      echo ""

    done

    msg "$(s cyan)Setting up directadmin custom hook script to be able to pass custom variables ...$(e)" --caller="${SCRIPT_NAME}"
    ${da_bin} set hook_custom_vars "${C_DA_HOOK_CUSTOM_VARS}"
    echo ""

    msg "$(s cyan)Setting up directadmin custom hook script logging on success status (only available for dns_write_post) ... $(e)" --caller="${SCRIPT_NAME}"
    ${da_bin} set special_exit_code "${C_DA_SPECIAL_EXIT_CODE}"
    echo ""

    msg "$(s cyan)Setting up all_pre and all_post hook scripts to always display environment variables ... $(e)" --caller="${SCRIPT_NAME}"
    ${da_bin} set always_load_all_script_env_vars "${C_DA_ALWAYS_LOAD_ALL_SCRIPT_ENV_VARS}"
    echo ""

    msg "$(s cyan)Requesting directadmin to restart ...$(e)" --caller="${SCRIPT_NAME}"
    restart_da
    echo ""

    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This will change da related authentication.
# It also has more options to secure DA installation. Example maybe this one we can create 2 step authentication
configure_da_auth() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_scripts_path da_bin da_cb_bin retval
    da_scripts_path="/usr/local/directadmin/scripts"
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"

    msg "$(s cyan)Checking directadmin path ...$(e)" --caller="${SCRIPT_NAME}"
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}" "${da_scripts_path}"
    echo ""

    # This one moved to configure_da_owner_accounts()
    # This will change Directadmin admin account:
    #msg "$(s cyan)Changing the first directadmin admin username from default $(get_current_da_owner_username) username to ${C_DA_OWNER_USERNAME1} ...$(e)" --caller="${SCRIPT_NAME}"
    #${da_scripts_path}/change_username.sh "$(get_current_da_owner_username)" "${C_DA_OWNER_USERNAME1}"
    #echo ""
    # By default, directadmin installation uses a short password which is not secured. Change it here
    #msg "$(s cyan)Changing the first admin (${C_DA_OWNER_USERNAME1})'s password ...$(e)" --caller="${SCRIPT_NAME}"
    # echo "${C_DA_OWNER_USERNAME1}:${C_DA_OWNER_USERPASS1}" | chpasswd
    #echo ""

    # TODO this add custom page for login (using recaptcha) to increase security
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_bind() {
  local run_mode extra_option func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  start_execute_options "${run_mode}" "${func_name}"
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local bind_named_conf grep_found

    if [ "${C_ENABLE_BIND}" == "true" ]; then
      if [ "${DISTRO_ID}" == "debian" ]; then
        bind_named_conf="/etc/bind/named.conf.options"
        if [[ ! -f "${bind_named_conf}" ]]; then
          # This bind option should exist
          msg "$(s yellow)Warning, file named.conf does not exist in ${bind_named_conf}! Installing bind9$(e)" --caller="${SCRIPT_NAME}"
          apt-get -y install bind9
        fi

      else
        # Have not implemented for other distro
        msg "$(s yellow)Warning, please inspect the bind.conf location for this DISTRO ${DISTRO_ID}!$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi

      # Make sure bind is enabled:
      if [ "${C_SERVER_TYPE}" == "directadmin" ]; then
        msg "$(s cyan)Enabling DNS service (named) in directadmin services.status ...$(e)" --caller="${SCRIPT_NAME}"
        sed -i 's/named=OFF/named=ON/' /usr/local/directadmin/data/admin/services.status
        get_status_message "$?"
      fi

      msg "$(s cyan)Stopping DNS service (named) ...$(e)" --caller="${SCRIPT_NAME}"
      service named start
      get_status_message "$?"
      msg "$(s cyan)Enabling DNS service (named) execution script in /etc/init.d/named ...$(e)" --caller="${SCRIPT_NAME}"
      #cp -f /etc/init.d/named.original.backup /etc/init.d/named
      sed -i '/exit 0; #New line from/d' /etc/init.d/named
      get_status_message "$?"
      msg "$(s cyan)Enabling DNS service (named) from systemd startup  in /usr/lib/systemd/system/named.service ...$(e)" --caller="${SCRIPT_NAME}"
      # Original: ExecStart=/usr/sbin/named -f $OPTIONS
      sed -i "s/ExecStart=.*/ExecStart=\/usr\/sbin\/named -f \$OPTIONS/" /usr/lib/systemd/system/named.service
      get_status_message "$?"
      msg "$(s cyan)Enabling DNS service (named) from systemd startup  in /etc/systemd/system/named.service...$(e)" --caller="${SCRIPT_NAME}"
      # Original: ExecStart=/usr/sbin/named -f -u bind
      sed -i "s/ExecStart=.*/ExecStart=\/usr\/sbin\/named -f -u bind/" /etc/systemd/system/named.service
      get_status_message "$?"
      msg "$(s cyan)Reloading systemd startup ...$(e)" --caller="${SCRIPT_NAME}"
      systemctl daemon-reload
      get_status_message "$?"
      echo ""

      # Configure bind here (if needed), based on the named.conf
      grep_found=$(grep -ic 'allow-query { localhost; };' "${bind_named_conf}")
      if [ "${grep_found}" = 0 ]; then
        msg "$(s cyan)Adding option allow-query into ${bind_named_conf}...$(e)" --caller="${SCRIPT_NAME}"
        sed -i "s|\options {|&\n\tallow-query \{ localhost; }; #New line from ${SCRIPT_NAME}|" "${bind_named_conf}"
        get_status_message "$?"
      else
        msg "$(s yellow)[Skipped]: The allow-query value was previously set in ${bind_named_conf}$(e)" --caller="${SCRIPT_NAME}"
      fi
      grep_found=$(grep -ic 'allow-recursion { localhost; };' "${bind_named_conf}")
      if [ "${grep_found}" = 0 ]; then
        msg "$(s cyan)Adding option allow-recursion into ${bind_named_conf}...$(e)" --caller="${SCRIPT_NAME}"
        sed -i "s|\options {|&\n\tallow-recursion\{ localhost; }; #New line from ${SCRIPT_NAME}|" "${bind_named_conf}"
        get_status_message "$?"
      else
        msg "$(s yellow)[Skipped]: The allow-query value was previously set in ${bind_named_conf}$(e)" --caller="${SCRIPT_NAME}"
      fi

      grep_found=$(grep -ic 'version "NA";' "${bind_named_conf}")
      if [ "${grep_found}" = 0 ]; then
        msg "$(s cyan)Adding option version N/A into ${bind_named_conf}...$(e)" --caller="${SCRIPT_NAME}"
        sed -i "s|\options {|&\n\tversion \"NA\"; #New line from ${SCRIPT_NAME}|" "${bind_named_conf}"
        get_status_message "$?"
      else
        msg "$(s yellow)[Skipped]: The version value was previously set in ${bind_named_conf}$(e)" --caller="${SCRIPT_NAME}"
      fi

      grep_found=$(grep -ic 'recursion yes;' "${bind_named_conf}")
      if [ "${grep_found}" = 0 ]; then
        msg "$(s cyan)Adding option recursion yes into ${bind_named_conf}...$(e)" --caller="${SCRIPT_NAME}"
        sed -i "s|\options {|&\n\trecursion yes; #New line from ${SCRIPT_NAME}|" "${bind_named_conf}"
        get_status_message "$?"
      else
        msg "$(s yellow)[Skipped]: The version value was previously set in ${bind_named_conf}$(e)" --caller="${SCRIPT_NAME}"
      fi
      echo ""
      # Enable DNSSEC if supported
      if [ "${C_ENABLE_DNSSEC}" == "true" ]; then
        if [[ "${DNS_PROVIDER}" == "linode" ]]; then
          # https://www.linode.com/docs/guides/dns-manager/#dnssec-limitations
          msg "$(s yellow)[Skipped]: Warning, the DNS provider ${DNS_PROVIDER} does not support DNSSEC$(e)" --caller="${SCRIPT_NAME}"
        else
          msg "$(s cyan)Installing DNSSEC using directadmin script (dnssec.sh) ...$(e)" --caller="${SCRIPT_NAME}"
          ${da_script_path}/dnssec.sh install
          echo ""
          msg "$(s cyan)Adding the some strings into the 'options { .... }' section at ${bind_named_conf} to enable DNSSEC ...$(e)" --caller="${SCRIPT_NAME}"
          if [ -f "${bind_named_conf}" ]; then
            grep_found=$(grep -ic 'bindkeys-file \"\/etc\/bind\/named.iscdlv.key\";' "${bind_named_conf}")
            if [ "${grep_found}" = 0 ]; then
              sed -i "s|\options {|&\n\tbindkeys-file \"\/etc\/bind\/named.iscdlv.key\";|" "${bind_named_conf}"
            fi
            grep_found=$(grep -ic 'dnssec-lookaside auto;' "${bind_named_conf}")
            if [ "${grep_found}" = 0 ]; then
              sed -i "s|\options {|&\n\tdnssec-lookaside auto;|" "${bind_named_conf}"
            fi
            grep_found=$(grep -ic 'dnssec-enable yes;' "${bind_named_conf}")
            if [ "${grep_found}" = 0 ]; then
              sed -i "s|\options {|&\n\tdnssec-enable yes;|" "${bind_named_conf}"
            fi

            # This setting is only useful when DNSSEC is installed (by default it is disabled)
            msg "$(s cyan)Enabling TLSA DNS record in directadmin.conf ...$(e)" --caller="${SCRIPT_NAME}"
            ${da_bin} set dns_tlsa 1
            echo ""
            msg "$(s cyan)Requesting directadmin to restart ...$(e)" --caller="${SCRIPT_NAME}"
            restart_da
            echo ""
          else
            msg "$(s red)Error,the file ${bind_named_conf} does not exist! Make sure bind is installed first!$(e)" --caller="${SCRIPT_NAME}"
            exit 1
          fi
        fi
      else
        msg "$(s yellow)[Skipped]: The setting C_ENABLE_DNSSEC is not set to true. DNSSEC installation is skipped!$(e)" --caller="${SCRIPT_NAME}"
      fi
    else
      msg "$(s cyan)Removing bind DNS service (named) in directadmin ...$(e)" --caller="${SCRIPT_NAME}"
      echo ""
      # Guide: https://help.directadmin.com/item.php?id=25
      # Disable named or DNS service
      if [ "${C_SERVER_TYPE}" == "directadmin" ]; then
        msg "$(s cyan)Disabling DNS service (named) in directadmin services.status ...$(e)" --caller="${SCRIPT_NAME}"
        sed -i 's/named=ON/named=OFF/' /usr/local/directadmin/data/admin/services.status
        get_status_message "$?"
      fi
      msg "$(s cyan)Stopping DNS service (named) ...$(e)" --caller="${SCRIPT_NAME}"
      service named stop
      get_status_message "$?"

      grep_found=$(grep -ic 'exit 0; \#New line' /etc/init.d/named)
      if [ "${grep_found}" = 0 ]; then
        msg "$(s cyan)Halting DNS service (named) execution script in /etc/init.d/named ...$(e)" --caller="${SCRIPT_NAME}"
        sed -i "s|\#\!\/bin\/sh -e|&\nexit 0; #New line from ${SCRIPT_NAME}|" /etc/init.d/named
        get_status_message "$?"
      else
        msg "$(s yellow)[Skipped]: Already halted DNS service (named) execution script in /etc/init.d/named ...$(e)" --caller="${SCRIPT_NAME}"
      fi
      #cp -f /etc/init.d/named /etc/init.d/named.original.backup
      #{
      #  echo "#!/bin/bash"
      #  echo "exit 0;"
      #} >/etc/init.d/named
      msg "$(s cyan)Halting DNS service (named) from systemd startup  in /usr/lib/systemd/system/named.service ...$(e)" --caller="${SCRIPT_NAME}"
      # Original: ExecStart=/usr/sbin/named -f $OPTIONS
      sed -i "s/ExecStart=.*/ExecStart=echo -n ''/" /usr/lib/systemd/system/named.service
      get_status_message "$?"
      msg "$(s cyan)Halting DNS service (named) from systemd startup  in /etc/systemd/system/named.service...$(e)" --caller="${SCRIPT_NAME}"
      # Original: ExecStart=/usr/sbin/named -f -u bind
      if [ -f "/etc/systemd/system/named.service" ]; then
        sed -i "s/ExecStart=.*/ExecStart=echo -n ''/" /etc/systemd/system/named.service
        get_status_message "$?"
      fi

      msg "$(s cyan)Reloading systemd startup ...$(e)" --caller="${SCRIPT_NAME}"
      systemctl daemon-reload
      get_status_message "$?"
      echo ""
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This will configure both ipv4 and ipv6 (add ipv4 or ipv6) and link them together only based on the IP from config files
# configure_da_ips --run-force --init, the option --init removes previous data and force this function configure_da_ips to start from scratch, useful if the ipv6 file is corrupted
configure_da_ips() {
  local run_mode extra_option func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  start_execute_options "${run_mode}" "${func_name}"
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_ip_list da_conf da_bin da_cb_bin \
      da_ipv4_adds da_ipv4 c_da_ipv4 da_ipv4_file ipv4_found \
      da_ipv6_adds da_ipv6 c_da_ipv6 da_ipv6_file ipv6_found linked_ips

    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"

    msg "$(s cyan)Checking directadmin paths ...$(e)" --caller="${SCRIPT_NAME}"
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}"
    echo ""

    da_ip_list="/usr/local/directadmin/data/admin/ip.list"

    da_ipv4_adds=$(ls /usr/local/directadmin/data/admin/ips/*.* 2>/dev/null)
    da_ipv6_adds=$(ls /usr/local/directadmin/data/admin/ips/*:* 2>/dev/null)

    # Get IPv6 config file
    c_da_ipv4="${C_IPV4_ADD0}"
    # Directadmin IP file use this form 1234:1234:0:0:1234:1234 so we need to convert ipv6 from config file into this form using ipv6calc
    maxibuild --include "ipv6calc"
    c_da_ipv6=$(ipv6calc --addr2uncompaddr "${C_IPV6_ADD0}")

    ipv6_da_file="/usr/local/directadmin/data/admin/ips/${c_da_ipv6}"
    # This ipv4_da_file is not required at this moment but left for reference:
    #ipv4_da_file="/usr/local/directadmin/data/admin/ips/${c_da_ipv4}"

    # Very important note. The reason we enable ipv6=1 is to enable ipv6 form to add Ipv6 in directadmin system (without this step API might have problem)
    msg "$(s cyan)Enabling ipv6 in directadmin.conf config before adding IPv6...$(e)" --caller="${SCRIPT_NAME}"
    ${da_bin} set ipv6 1
    echo ""
    # Must restart to enable the ipv6 form
    msg "$(s cyan)Requesting directadmin to restart after changing directadmin.conf ...$(e)" --caller="${SCRIPT_NAME}"
    restart_da
    echo ""
    # Configure IPv4 address (Check existing)
    msg "$(s cyan)Checking if there is any directadmin IPv4 files exist inside /usr/local/directadmin/data/admin/ips/ ...$(e)" --caller="${SCRIPT_NAME}"

    if [ -z "${da_ipv4_adds}" ]; then
      # Display error instead of warning because ipv4 address based on config should exist in directadmin as default IP. If it does not exist, that means, something wrong with the DA installation
      msg "$(s red)Error, there is no IPv4 IP address file is found inside /usr/local/directadmin/data/admin/ips/. There must be an IPv4 address ${C_IPV4_ADD0} exist in the location!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
      # Below is not required at this moment
      #msg "$(s yellow)Warning, there is no IPv4 IP address file is found inside /usr/local/directadmin/data/admin/ips/ $(e)" --caller="${SCRIPT_NAME}"
      #if [ "${C_DA_AUTO_ADD_IPV46_ENTRY}" == "true" ]; then
      #  msg "$(s cyan)Automatically added missing IPv4 IP address using directadmin API ... $(e)" --caller="${SCRIPT_NAME}"
      da_api_admin add-ip --ip-address "${C_IPV4_ADD0}" --netmask "${C_IPV4_NETMASK_IP0}"
      #else
      #  msg "$(s yellow)Warning, C_DA_AUTO_ADD_IPV46_ENTRY is not set. Please manually add missing IPv4 IP address via GUI$(e)" --caller="${SCRIPT_NAME}"
      #  # Give details how to login and add here
      #  exit 1
      #fi
    fi

    for da_ipv4_file in $(echo "${da_ipv4_adds}" | tr ' ' '\n'); do
      # From da ip file
      da_ipv4=$(basename "${da_ipv4_file}")
      msg "da_ipv4 is ${da_ipv4}"
      if [[ "${da_ipv4}" == "${c_da_ipv4}" ]]; then
        msg "$(s green)OK, found the IPv4 address ${C_IPV4_ADD0} that matches with the IP file in [${da_ipv4_file}]$(e)" --caller="${SCRIPT_NAME}"
        # We should break this and ignore others because we only want the IP that match in the config file
        ipv4_found=true
        break
      else
        msg "$(s yellow)[Ignored]: Warning, the IPv4 address ${C_IPV4_ADD0} does not match with the IP file in [${da_ipv4_file}]$(e)" --caller="${SCRIPT_NAME}"
        ipv4_found=false
      fi
    done

    if [[ "${ipv4_found}" == "false" ]]; then
      msg "$(s red)Error, no IPv4 matching found between config file and directadmin IP files. At least one IP should be there. Something is wrong, please inspect$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi
    echo ""

    # IPV6 start here
    # ( deprecated ): If --init passed in extra_option, we force rebuild the IP (only IPv6 was modified so we only remove ipv6 file to start over)
    # We do not need to have this option, we force rebuild IPv6 by removing it first
    #if [ "${extra_option}" == "--init" ]; then
    msg "$(s cyan)Removing existing directadmin IPv6 IP files to rebuild IPv6 IP ...$(e)" --caller="${SCRIPT_NAME}"
    rm -f ${da_ipv6_adds}
    echo ""
    #fi
    # So we always have empty IPv6 then we can rebuild:
    msg "$(s cyan)Checking if there is any directadmin Ipv6 files exist inside /usr/local/directadmin/data/admin/ips/ ...$(e)" --caller="${SCRIPT_NAME}"
    if [ -z "${da_ipv6_adds}" ]; then
      # For Ipv6, we don't display error and exit, we auto add the IP based on the config file
      msg "$(s yellow)Warning, there is no IPv6 IP address file is found inside /usr/local/directadmin/data/admin/ips/ $(e)" --caller="${SCRIPT_NAME}"
      if [ "${C_DA_AUTO_ADD_IPV46_ENTRY}" == "true" ]; then
        msg "$(s cyan)Automatically adding missing IPv6 IP address using directadmin API ... $(e)" --caller="${SCRIPT_NAME}"
        #1) First method: Create ipv6 file using directadmin API
        # Use converted IPv6 (I don't have to convert it actually, this will be done automatically)
        da_api_admin add-ip --ip-address "${c_da_ipv6}" --netmask "${C_IPV6_NETMASK0}"

        #2) Second method: Manually create ipv6 file (alternative way) if the above method API doesn't produce the IP file (just in case)
        if [ ! -f "${ipv6_da_file}" ]; then
          # Normally API will not fail, but just in case if ipv6 file is still not created,
          # we can use this unofficial method created by me here:
          # https://forum.directadmin.com/threads/how-to-add-ip6-address-in-da-via-terminal-not-through-gui.62752/
          msg "$(s cyan)Automatically adding missing IPv6 IP address using manual file creation ...$(e)" --caller="${SCRIPT_NAME}"
          touch "${ipv6_da_file}"
          {
            echo "gateway="
            echo "global=no"
            echo "linked_ips="
            echo "netmask=/64"
            echo "ns="
            echo "reseller="
            echo "status=free"
            echo "value="
          } >"${ipv6_da_file}"
          chmod 600 "${ipv6_da_file}"
          chown diradmin:diradmin "${ipv6_da_file}"
          grep_result=$(grep -c "${c_da_ipv6}" "${da_ip_list}")
          if [ "${grep_result}" -ne 0 ]; then
            echo "${c_da_ipv6}" >>"${da_ip_list}"
          fi
          msg "$(s cyan)Rebuilding server config files for new IPv6 ...$(e)" --caller="${SCRIPT_NAME}"
          ${da_cb_bin} rewrite_confs >/dev/null
        fi
        # Update new variable to read IPv6
        da_ipv6_adds=$(ls /usr/local/directadmin/data/admin/ips/*:* 2>/dev/null)
      else
        msg "$(s yellow)Warning, IPv6 has not been setup through Directadmin and C_DA_AUTO_ADD_IPV46_ENTRY is not set to true. Please manually enter IPv6 from GUI (full form) then run this script again$(e)" --caller="${SCRIPT_NAME}"
        # Enable the DA port in firewall only when pressing enter (good confirmation from user)
        read -r -s -n 1 -p "[${SCRIPT_NAME}]: Press any key to start adding TCP port ${C_DA_PORT}/tcp in ufw to allow directadmin login ..."
        echo ""
        msg "$(s cyan)Allowing TCP port ${C_DA_PORT}/tcp for accessing directadmin admin login page ...$(e)" --caller="${SCRIPT_NAME}"
        sudo ufw allow "${C_DA_PORT}/tcp"
        echo ""
        # Need to restart directadmin because we did change port from 2222 to new port before calling this function
        msg "$(s cyan)Requesting directadmin to restart$(e)" --caller="${SCRIPT_NAME}"
        restart_da
        msg "$(s green)Use the following login information to enter into directadmin login admin page and then add IPv6 IP address. When you are done, re-run this script again:$(e)" --caller="${SCRIPT_NAME}"
        echo ""
        msg "$(s magenta)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
        echo "Directadmin admin login page can be accessed through http://${C_IPV4_ADD0}:${C_DA_PORT}"
        echo "username: ${C_DA_OWNER_USERNAME1}"
        echo "password: ${C_DA_OWNER_USERPASS1}"
        echo ""
        echo "Directadmin default setup.txt information:"
        awk '{ print }' /usr/local/directadmin/scripts/setup.txt
        msg "$(s magenta)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
        echo ""
        # Need to exit this because we need to re-run this script before mark it as executed
        exit 1
      fi
    fi

    # This is for linking between IPv6 and IPv4
    for da_ipv6_file in $(echo "${da_ipv6_adds}" | tr ' ' '\n'); do
      # From da ip file
      da_ipv6=$(basename "${da_ipv6_file}")
      msg "da_ipv6 is ${da_ipv6}"
      if [[ "${da_ipv6}" == "${c_da_ipv6}" ]]; then
        msg "$(s green)OK, found the IPv6 address ${C_IPV6_ADD0} that matches with the IP file in [${da_ipv6_file}]$(e)" --caller="${SCRIPT_NAME}"
        # We should break this and ignore others because we only want the IP that match in the config file
        ipv6_found=true
        echo ""
        echo "Linking Ipv4 and Ipv6 ..."
        echo ""
        msg "$(s green)Checking if IPs are linked based on IPv6 IP file ...$(e)" --caller="${SCRIPT_NAME}"
        linked_ips=$(sed -n 's/^linked_ips=//p' "${da_ipv6_file}")
        if [[ "${linked_ips}" == "" || -z "${linked_ips}" ]]; then

          msg "$(s yellow)Warning, the IPv6 address linked_ip data is empty in file ${da_ipv6_file}!$(e)" --caller="${SCRIPT_NAME}"
          echo ""
          if [ "${C_DA_AUTO_LINK_IP}" == "true" ]; then
            msg "$(s cyan)Linking IPv6 address ${da_ipv6} with IPv4 address ${C_IPV4_ADD0} using directadmin task.queue ...$(e)" --caller="${SCRIPT_NAME}"
            echo "action=linked_ips&ip_action=add&ip=${da_ipv6}&ip_to_link=${C_IPV4_ADD0}&apache=yes&dns=yes&apply=yes" >>/usr/local/directadmin/data/task.queue
            /usr/local/directadmin/dataskq d2000 >/dev/null
            echo ""
            msg "$(s cyan)Linking IPv4 address ${C_IPV4_ADD0} with IPv6 address ${da_ipv6} using directadmin task.queue ...$(e)" --caller="${SCRIPT_NAME}"
            echo "action=linked_ips&ip_action=add&ip=${C_IPV4_ADD0}&ip_to_link=${da_ipv6}&apache=yes&dns=yes&apply=yes" >>/usr/local/directadmin/data/task.queue
            /usr/local/directadmin/dataskq d2000 >/dev/null
            echo ""
            # Here we check if the linking progress is success, if success, break the loop
            while :; do
              # Normally directadmin task.queue completes in 1 minute but sometimes it is less than 10 seconds, so we reduce the check in seconds
              msg "$(s yellow)Waiting for the IPv4 address and IPv6 address are linked together from task.queue ....$(e)" --start-spin --caller="${SCRIPT_NAME}"
              linked_ips=$(sed -n 's/^linked_ips=//p' "${da_ipv6_file}")
              if [[ -n "${linked_ips}" ]]; then
                msg "$(s green)OK, found IPv6 linked_ips with value: ${linked_ips}$(e)" --stop-spin --caller="${SCRIPT_NAME}"
                # This is when success, we create that executed flag file and break the loop.
                # Good idea to break we only need first match. no reason to loop again.
                break
              fi
              sleep 5
            done
          else
            msg "$(s yellow)Warning C_DA_AUTO_LINK_IP is not set to true. Please manually link the IPv4 address and IPv6 address via directadmin and run this script again!$(e)" --start-spin --caller="${SCRIPT_NAME}"
            # Enable the DA port in firewall only when pressing enter (good confirmation from user)
            read -r -s -n 1 -p "[${SCRIPT_NAME}]: Press any key to start adding TCP port ${C_DA_PORT}/tcp in ufw to allow directadmin login ..."
            echo ""
            msg "$(s cyan)Allowing TCP port ${C_DA_PORT}/tcp for accessing directadmin admin login page ...$(e)" --caller="${SCRIPT_NAME}"
            sudo ufw allow "${C_DA_PORT}/tcp"
            echo ""
            # Need to restart directadmin because we did change port from 2222 to new port before calling this function
            msg "$(s cyan)Requesting directadmin to restart$(e)" --caller="${SCRIPT_NAME}"
            restart_da
            msg "$(s green)Use the following login information to enter into directadmin login admin page and then link the IPv4 IP address with IPv6 IP address. When you are done, re-run this script again:$(e)" --caller="${SCRIPT_NAME}"
            echo ""
            msg "$(s magenta)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
            echo "Directadmin admin login page can be accessed through http://${C_IPV4_ADD0}:${C_DA_PORT}"
            echo "username: ${C_DA_OWNER_USERNAME1}"
            echo "password: ${C_DA_OWNER_USERPASS1}"
            echo ""
            echo "Directadmin default setup.txt information:"
            awk '{ print }' /usr/local/directadmin/scripts/setup.txt
            msg "$(s magenta)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
            echo ""
            # Need to exit this because we need to re-run this script before mark it as executed
            exit 1
          fi
        else
          msg "$(s green)OK, already found IPv6 linked_ips with value: ${linked_ips}$(e)" --caller="${SCRIPT_NAME}"
        fi
        break
      else
        msg "$(s yellow)[Ignored]: Warning, the IPv6 address ${C_IPV6_ADD0} does not match with the IP file in [${da_ipv6_file}]$(e)" --caller="${SCRIPT_NAME}"
        ipv6_found=false
      fi
    done

    if [[ "${ipv6_found}" == "false" ]]; then
      msg "$(s red)Error, no IPv6 matching found between config file and directadmin IP files. At least one IP should be there. Something is wrong, please inspect$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Install CSF Firewall in DA way
# Important note, CSF will auto add port 2222 if detect directadmin BUT if the port is changed before installation, it will not add custom port!
# So at this point DA is not accesible using custom port
# To add custom port for directadmin call configure_csf() function
install_da_csf() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    csf_conf=/etc/csf/csf.conf

    # This fixed lfd cannot started
    maxibuild --include "libio-socket-inet6-perl"
    if [[ "${C_DA_INSTALL_TYPE}" == "auto" ]]; then
      msg "$(s yellow)[Skipped]: Directadmin installation type is set to AUTO which already included CSF installation$(e)" --caller="${SCRIPT_NAME}"
    elif [[ "${C_DA_CB_INSTALL_CSF}" == "yes" ]]; then
      msg "$(s cyan)Setting CSF installation in custombuild option ...$(e)" --caller="${SCRIPT_NAME}"
      "${da_cb_bin}" set csf yes
      get_status_message "$?"
      echo ""
      msg "$(s cyan)Installing CSF based on custombuild option set in config file ...$(e)" --caller="${SCRIPT_NAME}"
      "${da_cb_bin}" csf
      get_status_message "$?"
    else
      # CSF is a must for this server, even if C_DA_CB_INSTALL_CSF == "no" we still need to install it manual way like below:
      # For manual installation of CSF when csf=no is set in custombuild (this might not be supported by DA in the future as DA has its own ./build csf)
      # The ./build csf might use this script IMO because the documentation still supports it: https://docs.directadmin.com/directadmin/general-usage/securing-with-bfm.html#enabling-csf-for-an-existing-server
      if ! command -v csf &>/dev/null; then
        local csf_conf da_conf inst_result csf_pignore inst_result csf_pignore
        msg "$(s cyan)No CSF binary is found (CSF is not installed)$(e)" --caller="${SCRIPT_NAME}"
        msg "$(s cyan)Installing CSF on ${C_BOX_HOSTNAME_FQHN} for directadmin based on (poralix steps) ...$(e)" --caller="${SCRIPT_NAME}"
        sleep 2

        msg "$(s cyan)Checking whether directadmin config is exist ...$(e)" --caller="${SCRIPT_NAME}"

        if [ ! -s "${da_conf}" ]; then
          if [ -s /usr/local/directadmin/data/templates/directadmin.conf ]; then
            # this template contains the default value for directadmin.conf
            da_conf=/usr/local/directadmin/data/templates/directadmin.conf
            msg "$(s yellow)Warning, directadmin is not yet installed. Will use ${da_conf} for settings$(e)" --caller="${SCRIPT_NAME}"
          else
            msg "$(s red)Error, cannot find conf/directadmin.conf, nor data/templates/directadmin.conf. Please install directadmin first$(e)" --caller="${SCRIPT_NAME}"
            exit 147
          fi
        fi
        echo ""
        msg "$(s cyan)Downloading Config Server Firewall (CSF) ...$(e)" --caller="${SCRIPT_NAME}"
        navigate_to /usr/local/src
        wget --no-verbose -O csf.tgz https://download.configserver.com/csf.tgz
        if [ ! -s csf.tgz ]; then
          msg "$(s red)Error, download failed for csf.tgz. Please inspect manually and re-run this script to continue$(e)" --caller="${SCRIPT_NAME}"
          exit 1
        else
          msg "$(s cyan)Unzipping downloaded file csf.tgz ... $(e)" --caller="${SCRIPT_NAME}"
          tar -zxf csf.tgz
          navigate_to ./csf
          echo ""
        fi

        inst_result=$(./csftest.pl | tail -n 1 | grep -c 'RESULT: csf should function on this server')
        if [ "${inst_result}" != "1" ]; then
          ./csftest.pl
          echo ""
          echo ""
          msg "$(s red)Error, CSF installation test did not pass. Please inspect manually and re-run this script to continue$(e)" --caller="${SCRIPT_NAME}"
          exit 1
        else
          msg "$(s green)OK, CSF installation test passed! Installing CSF for Directadmin ...$(e)" --caller="${SCRIPT_NAME}"
          echo ""
          ./install.directadmin.sh
          echo ""
          if [ ! -s "${csf_conf}" ]; then
            msg "$(s red)Error, cannot find ${csf_conf} after installation. Please inspect manually and re-run this script to continue$(e)" --caller="${SCRIPT_NAME}"
            exit 1
          fi
        fi
        echo ""
        msg "$(s cyan)Ignoring CSF alert for some users in csf.pignore ...$(e)" --caller="${SCRIPT_NAME}"
        csf_pignore=/etc/csf/csf.pignore
        if [ -e "${csf_pignore}" ]; then
          if ! grep -m1 -q '^user:mysql$' "${csf_pignore}"; then
            echo "user:mysql" >>"${csf_pignore}"
          fi
          if ! grep -m1 -q '^user:diradmin$' "${csf_pignore}"; then
            echo "user:diradmin" >>"${csf_pignore}"
          fi
        fi
        echo ""

        # Removed: Note this is not needed anymore after DirectAdmin version 1.61.0 ( it is said to be removed from the installation script)
        # https://docs.directadmin.com/directadmin/general-usage/securing-da-panel.html#i-wish-to-have-a-block-ip-sh-so-i-can-block-ips-through-directadmin
        # msg "$(s cyan)Downloading other directadmin-csf script integration ...$(e)" --caller="${SCRIPT_NAME}"
        # navigate_to /usr/local/directadmin/scripts/custom/
        # wget --no-verbose --no-check-certificate -O block_ip.sh http://files.plugins-da.net/dl/csf_block_ip.sh.txt
        # wget --no-verbose --no-check-certificate -O unblock_ip.sh http://files.plugins-da.net/dl/csf_unblock_ip.sh.txt
        # wget --no-verbose --no-check-certificate -O show_blocked_ips.sh http://files.plugins-da.net/dl/csf_show_blocked_ips.sh.txt
        # wget --no-verbose --no-check-certificate -O brute_force_notice_ip.sh http://files.directadmin.com/services/all/brute_force_notice_ip.sh
        # echo ""

        # msg "$(s cyan)Correcting the permission of the downloaded scripts ...$(e)" --caller="${SCRIPT_NAME}"
        # chmod 700 block_ip.sh show_blocked_ips.sh unblock_ip.sh brute_force_notice_ip.sh
        # echo ""
        # msg "$(s cyan)Creating the empty block list and exempt list files ...$(e)" --caller="${SCRIPT_NAME}"
        # touch /root/blocked_ips.txt
        # touch /root/exempt_ips.txt
        # echo ""
        # Set this using directadmin binary instead
        #msg "$(s cyan)Hiding directadmin bruteforce notification ...$(e)" --caller="${SCRIPT_NAME}"
        #grep_count=$(grep -c hide_brute_force_notifications /usr/local/directadmin/conf/directadmin.conf)
        #if [ "${grep_count}" = "0" ]; then
        #  echo "hide_brute_force_notifications=1" >>/usr/local/directadmin/conf/directadmin.conf
        #fi
        # Credit to poralix for giving idea how to integrate CSF on directadmin:
        echo ""
        echo ""
        echo "Install complete!"
        echo "To access the plugin, go to:"
        echo "  Admin Level -> ConfigServer Firewall\&Security"
        echo ""
        echo "This is a modified version based on the guide at https://help.poralix.com/articles/how-to-block-ips-with-csf-directadmin-bfm"
        echo ""
        echo ""
        #wget http://files.directadmin.com/services/all/csf/csf_install.sh
        # Or alternatively way to install CSF is to use my own script file from maxicode
        #da_install_scripts_path="${LATEST_OS_CODE_PATH}/usr/local/directadmin/install_scripts"
        #if [ ! -d "${da_install_scripts_path}" ]; then
        #  msg "$(s red)Error, directadmin install script path does not exist in ${maxicode_latest_path}. The script should be there!$(e)" --caller="${SCRIPT_NAME}"
        #  exit 1
        #fi
        #navigate_to "${INST_TEMP_DIR}"
        #cp "${da_install_scripts_path}/csf_install.sh" "${INST_TEMP_DIR}/csf_install.sh"
        #chmod +x csf_install.sh
        #/bin/sh ./csf_install.sh
      else
        # CSF binary found,
        grep_count=$(csf -v 2>/dev/null | grep -c 'csf:')
        if [ "${grep_count}" = "0" ]; then
          msg "$(s yellow)Warning, CSF already installed but it does not show its version. CSF Installation might have been corrupted$(e)" --caller="${SCRIPT_NAME}"
          echo "Uninstalling csf and lfd..."
          echo
          sed -i 's/lfd=ON/lfd=OFF/' /usr/local/directadmin/data/admin/services.status
          /usr/sbin/csf -f
          if test "$(cat /proc/1/comm)" = "systemd"; then
            systemctl disable csf.service
            systemctl disable lfd.service
            systemctl stop lfd.service
            systemctl stop csf.service
            rm -fv /usr/lib/systemd/system/csf.service
            rm -fv /usr/lib/systemd/system/lfd.service
            systemctl daemon-reload
          else
            if [ -f /etc/redhat-release ]; then
              /sbin/chkconfig csf off
              /sbin/chkconfig lfd off
              /sbin/chkconfig csf --del
              /sbin/chkconfig lfd --del
            elif [ -f /etc/debian_version ] || [ -f /etc/lsb-release ]; then
              update-rc.d -f lfd remove
              update-rc.d -f csf remove
            elif [ -f /etc/gentoo-release ]; then
              rc-update del lfd default
              rc-update del csf default
            elif [ -f /etc/slackware-version ]; then
              rm -vf /etc/rc.d/rc3.d/S80csf
              rm -vf /etc/rc.d/rc4.d/S80csf
              rm -vf /etc/rc.d/rc5.d/S80csf
              rm -vf /etc/rc.d/rc3.d/S85lfd
              rm -vf /etc/rc.d/rc4.d/S85lfd
              rm -vf /etc/rc.d/rc5.d/S85lfd
            else
              /sbin/chkconfig csf off
              /sbin/chkconfig lfd off
              /sbin/chkconfig csf --del
              /sbin/chkconfig lfd --del
            fi
            rm -fv /etc/init.d/csf
            rm -fv /etc/init.d/lfd
          fi

          rm -fv /etc/chkserv.d/lfd
          rm -fv /usr/sbin/csf
          rm -fv /usr/sbin/lfd
          rm -fv /etc/cron.d/csf_update
          rm -fv /etc/cron.d/lfd-cron
          rm -fv /etc/cron.d/csf-cron
          rm -Rfv /usr/local/directadmin/plugins/csf
          rm -fv /etc/logrotate.d/lfd
          rm -fv /usr/local/man/man1/csf.man.1
          rm -Rfv /etc/csf /usr/local/csf /var/lib/csf

          # Remove integration with DA BFM (old way). New version 1.61.0 is said not to have these 4 files:
          # https://docs.directadmin.com/directadmin/general-usage/securing-da-panel.html#i-wish-to-have-a-block-ip-sh-so-i-can-block-ips-through-directadmin
          # The script http://files.directadmin.com/services/all/csf/csf_install.sh is said to not have this 6 files created in the future :
          # https://docs.directadmin.com/directadmin/general-usage/securing-with-bfm.html

          rm -fv /usr/local/directadmin/scripts/custom/block_ip.sh
          rm -fv /usr/local/directadmin/scripts/custom/unblock_ip.sh
          rm -fv /usr/local/directadmin/scripts/custom/show_blocked_ips.sh
          rm -fv /usr/local/directadmin/scripts/custom/brute_force_notice_ip.sh
          rm -fv /root/blocked_ips.txt
          rm -fv /root/exempt_ips.txt

          echo
          echo "...Done"
          install_da_csf
        else
          msg "$(s green)OK, CSF already installed with the following version status: $(e)" --caller="${SCRIPT_NAME}"
          echo ""
          csf -v
          echo ""
        fi
      fi
    fi
    # TIPS. CSF can be removed with this command:
    # sh /etc/csf/uninstall.sh
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

install_general_csf() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    # If DA INSTALL TYPE IS auto don't run this because it will install CSF automatically (as stated in documentation)
    local gc csf_ipv4_tcp_in ipv4_tcp_out ipv6_tcp_in ipv6_tcp_out extra_allow_ports kernel_numericver
    local bl_ip_html_source bl_ip_html_dest gc retval

    if ! command -v csf &>/dev/null; then
      msg "No CSF binary is found (CSF is not installed)"
      sleep 2
      if [ "${C_SERVER_TYPE}" == "general" ]; then
        msg "Script installation type is set to 'general'. Installing and Setting up CSF for ${C_BOX_HOSTNAME_FQHN} ..."
        sleep 2
        msg "Removing existing CSF if exist using built-in script ..."
        sh /etc/csf/uninstall.sh
        msg "Removing previous downloaded file ..."
        rm -fv "${INST_TEMP_DIR}/csf.tgz"
        navigate_to "${INST_TEMP_DIR}"
        msg "Downloading and extracting CSF file in ${INST_TEMP_DIR} ..."
        curl -SL https://download.configserver.com/csf.tgz | tar -xzf -
        # Now after extracted we have csf folder, let's enter to this path
        navigate_to "./csf"

        msg "Testing CSF pre-installation requirement ..."
        gc=$(./csftest.pl | tail -n 1 | grep -c 'RESULT: csf should function on this server')
        if [ "${gc}" != "1" ]; then
          ./csftest.pl
          echo ""
          echo ""
          echo "CSF test did not pass. Will not continue. Solve the issue and rerun this script again"
          _exit 2
        else
          echo "[OK]: CSF test passed!"
        fi

        msg "Now installing CSF ..."
        chmod +x install.sh
        sh "install.sh"
        # When finished, we go back to original path

        # CSF recommends to disable and remove APF+BFD (if exist). Check APF:
        msg "Checking and removing existing APF+BFD (recommended) ..."
        if command -v apf &>/dev/null; then
          msg "Warning, Found apf command. Removing apf bfd with remove_apf_bfd.sh ..."
          #sh /usr/local/csf/bin/disable_apf_bfd.sh #Script disabled because not found in the csf bin folder
          sh /usr/local/csf/bin/remove_apf_bfd.sh
        else
          msg "[Skipped]: OK, No existing APF+BFD installation to remove"
        fi
      elif [ "${C_SERVER_TYPE}" == "directadmin" ]; then
        msg "Script installation type is set to DIRECTADMIN. Installing CSF on ${C_BOX_HOSTNAME_FQHN} using DA script by Poralix..."
        sleep 2
        #wget http://files.directadmin.com/services/all/csf/csf_install.sh
        navigate_to "${INST_TEMP_DIR}"
        cp "${DATA_PATH}/maxinet/storage/os/${DISTRO_ID}/usr/local/directadmin/install_scripts/csf_install.sh" "${INST_TEMP_DIR}/csf_install.sh"
        chmod +x csf_install.sh
        /bin/sh ./csf_install.sh
      fi
    else
      msg "Found CSF binary (CSF already installed). Continuing setup ..."
    fi
    # After install CSF definitely we got this
    if [ -f /etc/csf/csf.conf ]; then
      msg "Now configuring CSF config at /etc/csf/csf.conf ..."
      sleep 1
      # This also must have comma,
      if [ -n "${C_CSF_EXTRA_ALLOW_PORTS}" ]; then
        extra_allow_ports=",${C_DA_PORT},${C_CSF_EXTRA_ALLOW_PORTS}"
      else
        extra_allow_ports=",${C_DA_PORT}"
      fi
      echo "DEBUG: extra_allow_ports=${extra_allow_ports}"
      grep -wq "^TCP_IN = .*${extra_allow_ports}" /etc/csf/csf.conf
      if [ $? = 1 ]; then
        msg "Adding extra port(s) ${extra_allow_ports} in CSF firewall in CSF for TCP_IN ..."
        csf_ipv4_tcp_in=$(grep -i '^TCP_IN' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep="${extra_allow_ports}" '{ print $1 ep }')
        sed -i "s/TCP_IN = .*/TCP_IN = \"${csf_ipv4_tcp_in}\"/" /etc/csf/csf.conf
      else
        msg "[Skipped]: Extra port(s) ${extra_allow_ports} has already added in CSF for TCP_IN before"
      fi
      grep -wq "^TCP_OUT = .*${extra_allow_ports}" /etc/csf/csf.conf
      if [ $? = 1 ]; then
        msg "Adding extra port(s) ${extra_allow_ports} in CSF firewall in CSF for TCP_OUT ..."
        ipv4_tcp_out=$(grep -i '^TCP_OUT' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep="${extra_allow_ports}" '{ print $1 ep }')
        sed -i "s/TCP_OUT = .*/TCP_OUT = \"${ipv4_tcp_out}\"/" /etc/csf/csf.conf
      else
        msg "[Skipped]: Extra port(s) ${extra_allow_ports} has already added in CSF for TCP_OUT before"
      fi
      grep -wq "^TCP6_IN = .*${extra_allow_ports}" /etc/csf/csf.conf
      if [ $? = 1 ]; then
        msg "Adding extra port(s) ${extra_allow_ports} in CSF firewall in CSF for TCP6_IN ..."
        ipv6_tcp_in=$(grep -i '^TCP6_IN' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep="${extra_allow_ports}" '{ print $1 ep }')
        sed -i "s/TCP6_IN = .*/TCP6_IN = \"${ipv6_tcp_in}\"/" /etc/csf/csf.conf
      else
        msg "[Skipped]: Extra port(s) ${extra_allow_ports} has already added in CSF for TCP6_IN before"
      fi
      grep -wq "^TCP6_OUT = .*${extra_allow_ports}" /etc/csf/csf.conf
      if [ $? = 1 ]; then
        msg "Adding extra port(s) ${extra_allow_ports} in CSF firewall in CSF for TCP6_OUT ..."
        ipv6_tcp_out=$(grep -i '^TCP6_OUT' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep="${extra_allow_ports}" '{ print $1 ep }')
        sed -i "s/TCP6_OUT = .*/TCP6_OUT = \"${ipv6_tcp_out}\"/" /etc/csf/csf.conf
      else
        msg "[Skipped]: Extra port(s) ${extra_allow_ports} has already added in CSF for TCP6_OUT before"
      fi
      # Disable CSF testing mode
      msg "Disabling CSF testing mode ..."
      sed -i 's/TESTING = "1"/TESTING = "0"/g' /etc/csf/csf.conf
      #msg "Setting CONNLIMIT and PORTFLOOD best setting ..."
      #sed -i 's/CONNLIMIT = ""/CONNLIMIT = "22;5,80;20,443;20"/g' /etc/csf/csf.conf
      #sed -i 's/PORTFLOOD = ""/PORTFLOOD = "22;tcp;5;300,80;tcp;20;5,443;tcp;20;5"/g' /etc/csf/csf.conf
      msg "Enabling CSF email alert from 0 to 1 ..."
      sed -i 's/LF_SSH_EMAIL_ALERT = "0"/LF_SSH_EMAIL_ALERT = "1"/g' /etc/csf/csf.conf
      msg "Setting CSF email alert to ${C_ADMIN_EMAIL} ..."
      sed -i "s/LF_ALERT_TO = .*/LF_ALERT_TO = '\"${C_ADMIN_EMAIL}\"'/" /etc/csf/csf.conf
      msg "Enabling CSF SMTP_BLOCK ..."
      sed -i 's/SMTP_BLOCK = "0"/SMTP_BLOCK = "1"/g' /etc/csf/csf.conf
      msg "Setting CSF RESTRICT_SYSLOG from 0 to 3 to avoid warning ..."
      sed -i 's/RESTRICT_SYSLOG = "0"/RESTRICT_SYSLOG = "3"/g' /etc/csf/csf.conf
      msg "Setting CSF SYSLOG_CHECK to ${C_CSF_SYSLOG_CHECK} ..."
      sed -i "s/SYSLOG_CHECK = .*/SYSLOG_CHECK = \"${C_CSF_SYSLOG_CHECK}\"/" /etc/csf/csf.conf
      sleep 1
      msg "Testing CSF after changing configuration ..."
      echo ""
      perl /usr/local/csf/bin/csftest.pl
      echo ""
      msg "Setting CSF PT_LOAD_ACTION ..."
      sed -i "s/^PT_LOAD_ACTION = .*/PT_LOAD_ACTION = \"\/usr\/local\/maxicode\/maxicsf\/csfload\"/" /etc/csf/csf.conf
      msg "Setting CSF to send security alert to ${C_ADMIN_EMAIL} ..."
      csf -m "${C_ADMIN_EMAIL}"

      msg "Setting CSF RBL email ${C_ADMIN_EMAIL} ..."
      csf --rbl "${C_ADMIN_EMAIL}"

      msg "Enabling IPSET large IP for CSF ..."
      # inspired by: https://community.centminmod.com/threads/what-should-be-the-right-value-for-lf_ipset-on-csf-config.2045/
      kernel_numericver=$(uname -r | awk -F. '{ printf("%d%03d%03d%03d\n", $1,$2,$3,$4); }')
      # shellcheck disable=SC2143
      if [[ ! -f /proc/user_beancounters ]] && [[ "$(uname -r | grep linode)" || "$(find "/lib/modules/$(uname -r)" -name 'ipset')" ]] || [[ -f /proc/user_beancounters && "${kernel_numericver}" -ge '3000000000' ]]; then
        if [[ ! -f /usr/sbin/ipset ]]; then
          if [ "${DISTRO_ID}" == "centos" ]; then
            yum -q -y install ipset ipset-devel
          elif [ "${DISTRO_ID}" == "debian" ]; then
            sudo apt-get install ipset -y
          fi
          sed -i 's/LF_IPSET = \"0\"/LF_IPSET = \"1\"/' /etc/csf/csf.conf
        elif [[ -f /usr/sbin/ipset ]]; then
          sed -i 's/LF_IPSET = \"0\"/LF_IPSET = \"1\"/' /etc/csf/csf.conf
        fi
      fi
      # Increase block limit from 200 to 2500 (specified in config)
      msg "Setting CSF DENY_IP_LIMIT to ${C_CSF_DENY_IP_LIMIT} ..."
      sed -i "s/DENY_IP_LIMIT = .*/DENY_IP_LIMIT = '\"${C_CSF_DENY_IP_LIMIT}\"'/" /etc/csf/csf.conf
      # CSF Messenger: TODO haven't tested this messenger
      msg "Enabling CSF Messenger ..."
      sleep 1
      sed -i "s/MESSENGER = \"0\"/MESSENGER = \"1\"/" /etc/csf/csf.conf
      msg "Inserting CSF RECAPTCHA_SITEKEY ..."
      sleep 1
      sed -i "s/RECAPTCHA_SITEKEY = \"\"/RECAPTCHA_SITEKEY = \"${C_GOOGLE_RECAPTCHA_SITE_V2}\"/" /etc/csf/csf.conf
      msg "Inserting CSF RECAPTCHA_SECRET ..."
      sleep 1
      sed -i "s/RECAPTCHA_SECRET = \"\"/RECAPTCHA_SECRET = \"${C_GOOGLE_RECAPTCHA_SECRET_V2}\"/" /etc/csf/csf.conf
      msg "Adding csf user in the system ..."
      useradd csf -s /bin/false
      msg "Setting up CSF firewall blacklist template ..."
      mkdir -p /usr/local/directadmin/data/templates/custom
      bl_ip_html_source="${DATA_PATH}/maxinet/storage/os/${DISTRO_ID}/usr/local/directadmin/data/templates/custom/blacklisted_ip.html"
      bl_ip_html_dest="/usr/local/directadmin/data/templates/custom/blacklisted_ip.html"
      cp -r "${bl_ip_html_source}" "${bl_ip_html_dest}"
      chmod 644 "${bl_ip_html_dest}"
      chown diradmin:diradmin "${bl_ip_html_dest}"
      msg "Starting CSF and LFD for the first time ..."
      msg "Before we start it up, please confirm that your sshd port is listed in this output:"
      echo "-----------------"
      grep ^TCP_IN /etc/csf/csf.conf
      echo ""
      echo "If you do NOT see the port listed, press ctrl-c to immediately abort the script (you can add port missing port in maxinet.conf), then re-run this setup"
      echo "If you DO, the port correctly added, press enter to continue"
      _pause 60
      if [ "${DISTRO_ID}" == "centos" ]; then
        msg "Disabling built-in firewall (firewalld) in CentOS ..."
        systemctl disable firewalld
        systemctl stop firewalld
      elif [ "${DISTRO_ID}" == "debian" ]; then
        msg "Disabling and removing firewall (ufw) in Debian ..."
        sudo ufw disable
        sudo apt-get -y remove ufw
        sudo apt-get -y purge ufw
      else
        msg "Error, unknown value for distribution ID ${DISTRO_ID}"
        exit 1
      fi
      echo "-----------------"
      msg "Starting CSF ..."
      systemctl start csf
      # Check and fix csf process error here automatically
      repair_services "csf"
      # By default behaviour, LFD should start automatically when we run csf start
      # service lfd start
      repair_services "lfd"
      # This is a temporary allowed IP during setup which won't be blocked by firewall.
      msg "Temporarily allow IP ${C_HOST_PUBLIC_IP} in /etc/etc/csf/csf.allow during setup in CSF"
      csf -a "${C_HOST_PUBLIC_IP}" "Added by ${SCRIPT_NAME} for ${C_BOX_HOSTNAME_FQHN} as temporary allowed IP during setup"
      # After that, the next step is requesting SSL and seems like the box need to restart
      # The reason it needs to restart here because if I don't restart at this point, the front page is not accessible (seems like port 80 is blocked)
      # If I don't restart at this point, I will not be able to renew cert (letsencrypt will produce error like firewall problem but it's not).
      # This is related to Ipv6 DAD. Look at function configure_da_ips() for more information
      # DAD disable is not working. Still need to restart system. Just restart it and resume later.
      #msg "Creating reboot flag to restart system after installing CSF ..."
      #cat /dev/null >/var/run/reboot-required
      #msg "Warning, system will reboot and you can run this script again to continue setup"
      #_pause
    else
      msg "This is the weirdest error. Where the heck is /etc/csf/csf.conf? ..."
      exit 1
    fi
    # System will reboot automatically from above flag

    # TIPS. CSF can be removed with this command:
    #sh /etc/csf/uninstall.sh
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}
# This will configure csf port and other csf related configs
# Note if you use --run-force and want to reinstall CSF at this stage, please execute this command first:
# sh /etc/csf/uninstall.sh (I don't include this command inside this function because CSF should not be reinstalled without permission)
configure_csf() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local extra_allow_ports retval \
      csf_ipv4_tcp_in csf_ipv4_tcp_out csf_ipv6_tcp_in csf_ipv6_tcp_out kernel_numericver

    # After install CSF definitely we got this
    if [ -f /etc/csf/csf.conf ]; then
      msg "$(s cyan)Configuring CSF config at /etc/csf/csf.conf ...$(e)" --caller="${SCRIPT_NAME}"

      if [ -n "${C_CSF_EXTRA_ALLOW_PORTS}" ]; then
        extra_allow_ports="${C_GOTIFY_PORT},${C_DROP_BEAR_PORT},${C_DA_PORT},${C_CSF_EXTRA_ALLOW_PORTS}"
      else
        extra_allow_ports="${C_GOTIFY_PORT},${C_DROP_BEAR_PORT},${C_DA_PORT}"
      fi
      msg "$(s magenta)The extra allowed port to be added in CSF are: extra_allow_ports=${extra_allow_ports}$(e)" --caller="${SCRIPT_NAME}"
      echo ""

      msg "$(s cyan)Adding extra port(s) ${extra_allow_ports} in CSF firewall in CSF config for TCP_IN ...$(e)" --caller="${SCRIPT_NAME}"
      grep -wq "^TCP_IN = .*${extra_allow_ports}" /etc/csf/csf.conf
      retval=$?
      if [ "${retval}" -eq 1 ]; then
        csf_ipv4_tcp_in=$(grep -i '^TCP_IN' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep=",${extra_allow_ports}" '{ print $1 ep }')
        sed -i "s/TCP_IN = .*/TCP_IN = \"${csf_ipv4_tcp_in}\"/" /etc/csf/csf.conf
      else
        msg "$(s yellow)[Skipped]: Extra port(s) ${extra_allow_ports} has already been added in CSF config for TCP_IN before$(e)" --caller="${SCRIPT_NAME}"
      fi
      echo ""
      msg "$(s cyan)Adding extra port(s) ${extra_allow_ports} in CSF firewall in CSF config for TCP_OUT ...$(e)" --caller="${SCRIPT_NAME}"
      grep -wq "^TCP_OUT = .*${extra_allow_ports}" /etc/csf/csf.conf
      retval=$?
      if [ "${retval}" -eq 1 ]; then
        csf_ipv4_tcp_out=$(grep -i '^TCP_OUT' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep=",${extra_allow_ports}" '{ print $1 ep }')
        sed -i "s/TCP_OUT = .*/TCP_OUT = \"${csf_ipv4_tcp_out}\"/" /etc/csf/csf.conf
      else
        msg "$(s yellow)[Skipped]: Extra port(s) ${extra_allow_ports} has already been added in CSF config for TCP_OUT before$(e)" --caller="${SCRIPT_NAME}"
      fi
      echo ""
      msg "$(s cyan)Adding extra port(s) ${extra_allow_ports} in CSF firewall in CSF config for TCP6_IN ...$(e)" --caller="${SCRIPT_NAME}"
      grep -wq "^TCP6_IN = .*${extra_allow_ports}" /etc/csf/csf.conf
      retval=$?
      if [ "${retval}" -eq 1 ]; then

        csf_ipv6_tcp_in=$(grep -i '^TCP6_IN' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep=",${extra_allow_ports}" '{ print $1 ep }')
        sed -i "s/TCP6_IN = .*/TCP6_IN = \"${csf_ipv6_tcp_in}\"/" /etc/csf/csf.conf
      else
        msg "$(s yellow)[Skipped]: Extra port(s) ${extra_allow_ports} has already been added in CSF config for TCP6_IN before$(e)" --caller="${SCRIPT_NAME}"
      fi
      echo ""
      msg "$(s cyan)Adding extra port(s) ${extra_allow_ports} in CSF firewall in CSF config for TCP6_OUT ...$(e)" --caller="${SCRIPT_NAME}"
      grep -wq "^TCP6_OUT = .*${extra_allow_ports}" /etc/csf/csf.conf
      retval=$?
      if [ "${retval}" -eq 1 ]; then
        csf_ipv6_tcp_out=$(grep -i '^TCP6_OUT' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep=",${extra_allow_ports}" '{ print $1 ep }')
        sed -i "s/TCP6_OUT = .*/TCP6_OUT = \"${csf_ipv6_tcp_out}\"/" /etc/csf/csf.conf
      else
        msg "$(s yellow)[Skipped]: Extra port(s) ${extra_allow_ports} has already been added in CSF config for TCP6_OUT before$(e)" --caller="${SCRIPT_NAME}"
      fi
      echo ""

      # This is used only if server is in bruteforce mode
      #msg "Setting CONNLIMIT and PORTFLOOD best setting ..."
      #sed -i 's/CONNLIMIT = ""/CONNLIMIT = "22;5,80;20,443;20"/g' /etc/csf/csf.conf
      #sed -i 's/PORTFLOOD = ""/PORTFLOOD = "22;tcp;5;300,80;tcp;20;5,443;tcp;20;5"/g' /etc/csf/csf.conf

      # Disable CSF testing mode
      msg "$(s cyan)Disabling CSF testing mode ...$(e)" --caller="${SCRIPT_NAME}"
      sed -i 's/TESTING = "1"/TESTING = "0"/g' /etc/csf/csf.conf
      echo ""
      msg "$(s cyan)Enabling CSF SSH email alert LF_SSH_EMAIL_ALERT from 0 to 1 ...$(e)" --caller="${SCRIPT_NAME}"
      sed -i 's/LF_SSH_EMAIL_ALERT = "0"/LF_SSH_EMAIL_ALERT = "1"/g' /etc/csf/csf.conf
      echo ""
      msg "$(s cyan)Setting CSF LF email alert to email ${C_ADMIN_EMAIL} ...$(e)" --caller="${SCRIPT_NAME}"
      sed -i "s/LF_ALERT_TO = .*/LF_ALERT_TO = '\"${C_ADMIN_EMAIL}\"'/" /etc/csf/csf.conf
      echo ""
      msg "$(s cyan)Enabling CSF SMTP_BLOCK ...$(e)" --caller="${SCRIPT_NAME}"
      sed -i 's/SMTP_BLOCK = "0"/SMTP_BLOCK = "1"/g' /etc/csf/csf.conf
      echo ""
      msg "$(s cyan)Setting CSF RESTRICT_SYSLOG from 0 to 3 to avoid warning ...$(e)" --caller="${SCRIPT_NAME}"
      sed -i 's/RESTRICT_SYSLOG = "0"/RESTRICT_SYSLOG = "3"/g' /etc/csf/csf.conf
      echo ""
      msg "$(s cyan)Setting CSF SYSLOG_CHECK to ${C_CSF_SYSLOG_CHECK} ...$(e)" --caller="${SCRIPT_NAME}"
      sed -i "s/SYSLOG_CHECK = .*/SYSLOG_CHECK = '\"${C_CSF_SYSLOG_CHECK}\"'/" /etc/csf/csf.conf
      echo ""
      msg "$(s cyan)Setting CSF PT_LOAD_ACTION script path ...$(e)" --caller="${SCRIPT_NAME}"
      # TODO this script must be improved to detect server highload issue. I posted an answer to someone here why this is needed:
      # https://forum.directadmin.com/threads/random-instances-of-systemd-user-running-for-24-hours.64353/#post-335092
      sed -i "s/^PT_LOAD_ACTION = .*/PT_LOAD_ACTION = \"\/usr\/local\/maxicode\/maxicsf\/csfload\"/" /etc/csf/csf.conf
      echo ""
      msg "$(s cyan)Setting CSF to send security alert to ${C_ADMIN_EMAIL} ...$(e)" --caller="${SCRIPT_NAME}"
      csf -m "${C_ADMIN_EMAIL}"
      echo ""
      msg "$(s cyan)Enabling LF_IPSET large IP for CSF (if compatible) ...$(e)" --caller="${SCRIPT_NAME}"
      # This method is inspired by this post: https://community.centminmod.com/threads/what-should-be-the-right-value-for-lf_ipset-on-csf-config.2045/
      kernel_numericver=$(uname -r | awk -F. '{ printf("%d%03d%03d%03d\n", $1,$2,$3,$4); }')
      if [[ ! -f /proc/user_beancounters ]] && [[ "$(uname -r | grep linode)" || "$(find "/lib/modules/$(uname -r)" -name 'ipset')" ]] || [[ -f /proc/user_beancounters && "${kernel_numericver}" -ge '3000000000' ]]; then
        if [[ ! -f $(command -v ipset) ]]; then
          maxibuild --include "ipset"
          sed -i 's/LF_IPSET = \"0\"/LF_IPSET = \"1\"/' /etc/csf/csf.conf
        elif [[ -f $(command -v ipset) ]]; then
          sed -i 's/LF_IPSET = \"0\"/LF_IPSET = \"1\"/' /etc/csf/csf.conf
        fi
      fi
      echo ""
      # Increase block limit from 200 to C_CSF_DENY_IP_LIMIT (specified in config)
      msg "$(s cyan)Setting CSF DENY_IP_LIMIT to ${C_CSF_DENY_IP_LIMIT} ....$(e)" --caller="${SCRIPT_NAME}"
      sed -i "s/DENY_IP_LIMIT = .*/DENY_IP_LIMIT = '\"${C_CSF_DENY_IP_LIMIT}\"'/" /etc/csf/csf.conf
      echo ""
      # TODO test CSF messenger
      # This is CSF Messenger setting:
      msg "$(s cyan)Enabling CSF Messenger ...$(e)" --caller="${SCRIPT_NAME}"
      sed -i "s/MESSENGER = \"0\"/MESSENGER = \"1\"/" /etc/csf/csf.conf
      echo ""
      msg "$(s cyan)Adding csf user in the system ...$(e)" --caller="${SCRIPT_NAME}"
      useradd csf -s /bin/false
      echo ""
      msg "$(s cyan)Inserting CSF RECAPTCHA_SITEKEY ...$(e)" --caller="${SCRIPT_NAME}"
      sed -i "s/RECAPTCHA_SITEKEY = \"\"/RECAPTCHA_SITEKEY = \"${C_GOOGLE_RECAPTCHA_SITE_V2}\"/" /etc/csf/csf.conf
      echo ""
      msg "$(s cyan)Inserting CSF RECAPTCHA_SECRET ...$(e)" --caller="${SCRIPT_NAME}"
      sed -i "s/RECAPTCHA_SECRET = \"\"/RECAPTCHA_SECRET = \"${C_GOOGLE_RECAPTCHA_SECRET_V2}\"/" /etc/csf/csf.conf
      echo ""

      if [[ "${C_SERVER_TYPE}" == "directadmin" ]]; then
        msg "$(s cyan)Setting LF_DIRECTADMIN = 5 ...$(e)" --caller="${SCRIPT_NAME}"
        sed -i "s|^LF_DIRECTADMIN=.*|LF_DIRECTADMIN = \"5\"|" /etc/csf/csf.conf
        echo ""
        msg "$(s cyan)Setting LF_DIRECTADMIN_PERM = 1 ...$(e)" --caller="${SCRIPT_NAME}"
        sed -i "s|^LF_DIRECTADMIN_PERM=.*|LF_DIRECTADMIN_PERM = \"5\"|" /etc/csf/csf.conf
        echo ""
        msg "$(s cyan)Setting PORTS_directadmin into ${C_DA_PORT} ...$(e)" --caller="${SCRIPT_NAME}"
        sed -i "s|^PORTS_directadmin=.*|PORTS_directadmin = \"${C_DA_PORT}\"|" /etc/csf/csf.conf
        echo ""

        msg "$(s cyan)Writing new CSF firewall blacklist template ...$(e)" --caller="${SCRIPT_NAME}"
        mkdir -p /usr/local/directadmin/data/templates/custom
        {
          echo "<!DOCTYPE html>"
          echo "<html lang=\"en\">"
          echo "<head>"
          echo "    <title>Maxiwall Information</title>"
          echo "    <meta charset=\"utf-8\">"
          echo "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">"
          echo "</head>"
          echo "<body>"
          echo ""
          echo "<div class=\"container\">"
          echo "    <h1>Maxiwall Information</h1>"
          echo "    <p>Warning: For security reason, your IP has been blacklisted by our firewall due to repeated authorization failures.</p>"
          echo "    <h3> Solutions: </h3>"
          echo "    <p>1) Normally this is a temporary block and our firewall will unblock your IP within few minutes or few hours</p>"
          echo "    <p>2) If you think this is a mistake and need to have your IP whitelisted immediately, please email us at ${C_ADMIN_EMAIL}</p>"
          echo "    <p>3) If you are using a dynamic IP (most people do), you could try is to restart your main ISP router to get a new IP address </p>"
          echo "    <p>4) If you are using a static IP please, the step 3) might not be possible. Please contact us ${C_ADMIN_EMAIL} to unblock your IP with valid reason </p>"
          echo "</div>"
          echo ""
          echo "</body>"
          echo "</html>"
        } >"/usr/local/directadmin/data/templates/custom/blacklisted_ip.html"
        # msg "$(s cyan)Setting up CSF firewall blacklist template taken from maxicode ...$(e)" --caller="${SCRIPT_NAME}"
        # mkdir -p /usr/local/directadmin/data/templates/custom
        # cp "${LATEST_OS_CODE_PATH}/usr/local/directadmin/data/templates/custom/blacklisted_ip.html" "/usr/local/directadmin/data/templates/custom/blacklisted_ip.html"
        chmod 644 "/usr/local/directadmin/data/templates/custom/blacklisted_ip.html"
        chown diradmin:diradmin "/usr/local/directadmin/data/templates/custom/blacklisted_ip.html"
        echo ""
      fi

      msg "$(s cyan)Testing CSF after changing configuration ...$(e)" --caller="${SCRIPT_NAME}"
      while :; do
        inst_result=$(perl /usr/local/csf/bin/csftest.pl | tail -n 1 | grep -c 'RESULT: csf should function on this server')
        if [ "${inst_result}" != "1" ]; then
          msg "$(s red)Error, CSF installation test did not pass. Re-testing CSF installation in 5 seconds ...$(e)" --caller="${SCRIPT_NAME}"
          sleep 5
        else
          msg "$(s green)OK, CSF installation test passed! Installing CSF for Directadmin ...$(e)" --caller="${SCRIPT_NAME}"
          break
        fi
      done
      echo ""
      msg "$(s cyan)Starting CSF and LFD for the first time ...$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s cyan)Before we start it up, please confirm that your sshd port is listed in this output:$(e)" --caller="${SCRIPT_NAME}"
      echo "-----------------"
      grep ^TCP_IN /etc/csf/csf.conf
      echo ""
      msg "$(s cyan)If you do NOT see the port listed, press ctrl-c to immediately abort the script (you can add port missing port in maxinet.conf), then re-run this setup$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s cyan)If the port correctly added, press enter to continue$(e)" --caller="${SCRIPT_NAME}"
      _pause 30
      if [ "${DISTRO_ID}" == "centos" ]; then
        msg "$(s cyan)Disabling built-in firewall (firewalld) in CentOS ...$(e)" --caller="${SCRIPT_NAME}"
        systemctl disable firewalld
        systemctl stop firewalld
      elif [ "${DISTRO_ID}" == "debian" ]; then
        msg "$(s cyan)Disabling and removing firewall (ufw) in Debian ...$(e)" --caller="${SCRIPT_NAME}"
        sudo ufw disable
        sudo apt-get -y remove ufw
        sudo apt-get -y purge ufw
      else
        msg "$(s red)Error, unknown value for distribution ID ${DISTRO_ID}. This distribution ID is not supported$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi
      echo "-----------------"
      msg "Starting CSF ..."
      systemctl start csf

      repair_services "csf" "lfd"
      # By default behaviour, LFD should start automatically when we run csf start
      # service lfd start

      # Since CSF is running without problem after the above check, we temporarily allow current host public IP
      # This is a temporary allowed IP during setup which won't be blocked by firewall.
      msg "$(s cyan)Temporarily allow IP ${C_HOST_PUBLIC_IP} in /etc/etc/csf/csf.allow during setup in CSF$(e)" --caller="${SCRIPT_NAME}"
      csf -a "${C_HOST_PUBLIC_IP}" "Added by ${SCRIPT_NAME} for ${C_BOX_HOSTNAME_FQHN} as temporary allowed IP during setup"
      # After that, the next step is requesting SSL and seems like the box need to restart
      # The reason it needs to restart here because if I don't restart at this point, the front page is not accessible (seems like port 80 is blocked)
      # If I don't restart at this point, I will not be able to renew cert (letsencrypt will produce error like firewall problem but it's not).
      # This is related to Ipv6 DAD. Look at function configure_da_ips() for more information
      # DAD disable is not working. Still need to restart system. Just restart it and resume later.
      #msg "Creating reboot flag to restart system after installing CSF ..."
      #cat /dev/null >/var/run/reboot-required
      #msg "Warning, system will reboot and you can run this script again to continue setup"
      #_pause
    else
      msg "$(s red)Error, cannot configure CSF because csf.conf is missing. Where the hell is /etc/csf/csf.conf? If the installer might be broken, please reinstall CSF$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi
    # System will reboot automatically from above flag

    # TIPS. CSF can be removed with this command:
    #sh /etc/csf/uninstall.sh
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_sql() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    # Note that during installation MySQL generates a short password and da uses this root password. See the text message below:
    ##### MySQL root password seems to be unset, setting using MySQL queries...
    ####Setting password: SET PASSWORD FOR 'root'@'localhost' = PASSWORD('*******');
    # Mysql root password is also stored in setup.txt file
    local da_scripts_path mysql_on_my_cnf_etc mysql_on_my_cnf_da mysql_on_non_cnf mysql_granted my_cnf_db_root my_cnf_db_da_admin mysql_conf_db_da_admin \
      randomBlowfishSecret replace_pma_blowfish replace_pma_authtype retval loop_count grep_count mysql_authentication_test

    da_scripts_path="/usr/local/directadmin/scripts"
    mysql_conf_db_da_admin="/usr/local/directadmin/conf/mysql.conf"
    my_cnf_db_da_admin="/usr/local/directadmin/conf/my.cnf"
    my_cnf_db_root="/etc/my.cnf"

    # This mysqld method can be used only if correct password is supplied in /etc/my.cnf or blank password with no entries in /etc/my.cnf

    # Checking if mysqld binary exist
    msg "$(s cyan)Checking whether mysqld process is running ...$(e)" --caller="${SCRIPT_NAME}"
    if [ "$(systemctl is-active mysqld)" == "active" ]; then
      :
    else
      msg "$(s red)Error, mysqld is not running. Please inspect why and re-run this script to continue$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi
    echo ""
    msg "$(s cyan)Checking whether mysql is installed (binary file exist) ...$(e)" --caller="${SCRIPT_NAME}"
    if ! command -v mysql &>/dev/null; then
      msg "$(s yellow)Error, mysql binary is not found. Creating mysql symlink ...$(e)" --caller="${SCRIPT_NAME}"
      # This error has been fixed as I reported https://forum.directadmin.com/threads/directadmin-v1-645-has-been-released.67373/page-2#post-354952
      # and here: https://forum.directadmin.com/threads/da-v-1-645-mysql-and-mail-binary-are-missing-on-clean-install-debian-11.67378/#post-354953
      # but in case mysql binary is not found again, we can just create symlink
      ln -s /usr/local/bin/mariadb /usr/local/bin/mysql
      get_status_message "$?"
    fi
    echo ""
    msg "$(s cyan)Checking which mysql authentication to use ...$(e)" --caller="${SCRIPT_NAME}"
    echo ""
    # 1) Test using mysql if it's running and can be authenticated.
    msg "$(s cyan)Testing mysql authentication using non .cnf file ...$(e)" --caller="${SCRIPT_NAME}"
    mysql_on_non_cnf=$(
      mysql -e 'exit' 2>/dev/null
      echo $?
    )
    if [ "${mysql_on_non_cnf}" -eq 0 ]; then
      # In case password is empty then use this (normally initial setup server is empty but directadmin is not, so low chance this will be executed):
      mysql_granted="mysql -e"
      msg "$(s green)OK, the mysql will be authenticated without specifying config file with the following option: [ ${mysql_granted} ] ...$(e)" --caller="${SCRIPT_NAME}"
    else
      msg "$(s yellow)Warning, failed to authenticate mysql using non .cnf file$(e)" --caller="${SCRIPT_NAME}"
      echo ""
      # 2) Test using config password from /etc/my.cnf"
      msg "$(s cyan)Testing mysql authentication using non /etc/my.cnf file ...$(e)" --caller="${SCRIPT_NAME}"
      mysql_on_my_cnf_etc=$(
        mysql --defaults-extra-file=${my_cnf_db_root} -e 'exit' 2>/dev/null
        echo $?
      )
      echo ""
      if [ "${mysql_on_my_cnf_etc}" -eq 0 ]; then
        mysql_granted="mysql --defaults-extra-file=${my_cnf_db_root} -e"
        msg "$(s green)OK, the mysql will be authenticated using ${my_cnf_db_root} with the following option: [ ${mysql_granted} ]  ...$(e)" --caller="${SCRIPT_NAME}"

      else
        msg "$(s yellow)Warning, failed to authenticate mysql using /etc/my.cnf file$(e)" --caller="${SCRIPT_NAME}"
        echo ""
        # 3) Test using config password from /usr/local/directadmin/conf/my.cnf
        msg "$(s cyan)Testing mysql authentication using non /usr/local/directadmin/conf/my.cnf file ...$(e)" --caller="${SCRIPT_NAME}"
        mysql_on_my_cnf_da=$(
          mysql --defaults-extra-file=${my_cnf_db_da_admin} -e 'exit' 2>/dev/null
          echo $?
        )
        echo ""
        if [ "${mysql_on_my_cnf_da}" -eq 0 ]; then
          mysql_granted="mysql --defaults-extra-file=${my_cnf_db_da_admin} -e"
          msg "$(s green)OK, the mysql will be authenticated using ${my_cnf_db_da_admin} with the following option: [ ${mysql_granted} ] ...$(e)" --caller="${SCRIPT_NAME}"
        #sleep 1
        else
          msg "$(s yellow)Warning, failed to authenticate mysql using /usr/local/directadmin/conf/my.cnf file$(e)" --caller="${SCRIPT_NAME}"
          echo ""
          # If above not working I can use this: https://help.directadmin.com/item.php?id=45
          # or this: https://www.directadmin.com/features.php?id=2677
          msg "$(s red)Error, local SQL authentication is needed. If you know your root password, please supply it in ${my_cnf_db_root} or ${my_cnf_db_da_admin}$(e)" --caller="${SCRIPT_NAME}"
          msg "$(s red)If you don't know, you may need to reset root password manually using this article: https://help.directadmin.com/item.php?id=45$(e)" --caller="${SCRIPT_NAME}"
          exit 1
        fi
      fi
    fi

    msg "$(s cyan)Changing mysql root password ...$(e)" --caller="${SCRIPT_NAME}"
    ${mysql_granted} "ALTER USER 'root'@'localhost' IDENTIFIED BY '${C_DA_ROOT_SQLPASS}';"
    echo ""
    if [ -w "${my_cnf_db_root}" ]; then
      grep_count=$(grep -ic '^password=.*\|^password.*=.*' "${my_cnf_db_root}")
      #grep -ic '^password=.*\|^password.*=.*' /etc/my.cnf
      if [ "${grep_count}" = 0 ]; then
        # Appending the config, because password did not exist
        msg "$(s cyan)Updating new SQL root password in ${my_cnf_db_root} under [client] section ...$(e)" --caller="${SCRIPT_NAME}"
        sed -i "s|\[client\]|&\npassword=${C_DA_ROOT_SQLPASS}|" "${my_cnf_db_root}"
        get_status_message "$?"
      else
        msg "$(s cyan)Updating new SQL username root in ${my_cnf_db_root} ...$(e)" --caller="${SCRIPT_NAME}"
        # Password already exist, we just replace
        sed -i "/\[client\]/,/^\[/ s/password=.*/password=${C_DA_ROOT_SQLPASS}/" "${my_cnf_db_root}"
        get_status_message "$?"
      fi
      echo ""
      grep_count=$(grep -ic '^user=.*\|^user.*=.*' "${my_cnf_db_root}")
      if [ "${grep_count}" = 0 ]; then
        msg "$(s cyan)Writing new SQL root username in ${my_cnf_db_root} under [client] section ...$(e)" --caller="${SCRIPT_NAME}"
        #sleep 1
        # Append under client because did not exist
        sed -i 's|\[client\]|&\nuser=root|' "${my_cnf_db_root}"
        get_status_message "$?"
      else
        msg "$(s cyan)Updating SQL user to root in ${my_cnf_db_root} ...$(e)" --caller="${SCRIPT_NAME}"
        # Already exist, so we replace
        sed -i "/\[client\]/,/^\[/ s/user=.*/user=root/" "${my_cnf_db_root}"
        get_status_message "$?"
      fi
      echo ""

      grep_count=$(grep -ic '^bind-address=.*\|^bind-address.*=.*' "${my_cnf_db_root}")
      if [ "${grep_count}" = 0 ]; then
        msg "$(s cyan)Writing new config to disable mysql remote access in ${my_cnf_db_root} under [mysqld] section ...$(e)" --caller="${SCRIPT_NAME}"
        # Append under client because not exist
        sed -i 's|\[mysqld\]|&\nbind-address=127.0.0.1|' "${my_cnf_db_root}"
        get_status_message "$?"
      else
        msg "$(s cyan)Updating config to disable remote access in ${my_cnf_db_root} under [mysqld] section ...$(e)" --caller="${SCRIPT_NAME}"
        # Already exist, but we replace
        sed -i "/\[mysqld\]/,/^\[/ s/bind-address=.*/bind-address=127.0.0.1/" "${my_cnf_db_root}"
        get_status_message "$?"
      fi

      echo ""
      # This fix the following error: mysqldump error output: mysqldump: Error: 'Can't create/write to file '/tmp/#sql-temptable
      # From my old guide: https://stackoverflow.com/a/57609881/841677
      msg "$(s cyan)Creating msql temp folder with mysql:mysql permission ...$(e)" --caller="${SCRIPT_NAME}"
      mkdir -p /var/lib/mysql/tmp
      chown mysql:mysql /var/lib/mysql/tmp
      echo ""
      grep_count=$(grep -ic '^tmpdir=.*\|^tmpdir.*=.*' "${my_cnf_db_root}")
      if [ "${grep_count}" = 0 ]; then
        msg "$(s cyan)Writing new config to fix mysql temporary folder issue in ${my_cnf_db_root} under [mysqld] section ...$(e)" --caller="${SCRIPT_NAME}"
        # Append under client because not exist
        sed -i 's|\[mysqld\]|&\ntmpdir=\/var\/lib\/mysql\/tmp|' "${my_cnf_db_root}"
        get_status_message "$?"
      else
        msg "$(s cyan)Updating new config to fix mysql temporary folder issue in ${my_cnf_db_root} under [mysqld] section ...$(e)" --caller="${SCRIPT_NAME}"
        # Already exist, but we replace
        sed -i "/\[mysqld\]/,/^\[/ s/tmpdir=.*/tmpdir=\/var\/lib\/mysql\/tmp/" "${my_cnf_db_root}"
        get_status_message "$?"
      fi
    else
      msg "$(s red)Error, the file ${my_cnf_db_root} is missing. It should exist in that location if mysql is installed through directadmin$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi
    echo ""

    msg "$(s cyan)Removing unsecured anonymous users from database ...$(e)" --caller="${SCRIPT_NAME}"
    ${mysql_granted} "DELETE FROM mysql.user WHERE user='';"
    get_status_message "$?"
    echo ""
    msg "$(s cyan)Removing root users from non-localhost for security ...$(e)" --caller="${SCRIPT_NAME}"
    ${mysql_granted} "DELETE FROM mysql.user WHERE User='root' AND Host NOT IN ('localhost', '127.0.0.1', '::1');"
    get_status_message "$?"
    echo ""
    msg "$(s cyan)Removing test database if exist for security ...$(e)" --caller="${SCRIPT_NAME}"
    ${mysql_granted} "DROP DATABASE IF EXISTS test;"
    get_status_message "$?"
    echo ""
    msg "$(s cyan)Flushing mysql privileges ...$(e)" --caller="${SCRIPT_NAME}"
    ${mysql_granted} "FLUSH PRIVILEGES;"
    get_status_message "$?"
    echo ""
    # There is no recommendation to change da_admin sql username to something else at this moment,
    # so ignore username change for sql, just change password.
    msg "$(s cyan)Changing Directadmin da_admin default SQL password ...$(e)" --caller="${SCRIPT_NAME}"
    ${mysql_granted} "ALTER USER 'da_admin'@'localhost' IDENTIFIED BY '${C_DA_ADMIN_SQLPASS}';"
    get_status_message "$?"
    echo ""
    msg "$(s cyan)Updating da_admin SQL authentication information at ${mysql_conf_db_da_admin} ...$(e)" --caller="${SCRIPT_NAME}"
    if [ -s ${mysql_conf_db_da_admin} ]; then
      sed -i "s/^passwd=.*/passwd=${C_DA_ADMIN_SQLPASS}/" ${mysql_conf_db_da_admin}
    else
      echo -n '' >${mysql_conf_db_da_admin}
      chmod 600 ${mysql_conf_db_da_admin}
      chown diradmin:diradmin ${mysql_conf_db_da_admin}
      echo "user=da_admin" >>${mysql_conf_db_da_admin}
      echo "passwd=${C_DA_ADMIN_SQLPASS}" >>${mysql_conf_db_da_admin}
    fi
    echo ""
    msg "$(s cyan)Updating da_admin SQL authentication information at ${my_cnf_db_da_admin} ...$(e)" --caller="${SCRIPT_NAME}"
    if [ -s ${my_cnf_db_da_admin} ]; then
      sed -i "s/^password=.*/password=${C_DA_ADMIN_SQLPASS}/" ${my_cnf_db_da_admin}
    else
      echo -n '' >${my_cnf_db_da_admin}
      chmod 600 ${my_cnf_db_da_admin}
      chown diradmin:diradmin ${my_cnf_db_da_admin}
      echo "[client]"
      echo "user=da_admin" >>${my_cnf_db_da_admin}
      echo "password=${C_DA_ADMIN_SQLPASS}" >>${my_cnf_db_da_admin}
    fi

    echo ""
    mysql_authentication_test=$(
      mysql -e 'exit'
      echo $?
    )

    if [ "${mysql_authentication_test}" -eq 0 ]; then
      msg "$(s green)OK, mysql local system authentication test was correctly setup!$(e)" --caller="${SCRIPT_NAME}"
    else
      msg "$(s red)Error, mysql local system authentication test was failed! Please inspect why and re-run this setup again$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi
    echo ""

    msg "$(s cyan)Backing up original phpmyadmin config.inc.php at /var/www/html/phpMyAdmin as config.inc.php_original_${DATE_TIME_NOW}...$(e)" --caller="${SCRIPT_NAME}"
    cp -p "/var/www/html/phpMyAdmin/config.inc.php" "/var/www/html/phpMyAdmin/config.inc.php_backup_original_${DATE_TIME_NOW}"
    echo ""

    if [ ! -f /var/www/html/phpMyAdmin/config.inc.php ]; then
      msg "$(s red)Error, phpMyAdmin config file /var/www/html/phpMyAdmin/config.inc.php is missing. Please inspect manually and re-run this script to continue$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi
    # Enabling cookie authentication (so that we can use htpasswd for this)
    # To enable cookie authentication we need to have blow fish string
    # Some character might break sed like '/' so we don't want this character because this character can have problem later on.
    # No need to escape https://stackoverflow.com/questions/65528031/how-to-generate-openssl-blowfish-without-certain-characters-or-allow-certain-set
    msg "$(s cyan)Generating new blowfish secret key for phpMyAdmin in config.inc.php ...$(e)" --caller="${SCRIPT_NAME}"
    loop_count=0
    while :; do
      ((loop_count++))
      # This will generate 32bit long random number
      randomBlowfishSecret=$(openssl rand -base64 22)
      replace_pma_blowfish="\$cfg['blowfish_secret'] = '${randomBlowfishSecret}'; \/* YOU MUST FILL IN THIS FOR COOKIE AUTH! *\/"
      sed -i "s/\$cfg\[.blowfish_secret.\]\s*=.*/${replace_pma_blowfish}/" /var/www/html/phpMyAdmin/config.inc.php 2>/dev/null
      retval=$?
      if [ "${retval}" = 0 ]; then
        msg "$(s green)OK, successfully inserted blowfish secret key into /var/www/html/phpMyAdmin/config.inc.php after ${loop_count} retry(s)$(e)" --caller="${SCRIPT_NAME}"
        break
      fi
    done

    echo ""
    # Warning only use cookie authentication for development
    msg "$(s cyan)Setting phpMyAdmin authentication from http to cookie in config.inc.php to enable page login and httpd protection ...$(e)" --caller="${SCRIPT_NAME}"
    replace_pma_authtype="\$cfg['Servers'][\$i]['auth_type'] = 'cookie';"
    sed -i "s/\$cfg\['Servers'\]\[\$i\]\['auth_type'\] = 'http';/${replace_pma_authtype}/" /var/www/html/phpMyAdmin/config.inc.php
    get_status_message "$?"
    echo ""

    # We can setup theme for directadmin here.
    # For custom phpMyAdmin theme (not using theme yet). Theme we must get it from maxinet
    # msg "Setting up phpMyAdmin custom themes ..."

    # cp -p "phpMyAdmin_theme_from_maxinet_called_sofibox" into "/var/www/html/phpMyAdmin/themes/sofibox"
    # Temporarily no theme yet. In the future put theme here
    # And all the themes must have this permissions:
    # chmod 644 for files, chmod 755 for folders
    # And all must have this users:
    #chown webapps:webapps /var/www/html/phpMyAdmin/themes/*

    # This is used to fix problem with phpMyAdmin Storage: https://help.directadmin.com/item.php?id=564
    msg "$(s cyan)Creating phpMyAdmin configuration storage database ...$(e)" --caller="${SCRIPT_NAME}"
    navigate_to "${INST_TEMP_DIR}"
    msg "$(s cyan)Removing existing create_tables.sh file ...$(e)" --caller="${SCRIPT_NAME}"

    rm -f create_tables.sh
    echo ""
    msg "$(s cyan)Downloading create_tables.sh file ...$(e)" --caller="${SCRIPT_NAME}"
    wget --no-verbose -O create_tables.sh http://files1.directadmin.com/services/all/phpMyAdmin/create_tables.sh
    chmod 755 create_tables.sh
    msg "$(s cyan)Executing create_tables.sh to create phpMyAdmin configuration storage database ...$(e)" --caller="${SCRIPT_NAME}"
    ./create_tables.sh
    echo ""

    #[Sample my.cnf at /etc/my.cnf](https://gitlab.com/arafatx/sofibox-luks-earth/-/blob/master/etc/my.cnf)

    # Another alternative way to change directadmin da_admin SQL password:
    #msg "$(s cyan)Changing Directadmin da_admin SQL password using directadmin script reset_da_admin_password.sh ... $(e)" --caller="${SCRIPT_NAME}"
    # This script requires that we have root or da_admin password in setup.txt or defined in cnf, else it's not working
    #${da_scripts_path}/reset_da_admin_password.sh --password "${C_DA_ADMIN_SQLPASS}"
    #retval=$?
    #echo "${retval}"

    # Create mysql symlink here to home directory to solve system backup issue on mysql
    # https://forum.directadmin.com/threads/system-backup-mysql-problem.57146/
    echo ""
    msg "$(s cyan)Fixing issue with sql system backup in directadmin ...$(e)" --caller="${SCRIPT_NAME}"
    if [[ "${DISTRO_ID}" == "debian" ]]; then
      local mysql_path
      mysql_path="/var/lib/mysql"
      check_path "${mysql_path}"
      echo ""
      msg "$(s cyan)Removing previous symlink file ...$(e)" --caller="${SCRIPT_NAME}"
      # Don't use -r because this is just a file of symlink
      rm -f /home/mysql
      get_status_message "$?"
      echo ""
      msg "$(s cyan)Creating symlink from /var/lib/mysql to /home/mysql to resolve sql system backup issue ...$(e)" --caller="${SCRIPT_NAME}"
      ln -s /var/lib/mysql /home/mysql
      get_status_message "$?"
    else
      echo "[Skipped]: Note check if this distribution ID ${DISTRO_ID} has mysql symlink to /home/mysql if it has issue with sql system backup?"
      _confirm
    fi

    echo ""
    msg "$(s cyan)Restarting mysqld ...$(e)" --caller="${SCRIPT_NAME}"
    systemctl restart mysqld
    get_status_message "$?"
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This will configure everything about sql security
# Also configure https route for phpmyadmin here
configure_da_sql_security() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local httpd_alias_conf
    httpd_alias_conf="/etc/httpd/conf/extra/httpd-alias.conf"
    msg "$(s cyan)Configuring sql security ...$(e)" --caller="${SCRIPT_NAME}"
    echo ""
    # Important, this will make the phpmyadmin connection using SSL, so at this point phpmyadmin might not accessible or has certificate error because SSL is needed
    # Setup will install SSL in another function
    # Configuring phpmyadmin htaccess
    msg "$(s cyan)Creating https redirection .htaccess for mysql management (phpMyAdmin) ...$(e)" --caller="${SCRIPT_NAME}"
    touch /var/www/html/phpMyAdmin/.htaccess
    {
      echo "RewriteEngine On"
      echo "RewriteCond %{HTTPS} !=on"
      echo "RewriteRule ^/?(.*) https://%{SERVER_NAME}${C_PHPMYADMIN_LOGIN_ROUTE}\$1 [R=301,L]"
    } >/var/www/html/phpMyAdmin/.htaccess
    chmod 644 /var/www/html/phpMyAdmin/.htaccess
    chown webapps:webapps /var/www/html/phpMyAdmin/.htaccess
    echo ""
    # This is just temporary, in order to test whether phpmyadmin URL is working (this will be rebuild by the function configure_server_security())
    if [ "${C_PHPMYADMIN_SECURE_ROUTE}" == "true" ]; then
      msg "$(s yellow)Warning, C_PHPMYADMIN_SECURE_ROUTE is set to true, so you will not be able to use custom route for phpmyadmin set in config file at this point$(e)" --caller="${SCRIPT_NAME}"
    else
      msg "$(s cyan)Adding a temporary phpmyadmin custom URL route to ${C_PHPMYADMIN_LOGIN_ROUTE} ...$(e)" --caller="${SCRIPT_NAME}"
      {
        echo "# PHPMYADMIN custom URL (temporary):"
        echo "Alias ${C_PHPMYADMIN_LOGIN_ROUTE} \"/var/www/html/phpMyAdmin/\""
      } >>"${httpd_alias_conf}"
    fi
    echo ""
    restart_da_web_server
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This configure_da_mail can be roundcube squirrelmail or others
# Note to compress email we can use the following DA script: /usr/local/directadmin/scripts/dovecot_compress.sh all
# More info about speedup email: https://docs.directadmin.com/other-hosting-services/dovecot/customizing-dovecot.html#how-to-enable-email-compression
configure_da_mail() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local rc_index_file
    rc_index_file="/var/www/html/roundcube/index.php"
    if [ -f ${rc_index_file} ]; then
      local grep_count rc_version my_cnf_rc_file rc_config_file rc_built_in_plugins \
        replace_rc_authconf replace_rc_prodname replace_rc_rcguard_recaptcha_privatekey replace_rc_rcguard_recaptcha_publickey

      rc_version=$(grep '| Version' /var/www/html/roundcube/index.php | awk '{ print $3 }')
      my_cnf_rc_file="/var/www/html/roundcube/config/my.cnf"
      rc_config_file="/var/www/html/roundcube/config/config.inc.php"
      msg "$(s cyan)Roundcube version ${rc_version} has been detected installed in the system$(e)" --caller="${SCRIPT_NAME}"
      echo ""
      msg "$(s cyan)Backing up roundcube config at ${rc_config_file} as config.inc.php_original_${DATE_TIME_NOW}...$(e)" --caller="${SCRIPT_NAME}"
      cp -p "${rc_config_file}" "${rc_config_file}_backup_original_${DATE_TIME_NOW}"
      echo ""
      # By default roundcube is installed with a very short and weak password. We need to change the password to secured one
      # Remember roundcube password cannot contains character '@ , & and :' because config.inc.php use this separator and won't accept that password.
      msg "$(s cyan)Changing da_roundcube password in user database ...$(e)" --caller="${SCRIPT_NAME}"
      mysql -e "ALTER USER 'da_roundcube'@'localhost' IDENTIFIED BY '${C_DA_ROUNDCUBE_SQLPASS}'; FLUSH PRIVILEGES;"
      echo ""
      msg "$(s cyan)Updating da_roundcube password in config.inc.php ...$(e)" --caller="${SCRIPT_NAME}"
      replace_rc_authconf="\$config['db_dsnw'] = 'mysql:\/\/da_roundcube:${C_DA_ROUNDCUBE_SQLPASS}@localhost\/da_roundcube';"
      sed -i "s/\$config\[.db_dsnw.\]\s*=.*/${replace_rc_authconf}/" "${rc_config_file}"
      echo ""
      msg "$(s cyan)Changing roundcube product name in config.inc.php for display purpose ...$(e)" --caller="${SCRIPT_NAME}"
      replace_rc_prodname="\$config['product_name'] = '${C_ROUNDCUBE_CUSTOM_NAME}';"
      sed -i "s/\$config\[.product_name.\]\s*=.*/${replace_rc_prodname}/" "${rc_config_file}"
      echo ""

      grep_count=$(grep -ic "\$config\['force_https'\]" "${rc_config_file}")
      if [ "${grep_count}" = 0 ]; then
        msg "$(s cyan)Enabling force_https for roundcube at config.inc.php ...$(e)" --caller="${SCRIPT_NAME}"
        #sleep 1
        echo "\$config['force_https'] = true;" >>"${rc_config_file}"
      else
        msg "$(s yellow)[Skipped]: The force_https has already been set in roundcube setting config.inc.php previously$(e)" --caller="${SCRIPT_NAME}"
      fi
      echo ""
      if [ -s "${my_cnf_rc_file}" ]; then
        msg "$(s cyan)Updating SQL da_roundcube username in ${my_cnf_rc_file} ...$(e)" --caller="${SCRIPT_NAME}"
        sed -i "/\[client\]/,/^\[/ s/user=.*/user=da_roundcube/" "${my_cnf_rc_file}"
        echo ""
        msg "$(s cyan)Updating SQL da_roundcube password in ${my_cnf_rc_file} ...$(e)" --caller="${SCRIPT_NAME}"
        sed -i "/\[client\]/,/^\[/ s/password=.*/password=${C_DA_ROUNDCUBE_SQLPASS}/" ${my_cnf_rc_file}
      else
        # If no file was created, we write this file for my.cnf (roundcube auth sql config)
        echo -n '' >${my_cnf_rc_file}
        chmod 600 ${my_cnf_rc_file}
        chown diradmin:diradmin ${my_cnf_rc_file}
        echo "[client]"
        echo "user=da_roundcube" >>${my_cnf_rc_file}
        echo "password=${C_DA_ROUNDCUBE_SQLPASS}" >>${my_cnf_rc_file}
      fi

      msg "$(s cyan)Enabling some roundcube built-in plugins ...$(e)" --caller="${SCRIPT_NAME}"
      # You can add extra plugin here inside this array:
      rc_built_in_plugins=("'password',"
        "'archive',"
        "'zipdownload',"
        "'newmail_notifier',"
        "'managesieve',"
        "'markasjunk',"
        "'emoticons',"
        "'attachment_reminder',"
        "'new_user_dialog',"
      )
      #printf "%s\n" "${rc_built_in_plugins[@]}"
      for rc_built_in_plugin in "${rc_built_in_plugins[@]}"; do
        grep_count=$(grep -ic "${rc_built_in_plugin}" "${rc_config_file}")
        if [ "${grep_count}" -eq 0 ]; then
          # Use this code and loop above rc_plugins must be array
          msg "$(s cyan)Adding ${rc_built_in_plugin} into roundcube plugin list ...$(e)" --caller="${SCRIPT_NAME}"
          sed -i "s|\$config\[.plugins.\] = array(|&\n    ${rc_built_in_plugin}|" "${rc_config_file}"
        else
          msg "$(s yellow)[Skipped] The plugin ${rc_built_in_plugin} has already been set in ${rc_config_file}$(e)" --caller="${SCRIPT_NAME}"
        fi
      done
      echo ""
      msg "$(s cyan)Installing roundcube 3rd party plugins ...$(e)" --caller="${SCRIPT_NAME}"
      # Here we install roundcube 3rd party plugins
      if [ "${C_ENABLE_ROUNDCUBE_RCGUARD}" == "true" ]; then
        # I posted bug here: https://github.com/dsoares/roundcube-rcguard/issues/39, but just that server restart fixed the problem

        #sleep 1
        navigate_to "/var/www/html/roundcube/plugins/"
        msg "$(s cyan)Removing existing rcguard plugin for roundcube ...$(e)" --caller="${SCRIPT_NAME}"
        rm -rf rcguard
        echo ""
        msg "$(s cyan)Installing rcguard (Google recaptcha) to protect roundcube ...$(e)" --caller="${SCRIPT_NAME}"
        GIT_SSL_NO_VERIFY=true git clone https://github.com/dsoares/rcguard.git rcguard
        chown -R webapps:webapps rcguard/
        chmod 755 rcguard
        navigate_to "/var/www/html/roundcube/plugins/rcguard/"
        find . -type d -exec chmod 0755 {} \;
        find . -type f -exec chmod 0644 {} \;
        mv config.inc.php.dist config.inc.php
        echo ""

        msg "$(s cyan)Configuring rcguard recaptcha_publickey in config.inc.php ...$(e)" --caller="${SCRIPT_NAME}"
        replace_rc_rcguard_recaptcha_publickey="\$config['recaptcha_publickey'] = '${C_GOOGLE_RECAPTCHA_SITE_V2}';"
        sed -i "s/\$config\[.recaptcha_publickey.\]\s*=.*/${replace_rc_rcguard_recaptcha_publickey}/" /var/www/html/roundcube/plugins/rcguard/config.inc.php
        echo ""
        msg "$(s cyan)Configuring rcguard recaptcha_privatekey in config.inc.php ...$(e)" --caller="${SCRIPT_NAME}"
        replace_rc_rcguard_recaptcha_privatekey="\$config['recaptcha_privatekey'] = '${C_GOOGLE_RECAPTCHA_SECRET_V2}';"
        sed -i "s/\$config\[.recaptcha_privatekey.\]\s*=.*/${replace_rc_rcguard_recaptcha_privatekey}/" /var/www/html/roundcube/plugins/rcguard/config.inc.php
        echo ""
        msg "$(s cyan)Creating mysql table for rcguard ...$(e)" --caller="${SCRIPT_NAME}"
        # The plugin already provide initial script to create rcguard table in roundcube. So we can just add this sql file under da_roundcube username
        mysql da_roundcube </var/www/html/roundcube/plugins/rcguard/SQL/mysql.initial.sql
        echo ""
        # Add rcguard plugin into roundcube config if doesn't exist
        grep_count=$(grep -ic "'rcguard'," ${rc_config_file})
        if [ "${grep_count}" -eq 0 ]; then
          # Use this code and loop above rc_plugins must be array
          msg "$(s cyan)Adding 'rcguard', into roundcube plugin list ...$(e)" --caller="${SCRIPT_NAME}"
          sed -i "s|\$config\[.plugins.\] = array(|&\n    'rcguard',|" ${rc_config_file}
        else
          msg "$(s yellow)[Skipped] The plugin 'rcguard', has already been set in ${rc_config_file}$(e)" --caller="${SCRIPT_NAME}"
        fi

      else
        msg "$(s yellow)[Skipped]: rcguard plugin installation config C_ENABLE_ROUNDCUBE_RCGUARD is not set to true$(e)" --caller="${SCRIPT_NAME}"
      fi
    else
      msg "$(s cyan)[Skipped]: Warning, unable to detect roundcube version (${rc_index_file} was missing)$(e)" --caller="${SCRIPT_NAME}"
    fi
    # configure other mail here, like squirrelmail from here
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This will add another extra scurity for email config or settings
# This also will configure custom route for mail app like roundcube
configure_da_mail_security() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local httpd_alias_conf
    httpd_alias_conf="/etc/httpd/conf/extra/httpd-alias.conf"
    msg "$(s cyan)Configuring mail security ...$(e)" --caller="${SCRIPT_NAME}"
    echo ""
    # This is just temporary, in order to test whether roundcube custom URL is working (this will be rebuild by the function configure_server_security())
    if [ "${C_ROUNDCUBE_SECURE_ROUTE}" == "true" ]; then
      msg "$(s yellow)Warning, C_ROUNDCUBE_SECURE_ROUTE is set to true, so you will not be able to use custom route for roundcube set in config file at this point$(e)" --caller="${SCRIPT_NAME}"
    else
      msg "$(s cyan)Adding a temporary roundcube custom URL route to ${C_ROUNDCUBE_SECURE_ROUTE} ...$(e)" --caller="${SCRIPT_NAME}"
      {
        echo "# ROUNDCBE custom URL (temporary):"
        echo "Alias ${C_ROUNDCUBE_LOGIN_ROUTE} \"/var/www/html/roundcube/\""
      } >>"${httpd_alias_conf}"
    fi
    echo ""
    restart_da_web_server
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_ftp() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local da_bin da_cb_bin da_cb_custom_conf_path

    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"

    da_cb_custom_conf_path="/usr/local/directadmin/custombuild/custom"

    mkdir -p "${da_cb_custom_conf_path}"

    msg "$(s cyan)Checking required paths ...$(e)" --caller="${SCRIPT_NAME}"
    check_path "${da_bin}" "${da_cb_bin}" "${da_cb_custom_conf_path}"
    echo ""

    if [ "${C_DA_CB_FTP_SOFTWARE}" == "pureftpd" ]; then
      local grep_count
      msg "$(s cyan)Setting up /etc/rsyslog.conf to use pure-ftpd log at /var/log/pureftpd.log ...$(e)" --caller="${SCRIPT_NAME}"
      grep_count=$(grep -ic '\/var\/log\/pureftpd\.log' /etc/rsyslog.conf)
      if [ "${grep_count}" -eq 0 ]; then
        printf "ftp.*\t\t\t\t/var/log/pureftpd.log\n" >>/etc/rsyslog.conf
      else
        msg "$(s yellow)[Skipped]: Found ftp log entry '/var/log/pureftpd.log' at /etc/ryslog.conf$(e)" --caller="${SCRIPT_NAME}"
      fi
      echo ""
      msg "$(s cyan)Changing brute_force_messages_log value to /var/log/pureftpd.log in directadmin.conf ...$(e)" --caller="${SCRIPT_NAME}"
      ${da_bin} set brute_force_messages_log /var/log/pureftpd.log restart
      echo ""
      msg "$(s cyan)Changing FTPD_LOG value to /var/log/pureftpd.log in csf.conf ...$(e)" --caller="${SCRIPT_NAME}"
      check_path "/etc/csf/csf.conf"
      sed -i "s/FTPD_LOG = .*/FTPD_LOG = \"\/var\/log\/pureftpd.log\"/" /etc/csf/csf.conf
      get_status_message "$?"
      echo ""
      msg "$(s cyan)Restarting CSF and LFD ...$(e)" --caller="${SCRIPT_NAME}"
      csf -ra >/dev/null
    elif [ "${C_DA_CB_FTP_SOFTWARE}" == "proftpd" ]; then
      # Note the unified ftp password config has been previously set (this is required)
      msg "$(s yellow)Enabling SFTP for proftpd ...$(e)" --caller="${SCRIPT_NAME}"
      echo ""
      msg "$(s cyan)Creating custom directory for proftpd to hold custom config files ...$(e)" --caller="${SCRIPT_NAME}"
      mkdir -p "/usr/local/directadmin/custombuild/custom/proftpd/conf"
      echo ""
      msg "$(s cyan)Downloading proftpd build configuration file ...$(e)" --caller="${SCRIPT_NAME}"
      wget -O "/usr/local/directadmin/custombuild/custom/proftpd/configure.proftpd" http://files.directadmin.com/services/all/sftp/configure.proftpd.sftp
      echo ""
      msg "$(s cyan)Fixing permission for configure.proftpd ...$(e)" --caller="${SCRIPT_NAME}"
      chmod -v 755 "/usr/local/directadmin/custombuild/custom/proftpd/configure.proftpd"
      echo ""
      msg "$(s cyan)Downloading proftpd config template file ...$(e)" --caller="${SCRIPT_NAME}"
      wget -O "/usr/local/directadmin/custombuild/custom/proftpd/conf/proftpd.conf" http://files.directadmin.com/services/all/sftp/proftpd.conf
      echo ""
      msg "$(s cyan)Downloading proftpd.sftp.conf file into /etc/proftpd.sftp.conf ...$(e)" --caller="${SCRIPT_NAME}"
      wget -O /etc/proftpd.sftp.conf http://files.directadmin.com/services/all/sftp/proftpd.sftp.conf
      echo ""

      msg "$(s cyan)Creating proftpd SSH folder ...$(e)" --caller="${SCRIPT_NAME}"
      mkdir -p /etc/proftpd/ssh
      echo ""

      msg "$(s cyan)Copying SSH key from /etc/ssh/ssh_host_rsa_key* into /etc/proftpd/ssh/* ...$(e)" --caller="${SCRIPT_NAME}"
      cp /etc/ssh/ssh_host_rsa_key* /etc/proftpd/ssh
      echo ""
      msg "$(s cyan)Fixing permission /etc/proftpd/ssh/ssh_host_rsa_key ...$(e)" --caller="${SCRIPT_NAME}"
      chmod -v 400 /etc/proftpd/ssh/ssh_host_rsa_key
      echo ""
      msg "$(s cyan)Backing up file /etc/proftpd.sftp.conf into /etc/proftpd.sftp.conf_original ...$(e)" --caller="${SCRIPT_NAME}"
      cp /etc/proftpd.sftp.conf /etc/proftpd.sftp.conf_original
      echo ""
      msg "$(s cyan)Changing proftpd SSH key location for /etc/proftpd.sftp.conf ...$(e)" --caller="${SCRIPT_NAME}"
      sed -i 's|^SFTPHostKey .*|SFTPHostKey \/etc\/proftpd\/ssh\/ssh_host_rsa_key|' /etc/proftpd.sftp.conf
      echo ""
      msg "$(s cyan)Writing proftpd template file for new installer ...$(e)" --caller="${SCRIPT_NAME}"
      # TODO always check chiper for latest. This template is based on http://files.directadmin.com/services/all/sftp/proftpd.conf
      {
        echo "ServerName		\"ProFTPd\""
        echo "ServerType          	standalone"
        echo ""
        echo "Port                    0"
        echo "<VirtualHost 0.0.0.0>"
        echo "        Port 0 # Add port to 0 here to prevent unencrypted FTP connection"
        echo "	AuthUserFile	/etc/proftpd.passwd"
        echo "</VirtualHost>"
        echo ""
        echo "PassivePorts		35000 35999"
        echo "UseReverseDNS		off"
        echo "TimesGMT		off"
        echo "TimeoutLogin		120"
        echo "TimeoutIdle		600"
        echo "TimeoutNoTransfer	900"
        echo "TimeoutStalled		3600"
        echo ""
        echo "ScoreboardFile  /var/run/proftpd/proftpd.scoreboard"
        echo "PidFile			/var/run/proftpd/proftpd.pid"
        echo ""
        echo "TransferLog		/var/log/proftpd/xferlog.legacy"
        echo "LogFormat		default \"%h %l %u %t \"%r\" %s %b\""
        echo "LogFormat		auth    \"%v [%P] %h %t \"%r\" %s\""
        echo "LogFormat		write   \"%h %l %u %t \"%r\" %s %b\""
        echo ""
        echo "#DON'T modify this log format.  Its used by DirectAdmin to determine user usage"
        echo "LogFormat		userlog \"%u %b %m %a\""
        echo "ExtendedLog		/var/log/proftpd/|SERVER_IP|.bytes WRITE,READ userlog"
        echo ""
        echo "AuthUserFile                    /etc/proftpd.passwd"
        echo "DefaultServer		on"
        echo "AuthOrder mod_auth_file.c"
        echo ""
        echo "#AuthPAM off"
        echo ""
        echo "<IfModule mod_tls.c>"
        echo "	TLSEngine on"
        echo "  TLSRequired on #Add this to force encryption for FTPS"
        echo "  Port 21"
        echo "  TLSOptions NoSessionReuseRequired #This is option is used to fix some clients that does not list out files in FTP"
        echo "	TLSLog /var/log/proftpd/proftpd.tls.log"
        echo "        TLSProtocol ALL -TLSv1 -TLSv1.1"
        echo "        TLSCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384"
        echo "        TLSVerifyClient off"
        echo "	#Certificates"
        echo "	TLSRSACertificateFile /etc/exim.cert"
        echo "	TLSRSACertificateKeyFile /etc/exim.key"
        echo "	#TLSCACertificateFile /etc/ftpd/root.cert.pem"
        echo ""
        echo "	TLSCipherSuite HIGH:MEDIUM:+TLSv1:!SSLv2:+SSLv3"
        echo "</IfModule>"
        echo ""
        echo "<Global>"
        echo "	PassivePorts            35000 35999"
        echo "	DeferWelcome		on"
        echo ""
        echo "	RequireValidShell	no"
        echo ""
        echo "	DefaultRoot		~"
        echo "	DirFakeUser on ftp"
        echo "	DirFakeGroup on ftp"
        echo ""
        echo "	User			ftp"
        echo "	Group			ftp"
        echo "	#UserAlias		anonymous ftp"
        echo ""
        echo "	AllowStoreRestart	on"
        echo "	AllowRetrieveRestart	on"
        echo ""
        echo "	#ListOptions		-a #deprecated"
        echo ""
        echo "	Umask			022"
        echo "	DisplayLogin		welcome.msg"
        echo "	DisplayChdir		readme"
        echo "	AllowOverwrite		yes"
        echo "	ExtendedLog		/var/log/proftpd/access.log WRITE,READ write"
        echo "	ExtendedLog		/var/log/proftpd/auth.log AUTH auth"
        echo ""
        echo "	#"
        echo "	# Paranoia logging level...."
        echo "	#"
        echo "	#ExtendedLog    /var/log/proftpd/paranoid.log ALL default"
        echo ""
        echo "	<IfModule mod_tls.c>"
        echo "		TLSEngine on"
        echo "		TLSLog /var/log/proftpd/proftpd.tls.log"
        echo "		TLSRSACertificateFile /etc/exim.cert"
        echo "		TLSRSACertificateKeyFile /etc/exim.key"
        echo "	</IfModule>"
        echo "</Global>"
        echo ""
        echo "Include /etc/proftpd.sftp.conf"
      } >/usr/local/directadmin/custombuild/custom/proftpd/conf/proftpd.conf
      echo ""
      msg "$(s cyan)Rebuilding proftpd using new config ...$(e)" --caller="${SCRIPT_NAME}"
      "${da_cb_bin}" proftpd
      echo ""
    else
      msg "$(s yellow)[Skipped]: FTP software ${C_DA_CB_FTP_SOFTWARE} configuration is not yet implemented$(e)" --caller="${SCRIPT_NAME}"
    fi
    # No need to remove ftp log from rsyslog.conf using ftp.none because DA BFM and LFD from CSF needs the log to auto block
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This function will configure server (nginx, apache, nginx_apache) for security
# Example creating alias name for db, mail, setting up server for production and more
configure_server_security() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local httpd_alias_conf httpd_include_conf httpd_default_conf httpd_info_conf
    httpd_alias_conf="/etc/httpd/conf/extra/httpd-alias.conf"
    httpd_include_conf="/etc/httpd/conf/extra/httpd-includes.conf"
    httpd_default_conf="/etc/httpd/conf/extra/httpd-default.conf"
    httpd_info_conf="/etc/httpd/conf/extra/httpd-info.conf"

    check_path "${httpd_alias_conf}" "${httpd_include_conf}" "${httpd_default_conf}" "${httpd_info_conf}"

    msg "$(s cyan)Backing up original httpd-alias.conf at /etc/httpd/ as httpd-alias.conf_backup_original_${DATE_TIME_NOW} ...$(e)" --caller="${SCRIPT_NAME}"
    cp -p "${httpd_alias_conf}" "${httpd_alias_conf}_backup_original_${DATE_TIME_NOW}"
    echo ""
    msg "$(s cyan)Writing httpd custom config for httpd-alias.conf in ${httpd_alias_conf} ...$(e)" --caller="${SCRIPT_NAME}"
    {
      echo "# ==============================================="
      echo "# This configuration file was generated by ${SCRIPT_NAME}"
      echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
      echo "# ==============================================="
      echo "RewriteEngine On"
      echo "Alias /config \"/var/www/html/redirect.php\""
      echo "Alias /.well-known/acme-challenge \"/var/www/html/.well-known/acme-challenge\""
      echo ""
      # Here we can specify what URL should be blocked (with 404.html page)
      echo "# BLOCKED common route for security:"
      echo "Alias /phpMyAdmin \"/var/www/html/server/error_docs/404.html\""
      echo "Alias /phpmyadmin \"/var/www/html/server/error_docs/404.html\""
      echo "Alias /pma \"/var/www/html/server/error_docs/404.html\""
      echo "Alias /squirrelmail \"/var/www/html/server/error_docs/404.html\""
      echo "Alias /webmail \"/var/www/html/server/error_docs/404.html\""
      echo "Alias /roundcube \"/var/www/html/server/error_docs/404.html\""
      echo ""
      echo "# CUSTOM URLs:"
      echo "# PHPMYADMIN custom URL:"
      echo "Alias ${C_PHPMYADMIN_LOGIN_ROUTE} \"/var/www/html/phpMyAdmin/\""
      echo "# ROUNDCUBE custom URL:"
      echo "Alias ${C_ROUNDCUBE_LOGIN_ROUTE} \"/var/www/html/roundcube/\""
      echo "# HTPASSWD secure directories:"
      echo ""
    } >"${httpd_alias_conf}"
    echo ""

    if [ "${C_SECURE_LOGIN_ROUTE}" == "true" ]; then
      if command -v htpasswd &>/dev/null; then
        # Create htpasswd for phpmyadmin URL: (only create user information but not enabled it)
        msg "$(s cyan)Creating httpasswd for restricting phpMyAdmin URL route ... $(e)" --caller="${SCRIPT_NAME}"
        # Supply -c for first user, this will produce sensitive output with standard error, hide with 2>
        htpasswd -b -c /etc/httpd/.htpasswd "${C_HTTPASSWD_PHPMYADMIN_USERNAME}" "${C_HTTPASSWD_PHPMYADMIN_PASS}" 2>/dev/null
        echo ""
        #only create user information but not enabled it
        msg "$(s cyan)Creating httpasswd for restricting roundcube URL route ... $(e)" --caller="${SCRIPT_NAME}"
        # Don't supply -c for next user (if supply -c, it will replace the previous one), this will produce sensitive output with standard error, hide with 2>
        htpasswd -b /etc/httpd/.htpasswd "${C_HTTPASSWD_ROUNDCUBE_USERNAME}" "${C_HTTPASSWD_ROUNDCUBE_PASS}" 2>/dev/null
        echo ""
        # For restricting server-info and server-status page
        msg "$(s cyan)Creating httpasswd for restricting server-info and server-status page ... $(e)" --caller="${SCRIPT_NAME}"
        # Don't supply -c for next user (if supply -c, it will replace the previous one), this will produce sensitive output with standard error, hide with 2>
        htpasswd -b /etc/httpd/.htpasswd "${C_APACHE_SERVER_ROUTE_USERNAME}" "${C_APACHE_SERVER_ROUTE_PASS}" 2>/dev/null
        echo ""

        msg "$(s cyan)Correcting the permission of /etc/httpd/.htpasswd ... $(e)" --caller="${SCRIPT_NAME}"
        chown apache:apache /etc/httpd/.htpasswd
        chmod +r /etc/httpd/.htpasswd
        echo ""
      else
        msg "$(s red)Error, htpasswd binary does not exist! Make sure it exist and rerun this setup again$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi
      msg "$(s cyan)Protecting phpMyAdmin and roundcube with htpasswd because C_SECURE_LOGIN_ROUTE is se to true ...$(e)" --caller="${SCRIPT_NAME}"
      {
        echo "#Protect phpMyAdmin directory:"
        echo "<Directory \"/var/www/html/phpMyAdmin/\">"
        echo "#AllowOverride AuthConfig"
        echo "AuthType Basic"
        echo "AuthName \"${C_BOX_HOSTNAME_FQHN}": DB-Auth\"
        echo "AuthUserFile /etc/httpd/.htpasswd"
        echo "Require user ${C_HTTPASSWD_PHPMYADMIN_USERNAME}"
        echo "</Directory>"
        echo ""
        echo "#Protect roundcube directory:"
        echo "<Directory \"/var/www/html/roundcube/\">"
        echo "#AllowOverride AuthConfig"
        echo "AuthType Basic"
        echo "AuthName \"${C_BOX_HOSTNAME_FQHN}": Mail-Auth\"
        echo "AuthUserFile /etc/httpd/.htpasswd"
        echo "Require user ${C_HTTPASSWD_ROUNDCUBE_USERNAME}"
        echo "</Directory>"
      } >>"${httpd_alias_conf}"

    else
      msg "$(s cyan)[Skipped]: C_SECURE_LOGIN_ROUTE is not set. Custom URL routes are not protected$(e)" --caller="${SCRIPT_NAME}"

    fi
    echo ""
    ######## Temporarily disable this because we do not need to force redirection (might have issue), just backup
    msg "$(s cyan)Backing up original httpd-includes.conf at ${httpd_include_conf} as ${httpd_include_conf}_backup_original_${DATE_TIME_NOW} ...$(e)" --caller="${SCRIPT_NAME}"
    cp -p "${httpd_include_conf}" "${httpd_include_conf}_backup_original_${DATE_TIME_NOW}"

    ## It is a new file, so we make sure it is exist
    #cat /dev/null >"${httpd_include_conf}"
    # msg "$(s cyan)Writing https redirection for all routes in httpd-includes.conf ...$(e)" --caller="${SCRIPT_NAME}"
    #{
    #  # Make https for all directories (This will take over force https setting at Directadmin)
    #  echo "# ==============================================="
    #  echo "# This configuration file was generated by ${SCRIPT_NAME}"
    #  echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
    #  echo "# ==============================================="
    #  echo "<location /*>"
    #  echo "RewriteEngine On"
    #  echo "RewriteCond %{HTTPS} off"
    #  echo "RewriteRule (.*) https://%{HTTP_HOST}%{REQUEST_URI}"
    #  echo "</location>"
    #} >>${httpd_include_conf}
    #echo ""

    # This will set server for production
    msg "$(s cyan)Backing up original httpd-default.conf at ${httpd_default_conf} as ${httpd_default_conf}_backup_original_${DATE_TIME_NOW} ...$(e)" --caller="${SCRIPT_NAME}"
    cp -p "${httpd_default_conf}" "${httpd_default_conf}_backup_original_${DATE_TIME_NOW}"
    echo ""
    msg "$(s cyan)Customizing server config at ${httpd_default_conf} ...$(e)" --caller="${SCRIPT_NAME}"
    sed -i 's|^ServerTokens .*|ServerTokens Prod|' ${httpd_default_conf}
    sed -i 's|^ServerSignature .*|ServerSignature Off|' ${httpd_default_conf}
    echo ""

    msg "$(s cyan)Backing up original httpd-info.conf at ${httpd_info_conf} as ${httpd_info_conf}_backup_original_${DATE_TIME_NOW} ...$(e)" --caller="${SCRIPT_NAME}"
    cp -p "${httpd_info_conf}" "${httpd_info_conf}_backup_original_${DATE_TIME_NOW}"
    echo ""

    server_status_route=$(echo "${C_APACHE_SERVER_STATUS_ROUTE}" | sed 's/^\///')
    server_info_route=$(echo "${C_APACHE_SERVER_INFO_ROUTE}" | sed 's/^\///')

    {
      echo "# ==============================================="
      echo "# This configuration file was generated by ${SCRIPT_NAME}"
      echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
      echo "# ==============================================="
      echo "<location /${server_status_route}>"
      echo "SetHandler server-status"
      echo "AuthType basic"
      echo "AuthName \"Apache server status\""
      echo "AuthUserFile /etc/httpd/.htpasswd"
      echo "Require valid-user"
      echo "</location>"
      echo ""
      echo "ExtendedStatus Off"
      echo ""
      echo "<location /${server_info_route}>"
      echo "SetHandler server-info"
      echo "AuthType basic"
      echo "AuthName \"Apache server info\""
      echo "AuthUserFile /etc/httpd/.htpasswd"
      echo "Require valid-user"
      echo "</location>"
    } >${httpd_info_conf}
    # Restarting web server based on config file ( do not rewrite_confs because that command will replace everything to default )
    # Warning, do not run rewrite_confs at this point until configure_da_custom_configs() is called.
    msg "$(s cyan)Requesting to restart web server ...$(e)" --caller="${SCRIPT_NAME}"
    restart_da_web_server
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This function will create / copy all custom configs like roundcube, phpmyadmin, apache etc in DA custom folder
# So when we update Directadmin, it won't replace these files.
configure_da_custom_configs() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    # This will build custom config for DA with secured settings
    local da_conf da_bin da_cb_bin da_cb_custom_conf_path httpd_alias_conf httpd_include_conf httpd_info_conf phpmyadmin_path roundcube_path

    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    da_cb_custom_conf_path="/usr/local/directadmin/custombuild/custom"
    httpd_alias_conf="/etc/httpd/conf/extra/httpd-alias.conf"
    httpd_include_conf="/etc/httpd/conf/extra/httpd-includes.conf"
    httpd_default_conf="/etc/httpd/conf/extra/httpd-default.conf"
    httpd_info_conf="/etc/httpd/conf/extra/httpd-info.conf"
    phpmyadmin_path="/var/www/html/phpMyAdmin"
    roundcube_path="/var/www/html/roundcube"

    mkdir -p "${da_cb_custom_conf_path}"

    msg "$(s cyan)Checking required paths ...$(e)" --caller="${SCRIPT_NAME}"
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}" "${da_cb_custom_conf_path}" "${httpd_alias_conf}" "${httpd_include_conf}" "${httpd_default_conf}" "${httpd_info_conf}" "${phpmyadmin_path}" "${phpmyadmin_path}"
    echo ""

    # For apache2 (ap2)
    # 1) create custom folder at /usr/local/directadmin/custombuild/custom/ap2/conf/extra
    msg "$(s cyan)Creating a custom config folder for apache/httpd (ap2) at ${da_cb_custom_conf_path}/ap2/conf/extra ...$(e)" --caller="${SCRIPT_NAME}"
    mkdir -p "${da_cb_custom_conf_path}/ap2/conf/extra"
    echo ""
    msg "$(s cyan)Copying httpd-alias.conf into DA custom ap2 folder ...$(e)" --caller="${SCRIPT_NAME}"
    cp -p "${httpd_alias_conf}" "${da_cb_custom_conf_path}/ap2/conf/extra/httpd-alias.conf"
    echo ""
    msg "$(s cyan)Copying httpd-includes.conf into ${da_cb_custom_conf_path}/ap2/conf/extra/httpd-includes.conf ...$(e)" --caller="${SCRIPT_NAME}"
    cp -p "${httpd_include_conf}" "${da_cb_custom_conf_path}/ap2/conf/extra/httpd-includes.conf"
    echo ""

    msg "$(s cyan)Copying httpd-default.conf into ${da_cb_custom_conf_path}/ap2/conf/extra/httpd-default.conf ...$(e)" --caller="${SCRIPT_NAME}"
    cp -p "${httpd_default_conf}" "${da_cb_custom_conf_path}/ap2/conf/extra/httpd-default.conf"
    echo ""

    msg "$(s cyan)Copying httpd-info.conf into ${da_cb_custom_conf_path}/ap2/conf/extra/httpd-info.conf ...$(e)" --caller="${SCRIPT_NAME}"
    cp -p "${httpd_info_conf}" "${da_cb_custom_conf_path}/ap2/conf/extra/httpd-info.conf"
    echo ""

    # 2 For phpmyadmin custom config
    msg "$(s cyan)Creating a custom config folder for phpMyAdmin at ${da_cb_custom_conf_path}/phpMyAdmin ...$(e)" --caller="${SCRIPT_NAME}"
    mkdir -p "${da_cb_custom_conf_path}/phpmyadmin"
    echo ""
    # .htaccess
    msg "$(s cyan)Copying phpMyAdmin .htaccess into phpmyadmin DA custom folder ...$(e)" --caller="${SCRIPT_NAME}"
    cp -p "/var/www/html/phpMyAdmin/.htaccess" "/usr/local/directadmin/custombuild/custom/phpmyadmin/.htaccess"
    echo ""
    # config.inc.php
    msg "$(s cyan)Copying original phpmyadmin config from ${phpmyadmin_path}/config.inc.php into ${da_cb_custom_conf_path}/phpmyadmin/config.inc.php ...$(e)" --caller="${SCRIPT_NAME}"
    #sleep 1
    cp -p "${phpmyadmin_path}/config.inc.php" "${da_cb_custom_conf_path}/phpmyadmin/config.inc.php"
    echo ""

    # For custom phpMyAdmin theme (not using theme yet) leave this comment until I have new custom theme
    #mkdir -p /usr/local/directadmin/custombuild/custom/phpmyadmin/themes
    #msg "Copying custom phpMyAdmin themes ..."
    #cp -p "/var/www/html/phpMyAdmin/themes/sofibox" "/usr/local/directadmin/custombuild/custom/phpmyadmin/themes/sofibox"
    #sleep 1

    #3 - For main roundcube (2 important files: config.inc.php, my.cnf)
    msg "$(s cyan)Creating a custom config folder for roundcube at ${da_cb_custom_conf_path}/roundcube ...$(e)" --caller="${SCRIPT_NAME}"
    mkdir -p "${da_cb_custom_conf_path}/roundcube"
    echo ""
    msg "$(s cyan)Copying original roundcube config from into DA roundcube custom folder ...$(e)" --caller="${SCRIPT_NAME}"
    #sleep 1
    cp -p "${roundcube_path}/config/config.inc.php" "${da_cb_custom_conf_path}/roundcube/config.inc.php"
    echo ""
    # Remember when rebuild roundcube ./build roundcube DA will automatically update my.cnf. Don't touch that.
    # I wrote answer here: https://forum.directadmin.com/threads/script-to-reset-da_admin-da_roundcube-password.57101/#post-324944

    #4 - For roundcube rcguard plugin (copy the whole folder)
    msg "$(s cyan)Creating a custom config folder for roundcube plugins ${da_cb_custom_conf_path}/roundcube/plugins ...$(e)" --caller="${SCRIPT_NAME}"
    mkdir -p /usr/local/directadmin/custombuild/custom/roundcube/plugins/
    echo ""
    msg "$(s cyan)Copying custom roundcube custom plugins ...$(e)" --caller="${SCRIPT_NAME}"
    cp -p -r ${roundcube_path}/plugins/rcguard ${da_cb_custom_conf_path}/roundcube/plugins/
    echo ""

    #n - For others later in here

    # TODO if problem with modsecurity use this custom config (monitoring this):
    #    cd /usr/local/directadmin/custombuild/
    #mkdir -p custom/nginx_reverse/conf/
    #[ -f "custom/nginx_reverse/conf/nginx-modsecurity.conf" ] || cp -p configure/nginx_reverse/conf/nginx-modsecurity.conf custom/nginx_reverse/conf/nginx-modsecurity.conf
    #perl -pi -e "s/^SecDefaultAction /#SecDefaultAction /" custom/nginx_reverse/conf/nginx-modsecurity.conf
    #./build rewrite_confs

    #n-Create custom php ini file here (create custom php ini file here with the following information) -- what is the purpose? find it out
    # increase memory consumption or upload sql size, make custom path in custom/php.conf.d
    #https://forum.directadmin.com/threads/solved-customized-50-webapps-ini-and-10-directadmin-ini.61045/#post-312326

    # at the end must do build phpmyadmin, roundcube, rewrite_confs to save httpd changes.
    # Need to rebuild this because previously we change config.inc.php. Better rebuild for new setting.
    msg "$(s cyan)Rebuilding phpMyAdmin for new settings ...$(e)" --caller="${SCRIPT_NAME}"
    ${da_cb_bin} phpmyadmin
    echo ""
    msg "$(s cyan)Rebuilding roundcube for new settings ...$(e)" --caller="${SCRIPT_NAME}"
    ${da_cb_bin} roundcube
    echo ""
    msg "$(s cyan)Rebuilding server configs for new settings ...$(e)" --caller="${SCRIPT_NAME}"
    ${da_cb_bin} rewrite_confs 1>/dev/null 2>/dev/null

    # Rebuilding other directadmin package more starting here if needed ...
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Configure apps in /var/www/html
configure_web_apps() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    #local c_ipv4add0_escaped
    #c_ipv4add0_escaped="${C_IPV4_ADD0//./\\.}"

    # If needed run this to get latest code in storage folder straight from git by running the following command:
    # get_latest_code

    msg "$(s cyan)Copying custom webapps from storage into /var/www/html ...$(e)" --caller="${SCRIPT_NAME}"
    mkdir -p /var/www/html
    cp -ra "${LATEST_OS_CODE_PATH}"/var/www/html/. /var/www/html/
    get_status_message $?
    echo ""

    msg "$(s cyan)giving all files inside /var/www/html permission name to webapps user and group ...$(e)" --caller="${SCRIPT_NAME}"
    chown -R webapps:webapps /var/www/html
    get_status_message $?
    echo ""

    msg "$(s cyan)Giving file permission recursively for /var/www/html contents $(e)" --caller="${SCRIPT_NAME}"
    sudo find /var/www/html -type f -exec chmod 644 {} \;
    get_status_message $?
    echo ""
    msg "$(s cyan)Giving directory permission recursively for /var/www/html contents $(e)" --caller="${SCRIPT_NAME}"
    sudo find /var/www/html -type d -exec chmod 755 {} \;
    get_status_message $?
    echo ""

    # or I can use this as place holder:

    #msg "$(s cyan)Writing .htaccess rule at /var/www/html/.htaccess ...$(e)" --caller="${SCRIPT_NAME}"
    #{
    #  echo "RewriteEngine On"
    #  echo "DirectoryIndex index.php index.html"
    #  echo ""

    #  echo "# Define error documents"
    #  echo "#ErrorDocument 400 /error_docs/sun/400.php"
    #  echo "#ErrorDocument 401 /error_docs/sun/401.php"
    #  echo "#ErrorDocument 403 /error_docs/sun/403.php"
    #  echo "ErrorDocument 404 /error_docs/sun/404.php"
    #  echo "#ErrorDocument 500 /error_docs/sun/500.php"

    #  echo "# First condition if IP is given, redirect to hostname"
    #  echo "RewriteCond %{HTTP_HOST} ^${c_ipv4add0_escaped}(:[0-9]+)?\$"
    #  echo "RewriteRule ^(.*)$ https://${C_BOX_HOSTNAME_FQHN}/\$1 [L,R=301]"
    #  echo ""

    #  echo "# Second condition, if https is off, redirect to"
    #  echo "RewriteCond %{HTTPS} off"
    #  echo "RewriteCond %{HTTP:X-Forwarded-Proto} !https"
    #  echo "RewriteRule ^(.*)$ https://${C_BOX_HOSTNAME_FQHN}/\$1 [L,R=301]"
    #} >"/var/www/html/.htaccess"

    #chmod 644 /var/www/html/.htaccess
    # chown webapps:webapps /var/www/html/.htaccess

    # # 1) Replace index.html by calling index.php (index.html by default has root permission and root group)
    # msg "$(s cyan)Redirect index.html to index.php ...$(e)" --caller="${SCRIPT_NAME}"
    #{
    #  echo "<!DOCTYPE html>"
    #  echo "<html lang=\"en\">"
    #  echo "  <META HTTP-EQUIV=\"Refresh\""
    #  echo "  CONTENT=\"0; URL=https://${C_BOX_HOSTNAME_FQHN}/index.php\">"
    #  echo "</html>"
    #} >"/var/www/html/index.html"
    #echo ""

    # every custom webapps like /billing should be here
    # msg "$(s cyan)Configuring server frontpage ...$(e)" --caller="${SCRIPT_NAME}"

    #cat /dev/null >/var/www/html/index.php
    #{
    #  echo "<?php"
    #  echo "echo \"MaXi32 - Arafat Ali - Rebuilding server ...\""
    #  echo "?>"
    #  echo "<!DOCTYPE html>"
    #  echo "<html lang=\"en\">"
    #  echo "<!--"
    #  echo "Author: Arafat Ali"
    #  echo "Email: arafat@maxibi.com"
    #  echo "-->"
    #  echo "<head>"
    #  echo "  <meta charset=\"UTF-8\">"
    #  echo "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\">"
    #  echo "<title>${C_BOX_HOSTNAME_FQHN^} Server - Sofibox Cloud Hosting</title>"
    #  echo "</head>"
    #  echo "<body>"
    #  echo "</body>"
    #  echo "</html>"
    #} \
    #  >/var/www/html/index.php

    #chmod 644 /var/www/html/index.php
    #chown webapps:webapps /var/www/html/index.php

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This is for configuring all directadmin.conf settings
# For configuring admin setting and extra hardening any DA related installation
configure_da_settings() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_conf da_bin da_cb_bin

    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    msg "$(s cyan)Checking if directadmin binary, custombuild and directadmin.conf are presents ...$(e)" --caller="${SCRIPT_NAME}"
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}"
    echo ""

    # Using API (some values are not present in directadmin.conf), so we use this extra API
    # For DA Administrator Settings:
    msg "$(s cyan)Configuring Directadmin Admin settings with recommend values ...$(e)" --caller="${SCRIPT_NAME}"
    da_api_admin set-da-admin-settings --recommend-values

    msg "$(s cyan)Configuring Directadmin Server, Security and Email settings with recommend values ...$(e)" --caller="${SCRIPT_NAME}"
    da_api_admin set-da-server-settings --recommend-values

    # Need this before changing or adding directadmin username
    # Set the maximum length of directadmin username (default is 14) for higher than 14 make sure mariadb or mysql is latest version
    # TODO: Set max_username_length based on this rule: https://www.directadmin.com/features.php?id=2294
    msg "$(s cyan)Setting directadmin max username to ${C_DA_MAX_USERNAME_LENGTH} ...$(e)" --caller="${SCRIPT_NAME}"
    ${da_bin} set max_username_length "${C_DA_MAX_USERNAME_LENGTH}"
    echo ""
    msg "$(s cyan)Enforcing Directadmin difficult password ...$(e)" --caller="${SCRIPT_NAME}"
    ${da_bin} set enforce_difficult_passwords "${C_DA_ENFORCE_DIFFICULT_PASSWORDS}"
    # This setting force_hostname will only allow hostname url login in Directadmin. For example, without this option you can use any domain within directadmin system to login.
    # eg: userdomain.com:2222 . Sometimes this user does not have valid certificate, thus this will cause security issue.
    # so, it is better to redirect to one hostname with a valid certificate:
    # Also explained in here: https://www.directadmin.com/features.php?id=917
    # It is recommend to enable this option for security
    # Note before directadmin installation, this already set by hostname.sh script
    msg "$(s cyan)Enabling directadmin to force login with only hostname ${C_BOX_HOSTNAME_FQHN} ...$(e)" --caller="${SCRIPT_NAME}"
    ${da_bin} set force_hostname "${C_BOX_HOSTNAME_FQHN}"
    msg "$(s cyan)Enabling directadmin backup encryption ...$(e)" --caller="${SCRIPT_NAME}"
    ${da_bin} set allow_backup_encryption "${C_DA_ALLOW_BACKUP_ENCRYPTION}"
    msg "$(s cyan)Setting directadmin online document ...$(e)" --caller="${SCRIPT_NAME}"
    ${da_bin} set admin_helper "${C_DA_ADMIN_HELPER}"
    ${da_bin} set reseller_helper "${C_DA_RESELLER_HELPER}"
    ${da_bin} set user_helper "${C_DA_USER_HELPER}"
    echo ""
    msg "$(s cyan)Setting directadmin servername ...$(e)" --caller="${SCRIPT_NAME}"
    ${da_bin} set servername "${C_BOX_HOSTNAME_FQHN}"
    echo ""
    msg "$(s cyan)Setting directadmin nameservers ...$(e)" --caller="${SCRIPT_NAME}"
    ${da_bin} set ns1 "${C_BOX_NS1}"
    ${da_bin} set ns2 "${C_BOX_NS2}"
    echo ""
    msg "$(s cyan)Setting directadmin execution timeout ...$(e)" --caller="${SCRIPT_NAME}"
    # Set the timeout setting in second for directadmin execution before generating a timeout signal and aborting (default 60 seconds)
    ${da_bin} set timeout "${C_DA_TIMEOUT}"
    echo ""
    # https://www.directadmin.com/features.php?id=930
    ${da_bin} set tokenizer_debug "${C_DA_TOKENIZER_DEBUG}"
    echo ""

    # Only enable this when DA version is at least 1.63.1
    if is_valid version_required "$(${da_bin} v | grep -oP '[0-9]+\.[0-9]+\.[0-9]+')" "1.63.1"; then
      msg "$(s cyan)Setting directadmin session minutes ...$(e)" --caller="${SCRIPT_NAME}"
      # Set the login session timeout in minutes (when idle), session counter reset to 0 if any da page is reload (default 60 minutes / 1 hour)
      # 2880 = 2 days / 48 hours
      #  This had bug before (it is fixed now): https://forum.directadmin.com/threads/bug-cannot-set-session_minutes-using-directadmin-set-command.64280/#post-334271
      ${da_bin} set session_minutes "${C_DA_SESSION_MINUTES}"
    fi

    echo ""
    msg "$(s cyan)Setting directadmin max file size ...$(e)" --caller="${SCRIPT_NAME}"
    # Increase upload max file size in bytes
    # 5368709120 = 5GB
    ${da_bin} set maxfilesize "${C_DA_MAXFILESIZE}"
    echo ""
    msg "$(s cyan)Setting directadmin login history ...$(e)" --caller="${SCRIPT_NAME}"
    # Set directadmin login history (default 10)
    ${da_bin} set login_history "${C_DA_LOGIN_HISTORY}"

    # Do not disable disable_ip_check (this one is session security) - default is 0
    # Deprecated variable
    # ${da_bin} set disable_ip_check "${C_DA_DISABLE_IPCHECK}"

    # Disable foreign IP when login - default is 0
    ${da_bin} set allow_foreign_key "${C_DA_ALLOW_FOREIGN_KEY}"
    # Enable simple disk usage - lowering disk access (this might increase performance)
    ${da_bin} set simple_disk_usage "${C_DA_SIMPLE_DISK_USAGE}"
    # Enable zip compression in file manager (allow zip and unzip feature)
    ${da_bin} set zip "${C_DA_ZIP}"
    # Disable awstats (disable by default) and webalizer (enabled by default) and rotation (enabled by default)
    ${da_bin} set awstats "${C_DA_AWSTATS}"
    ${da_bin} set webalizer "${C_DA_WEBALIZER}"
    ${da_bin} set rotation "${C_DA_ROTATION}"
    # Disable this feature increase performance (default is enabled)
    ${da_bin} set count_pop_usage "${C_DA_COUNT_POP_USAGE}"
    # Purge spam email every 1 day (this can increase performance if value is low)
    ${da_bin} set purge_spam_days "${C_DA_PURGE_SPAM_DAYS}"
    # Skip some backups path
    ${da_bin} set skip_hometargz_in_backups "${C_DA_SKIP_HOMETARGZ_IN_BACKUPS}"
    ${da_bin} set skip_domains_in_backups "${C_DA_SKIP_DOMAINS_IN_BACKUPS}"
    ${da_bin} set skip_imap_in_backups "${C_DA_SKIP_IMAP_IN_BACKUPS}"
    ${da_bin} set skip_databases_in_backups "${C_DA_SKIP_DATABASES_IN_BACKUPS}"
    # Skip database usage show (default 1 - show all databases size)
    ${da_bin} set show_db_usage "${C_DA_SHOW_DB_USAGE}"
    # Enable domain owner checking for unique subdomain
    ${da_bin} set check_subdomain_owner "${C_DA_CHECK_SUBDOMAIN_OWNER}"
    # Set bruteforce and blacklist setting
    ${da_bin} set bruteforce "${C_DA_BRUTEFORCE}"
    # Prevent local IP block:
    ${da_bin} set exempt_local_block "${C_DA_EXEMPT_LOCAL_BLOCK}"
    ${da_bin} set brute_force_time_limit "${C_DA_BRUTE_FORCE_TIME_LIMIT}"
    ${da_bin} set clear_blacklist_ip_time "${C_DA_CLEAR_BLACKLIST_IP_TIME}"
    ${da_bin} set clear_brute_log_entry_time "${C_DA_CLEAR_BRUTE_LOG_ENTRY_TIME}"
    ${da_bin} set clear_brute_log_time "${C_DA_CLEAR_BRUTE_LOG_TIME}"
    ${da_bin} set hide_brute_force_notifications "${C_DA_HIDE_BRUTE_FORCE_NOTIFICATIONS}"
    ${da_bin} set ip_brutecount "${C_DA_IP_BRUTECOUNT}"
    ${da_bin} set unblock_brute_ip_time "${C_DA_UNBLOCK_BRUTE_IP_TIME}"
    ${da_bin} set brute_dos_count "${C_DA_BRUTE_DOS_COUNT}"
    # Set ability for directadmin to scan bruteforce log
    ${da_bin} set brute_force_log_scanner "${C_DA_BRUTE_FORCE_LOG_SCANNER}"
    # Scan domain log for bruteforce like wordpress, 1=manual entry, 2=auto entry in /usr/local/directadmin/data/admin/brute.conf
    ${da_bin} set brute_force_scan_apache_logs "${C_DA_BRUTE_FORCE_SCAN_APACHE_LOGS}"
    # Don't bother the bruteforce count (increase performance for bruteforce page in directadmin)
    ${da_bin} set user_brutecount "${C_DA_USER_BRUTECOUNT}"
    # Check partition usage
    ${da_bin} set check_partitions "${C_DA_CHECK_PARTITIONS}"
    ${da_bin} set partition_usage_threshold "${C_DA_PARTITION_USAGE_THRESHOLD}"
    # Set backup compression format
    ${da_bin} set backup_gzip "${C_DA_BACKUP_GZIP}"
    # Demo for skin
    ${da_bin} set demodocsroot "${C_DA_DEMODOCSROOT}"
    # Do not allow password reset in UI (default is not set to allow)
    ${da_bin} set lost_password "${C_DA_LOST_PASSWORD}"
    # Set user can set email limit sent
    ${da_bin} set user_can_set_email_limit "${C_DA_USER_CAN_SET_EMAIL_LIMIT}"
    # Set max per email send limit
    ${da_bin} set max_per_email_send_limit "${C_DA_MAX_PER_EMAIL_SEND_LIMIT}"
    # Set webmail link
    ${da_bin} set webmail_link "${C_DA_WEBMAIL_LINK}"
    # Based on this: https://directadmin.com/features.php?id=1932
    bind_current_version=$(named -v | awk '{ print $2 }' | grep -oP '[0-9]+\.[0-9]+\.[0-9]+')
    dns_caa_bind_required_version="9.9.6"

    if is_valid version_required "${dns_caa_bind_required_version}" "${bind_current_version}"; then
      msg "$(s cyan)Enabling directadmin DNS CAA record ... $(e)" --caller="${SCRIPT_NAME}"
      ${da_bin} set dns_caa 1
    else
      msg "$(s yellow)[Skipped] Disabling directadmin DNS CAA record because current bind version does not meet requirement (required bind v${dns_caa_bind_required_version}+)... $(e)" --caller="${SCRIPT_NAME}"
      ${da_bin} set dns_caa 0
    fi

    # This will enable hsts for hostname on login port only
    # Important, this will not work until SSL certificate is requested by calling configure_da_hostname_ssl()
    if [[ "${C_DA_ENABLE_HOST_HSTS}" != "false" ]]; then
      ${da_bin} set hsts "${C_DA_ENABLE_HOST_HSTS}"
      # The document also recommend to enable force_hostname (this was done on top)
    fi

    # This will either hide DA version or show in header
    # Deprecated variable in the new version of DA
    # ${da_bin} set show_info_in_header "${C_DA_SHOW_INFO_IN_HEADER}"

    # # This will either hide DA version or show in web title
    ${da_bin} set show_info_in_title "${C_DA_SHOW_INFO_IN_TITLE}"

    # This will sync restore
    ${da_bin} set tally_after_restore "${C_DA_TALLY_AFTER_RESTORE}"
    echo ""

    # Whether to enable AUTO SSL or disable
    if [ "${C_DA_ENABLE_DOMAIN_AUTO_SSL}" == "false" ]; then
      ${da_bin} set admin_ssl_check_retries 0
    else
      ${da_bin} set admin_ssl_check_retries 1
    fi

    # Make the imap backup faster (disabled by default)
    ${da_bin} set direct_imap_backup "${C_DA_DIRECT_IMAP_BACKUP}"
    # Set the jailshell option.
    ${da_bin} set jail "${C_DA_JAIL}"

    ${da_bin} set letsencrypt_list "${C_DA_LETSENCRYPT_LIST}"
    ${da_bin} set letsencrypt_list_selected "${C_DA_LETSENCRYPT_LIST_SELECTED}"
    ${da_bin} set letsencrypt_renewal_success_notice "${C_DA_LETSENCRYPT_RENEWAL_SUCCESS_NOTICE}"
    # Option to set proftpd unified
    ${da_bin} set unified_ftp_password_file "${C_DA_UNIFIED_FTP_PASSWORD_FILE}"
    # set php_fpm spawn process limit
    ${da_bin} set php_fpm_max_children_default "${C_PHP_FPM_MAX_CHILDREN_DEFAULT}"
    echo ""
    ${da_bin} set twostep_auth "${C_DA_TWOSTEP_AUTH}"
    echo ""
    ${da_bin} set block_ip_after_failed_twostep_auth "${C_DA_BLOCK_IP_AFTER_FAILED_TWOSTEP_AUTH}"
    echo ""
    ${da_bin} set max_twostep_auth_attempts "${C_DA_MAX_TWOSTEP_AUTH_ATTEMPTS}"
    echo ""
    ${da_bin} set twostep_auth_discrepancy "${C_DA_TWOSTEP_AUTH_DISCREPANCY}"
    echo ""
    ${da_bin} set twostep_auth_trust_days "${C_DA_TWOSTEP_AUTH_TRUST_DAYS}"
    echo ""
    ${da_bin} set brute_force_apache_log_list_update_interval "${C_DA_BRUTE_FORCE_APACHE_LOG_LIST_UPDATE_INTERVAL}"
    echo ""
    ${da_bin} set ip_blacklist "${C_DA_IP_BLACKLIST}"
    echo ""
    ${da_bin} set ip_whitelist "${C_DA_IP_WHITELIST}"
    echo ""
    ${da_bin} set brute_force_ignore_attempts_on_suspended "${C_DA_BRUTE_FORCE_IGNORE_ATTEMPTS_ON_SUSPENDED}"
    echo ""

    ${da_bin} set brute_force_notifications_email_only "${C_DA_BRUTE_FORCE_NOTIFICATIONS_EMAIL_ONLY}"
    echo ""

    ${da_bin} set include_directadmin_port_in_brute_firewall "${C_DA_INCLUDE_DIRECTADMIN_PORT_IN_BRUTE_FIREWALL}"
    echo ""

    ${da_bin} set brute_force_exim_log "${C_DA_BRUTE_FORCE_EXIM_LOG}"
    echo ""

    ${da_bin} set brute_force_exim_panic_log "${C_DA_BRUTE_FORCE_EXIM_PANIC_LOG}"
    echo ""

    ${da_bin} set brute_force_exim_reject_log "${C_DA_BRUTE_FORCE_EXIM_REJECT_LOG}"
    echo ""
    ${da_bin} set brute_force_mail_log "${C_DA_BRUTE_FORCE_MAIL_LOG}"
    echo ""

    ${da_bin} set brute_force_messages_log "${C_DA_BRUTE_FORCE_MESSAGES_LOG}"
    echo ""

    ${da_bin} set brute_force_mysql_log "${C_DA_BRUTE_FORCE_MYSQL_LOG}"
    echo ""

    ${da_bin} set brute_force_pma_log "${C_DA_BRUTE_FORCE_PMA_LOG}"
    echo ""
    ${da_bin} set brute_force_pureftpd_log "${C_DA_BRUTE_FORCE_PUREFTPD_LOG}"
    echo ""

    ${da_bin} set brute_force_roundcube_log "${C_DA_BRUTE_FORCE_ROUNDCUBE_LOG}"
    echo ""

    ${da_bin} set brute_force_secure_log "${C_DA_BRUTE_FORCE_SECURE_LOG}"
    echo ""

    # A lot of setting have been changed, now we need to restart directadmin
    msg "$(s cyan)Requesting directadmin to restart ...$(e)" --caller="${SCRIPT_NAME}"
    restart_da
    # Add more security concern here for directadmin installation
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This is for configuring all the custombuild extra settings
configure_da_cb_settings() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_bin da_cb_bin c_da_php_enable_dangerous_function
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    da_cb_custom_path="/usr/local/directadmin/custombuild/custom/"

    mkdir -p "${da_cb_custom_path}"
    msg "$(s cyan)Checking if directadmin binary, custombuild and directadmin.conf are presents ...$(e)" --caller="${SCRIPT_NAME}"
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}" "${da_cb_custom_path}"
    echo ""

    if [ -n "${C_DA_PHP_DISABLE_DANGEROUS_FUNCTION}" ]; then
      local c_da_php_enable_dangerous_function
      msg "$(s cyan)Removing previous file php_disable_functions ...$(e)" --caller="${SCRIPT_NAME}"
      rm -f ${da_cb_custom_path}/php_disable_functions
      echo ""
      msg "$(s cyan)Disabling PHP dangerous function through custombuild ...$(e)" --caller="${SCRIPT_NAME}"
      touch "${da_cb_custom_path}/php_disable_functions"
      c_da_php_enable_dangerous_function=$(printf ",%s" "${C_DA_PHP_DISABLE_DANGEROUS_FUNCTION[@]}")
      c_da_php_enable_dangerous_function=${c_da_php_enable_dangerous_function:1}
      echo "${c_da_php_enable_dangerous_function}" >"${da_cb_custom_path}/php_disable_functions"
      echo ""
      msg "$(s cyan)Securing all php installation ...$(e)" --caller="${SCRIPT_NAME}"
      ${da_cb_bin} set secure_php yes
      ${da_cb_bin} secure_php
      echo ""
      msg "$(s cyan)Checking whether current PHP global disabled_functions exist ...$(e)" --caller="${SCRIPT_NAME}"
      has_php_disable_function="$(grep -w "${c_da_php_enable_dangerous_function}" /usr/local/php*/lib/php.ini | wc -l)"
      if [[ "${has_php_disable_function}" -gt 0 ]]; then
        msg "$(s green)[ OK ] written on ${has_php_disable_function} PHP(s) version$(e)"
      else
        msg "$(s red)[ FAILED ]$(e)"
        exit 1
      fi
      echo ""
      msg "$(s cyan)Setting userdir_access into ${C_DA_CB_USERDIR_ACCESS} ... $(e)" --caller="${SCRIPT_NAME}"
      ${da_cb_bin} set userdir_access "${C_DA_CB_USERDIR_ACCESS}"
    else
      msg "$(s yellow)****Warning, the value C_DA_PHP_DISABLE_DANGEROUS_FUNCTION is empty. This means all PHP dangerous functions might not be disabled$(e)" --caller="${SCRIPT_NAME}"
      sleep 3
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi

}

configure_da_redis() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    if [ "${C_DA_INSTALL_REDIS}" == "true" ]; then
      local da_conf da_bin da_cb_bin
      da_bin="/usr/local/directadmin/directadmin"
      da_cb_bin="/usr/local/directadmin/custombuild/build"
      da_conf="/usr/local/directadmin/conf/directadmin.conf"

      msg "$(s cyan)Checking if directadmin binary, custombuild and directadmin.conf are presents ...$(e)" --caller="${SCRIPT_NAME}"
      check_path "${da_bin}" "${da_cb_bin}" "${da_conf}"
      echo ""

      da_install_log="${LOG_PATH}/da-install.log"
      touch "${da_install_log}"
      msg "$(s cyan)Installing redis in system level ...$(e)" --caller="${SCRIPT_NAME}"
      ${da_cb_bin} set redis yes
      {
        ${da_cb_bin} redis
      } >>da_install_log
      echo ""
      msg "$(s cyan)Installing redis as php-extension ...$(e)" --caller="${SCRIPT_NAME}"
      ${da_cb_bin} set php_redis yes
      {
        ${da_cb_bin} php_redis
      } >>da_install_log
      echo ""
      # Create system service for redis, run the redis-server in background..
    else
      msg "$(s yellow)[Skipped], C_DA_INSTALL_REDIS is not set to true in config file. Redis will not be installed on this system$(e)" --caller="${SCRIPT_NAME}"
    fi
    #build php_redis and build redis
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This will install OS memcached and php memcached extension (mostly needed by other platform such as prestashop 1.7)
configure_da_memcached() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local search_count
    msg "Installing memcached components in OS level ..."
    # Remember libmemcached-dev is needed for Debian. In CentOS it's called libmemcached-devel
    apt-get -y install memcached libmemcached-tools libmemcached-dev
    check_path "/etc/memcached.conf"
    echo ""
    search_count=$(grep -ic "\-l ::1" /etc/memcached.conf)
    if [ "${search_count}" = 0 ]; then
      msg "Setting memcached to listen to IPv6 ..."
      sleep 1
      sed -i "s/^\-l.*/\-l 127.0.0.1 \-l ::1/" /etc/memcached.conf
    else
      msg "[Skipped] memcached config is already set to listen to IPv6"
      sleep 1
    fi
    msg "Restarting memcached ... "
    systemctl restart memcached
    get_status_message "$?"
    echo ""
    msg "Checking memcached status ... "
    systemctl --no-pager status memcached
    get_status_message "$?"
    echo ""
    # msg "Installing memcached for php-extension using Poralix script ..."
    msg "Removing previous php-extension.sh ..."
    rm -f "php-extension.sh"
    # cp "${DATA_PATH}/maxinet/storage/os/${DISTRO_ID}/usr/local/directadmin/install_scripts/php_extension.sh" "${INST_TEMP_DIR}/php_extension.sh"
    msg "Downloading php-extension.sh into ${INST_TEMP_DIR}/php-extension.sh ..."
    wget -O ${INST_TEMP_DIR}/php-extension.sh https://raw.githubusercontent.com/sofibox/directadmin-utils/master/php/php-extension.sh
    set_linux_crlf "${INST_TEMP_DIR}/php-extension.sh"
    echo ""
    msg "Making php-extension.sh executable ..."
    chmod +x "${INST_TEMP_DIR}/php-extension.sh"
    # This one just checking not verifying, so whether exist or not we just execute install
    # msg "Checking existing php-memcached installation ..."
    # /bin/sh ./php-extension.sh status memcached
    echo ""
    msg "Installing php-memcached for all PHP versions ..."
    "${INST_TEMP_DIR}/php-extension.sh" install memcached
    get_status_message "$?"
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi

}

configure_da_geoip() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    msg "Installing geoip components in OS level ..."
    # Just like the memcached need libmemcache-dev, this geoip needs libgeoip-dev
    apt-get -y install libgeoip-dev geoip-bin geoip-database

    msg "Installing geoip for php-extension using Poralix script ..."
    sleep 1
    navigate_to "${INST_TEMP_DIR}"
    cp "${DATA_PATH}/maxinet/storage/os/${DISTRO_ID}/usr/local/directadmin/install_scripts/php_extension.sh" "${INST_TEMP_DIR}/php_extension.sh"
    chmod +x php_extension.sh
    # This one just checking not verifying, so whether exist or not we just execute install
    msg "Checking existing php-geoip installation ..."
    sleep 1
    /bin/sh ./php_extension.sh status geoip
    msg "Installing php-geoip for all PHP versions ..."
    sleep 2
    # For geoip from poralix script, it needs to select --beta because stable release has error during installation
    /bin/sh ./php_extension.sh install geoip --beta

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Note this function creates custom template dns for directadmin,
# currently nothing to adjust because the latest version of directadmin already included this by default.
configure_da_dns_templates() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local da_template_custom da_conf da_bin da_cb_bin da_current_version dns_compatible_version

    da_template_custom="/usr/local/directadmin/data/templates/custom"
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    dns_compatible_version="36f862603bd077978a451db5497132bb8f9efe9e"

    msg "$(s cyan)Checking if directadmin binary, custombuild and directadmin.conf are presents ...$(e)" --caller="${SCRIPT_NAME}"
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}"
    echo ""

    msg "$(s cyan)Creating directadmin DNS custom template folder ...$(e)" --caller="${SCRIPT_NAME}"
    mkdir -p "${da_template_custom}"
    chown diradmin:diradmin ${da_template_custom}
    echo ""

    msg "$(s cyan)Creating SPF, DKIM and DMARC DNS custom template for directadmin server ...$(e)" --caller="${SCRIPT_NAME}"
    da_current_version=$(${da_bin} v | awk '{ print $3 }')
    if [ "${da_current_version}" == "${dns_compatible_version}" ]; then
      :
    else
      msg "$(s yellow)Warning, current DNS config has been tested with directadmin ${dns_compatible_version} but directadmin version is ${da_current_version}$(e)" --caller="${SCRIPT_NAME}"
      # Whether to continue or not without changing the variable dns_compatible_version
      # _confirm
      # Probably is working fine no need to have confirmation
      _pause 10
    fi

    touch "${da_template_custom}/dns_txt.conf"
    {
      # Note 1: since directadmin version 1.61.6 (unreleased) SPF is enabled by default (it has its own template): https://www.directadmin.com/features.php?id=2946
      # Note 2: The new SPF template is already defined in /usr/local/directadmin/data/templates/dns_txt.conf with the following contents:
      # If ipv4
      # echo "|DOMAIN|.=\"v=spf1 a mx ip4:|SERVER_IP||EXTRA_SPF| ~all\""
      # If ipv6
      echo "|DOMAIN|.=\"v=spf1 a mx ip4:|SERVER_IP||EXTRA_SPF||SPF_IPV6| ~all\""
      echo "_dmarc=\"v=DMARC1; p=none; sp=none; rua=mailto:spam-reports@|DOMAIN|\""
      # Note 1: Directadmin currently have issue using this record '_domainkey' with API (only work with GUI). So the following echo lines does nothing on API
      # So, in API must manually add dns record for _domainkey
      # https://forum.directadmin.com/threads/possible-bug-when-using-dns_txt-conf-with-api-include-step-to-reproduce.63247/
      echo "_domainkey=\"o=~; r=webmaster@|DOMAIN|\""

      # TODO Google site verification should be here as a DNS text record

    } >"${da_template_custom}/dns_txt.conf"

    # Create MX record for root domain
    touch "${da_template_custom}/dns_mx.conf"

    {
      echo "mail=10"
      echo "|DOMAIN|.=\"MX 10 |DOMAIN|.\""
    } >"${da_template_custom}/dns_mx.conf"

    echo ""
    # rewrite_confs here so that dns_txt.conf is updated
    # Fixed DNS new record updated:
    msg "$(s cyan)Updating DNS template by executing custombuild rewrite_confs ...$(e)" --caller="${SCRIPT_NAME}"
    ${da_cb_bin} rewrite_confs
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This function is used to configure place.server.com DKIM, DMARC, SPF and other related records
configure_da_fqhn_server() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_conf da_bin da_cb_bin da_scripts_path

    da_scripts_path="/usr/local/directadmin/scripts"
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"

    msg "$(s cyan)Checking if required files are presents ...$(e)" --caller="${SCRIPT_NAME}"
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}" "${da_scripts_path}/dkim_create.sh"
    echo ""

    # Make sure a hostname is created (the new directadmin installer did not create this file and we have to manually create this)
    # https://forum.directadmin.com/threads/how-to-enable-dkim-spf-for-server-domain.66593/#post-349863
    msg "$(s cyan)Creating hostname DNS record ...$(e)" --caller="${SCRIPT_NAME}"
    da_api_admin add-hostname --hostname "${C_BOX_HOSTNAME_FQHN}" --ip-address "${C_IPV4_ADD0}" --nameserver1 "${C_BOX_NS1}" --nameserver2 "${C_BOX_NS2}"
    echo ""

    # This method is required for dkim_create.sh to work (latest directadmin installer has bug, it did not create this folder)
    msg "$(s cyan) Creating a hostname empty directory at /etc/virtual/${C_BOX_HOSTNAME_FQHN}...$(e)" --caller="${SCRIPT_NAME}"
    mkdir -p /etc/virtual/"${C_BOX_HOSTNAME_FQHN}"
    chown mail:mail /etc/virtual/"${C_BOX_HOSTNAME_FQHN}"
    chmod 711 /etc/virtual/"${C_BOX_HOSTNAME_FQHN}"
    echo ""

    # DKIM for hostname can only be created using script (old way) as mentioned here:
    # https://forum.directadmin.com/threads/configure-dkim-for-host-domain-com-email-addresses.59809/post-309496
    # Remember this script does not touch the DNS zone directly, it uses taskq DNS so we have to wait at least 1 minute before it inserts into DNS record
    msg "$(s cyan) Creating DKIM for hostname ${C_BOX_HOSTNAME_FQHN} ...$(e)" --caller="${SCRIPT_NAME}"
    ${da_scripts_path}/dkim_create.sh "${C_BOX_HOSTNAME_FQHN}" force
    echo ""

    # This is a very important API call to restore the DNS record to default states based on customized option. If IPv6 is configured, the old DNS record will not have IPv6 DNS records
    # If we execute this, it will add IPv6 records automatically. In addition, a new custom template also will be used to write DNS record here like the _dmarc from /usr/local/directadmin/data/templates/custom
    # This API call also speeds up the dkim_create.sh taskq call. So, we can see immediate records being inserted into DNS record without having to wait for at least 1 minute
    msg "$(s cyan)Restoring/resetting domain DNS records to default state ...$(e)" --caller="${SCRIPT_NAME}"
    da_api_admin restore-dns-record --domain "${C_BOX_HOSTNAME_FQHN}"
    echo ""

    msg "$(s cyan)Creating DKIM signing policy TXT record for ${C_BOX_HOSTNAME_FQHN} ...$(e)" --caller="${SCRIPT_NAME}"
    # This value "o%3D%7E%3B+r%3Dwebmaster%40${da_reseller_domain_first}" (encoded) is equal to "_domainkey="o=~; r=webmaster@${da_reseller_domain_first}"
    # No need to encode the value, it's working it seems like directadmin know how to handle this data in API, in debug mode it added extra quote for the value
    da_api_admin create-admin-dns-record --domain "${C_BOX_HOSTNAME_FQHN}" --record-type TXT --record-name "_domainkey" --record-value "o=~; r=webmaster@${C_BOX_HOSTNAME_FQHN}" --record-ttl 30 --affect-pointers yes
    echo ""

    copy_local_dns_to_external_dns "${C_BOX_HOSTNAME_FQHN}"
    # Very important, by default the test.domain.com was created by directadmin as the server hostname,
    # This record must also exists and propagated properly in either local or external DNS. That means, we should create this record first before any other records
    # It is not possible to create this record later because for example if using directadmin, it needs to detect server hostname propagated (license matter) before it can successfully install.
    # So when we call copy_local_dns_to_external_dns, it create this hostname and it is only useful for creating DNS record start from scratch (or rebuild dns record for test.domain.com).
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Here, we update the first owner account information (the original admin)
configure_da_owner_accounts() {
  # TODO Note we can use export DA_ADMIN_USER and DA_ADMIN_PASSWORD for creating new admin
  # TODO testing owner restore progress bar
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_scripts_path da_bin da_cb_bin da_conf retval current_da_owner_username da_owner_role da_owner_creator da_owner_username da_owner_password

    da_scripts_path="/usr/local/directadmin/scripts"
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"

    msg "$(s cyan)Checking if required files are presents ...$(e)" --caller="${SCRIPT_NAME}"
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}" "${da_scripts_path}/change_username.sh" "${da_scripts_path}/decrypt_file.sh"
    echo ""

    # This will make sure that the admin root creator has the correct username (refer to config username). If different rename it
    current_da_owner_username=$(get_current_da_owner_username)
    da_owner_role="${C_DA_OWNER_ROLE1}"
    da_owner_creator="${C_DA_OWNER_CREATOR1}"
    da_owner_username="${C_DA_OWNER_USERNAME1}"
    da_owner_password="${C_DA_OWNER_USERPASS1}"
    echo "current_da_owner_username: ${current_da_owner_username}"
    echo "da_owner_role: ${da_owner_role}"
    echo "da_owner_creator: ${da_owner_creator}"
    echo "da_owner_username: ${da_owner_username}"
    echo "da_owner_password: ${da_owner_password}"
    echo ""

    if [ "${current_da_owner_username}" != "${da_owner_username}" ]; then
      msg "$(s yellow)Warning, current directadmin owner username is not equal to owner username in config file. Renaming owner to ${C_DA_OWNER_USERNAME1} ...$(e)" --caller="${SCRIPT_NAME}"
      ${da_scripts_path}/change_username.sh "$(get_current_da_owner_username)" "${C_DA_OWNER_USERNAME1}"
      get_status_message "$?"
    else
      msg "$(s green)OK, the current directadmin owner username $(get_current_da_owner_username) is equal to the owner username in config file$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""

    # By default, directadmin installation uses a short password which is not secured. Change it here
    msg "$(s cyan)Changing the first directadmin owner ($(get_current_da_owner_username))'s password via stdin ...$(e)" --caller="${SCRIPT_NAME}"

    # Warning this method of changing password alone has bug if do backup: https://forum.directadmin.com/threads/reproducible-bug-admin-backup-restoration-will-not-use-previous-password-changed-via-terminal.64868/
    # Still use this method but do extra change password below to fix the password backup or restore bug
    echo "$(get_current_da_owner_username)":"${C_DA_OWNER_USERPASS1}" | chpasswd
    get_status_message "$?"
    echo ""

    # Must do this extra change password
    msg "$(s cyan)Changing the first directadmin owner ($(get_current_da_owner_username))'s password via API ...$(e)" --caller="${SCRIPT_NAME}"
    da_api_admin change-user-password --username $(get_current_da_owner_username) --password ${da_owner_password}
    echo ""
    # There is only 1 owner, so use this:
    if [[ "${C_DA_OWNER_RESTORE_USER_BACKUP1}" == "true" && "${C_DA_ENABLE_USER_BACKUP_RESTORE}" == "true" ]]; then

      # 2) Then check if the backup file exist for this owner (refer to config username) - must be pushed from scp to root folder admin_backups/*
      # The role is admin (left name) and the creator is root (middle name)
      # If exist let say the backup file name is admin.root.xxxx.tar.gz,
      local backup_source_location backup_source_location_encrypted da_owner_backup_location
      if [[ -f "${SCRIPT_PATH}/admin_backups/${da_owner_role}.${da_owner_creator}.${da_owner_username}.tar" ]]; then
        backup_source_location="${SCRIPT_PATH}/admin_backups/${da_owner_role}.${da_owner_creator}.${da_owner_username}.tar"
      elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_owner_role}.${da_owner_creator}.${da_owner_username}.tar.enc" ]]; then
        # This is the case if backup is encrypted
        backup_source_location="${SCRIPT_PATH}/admin_backups/${da_owner_role}.${da_owner_creator}.${da_owner_username}.tar"
        backup_source_location_encrypted="${SCRIPT_PATH}/admin_backups/${da_owner_role}.${da_owner_creator}.${da_owner_username}.tar.enc"
        msg "$(s cyan)Decrypting backup file ${backup_source_location_encrypted} ...$(e)" --caller="${SCRIPT_NAME}"
        echo "${C_DA_USER_BACKUP_PASSWORD}" >"${SECURE_PATH}/backup_file"
        ${da_scripts_path}/decrypt_file.sh "${backup_source_location_encrypted}" "${backup_source_location}" "${SECURE_PATH}/backup_file"
        get_status_message "$?"
        echo ""
        msg "$(s cyan)Removing backup password file ${SECURE_PATH}/backup_file ...$(e)" --caller="${SCRIPT_NAME}"
        rm -f "${SECURE_PATH}/backup_file"
        get_status_message "$?"
        echo ""
      elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_owner_role}.${da_owner_creator}.${da_owner_username}.tar.gz" ]]; then
        # This is the case if backup is not encrypted (and file type is .tar.gz)
        backup_source_location="${SCRIPT_PATH}/admin_backups/${da_owner_role}.${da_owner_creator}.${da_owner_username}.tar.gz"
      elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_owner_role}.${da_owner_creator}.${da_owner_username}.tar.gz.enc" ]]; then
        # This is the case if backup is encrypted
        backup_source_location="${SCRIPT_PATH}/admin_backups/${da_owner_role}.${da_owner_creator}.${da_owner_username}.tar.gz"
        backup_source_location_encrypted="${SCRIPT_PATH}/admin_backups/${da_owner_role}.${da_owner_creator}.${da_owner_username}.tar.gz.enc"
        # Note when I use API with supplying decryption password (even the password is decoded), it will not work (this might be bug in DA):
        # Decryption of /home/....tar.gz.enc has failed: Either dest_file, encrypted_file, or encryption_password variables are missing or empty.
        # Alternatively I will use the decryption script to decrypt the file manually in Directadmin
        msg "$(s cyan)Decrypting backup file ${backup_source_location_encrypted} ...$(e)" --caller="${SCRIPT_NAME}"
        echo "${C_DA_USER_BACKUP_PASSWORD}" >"${SECURE_PATH}/backup_file"
        ${da_scripts_path}/decrypt_file.sh "${backup_source_location_encrypted}" "${backup_source_location}" "${SECURE_PATH}/backup_file"
        get_status_message "$?"
        echo ""
        msg "$(s cyan)Removing backup password file ${SECURE_PATH}/backup_file ...$(e)" --caller="${SCRIPT_NAME}"
        rm -f "${SECURE_PATH}/backup_file"
        get_status_message "$?"
        echo ""
      elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_owner_role}.${da_owner_creator}.${da_owner_username}.tar.zst" ]]; then
        # This is the case if backup is not encrypted (and file type is .tar.zst)
        backup_source_location="${SCRIPT_PATH}/admin_backups/${da_owner_role}.${da_owner_creator}.${da_owner_username}.tar.zst"
      elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_owner_role}.${da_owner_creator}.${da_owner_username}.tar.zst.enc" ]]; then
        # This is the case if backup is encrypted
        backup_source_location="${SCRIPT_PATH}/admin_backups/${da_owner_role}.${da_owner_creator}.${da_owner_username}.tar.zst"
        backup_source_location_encrypted="${SCRIPT_PATH}/admin_backups/${da_owner_role}.${da_owner_creator}.${da_owner_username}.tar.zst.enc"
        msg "$(s cyan)Decrypting backup file ${backup_source_location_encrypted} ...$(e)" --caller="${SCRIPT_NAME}"
        echo "${C_DA_USER_BACKUP_PASSWORD}" >"${SECURE_PATH}/backup_file"
        ${da_scripts_path}/decrypt_file.sh "${backup_source_location_encrypted}" "${backup_source_location}" "${SECURE_PATH}/backup_file"
        get_status_message "$?"
        echo ""
        msg "$(s cyan)Removing backup password file ${SECURE_PATH}/backup_file ...$(e)" --caller="${SCRIPT_NAME}"
        rm -f "${SECURE_PATH}/backup_file"
        get_status_message "$?"
        echo ""
      else
        echo "Backup file does not exist for this user ${da_owner_username}. If you want to ignore this backup, disable this user backup restoration from config file "
        exit 1
      fi

      if [ -f "${backup_source_location}" ]; then
        msg "$(s green)OK, backup source location exist: ${backup_source_location}$(e)" --caller="${SCRIPT_NAME}"
      else
        msg "$(s red)Error, no backup file exist in ${backup_source_location}$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi

      echo ""

      # This is the owner main backup location
      da_owner_backup_location=/home/$(get_current_da_owner_username)/admin_backups/$(basename -- ${backup_source_location})

      msg "$(s cyan)Copying backup file from ${backup_source_location} into ${da_owner_backup_location}...$(e)" --caller="${SCRIPT_NAME}"
      cp -fp "${backup_source_location}" "${da_owner_backup_location}"
      get_status_message "$?"

      if [ -f "${da_owner_backup_location}" ]; then
        msg "$(s green)OK, the user backup file was copied in owner backup location at ${da_owner_backup_location}$(e)" --caller="${SCRIPT_NAME}"
      else
        msg "$(s red)Error, the user backup file does not exist in owner backup location at ${da_owner_backup_location} after performed a copy operation$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi
      echo ""
      msg "$(s cyan)Changing file owner permission for ${da_owner_backup_location} ...$(e)" --caller="${SCRIPT_NAME}"
      chown -v "$(get_current_da_owner_username):$(get_current_da_owner_username)" "${da_owner_backup_location}"
      get_status_message "$?"
      echo ""
      msg "$(s cyan)Changing file permission for ${da_owner_backup_location} ...$(e)" --caller="${SCRIPT_NAME}"
      chmod -v 640 "${da_owner_backup_location}"
      get_status_message "$?"
      echo ""

      # Note, this also required to have the matching password from the backup file with the config file in order to check correct restore status (if not match, it will return error but restore works normally)
      # To fix this issue, login into terminal and change the owner password with command:
      # passwd owner_username
      # or i will do automatic change in API
      da_api_admin restore-user-backup --backup-ip "${C_IPV4_ADD0}" --backup-path "$(dirname ${da_owner_backup_location})" --backup-file-name "$(basename -- ${da_owner_backup_location})" --backup-password ${C_DA_USER_BACKUP_PASSWORD}
      echo ""
      msg "$(s cyan) Getting list of all domains created ...$(e)" --caller="${SCRIPT_NAME}"
      readarray -t da_domains <<<"$(grep -w "${da_owner_username}" "/etc/virtual/domainowners" | cut -d ":" -f 1)"
      echo ""

      if [ -n "${da_domains}" ]; then
        echo "Domains list for ${da_owner_username}:"
        echo "${da_domains[*]}"
        echo ""
        for da_domain in "${da_domains[@]}"; do
          msg "$(s cyan)Writing all DNS record for domain ${da_domain} to external DNS ...$(e)" --caller="${SCRIPT_NAME}"
          copy_local_dns_to_external_dns "${da_domain}"
          echo ""
        done
      else
        msg "$(s yellow)[Skipped]: The user ${da_owner_username} does not have any domain record$(e)" --caller="${SCRIPT_NAME}"
      fi
    else
      msg "$(s cyan)Renaming owner account name to ${C_DA_OWNER_NAME1} ...$(e)" --caller="${SCRIPT_NAME}"
      # No need to sign as owner1 we dont know if owner1 has changed ts username
      da_api_admin modify-user --where-username-is "$(get_current_da_owner_username)" --name "${C_DA_OWNER_NAME1}"
      echo ""

      # Running additional command for owner if no backup is restored
      configure_da_owner_skins --run
    fi

    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This function is used to configure da_admin accounts
# eg: You can create any extra admin accounts here or create multiple reseller packages that only can be done by admin or owner.
# Note 1: The rule in directadmin, only owner or existing admin can create another admin account
# Note 2: It is not compulsory to create domain for admin for security purpose.
# Note 3: There will be security risk, if the web application is compromised, your directadmin admin username will be compromised too. So do not create domain for admin.
# Note 4: For best practice and security in directadmin, we must use admin account to fully manage directadmin users instead of using an owner account.
# Note 5: Optional you can suspend the owner account via directadmin and lock the user account in the system
configure_da_admin_accounts() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_scripts_path da_bin da_cb_bin da_conf retval

    da_scripts_path="/usr/local/directadmin/scripts"
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    msg "$(s cyan)Checking if required files are presents ...$(e)" --caller="${SCRIPT_NAME}"
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}" "${da_scripts_path}/decrypt_file.sh"
    echo ""

    da_admin_role="${C_DA_ADMIN_ROLE1}"
    da_admin_creator="${C_DA_ADMIN_CREATOR1}"
    da_admin_username="${C_DA_ADMIN_USERNAME1}"

    echo "da_admin_role: ${da_admin_role}"
    echo "da_admin_creator: ${da_admin_creator}"
    echo "da_admin_username: ${da_admin_username}"
    echo ""

    if [[ "${C_DA_ADMIN_RESTORE_USER_BACKUP1}" == "true" && "${C_DA_ENABLE_USER_BACKUP_RESTORE}" == "true" ]]; then
      local backup_source_location backup_source_location_encrypted da_owner_backup_location
      if [[ -f "${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar" ]]; then
        backup_source_location="${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar"
      elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar.enc" ]]; then
        # This is the case if backup is encrypted
        backup_source_location="${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar"
        backup_source_location_encrypted="${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar.enc"
        msg "$(s cyan)Decrypting backup file ${backup_source_location_encrypted} ...$(e)" --caller="${SCRIPT_NAME}"
        echo "${C_DA_USER_BACKUP_PASSWORD}" >"${SECURE_PATH}/backup_file"
        ${da_scripts_path}/decrypt_file.sh "${backup_source_location_encrypted}" "${backup_source_location}" "${SECURE_PATH}/backup_file"
        get_status_message "$?"
        echo ""
        msg "$(s cyan)Removing backup password file ${SECURE_PATH}/backup_file ...$(e)" --caller="${SCRIPT_NAME}"
        rm -f "${SECURE_PATH}/backup_file"
        get_status_message "$?"
        echo ""
      elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar.gz" ]]; then
        # This is the case if backup is not encrypted (and file type is .tar.gz)
        backup_source_location="${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar.gz"
      elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar.gz.enc" ]]; then
        # This is the case if backup is encrypted
        backup_source_location="${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar.gz"
        backup_source_location_encrypted="${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar.gz.enc"
        # Note when I use API with supplying decryption password (even the password is decoded), it will not work (this might be bug in DA):
        # Decryption of /home/....tar.gz.enc has failed: Either dest_file, encrypted_file, or encryption_password variables are missing or empty.
        # Alternatively I will use the decryption script to decrypt the file manually in Directadmin
        msg "$(s cyan)Decrypting backup file ${backup_source_location_encrypted} ...$(e)" --caller="${SCRIPT_NAME}"
        echo "${C_DA_USER_BACKUP_PASSWORD}" >"${SECURE_PATH}/backup_file"
        ${da_scripts_path}/decrypt_file.sh "${backup_source_location_encrypted}" "${backup_source_location}" "${SECURE_PATH}/backup_file"
        get_status_message "$?"
        echo ""
        msg "$(s cyan)Removing backup password file ${SECURE_PATH}/backup_file ...$(e)" --caller="${SCRIPT_NAME}"
        rm -f "${SECURE_PATH}/backup_file"
        get_status_message "$?"
        echo ""
      elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar.zst" ]]; then
        # This is the case if backup is not encrypted (and file type is .tar.zst)
        backup_source_location="${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar.zst"
      elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar.zst.enc" ]]; then
        # This is the case if backup is encrypted
        backup_source_location="${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar.zst"
        backup_source_location_encrypted="${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar.zst.enc"
        msg "$(s cyan)Decrypting backup file ${backup_source_location_encrypted} ...$(e)" --caller="${SCRIPT_NAME}"
        echo "${C_DA_USER_BACKUP_PASSWORD}" >"${SECURE_PATH}/backup_file"
        ${da_scripts_path}/decrypt_file.sh "${backup_source_location_encrypted}" "${backup_source_location}" "${SECURE_PATH}/backup_file"
        get_status_message "$?"
        echo ""
        msg "$(s cyan)Removing backup password file ${SECURE_PATH}/backup_file ...$(e)" --caller="${SCRIPT_NAME}"
        rm -f "${SECURE_PATH}/backup_file"
        get_status_message "$?"
        echo ""
      else
        echo "Backup file does not exist for this user ${da_admin_username}. If you want to ignore this backup, disable this user backup restoration from config file "
        exit 1
      fi

      if [ -f "${backup_source_location}" ]; then
        msg "$(s green)OK, backup source location exist: ${backup_source_location}$(e)" --caller="${SCRIPT_NAME}"
      else
        msg "$(s red)Error, no backup file exist in ${backup_source_location}$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi

      echo ""

      da_owner_backup_location=/home/$(get_current_da_owner_username)/admin_backups/$(basename -- ${backup_source_location})

      msg "$(s cyan)Copying backup from ${backup_source_location} to ${da_owner_backup_location}... $(e)" --caller="${SCRIPT_NAME}"
      cp -fp "${backup_source_location}" "${da_owner_backup_location}"
      get_status_message "$?"

      if [ -f "${da_owner_backup_location}" ]; then
        msg "$(s green)OK, the user backup file was copied in owner backup location at ${da_owner_backup_location}$(e)" --caller="${SCRIPT_NAME}"
      else
        msg "$(s red)Error, the user backup file does not exist in owner backup location at ${da_owner_backup_location} after performed a copy operation$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi
      echo ""
      msg "$(s cyan)Changing file owner permission for ${da_owner_backup_location} ...$(e)" --caller="${SCRIPT_NAME}"
      chown -v "$(get_current_da_owner_username):$(get_current_da_owner_username)" "${da_owner_backup_location}"
      get_status_message "$?"
      echo ""
      msg "$(s cyan)Changing file permission for ${da_owner_backup_location} ...$(e)" --caller="${SCRIPT_NAME}"
      chmod -v 640 "${da_owner_backup_location}"
      get_status_message "$?"
      echo ""

      da_api_admin restore-user-backup --backup-ip "${C_IPV4_ADD0}" --backup-path "$(dirname ${da_owner_backup_location})" --backup-file-name "$(basename -- ${da_owner_backup_location})" --backup-password ${C_DA_USER_BACKUP_PASSWORD}
      echo ""
      msg "$(s cyan) Getting list of all domains created ...$(e)" --caller="${SCRIPT_NAME}"
      readarray -t da_domains <<<"$(grep -w "${da_admin_username}" "/etc/virtual/domainowners" | cut -d ":" -f 1)"
      echo ""

      if [ -n "${da_domains}" ]; then
        echo "Domains list for ${da_owner_username}:"
        echo "${da_domains[*]}"
        echo ""
        for da_domain in "${da_domains[@]}"; do
          msg "$(s cyan)Writing all DNS record for domain ${da_domain} to external DNS ...$(e)" --caller="${SCRIPT_NAME}"
          copy_local_dns_to_external_dns "${da_domain}"
          echo ""
        done
      else
        msg "$(s yellow)[Skipped]: The user ${da_owner_username} does not have any domain record$(e)" --caller="${SCRIPT_NAME}"
      fi
    else
      msg "$(s cyan) Creating the first new directadmin admin account ${C_ADMIN_USERNAME1} ...$(e)" --caller="${SCRIPT_NAME}"
      # Must sign in as owner to create a new admin account. To use owner, account put --sign-as owner1 or --sign-as [owner_username] or leave --sign-as option
      # because by default, this script will use the first owner username and password for API if it is not supplied.
      da_api_admin create-admin-account --username "${C_DA_ADMIN_USERNAME1}" --email "${C_DA_ADMIN_SYSTEM_EMAIL1}" --password "${C_DA_ADMIN_USERPASS1}"
      echo ""
      msg "$(s cyan)Renaming admin account default name to ${C_DA_ADMIN_NAME1} ...$(e)" --caller="${SCRIPT_NAME}"
      da_api_admin modify-user --sign-as admin1 --where-username-is "${C_DA_ADMIN_USERNAME1}" --name "${C_DA_ADMIN_NAME1}"
      echo ""
      msg "$(s cyan)Creating a new  unlimited package with recommend values for resellers with the following name: ${C_DA_RESELLER_PACKAGE_NAME1} ...$(e)" --caller="${SCRIPT_NAME}"
      da_api_admin create-reseller-package --sign-as admin1 --package-name "${C_DA_RESELLER_PACKAGE_NAME1}" --recommend-values

      # Running additional command for admin if no backup is restored
      configure_da_admin_skins --run
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This function is used to create reseller accounts including its domain
# Note 1: For security purpose, all reseller users creation depend on an admin or owner account. So, we must create at least an admin account or use owner account to manage this
# Note 2: In directadmin rule, a reseller package must be created first from admin or owner. Only after a reseller package is created, then we can create a reseller account
# Note 3: For best security practice, when creating a package for reseller, do not enable anonymous FTP accounts and SSH access
# Some info & and references: Check if reseller package is created
# https://forum.directadmin.com/threads/server-migration-how-to-use-the-existing-configuration-during-setup.62937/
# https://forum.directadmin.com/threads/default-user-package-s-for-resellers.49156/
# Note 4: Very important note, when create a reseller, it will create a domain, and this means it create DNS records. So, if directadmin ipv6 is enable. This will cause timeouut
configure_da_reseller_accounts() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_reseller_packages_list count_reseller1 \
      da_reseller_creator da_reseller_role da_reseller_restore_user_backup da_reseller_uname da_reseller_password da_reseller_name da_reseller_system_email \
      da_reseller_mail_users da_reseller_mail_passwords da_reseller_domains da_reseller_wildcard_domains da_reseller_subdomains da_reseller_ip_type da_reseller_package_name \
      da_reseller_enable_domain_ssl \
      da_scripts_path da_bin da_cb_bin da_conf retval grep_count

    da_scripts_path="/usr/local/directadmin/scripts"
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    msg "$(s cyan)Checking if required files are presents ...$(e)" --caller="${SCRIPT_NAME}"
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}" "${da_scripts_path}/decrypt_file.sh"
    echo ""
    # This file contains list of packages for admin and reseller (use this file for checking existing package)
    da_reseller_packages_list="/usr/local/directadmin/data/admin/packages.list"

    # Skip this
    # We can restart directadmin to clear pending Directadmin cron
    #msg "$(s cyan)Requesting directadmin to restart before configuring directadmin accounts ...$(e)" --caller="${SCRIPT_NAME}"
    #restart_da
    #echo ""

    count_reseller1=1
    # !C_DA_RESELLER_USERNAME@ = Assign all reseller account based on the variable of C_DA_RESELLER_USERNAME[N] :
    while [[ ${count_reseller1} -le $(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w) ]]; do
      msg "$(s cyan)Getting all required variables from config file ...$(e)" --caller="${SCRIPT_NAME}"
      typeset -n da_reseller_creator="C_DA_RESELLER_CREATOR${count_reseller1}"
      typeset -n da_reseller_role="C_DA_RESELLER_ROLE${count_reseller1}"
      typeset -n da_reseller_restore_user_backup="C_DA_RESELLER_RESTORE_USER_BACKUP${count_reseller1}"
      typeset -n da_reseller_uname="C_DA_RESELLER_USERNAME${count_reseller1}"
      typeset -n da_reseller_password="C_DA_RESELLER_USERPASS${count_reseller1}"
      typeset -n da_reseller_name="C_DA_RESELLER_NAME${count_reseller1}"
      typeset -n da_reseller_system_email="C_DA_RESELLER_SYSTEM_EMAIL${count_reseller1}"
      typeset -n da_reseller_mail_users="C_DA_RESELLER_MAIL_USER${count_reseller1}"
      typeset -n da_reseller_mail_passwords="C_DA_RESELLER_MAIL_PASSWORD${count_reseller1}"
      typeset -n da_reseller_domains="C_DA_RESELLER_DOMAIN${count_reseller1}"
      typeset -n da_reseller_wildcard_domains="C_DA_RESELLER_WILDCARD_DOMAIN${count_reseller1}"
      typeset -n da_reseller_ip_type="C_DA_RESELLER_IP_TYPE${count_reseller1}"
      typeset -n da_reseller_package_name="C_DA_RESELLER_PACKAGE_NAME${count_reseller1}"
      typeset -n da_reseller_enable_domain_ssl="C_DA_RESELLER_ENABLE_DOMAIN_SSL${count_reseller1}"

      msg "$(s cyan)Checking if reseller package name ${da_reseller_package_name} was created by previous creator before ...$(e)" --caller="${SCRIPT_NAME}"
      grep_count=$(grep -ic "${da_reseller_package_name}" "${da_reseller_packages_list}")
      if [ "${grep_count}" -gt 0 ]; then
        msg "$(s green)OK, reseller package name ${da_reseller_package_name} found$(e)" --caller="${SCRIPT_NAME}"
        echo ""
      else
        msg "$(s yellow)Warning, ${da_reseller_package_name} does not exist in ${da_reseller_packages_list}. Please inspect why!$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi
      # Get the total domain count for this reseller
      da_reseller_domain_count="${#da_reseller_domains[@]}"
      # The first domain in array is used to create account (default domain for that reseller)
      da_reseller_domain_first_raw=$(echo "${da_reseller_domains[@]}" | awk '{ print $1 }')
      da_reseller_domain_first=$(echo "${da_reseller_domains[@]}" | awk '{ print $1 }' | awk -F':' '{print $1}')

      msg "$(s newline)"
      msg "$(s yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"
      msg "Reseller config variables:" --caller="${SCRIPT_NAME}"
      msg "Reseller count ${count_reseller1}/$(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w)" --caller="${SCRIPT_NAME}"
      msg "da_reseller_creator: ${da_reseller_creator}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_role: ${da_reseller_role}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_restore_user_backup: ${da_reseller_restore_user_backup}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_uname: ${da_reseller_uname}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_password: ${da_reseller_password}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_name: ${da_reseller_name}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_system_email: ${da_reseller_system_email}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_mail_users: ${da_reseller_mail_users[*]}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_mail_passwords: ${da_reseller_mail_passwords}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_domains_with_subdomains: ${da_reseller_domains[*]}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_domain_count: ${da_reseller_domain_count}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_domain_first_raw ${da_reseller_domain_first_raw}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_domain_first: ${da_reseller_domain_first}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_wildcard_domains: ${da_reseller_wildcard_domains[*]}" --caller="${SCRIPT_NAME}"
      # Deprecated variable
      # msg "da_reseller_subdomains: ${da_reseller_subdomains[*]}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_ip_type: ${da_reseller_ip_type}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_package_name: ${da_reseller_package_name}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_enable_domain_ssl: ${da_reseller_enable_domain_ssl}" --caller="${SCRIPT_NAME}"
      msg "$(s newline)"

      msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s newline)"

      if [[ "${da_reseller_restore_user_backup}" == "true" && "${C_DA_ENABLE_USER_BACKUP_RESTORE}" == "true" ]]; then
        local backup_source_location backup_source_location_encrypted da_owner_backup_location
        if [[ -f "${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar" ]]; then
          backup_source_location="${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar"
        elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar.enc" ]]; then
          # This is the case if backup is encrypted
          backup_source_location="${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar"
          backup_source_location_encrypted="${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar.enc"
          msg "$(s cyan)Decrypting backup file ${backup_source_location_encrypted} ...$(e)" --caller="${SCRIPT_NAME}"
          echo "${C_DA_USER_BACKUP_PASSWORD}" >"${SECURE_PATH}/backup_file"
          ${da_scripts_path}/decrypt_file.sh "${backup_source_location_encrypted}" "${backup_source_location}" "${SECURE_PATH}/backup_file"
          get_status_message "$?"
          echo ""
          msg "$(s cyan)Removing backup password file ${SECURE_PATH}/backup_file ...$(e)" --caller="${SCRIPT_NAME}"
          rm -f "${SECURE_PATH}/backup_file"
          get_status_message "$?"
          echo ""
        elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar.gz" ]]; then
          # This is the case if backup is not encrypted (and file type is .tar.gz)
          backup_source_location="${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar.gz"
        elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar.gz.enc" ]]; then
          # This is the case if backup is encrypted
          backup_source_location="${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar.gz"
          backup_source_location_encrypted="${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar.gz.enc"
          # Note when I use API with supplying decryption password (even the password is decoded), it will not work (this might be bug in DA):
          # Decryption of /home/....tar.gz.enc has failed: Either dest_file, encrypted_file, or encryption_password variables are missing or empty.
          # Alternatively I will use the decryption script to decrypt the file manually in Directadmin
          msg "$(s cyan)Decrypting backup file ${backup_source_location_encrypted} ...$(e)" --caller="${SCRIPT_NAME}"
          echo "${C_DA_USER_BACKUP_PASSWORD}" >"${SECURE_PATH}/backup_file"
          ${da_scripts_path}/decrypt_file.sh "${backup_source_location_encrypted}" "${backup_source_location}" "${SECURE_PATH}/backup_file"
          get_status_message "$?"
          echo ""
          msg "$(s cyan)Removing backup password file ${SECURE_PATH}/backup_file ...$(e)" --caller="${SCRIPT_NAME}"
          rm -f "${SECURE_PATH}/backup_file"
          get_status_message "$?"
          echo ""
        elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar.zst" ]]; then
          # This is the case if backup is not encrypted (and file type is .tar.zst)
          backup_source_location="${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar.zst"
        elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar.zst.enc" ]]; then
          # This is the case if backup is encrypted
          backup_source_location="${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar.zst"
          backup_source_location_encrypted="${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar.zst.enc"
          msg "$(s cyan)Decrypting backup file ${backup_source_location_encrypted} ...$(e)" --caller="${SCRIPT_NAME}"
          echo "${C_DA_USER_BACKUP_PASSWORD}" >"${SECURE_PATH}/backup_file"
          ${da_scripts_path}/decrypt_file.sh "${backup_source_location_encrypted}" "${backup_source_location}" "${SECURE_PATH}/backup_file"
          get_status_message "$?"
          echo ""
          msg "$(s cyan)Removing backup password file ${SECURE_PATH}/backup_file ...$(e)" --caller="${SCRIPT_NAME}"
          rm -f "${SECURE_PATH}/backup_file"
          get_status_message "$?"
          echo ""
        else
          echo "Backup file does not exist for this user ${da_reseller_uname}. If you want to ignore this backup, disable this user backup restoration from config file "
          _confirm
        fi

        if [ -f "${backup_source_location}" ]; then
          msg "$(s green)OK, backup source location exist: ${backup_source_location}$(e)" --caller="${SCRIPT_NAME}"
        else
          msg "$(s red)Error, no backup file exist in ${backup_source_location}$(e)" --caller="${SCRIPT_NAME}"
          exit 1
        fi
        echo ""

        da_owner_backup_location=/home/$(get_current_da_owner_username)/admin_backups/$(basename -- ${backup_source_location})

        msg "$(s cyan)Copying backup from ${backup_source_location} to ${da_owner_backup_location}... $(e)" --caller="${SCRIPT_NAME}"
        cp -fp "${backup_source_location}" "${da_owner_backup_location}"
        get_status_message "$?"

        if [ -f "${da_owner_backup_location}" ]; then
          msg "$(s green)OK, the user backup file was copied in owner backup location at ${da_owner_backup_location}$(e)" --caller="${SCRIPT_NAME}"
        else
          msg "$(s red)Error, the user backup file does not exist in owner backup location at ${da_owner_backup_location} after performed a copy operation$(e)" --caller="${SCRIPT_NAME}"
          exit 1
        fi
        echo ""
        msg "$(s cyan)Changing file owner permission for ${da_owner_backup_location} ...$(e)" --caller="${SCRIPT_NAME}"
        chown "$(get_current_da_owner_username):$(get_current_da_owner_username)" "${da_owner_backup_location}"
        get_status_message "$?"
        echo ""
        msg "$(s cyan)Changing file permission for ${da_owner_backup_location} ...$(e)" --caller="${SCRIPT_NAME}"
        chmod 640 "${da_owner_backup_location}"
        get_status_message "$?"
        echo ""
        da_api_admin restore-user-backup --backup-ip "${C_IPV4_ADD0}" --backup-path "$(dirname ${da_owner_backup_location})" --backup-file-name "$(basename -- ${da_owner_backup_location})" --backup-password ${C_DA_USER_BACKUP_PASSWORD}
        echo ""
        # We knew it will generate this /etc/virtual/domainowners after we have restored the backup file
        msg "$(s cyan) Getting list of all domains created from backup ...$(e)" --caller="${SCRIPT_NAME}"
        readarray -t da_domains <<<"$(grep -w "${da_reseller_uname}" "/etc/virtual/domainowners" | cut -d ":" -f 1)"
        echo ""
        if [ -n "${da_domains}" ]; then
          echo "Domains list for ${da_reseller_uname}:"
          echo "${da_domains[*]}"
          echo ""
          for da_domain in "${da_domains[@]}"; do
            msg "$(s cyan)Writing all DNS record for domain ${da_domain} to external DNS ...$(e)" --caller="${SCRIPT_NAME}"
            copy_local_dns_to_external_dns "${da_domain}"
            echo ""
          done
        else
          msg "$(s yellow)[Skipped]: The user ${da_owner_username} does not have any domain record$(e)" --caller="${SCRIPT_NAME}"
        fi
      else
        # Note 1: To create a reseller, we need to use an admin account:
        msg "$(s cyan)Creating a new reseller account ${da_reseller_uname} ${count_reseller1} out of $(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w) user(s) ... $(e)" --caller="${SCRIPT_NAME}"
        da_api_admin create-reseller-account --sign-as admin1 --username "${da_reseller_uname}" --email "${da_reseller_system_email}" --password "${da_reseller_password}" --domain "${da_reseller_domain_first}" --package-name "${da_reseller_package_name}" --ip-type "${da_reseller_ip_type}"
        echo ""
        msg "$(s cyan)Renaming reseller account name to ${da_reseller_name} ...$(e)" --caller="${SCRIPT_NAME}"
        da_api_admin modify-user --sign-as admin1 --where-username-is "${da_reseller_uname}" --name "${da_reseller_name}"
        echo ""
        # Now login as reseller and enable its own email DKIM. We can use reseller account to configure its own user-level variable settings like DKIM or DNS records
        msg "$(s cyan)Enabling email/domain DKIM for user ${da_reseller_uname} with default domain of ${da_reseller_domain_first} ...$(e)" --caller="${SCRIPT_NAME}"
        # Note 1: We don't use reseller1 because currently reseller can have 1 or more (this script support multiple creation of reseller)
        # eg: --sign-as ${da_reseller_uname}
        da_api_admin enable-email-dkim --sign-as "${da_reseller_uname}" --domain "${da_reseller_domain_first}"
        echo ""

        # Use reseller above and create TXT record _domainkey for DKIM signing policy (this should have have been done using dns_txt.conf but it has bug)
        # so, we manually add this using API here: https://forum.directadmin.com/threads/possible-bug-when-using-dns_txt-conf-with-api-include-step-to-reproduce.63247/
        msg "$(s cyan)Creating DKIM signing policy TXT record for ${da_reseller_domain_first} ...$(e)" --caller="${SCRIPT_NAME}"
        # This value "o%3D%7E%3B+r%3Dwebmaster%40${da_reseller_domain_first}" (encoded) is equal to "_domainkey="o=~; r=webmaster@${da_reseller_domain_first}"
        # No need to encode the value, it's working it seems like directadmin know how to handle this data in API, in debug mode it added extra quote for the value
        da_api_admin create-dns-record --sign-as "${da_reseller_uname}" --domain "${da_reseller_domain_first}" --record-type TXT --record-name "_domainkey" --record-value "o=~; r=webmaster@${da_reseller_domain_first}" --record-ttl 30 --affect-pointers yes
        echo ""
        msg "$(s cyan)Creating Mail MX record for ${da_reseller_domain_first} without subdomain ...$(e)" --caller="${SCRIPT_NAME}"
        #da_api_admin create-dns-record --sign-as "${da_reseller_uname}" --domain "${da_reseller_domain_first}" --record-type MX --record-domain "${da_reseller_domain_first}." --record-priority "${record_priority}" --record-subdomain "${record_subdomain}" --record-ttl 30 --affect-pointers yes
        da_api_admin create-dns-record --sign-as "${da_reseller_uname}" --domain "${da_reseller_domain_first}" --record-type MX --record-domain "${da_reseller_domain_first}." --record-priority "10" --record-subdomain "${da_reseller_domain_first}." --record-ttl 30 --affect-pointers yes
        echo ""

        # Adding extra subdomain starting here for first domain
        # da_reseller_domain_first_subdomains_raw=$(echo ${da_reseller_domain_first_raw} | awk -F':' '{print $2}')
        local da_reseller_domain_first_sub_domains
        readarray -t da_reseller_domain_first_sub_domains <<<"$(echo ${da_reseller_domain_first_raw} | awk -F':' '{print $2}' | awk -F',' '{for (i=1;i<=NF;i++)print $i}')"
        #da_reseller_domain_first=$(echo "${da_reseller_domains[@]}" | awk '{ print $1 }' | awk -F':' '{print $1}')

        # echo "da_reseller_domain_first_subdomains_raw: ${da_reseller_domain_first_subdomains_raw}"
        echo "da_reseller_domain_first_sub_domains: ${da_reseller_domain_first_sub_domains}"

        if [ -n "${da_reseller_domain_first_sub_domains}" ]; then
          for da_reseller_subdomain_first in "${da_reseller_domain_first_sub_domains[@]}"; do
            # echo "da_reseller_subdomain_first ${da_reseller_subdomain_first}"
            msg "$(s cyan)Creating reseller ${da_reseller_uname} subdomain ${da_reseller_subdomain_first}.${da_reseller_domain_first}$(e)" --caller="${SCRIPT_NAME}"
            da_api_admin create-user-subdomain --sign-as "${da_reseller_uname}" --domain "${da_reseller_domain_first}" --subdomain "${da_reseller_subdomain_first}"
            echo ""
          done
        else
          msg "$(s yellow)Notice: Skipped creating subdomain for domain ${da_reseller_domain_first} because it does not have subdomains defined in config file$(e)" --caller="${SCRIPT_NAME}"
        fi

        copy_local_dns_to_external_dns "${da_reseller_domain_first}"
        echo ""
        # This will be executed if reseller has more than 1 domains. We add the extra domains here and skipped the default domain:
        if [ "${da_reseller_domain_count}" -gt 1 ]; then
          msg "$(s cyan)Notice, this reseller ${da_reseller_uname} has ${da_reseller_domain_count} domains$(e)" --caller="${SCRIPT_NAME}"
          for extra_domain_raw in "${da_reseller_domains[@]}"; do
            local extra_domain extra_subdomains_raw extra_subdomains
            # Here, we don't add the first domain, we did that before when we first create reseller user account where directadmin automatically add this default or first domain
            extra_domain=$(echo "${extra_domain_raw}" | awk -F':' '{ print $1 }')
            extra_subdomains_raw=$(echo "${extra_domain_raw}" | awk -F':' '{ print $2 }')
            readarray -t extra_subdomains <<<"$(echo "${extra_subdomains_raw}" | awk -F',' '{for (i=1;i<=NF;i++)print $i}')"
            echo "extra_domain_raw:${extra_domain_raw}"
            echo "extra_domain: ${extra_domain}"
            echo "extra_subdomains_raw: ${extra_subdomains_raw}"
            echo "extra_subdomains: ${extra_subdomains[*]}"
            echo "================================================"
            if [[ "${extra_domain}" == "${da_reseller_domain_first}" ]]; then
              # Skip the domain that has been added before
              msg "$(s cyan)Skipped adding the default domain: ${da_reseller_domain_first}$(e)" --caller="${SCRIPT_NAME}"
              continue
            fi
            msg "$(s cyan)Creating extra domain ${extra_domain} for reseller ${da_reseller_uname} ...$(e)" --caller="${SCRIPT_NAME}"
            da_api_admin create-domain --sign-as "${da_reseller_uname}" --domain "${extra_domain}" --recommend-values
            echo ""
            msg "$(s cyan)Enabling email/domain DKIM for user ${da_reseller_uname} with extra domain of ${extra_domain} ...$(e)" --caller="${SCRIPT_NAME}"
            da_api_admin enable-email-dkim --sign-as "${da_reseller_uname}" --domain "${extra_domain}"
            echo ""
            msg "$(s cyan)Creating DKIM signing policy TXT record for extra domain ${extra_domain} ...$(e)" --caller="${SCRIPT_NAME}"
            da_api_admin create-dns-record --sign-as "${da_reseller_uname}" --domain "${extra_domain}" --record-type TXT --record-name "_domainkey" --record-value "o=~; r=webmaster@${extra_domain}" --record-ttl 30 --affect-pointers yes
            echo ""
            msg "$(s cyan)Creating Mail MX record for ${extra_domain} without subdomain ...$(e)" --caller="${SCRIPT_NAME}"
            da_api_admin create-dns-record --sign-as "${da_reseller_uname}" --domain "${extra_domain}" --record-type MX --record-domain "${extra_domain}." --record-priority "10" --record-subdomain "${da_reseller_domain_first}." --record-ttl 30 --affect-pointers yes
            echo ""

            # Adding extra subdomains starting here
            if [ -n "${extra_subdomains}" ]; then
              for extra_subdomain in "${extra_subdomains[@]}"; do
                #  echo "extra_subdomain: ${extra_subdomain}"
                msg "$(s cyan)Creating reseller ${da_reseller_uname} subdomain ${extra_subdomain}.${extra_domain}$(e)" --caller="${SCRIPT_NAME}"
                da_api_admin create-user-subdomain --sign-as "${da_reseller_uname}" --domain "${extra_domain}" --subdomain "${extra_subdomain}"
                echo ""
                # End looping for adding extra subdomains
              done
            else
              msg "$(s yellow)Notice: Skipped creating subdomain for domain ${extra_domain} because it does not have subdomains defined in config file$(e)" --caller="${SCRIPT_NAME}"
            fi
            echo ""
            copy_local_dns_to_external_dns "${extra_domain}"
          done # End looping for adding extra domains
        fi

      fi
      ((count_reseller1++))
      echo ""
    done
    echo ""

    if [[ "${da_reseller_restore_user_backup}" == "true" && "${C_DA_ENABLE_USER_BACKUP_RESTORE}" == "true" ]]; then
      :
    else
      # Now we create user unlimited package. A reseller account is needed to create user package (da_api_admin will check this condition)
      # Note here we user package name from C_DA_USER_PACKAGE_NAME1 (user1) because it's the first package for for first user
      # We use reseller account to create user package:
      msg "$(s cyan)Creating user unlimited package with the following name: ${C_DA_USER_PACKAGE_NAME1} ...$(e)" --caller="${SCRIPT_NAME}"
      da_api_admin create-user-package --sign-as "${C_DA_RESELLER_USERNAME1}" --package-name "${C_DA_USER_PACKAGE_NAME1}" --recommend-values
      echo ""
      # Run additional step as we did not restore backup (this would be new setting for this reseller):
      configure_da_reseller_skins --run-force
      configure_da_reseller_wildcard_domains --skip #(Skipped: Do not use wildcard for security purpose)
      configure_da_reseller_email_accounts --run-force
      configure_da_reseller_databases --run-force
    fi
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This is the pre-requirement before getting ssl
# Configure the wildcard certificate option here for external DNS
configure_da_ssl_pre() {

  # Note the following are the same (server certificate)
  #+ cp -f /usr/local/directadmin/conf/cakey.pem /etc/httpd/conf/ssl.key/server.key
  #+ cp -f /usr/local/directadmin/conf/cacert.pem /etc/httpd/conf/ssl.crt/server.crt
  #+ cp -f /usr/local/directadmin/conf/carootcert.pem /etc/httpd/conf/ssl.crt/server.ca

  # Must run this functions (configure_da_hostname_ssl) after running CSF because we need to make sure all appropriate ports are opened to request certs
  # Warning do not overused configure_da_hostname_ssl function because when requesting the same cert for the same domain 7 times for a week, you will get blocked.
  # This will set the hosting to SSL:
  # It's best to call SSL after domain propagation few hours later.

  # Call certificate request at the end because we want to create DNS entry and propagate first
  # Don't worry if some domains are not able to have SSL because of the propagation problem using external DNS
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_bin da_cb_bin da_conf

    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    msg "$(s cyan)Checking if directadmin required files ...$(e)" --caller="${SCRIPT_NAME}"
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}"
    echo ""

    #https://help.directadmin.com/item.php?id=629
    #1) Make sure enable_ssl_sni=1 in directadmin.conf (internal value is already default to 1, so if enable_ssl_sni has no entry this code does nothing)
    # msg "$(s cyan):Enabling enable_ssl_sni=1 in directadmin.conf config...$(e)" --caller="${SCRIPT_NAME}"
    # ${da_bin} set enable_ssl_sni 1
    # get_status_message "$?"
    # echo ""
    #2) Make sure letsencrypt=1 is set in directadmin.conf to install letsencrypt
    msg "$(s cyan)Setting letsencrypt=1 in directadmin.conf config ...$(e)" --caller="${SCRIPT_NAME}"
    ${da_bin} set letsencrypt 1
    get_status_message "$?"
    echo ""
    # (OPTIONAL) This option is to enable wildcard certificate
    msg "$(s cyan)Setting directadmin dns_ttl=1 to enable wildcard certificate at directadmin.conf ...$(e)" --caller="${SCRIPT_NAME}"
    ${da_bin} set dns_ttl "${C_DA_DNS_TTL}"
    get_status_message "$?"
    echo ""

    # Disable ssl=0. This one fixed issue where you cannot request cert using ssl=1.
    # only enable ssl=1 after request certificate success. From my notes few years, I disabled this first before renew else it wont work.
    msg "$(s cyan)Disabling ssl=0 in directadmin.conf config...$(e)" --caller="${SCRIPT_NAME}"
    ${da_bin} set ssl 0
    get_status_message "$?"
    echo ""

    msg "$(s cyan)Enabling ECC_CERTIFICATE for highest SSL encryption key ...$(e)" --caller="${SCRIPT_NAME}"
    ${da_bin} set ecc_certificates 1
    get_status_message "$?"
    echo ""

    msg "$(s cyan)Installing lego certificate management ...$(e)" --caller="${SCRIPT_NAME}"
    ${da_cb_bin} lego
    get_status_message "$?"
    echo ""

    # Install letsencrypt latest version at pre function
    # install the latest letsencrypt here (this will only get the latest letsencrypt.sh)
    msg "$(s cyan)Installing the latest letsencrypt.sh for Directadmin ...$(e)" --caller="${SCRIPT_NAME}"
    ${da_cb_bin} letsencrypt
    get_status_message "$?"
    echo ""

    # Enable zerossl based on config file
    # This method is not deprecated for hostname as mentioned in directadmin documentation: https://forum.directadmin.com/threads/switching-between-zerossl-and-letsencrypt-for-hostname.67206/#post-353578
    if [ "${C_DA_ENABLE_ZEROSSL_CERTIFICATE}" == "true" ]; then
      msg "$(s cyan)Enabling zerossl certificate ...$(e)" --caller="${SCRIPT_NAME}"
      touch /root/.zerossl
    else
      rm -f /root/.zerossl
    fi

    # Restart directadmin
    msg "$(s cyan)Restarting directadmin after changing directadmin.conf ...$(e)" --caller="${SCRIPT_NAME}"
    restart_da
    # No need to reboot
    #msg "Creating reboot flag to restart system before requesting SSL certificate for Directadmin ..."
    #cat /dev/null >/var/run/reboot-required
    #msg "Warning, system will reboot and you can run this script again to continue setup"
    #_pause 10
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}
update_timestamp() {
  TIMESTAMP=$(date +%s)
}
letsencrypt_challenge_check() {
  local domain curl_bin well_known_path timestamp
  well_known_path="/var/www/html/.well-known/acme-challenge"
  domain="$1"
  curl_bin=$(which curl)
  if [ -z "${curl_bin}" ]; then
    msg "$(s red)Error, curl binary is needed!$(e)" --caller="${SCRIPT_NAME}"
    exit 1
  fi

  if [ ! -d ${well_known_path} ]; then
    mkdir -p ${well_known_path}
  fi
  timestamp=$(date +%s)
  touch ${well_known_path}/letsencrypt_${timestamp}
  #Checking if http://www.domain.com/.well-known/acme-challenge/letsencrypt_${timestamp} is available
  if ! ${curl_bin} -k -I -L -X GET http://${domain}/.well-known/acme-challenge/letsencrypt_${timestamp} 2>/dev/null | grep -m1 -q 'HTTP.*200'; then
    echo 1
  else
    echo 0
  fi
  rm -f ${well_known_path}/letsencrypt_${timestamp}
}

# Certificate restoration for user domain is working perfectly
# This will configure all user domain SSL (including owner,admin,reseller, just to be sure that the user domain is created first)
# Note this is working but I consider this as beta feature at this point
# NOTE:
# How to force renew to test error:
# https://docs.directadmin.com/webservices/ssl/troubleshooting-letsencrypt.html#let-s-encrypt-manually-forcing-the-automated-renewal-to-test-for-errors
# After certificate restoration, need to wait for at least 1 minute for all certificate to sync.
configure_da_user_domain_ssl() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local da_bin da_cb_bin dataskq da_conf task_queue da_script_path lego_data_path da_user_path

    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    dataskq="/usr/local/directadmin/dataskq"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    da_conf_path="/usr/local/directadmin/conf"
    da_script_path="/usr/local/directadmin/scripts"
    # This file does not exist by default
    task_queue="/usr/local/directadmin/data/task.queue.cb"
    da_user_path="/usr/local/directadmin/data/users"

    msg "$(s cyan)Checking directadmin required files ...$(e)" --caller="${SCRIPT_NAME}"
    check_path "${da_bin}" "${da_cb_bin}" "${dataskq}" "${da_conf}" "${da_script_path}" "${da_conf_path}" "${da_user_path}"
    echo ""

    # Only do this if AUTO SSL is not enable

    # This script is based on the original DA script http://files.directadmin.com/services/all/letsencrypt/autoletsencrypt.sh
    # and the improvement was specifically made to solve this issue which is not documented:
    # https://forum.directadmin.com/threads/restore-ssl-certificate-for-user-domain-from-usr-local-directadmin-data-lego-folder.64842/

    # Make sure AUTO SSL is not enable to restore certificate because I think this might be conflict because AUTO SSL use different cert method
    if [ "${C_DA_ENABLE_DOMAIN_AUTO_SSL}" == "false" ]; then
      if [ "${C_DA_ENABLE_USER_DOMAIN_SSL_RESTORE}" == "true" ]; then

        local lego_data_path da_reseller_usernames_count reseller_count
        lego_data_path="/usr/local/directadmin/data/.lego"
        mkdir -p "${lego_data_path}/certificates"

        msg "$(s cyan)Configuring reseller SSL for restoration ...$(e)" --caller="${SCRIPT_NAME}"
        da_reseller_usernames_count=$(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w)
        reseller_count=1
        while [[ ${reseller_count} -le ${da_reseller_usernames_count} ]]; do
          echo ""
          echo "===== RESELLER USER: ${reseller_count} ========="
          typeset -n da_reseller_username="C_DA_RESELLER_USERNAME${reseller_count}"
          typeset -n da_reseller_restore_domain_ssl="C_DA_RESELLER_RESTORE_USER_DOMAIN_SSL${reseller_count}"
          echo "da_reseller_username: ${da_reseller_username}"
          echo "da_reseller_restore_domain_ssl: ${da_reseller_restore_domain_ssl}"
          echo ""
          if [ "${da_reseller_restore_domain_ssl}" == "true" ]; then

            all_domains=""
            msg "$(s cyan)Populating domain and subdomain entry(es) ...$(e)" --caller="${SCRIPT_NAME}"
            for root_domain in $(cat ${da_user_path}/${da_reseller_username}/domains.list); do
              # For domain first:======================
              echo "root_domain: ${root_domain}"
              all_domains=" ${all_domains} ${root_domain}"
              # For its subdomain: ====================
              for sub_domain in $(cat ${da_user_path}/${da_reseller_username}/domains/${root_domain}.subdomains); do
                all_domains="${all_domains} ${sub_domain}.${root_domain}"
                echo "all_domains: ${all_domains}"
              done
            done
            echo ""
            all_domains=(${all_domains})
            echo "all_domains: ${all_domains[*]}"

            # This 3 files must be pushed from SSH into ${lego_data_path} then check them if they exist
            for da_domain in "${all_domains[@]}"; do
              lego_cert_path="${lego_data_path}/certificates/${da_domain}.crt"
              lego_key_path="${lego_data_path}/certificates/${da_domain}.key"
              lego_issuer_cert_path=$(echo "${lego_cert_path}" | sed 's/\.crt/.issuer.crt/')
              lego_cert_json_path="${lego_data_path}/certificates/${da_domain}.json"

              msg "$(s cyan)Checking certificate for ${da_domain} files in ${SSL_PATH}/certificates ...$(e)" --caller="${SCRIPT_NAME}"
              check_path "${SSL_PATH}/certificates/${da_domain}.crt" "${SSL_PATH}/certificates/${da_domain}.key" "${SSL_PATH}/certificates/${da_domain}.issuer.crt" "${SSL_PATH}/certificates/${da_domain}.json"
              echo ""
              # Note that we only copy certificate that has domain exist for user
              # Here we copy the certificate folders (but based on the existing domain in da system)
              echo -n "Copying ${SSL_PATH}/certificates/${da_domain}.crt into ${lego_cert_path} ... "
              cp "${SSL_PATH}/certificates/${da_domain}.crt" "${lego_cert_path}"
              get_status_message "$?"
              echo -n "Copying ${SSL_PATH}/certificates/${da_domain}.key into ${lego_key_path} ... "
              cp "${SSL_PATH}/certificates/${da_domain}.key" "${lego_key_path}"
              get_status_message "$?"
              echo -n "Copying ${SSL_PATH}/certificates/${da_domain}.issuer.key into ${lego_issuer_cert_path} ... "
              cp "${SSL_PATH}/certificates/${da_domain}.issuer.crt" "${lego_issuer_cert_path}"
              get_status_message "$?"
              echo -n "Copying ${SSL_PATH}/certificates/${da_domain}.json into ${lego_cert_json_path} ... "
              cp "${SSL_PATH}/certificates/${da_domain}.json" "${lego_cert_json_path}"
              get_status_message "$?"
              msg "$(s cyan)Correcting permission of certificates ...$(e)" --caller="${SCRIPT_NAME}"
              chmod 600 "${lego_cert_path}" "${lego_key_path}" "${lego_issuer_cert_path}" "${lego_cert_json_path}"
              get_status_message "$?"
              echo ""
              msg "$(s cyan)Checking certificate path for ${da_domain} ...$(e)" --caller="${SCRIPT_NAME}"
              check_path "${lego_cert_path}" "${lego_key_path}" "${lego_issuer_cert_path}" "${lego_cert_json_path}"
              echo ""
              # Here we copy the accounts folder into the .lego root directory
              msg "Copying ${SSL_PATH}/accounts into ${lego_data_path} ... "
              cp -fr "${SSL_PATH}/accounts" "${lego_data_path}"
              get_status_message "$?"
              echo ""
              msg "$(s cyan)Checking lego accounts path ...$(e)" --caller="${SCRIPT_NAME}"
              check_path "${lego_data_path}/accounts"
              echo ""

              # Populating variable of reseller certificate
              key="${da_user_path}/${da_reseller_username}/domains/${da_domain}.key"
              cert="${da_user_path}/${da_reseller_username}/domains/${da_domain}.cert"
              cacert="${da_user_path}/${da_reseller_username}/domains/${da_domain}.ca"
              # combine_cert="${da_user_path}/${da_reseller_username}/domains/${da_domain}.combined"

              msg "$(s cyan)Checking lego certificate and key path ...$(e)" --caller="${SCRIPT_NAME}"
              if [ -s "${lego_cert_path}" ] && [ -s "${lego_key_path}" ]; then
                msg "$(s cyan)Checking certificate entry in with BEGIN CERTIFICATE in ${lego_cert_path} ...$(e)" --caller="${SCRIPT_NAME}"
                if [ $(grep -c "BEGIN CERTIFICATE" "${lego_cert_path}") -eq 1 ]; then
                  msg "$(s cyan)Notice entry count is 1. Copying ${lego_cert_path} into ${cert} ...$(e)" --caller="${SCRIPT_NAME}"
                  cp -pf "${lego_cert_path}" ${cert}
                  get_status_message "$?"
                else
                  msg "$(s cyan)Notice entry count is not 1. Generating new SSL key based on ${lego_cert_path} into ${cert} ...$(e)" --caller="${SCRIPT_NAME}"
                  openssl x509 -in "${lego_cert_path}" -out ${cert}
                  get_status_message "$?"
                fi
                echo ""
                msg "$(s cyan)Copying ${lego_key_path} into ${key} ...$(e)" --caller="${SCRIPT_NAME}"
                cp -pf "${lego_key_path}" ${key}
                get_status_message "$?"
                echo ""

                msg "$(s cyan)Checking whether issuer cert is empty in ${lego_issuer_cert_path} ...$(e)" --caller="${SCRIPT_NAME}"
                if [ -s "${lego_issuer_cert_path}" ]; then
                  msg "$(s cyan)Notice, issuer cert is not empty. Copying ${lego_issuer_cert_path} into ${cacert} ...$(e)" --caller="${SCRIPT_NAME}"
                  cp -pfv "${lego_issuer_cert_path}" ${cacert}
                  get_status_message "$?"
                  echo ""
                  msg "$(s cyan)Combining cert entry from ${cert} and ${cacert} into ${cert}.combined $(e)" --caller="${SCRIPT_NAME}"
                  cat ${cert} ${cacert} >${cert}.combined
                  get_status_message "$?"
                  echo ""
                else
                  msg "$(s cyan)Notice, issuer cert is empty. Copying ${lego_cert_path} into ${cert}.combined ...$(e)" --caller="${SCRIPT_NAME}"
                  cp -pfv "${lego_cert_path}" ${cert}.combined
                  get_status_message "$?"
                fi
                echo ""
                msg "$(s cyan)Creating certificate renewal time at ${cert}.creation_time ...$(e)" --caller="${SCRIPT_NAME}"
                # This file is the one that renew certificate, if this is deleted, renewal will be disable
                date +%s >${cert}.creation_time
                get_status_message "$?"
                echo ""
                msg "$(s cyan)Correcting all certificate ownership ...$(e)" --caller="${SCRIPT_NAME}"
                chown diradmin:${C_DA_SECURE_ACCESS_GROUP} ${key} ${cert} ${cert}.combined ${cacert} ${cert}.creation_time
                get_status_message "$?"
                echo ""
                msg "$(s cyan)Correcting all certificate permission ...$(e)" --caller="${SCRIPT_NAME}"
                chmod 640 ${key} ${cert} ${cert}.combined ${cacert} ${cert}.creation_time
                get_status_message "$?"
                echo ""
                msg "$(s green)OK, certificate for ${da_domain} has been created successfully!$(e)" --caller="${SCRIPT_NAME}"
              else
                msg "$(s red)Error, New key/certificate is empty. Exiting...$(e)" --caller="${SCRIPT_NAME}"
                exit 1
              fi

              echo "DirectAdmin certificate for ${da_domain} has been setup."
              echo ""
              msg "$(s cyan)Checking domain ${da_domain} cert at ${da_user_path}/${da_reseller_username}/domains/${da_domain}.cert ...$(e)" --caller="${SCRIPT_NAME}"
              if [ -e ${da_user_path}/${da_reseller_username}/domains/${da_domain}.cert ]; then
                REWRITE=false
                if ! grep -m1 -q '^ssl=ON' ${da_user_path}/${da_reseller_username}/domains/${da_domain}.conf; then
                  msg "$(s cyan)Turning ssl=ON for ${da_user_path}/${da_reseller_username}/domains/${da_domain}.conf ...$(e)" --caller="${SCRIPT_NAME}"
                  perl -pi -e 's|^ssl\=.*|ssl=ON|g' ${da_user_path}/${da_reseller_username}/domains/${da_domain}.conf
                  REWRITE=true
                fi
                if ! grep -m1 -q '^ssl=ON' ${da_user_path}/${da_reseller_username}/domains/${da_domain}.conf; then
                  msg "$(s cyan)Writing ssl=ON for ${da_user_path}/${da_reseller_username}/domains/${da_domain}.conf ...$(e)" --caller="${SCRIPT_NAME}"
                  echo 'ssl=ON' >>${da_user_path}/${da_reseller_username}/domains/${da_domain}.conf
                fi
                if ! grep -m1 -q '^SSLCACertificateFile=' ${da_user_path}/${da_reseller_username}/domains/${da_domain}.conf && ! grep -m1 -q '^SSLCertificateFile=' ${da_user_path}/${da_reseller_username}/domains/${da_domain}.conf && ! grep -m1 -q '^SSLCertificateKeyFile=' ${da_user_path}/${da_reseller_username}/domains/${da_domain}.conf; then
                  msg "$(s cyan)Adding certificate links for ${da_user_path}/${da_reseller_username}/domains/${da_domain}.conf ...$(e)" --caller="${SCRIPT_NAME}"
                  perl -pi -e "s|^UseCanonicalName=|SSLCACertificateFile=${da_user_path}/${da_reseller_username}/domains/${da_domain}.cacert\nSSLCertificateFile=${da_user_path}/${da_reseller_username}/domains/${da_domain}.cert\nSSLCertificateKeyFile=${da_user_path}/${da_reseller_username}/domains/${da_domain}.key\nUseCanonicalName=|g" ${da_user_path}/${da_reseller_username}/domains/${da_domain}.conf
                  REWRITE=true
                fi

                if ${REWRITE}; then
                  msg "$(s cyan)Writing rewrite values in task.queue ...$(e)" --caller="${SCRIPT_NAME}"
                  echo "action=rewrite&value=httpd&user=${da_reseller_username}" >>/usr/local/directadmin/data/task.queue
                  echo "action=rewrite&value=mail_sni&domain=${da_domain}" >>/usr/local/directadmin/data/task.queue
                fi
              fi
            done
          else
            msg "$(s yellow)[Skipped]: Warning SSL restoration is skipped based on config file for the user ${da_reseller_username}$(e)" --caller="${SCRIPT_NAME}"
            _pause 5
          fi

          echo "=========================================="
          _pause 1
          ((reseller_count++))
        done
        echo ""
        msg "$(s cyan)Configuring user SSL for restoration ...$(e)" --caller="${SCRIPT_NAME}"
        # For user SSL manual restoration
        local user_count da_user_usernames_count

        da_user_usernames_count=$(echo "${!C_DA_USER_USERNAME@}" | wc -w)
        user_count=1
        while [[ ${user_count} -le ${da_user_usernames_count} ]]; do

          echo ""
          echo "===== USER USER: ${user_count} ========="
          typeset -n da_user_username="C_DA_USER_USERNAME${user_count}"
          typeset -n da_user_restore_domain_ssl="C_DA_USER_RESTORE_USER_DOMAIN_SSL${user_count}"
          echo "da_user_username: ${da_user_username}"
          echo "da_user_restore_domain_ssl: ${da_user_restore_domain_ssl}"
          echo ""

          if [ "${da_user_restore_domain_ssl}" == "true" ]; then

            # TODO something wrong here with the populating ...
            # Make sure I populate the cert selected box too (refer to the cert request)

            all_domains=""
            msg "$(s cyan)Populating domain and subdomain entry(es) ...$(e)" --caller="${SCRIPT_NAME}"
            for root_domain in $(cat /usr/local/directadmin/data/users/${da_user_username}/domains.list); do
              # For domain first:======================
              echo "root_domain: ${root_domain}"
              all_domains=" ${all_domains} ${root_domain}"
              # For its subdomain: ====================
              for sub_domain in $(cat /usr/local/directadmin/data/users/${da_user_username}/domains/${root_domain}.subdomains); do
                all_domains="${all_domains} ${sub_domain}.${root_domain}"
                echo "all_domains: ${all_domains}"
              done
            done
            echo ""
            all_domains=(${all_domains})
            echo "all_domains: ${all_domains[*]}"

            # This 3 files must be pushed from SSH into ${lego_data_path} then check them if they exist
            for da_domain in "${all_domains[@]}"; do
              lego_cert_path="${lego_data_path}/certificates/${da_domain}.crt"
              lego_key_path="${lego_data_path}/certificates/${da_domain}.key"
              lego_issuer_cert_path=$(echo "${lego_cert_path}" | sed 's/\.crt/.issuer.crt/')
              lego_cert_json_path="${lego_data_path}/certificates/${da_domain}.json"

              msg "$(s cyan)Checking certificate for ${da_domain} files in ${SSL_PATH}/certificates ...$(e)" --caller="${SCRIPT_NAME}"
              check_path "${SSL_PATH}/certificates/${da_domain}.crt" "${SSL_PATH}/certificates/${da_domain}.key" "${SSL_PATH}/certificates/${da_domain}.issuer.crt" "${SSL_PATH}/certificates/${da_domain}.json"
              echo ""
              # Note that we only copy certificate that has domain exist for user
              # Here we copy the certificate folders (but based on the existing domain in da system)
              echo -n "Copying ${SSL_PATH}/certificates/${da_domain}.crt into ${lego_cert_path} ... "
              cp "${SSL_PATH}/certificates/${da_domain}.crt" "${lego_cert_path}"
              get_status_message "$?"
              echo -n "Copying ${SSL_PATH}/certificates/${da_domain}.key into ${lego_key_path} ... "
              cp "${SSL_PATH}/certificates/${da_domain}.key" "${lego_key_path}"
              get_status_message "$?"
              echo -n "Copying ${SSL_PATH}/certificates/${da_domain}.issuer.key into ${lego_issuer_cert_path} ... "
              cp "${SSL_PATH}/certificates/${da_domain}.issuer.crt" "${lego_issuer_cert_path}"
              get_status_message "$?"
              echo -n "Copying ${SSL_PATH}/certificates/${da_domain}.json into ${lego_cert_json_path} ... "
              cp "${SSL_PATH}/certificates/${da_domain}.json" "${lego_cert_json_path}"
              get_status_message "$?"
              msg "$(s cyan)Correcting permission of certificates ...$(e)" --caller="${SCRIPT_NAME}"
              chmod 600 "${lego_cert_path}" "${lego_key_path}" "${lego_issuer_cert_path}" "${lego_cert_json_path}"
              get_status_message "$?"
              echo ""
              msg "$(s cyan)Checking certificate path for ${da_domain} ...$(e)" --caller="${SCRIPT_NAME}"
              check_path "${lego_cert_path}" "${lego_key_path}" "${lego_issuer_cert_path}" "${lego_cert_json_path}"
              echo ""
              # Here we copy the accounts folder into the .lego root directory
              echo "Copying ${SSL_PATH}/accounts into ${lego_data_path} ... "
              cp -fr "${SSL_PATH}/accounts" "${lego_data_path}"
              get_status_message "$?"
              echo ""
              msg "$(s cyan)Checking lego accounts path ...$(e)" --caller="${SCRIPT_NAME}"
              check_path "${lego_data_path}/accounts"
              echo ""
              # Populating variable of reseller certificate
              key="${da_user_path}/${da_user_username}/domains/${da_domain}.key"
              cert="${da_user_path}/${da_user_username}/domains/${da_domain}.cert"
              cacert="${da_user_path}/${da_user_username}/domains/${da_domain}.ca"
              # combine_cert="${da_user_path}/${da_user_username}/domains/${da_domain}.combined"
              echo ""
              msg "$(s cyan)Checking lego certificate and key path ...$(e)" --caller="${SCRIPT_NAME}"
              if [ -s "${lego_cert_path}" ] && [ -s "${lego_key_path}" ]; then
                msg "$(s cyan)Checking certificate entry in with BEGIN CERTIFICATE in ${lego_cert_path} ...$(e)" --caller="${SCRIPT_NAME}"
                if [ $(grep -c "BEGIN CERTIFICATE" "${lego_cert_path}") -eq 1 ]; then
                  msg "$(s cyan)Notice entry count is 1. Copying ${lego_cert_path} into ${cert} ...$(e)" --caller="${SCRIPT_NAME}"
                  cp -pf "${lego_cert_path}" ${cert}
                  get_status_message "$?"
                else
                  msg "$(s cyan)Notice entry count is not 1. Generating new SSL key based on ${lego_cert_path} into ${cert} ...$(e)" --caller="${SCRIPT_NAME}"
                  openssl x509 -in "${lego_cert_path}" -out ${cert}
                  get_status_message "$?"
                fi
                echo ""
                msg "$(s cyan)Copying ${lego_key_path} into ${key} ...$(e)" --caller="${SCRIPT_NAME}"
                cp -pf "${lego_key_path}" ${key}
                get_status_message "$?"
                echo ""

                msg "$(s cyan)Checking whether issuer cert is empty in ${lego_issuer_cert_path} ...$(e)" --caller="${SCRIPT_NAME}"
                if [ -s "${lego_issuer_cert_path}" ]; then
                  msg "$(s cyan)Notice, issuer cert is not empty. Copying ${lego_issuer_cert_path} into ${cacert} ...$(e)" --caller="${SCRIPT_NAME}"
                  cp -pfv "${lego_issuer_cert_path}" ${cacert}
                  get_status_message "$?"
                  echo ""
                  msg "$(s cyan)Combining cert entry from ${cert} and ${cacert} into ${cert}.combined $(e)" --caller="${SCRIPT_NAME}"
                  cat ${cert} ${cacert} >${cert}.combined
                  get_status_message "$?"
                  echo ""
                else
                  msg "$(s cyan)Notice, issuer cert is empty. Copying ${lego_cert_path} into ${cert}.combined ...$(e)" --caller="${SCRIPT_NAME}"
                  cp -pfv "${lego_cert_path}" ${cert}.combined
                  get_status_message "$?"
                fi
                echo ""
                msg "$(s cyan)Creating certificate renewal time at ${cert}.creation_time ...$(e)" --caller="${SCRIPT_NAME}"
                # This file is the one that renew certificate, if this is deleted, renewal will be disable
                date +%s >${cert}.creation_time
                get_status_message "$?"
                echo ""
                msg "$(s cyan)Correcting all certificate ownership ...$(e)" --caller="${SCRIPT_NAME}"
                chown diradmin:${C_DA_SECURE_ACCESS_GROUP} ${key} ${cert} ${cert}.combined ${cacert} ${cert}.creation_time
                get_status_message "$?"
                echo ""
                msg "$(s cyan)Correcting all certificate permission ...$(e)" --caller="${SCRIPT_NAME}"
                chmod 640 ${key} ${cert} ${cert}.combined ${cacert} ${cert}.creation_time
                get_status_message "$?"
                echo ""
                msg "$(s green)OK, certificate for ${da_domain} has been created successfully!$(e)" --caller="${SCRIPT_NAME}"
              else
                msg "$(s red)Error, New key/certificate is empty. Exiting...$(e)" --caller="${SCRIPT_NAME}"
                exit 1
              fi

              echo "DirectAdmin certificate for ${da_domain} has been setup."
              echo ""
              msg "$(s cyan)Checking domain ${da_domain} cert at ${da_user_path}/${da_user_username}/domains/${da_domain}.cert ...$(e)" --caller="${SCRIPT_NAME}"
              if [ -e ${da_user_path}/${da_user_username}/domains/${da_domain}.cert ]; then
                REWRITE=false
                if ! grep -m1 -q '^ssl=ON' ${da_user_path}/${da_user_username}/domains/${da_domain}.conf; then
                  msg "$(s cyan)Turning ssl=ON for ${da_user_path}/${da_user_username}/domains/${da_domain}.conf ...$(e)" --caller="${SCRIPT_NAME}"
                  perl -pi -e 's|^ssl\=.*|ssl=ON|g' ${da_user_path}/${da_user_username}/domains/${da_domain}.conf
                  REWRITE=true
                fi
                if ! grep -m1 -q '^ssl=ON' ${da_user_path}/${da_user_username}/domains/${da_domain}.conf; then
                  msg "$(s cyan)Writing ssl=ON for ${da_user_path}/${da_user_username}/domains/${da_domain}.conf ...$(e)" --caller="${SCRIPT_NAME}"
                  echo 'ssl=ON' >>${da_user_path}/${da_user_username}/domains/${da_domain}.conf
                fi
                if ! grep -m1 -q '^SSLCACertificateFile=' ${da_user_path}/${da_user_username}/domains/${da_domain}.conf && ! grep -m1 -q '^SSLCertificateFile=' ${da_user_path}/${da_user_username}/domains/${da_domain}.conf && ! grep -m1 -q '^SSLCertificateKeyFile=' ${da_user_path}/${da_user_username}/domains/${da_domain}.conf; then
                  msg "$(s cyan)Adding certificate links for ${da_user_path}/${da_user_username}/domains/${da_domain}.conf ...$(e)" --caller="${SCRIPT_NAME}"
                  perl -pi -e "s|^UseCanonicalName=|SSLCACertificateFile=${da_user_path}/${da_user_username}/domains/${da_domain}.cacert\nSSLCertificateFile=${da_user_path}/${da_user_username}/domains/${da_domain}.cert\nSSLCertificateKeyFile=${da_user_path}/${da_user_username}/domains/${da_domain}.key\nUseCanonicalName=|g" ${da_user_path}/${da_user_username}/domains/${da_domain}.conf
                  REWRITE=true
                fi

                if ${REWRITE}; then
                  msg "$(s cyan)Writing rewrite values in task.queue ...$(e)" --caller="${SCRIPT_NAME}"
                  echo "action=rewrite&value=httpd&user=${da_user_username}" >>/usr/local/directadmin/data/task.queue
                  echo "action=rewrite&value=mail_sni&domain=${da_domain}" >>/usr/local/directadmin/data/task.queue
                fi
              fi
            done

          else
            msg "$(s yellow)[Skipped]: Warning SSL restoration is skipped based on config file for the user ${da_user_username}$(e)" --caller="${SCRIPT_NAME}"
            _pause 5
          fi
          echo "=========================================="
          _pause 1
          ((user_count++))
        done
      # Restoration end
      else
        if [ -f "/root/.zerossl" ]; then
          msg "$(s yellow)Notice: ZeroSSL flag is found. SSL certificate will be requested using ZeroSSL method$(e)" --caller="${SCRIPT_NAME}"
        fi
        msg "$(s yellow)Notice: SSL restoration is not set for all users based on C_DA_ENABLE_USER_DOMAIN_SSL_RESTORE value $(e)" --caller="${SCRIPT_NAME}"

        echo ""
        _pause 10

        # This certificate request can be backed up or restore compared auto SSL
        local has_letsencrypt_set letsencrypt_list_selected rewrite

        # This is the well known path for letsencrypt SSL server verification
        msg "$(s cyan)Checking if letsencrypt is enabled in directadmin.conf ...$(e)" --caller="${SCRIPT_NAME}"
        has_letsencrypt_set=$(${da_bin} c | grep -m1 '^letsencrypt=1$')

        if [ -z "${has_letsencrypt_set}" ]; then
          msg "$(s red)Error, let's encrypt hasn't been enabled on the system!$(e)" --caller="${SCRIPT_NAME}"
          exit 1
        else
          letsencrypt_list_selected="$(${da_bin} c | grep '^letsencrypt_list_selected=' | cut -d= -f2 | tr ':' ' ')"
        fi

        echo ""

        for da_user in $(ls ${da_user_path}); do
          {
            for root_domain in $(cat "${da_user_path}/${da_user}/domains.list"); do
              {
                msg "$(s cyan)Configure new certificate for domain ${root_domain} (belongs to user ${da_user}) ...$(e)" --caller="${SCRIPT_NAME}"
                echo ""
                if [ ! -e "${da_user_path}/${da_user}/domains/${root_domain}.cert" ] && [ -s "${da_user_path}/${da_user}/domains/${root_domain}.conf" ]; then
                  local all_domains challenge_test subdomain
                  # domain_list="${root_domain}"
                  all_domains="${root_domain}"

                  msg "$(s cyan)Requesting domain challenge test for domain ${root_domain} ...$(e)" --caller="${SCRIPT_NAME}"
                  challenge_test=$(letsencrypt_challenge_check ${root_domain})
                  get_status_message "${challenge_test}"
                  if [ ${challenge_test} -ne 1 ]; then
                    for extra_subdomain in ${letsencrypt_list_selected}; do
                      # Note extra_subdomain is taken from directadmin.conf
                      local list_extra_subdomain
                      {
                        list_extra_subdomain=${extra_subdomain}.${root_domain}
                        msg "$(s cyan)Requesting domain challenge test for domain ${list_extra_subdomain} ...$(e)" --caller="${SCRIPT_NAME}"
                        challenge_test=$(letsencrypt_challenge_check "${list_extra_subdomain}")
                        get_status_message "${challenge_test}"
                        if [ "${challenge_test}" -ne 1 ]; then
                          all_domains="${all_domains},${list_extra_subdomain}"
                        fi
                      }
                    done
                    echo ""

                    # Checking for subdomain for the domain if exist
                    for sub_domain in $(cat /usr/local/directadmin/data/users/${da_user}/domains/${root_domain}.subdomains); do
                      msg "$(s cyan)Requesting domain challenge test for domain ${sub_domain}.${root_domain} ...$(e)" --caller="${SCRIPT_NAME}"
                      challenge_test=$(letsencrypt_challenge_check "${sub_domain}.${root_domain}")
                      get_status_message "${challenge_test}"
                      if [ ${challenge_test} -ne 1 ]; then
                        all_domains="${all_domains},${sub_domain}.${root_domain}"
                      fi
                    done
                    echo ""
                    echo "List of all domains to be requested SSL: "
                    echo "${all_domains}"
                    echo ""
                    # Duplicate code
                    # challenge_test=$(letsencrypt_challenge_check ${root_domain})
                    msg "$(s cyan)Checking for ECC certificate ...$(e)" --caller="${SCRIPT_NAME}"
                    has_ecc_certificates=$(cat "${da_conf}" | grep "^ecc_certificates=" | cut -d= -f2)
                    echo ""
                    if echo "${all_domains}" | grep -m1 -q ','; then
                      msg "$(s cyan)Requesting SSL certificate for multiple domains: ${all_domains} ...$(e)" --caller="${SCRIPT_NAME}"
                      if [ -n "${has_ecc_certificates}" ]; then
                        ${da_script_path}/letsencrypt.sh request ${all_domains} ${C_DA_CERTIFICATE_SIZE}
                      else
                        ${da_script_path}/letsencrypt.sh request ${all_domains} 4096
                      fi
                    else
                      msg "$(s cyan)Requesting SSL certificate for single domain: ${root_domain} ...$(e)" --caller="${SCRIPT_NAME}"
                      if [ -n "${has_ecc_certificates}" ]; then
                        ${da_script_path}/letsencrypt.sh request_single ${root_domain} ${C_DA_CERTIFICATE_SIZE}
                      else
                        ${da_script_path}/letsencrypt.sh request_single ${root_domain} 4096
                      fi
                    fi
                    echo ""
                  fi
                fi
                msg "$(s cyan)Checking domain ${root_domain} cert at ${da_user_path}/${da_user}/domains/${root_domain}.cert ...$(e)" --caller="${SCRIPT_NAME}"
                if [ -e "${da_user_path}/${da_user}/domains/${root_domain}.cert" ]; then
                  rewrite=false
                  if ! grep -m1 -q '^ssl=ON' "${da_user_path}/${da_user}/domains/${root_domain}.conf"; then
                    msg "$(s cyan)Turning ssl=ON for ${da_user_path}/${da_user}/domains/${root_domain}.conf ...$(e)" --caller="${SCRIPT_NAME}"
                    perl -pi -e 's|^ssl\=.*|ssl=ON|g' "${da_user_path}/${da_user}/domains/${root_domain}.conf"
                    rewrite=true
                    echo ""
                  fi
                  if ! grep -m1 -q '^ssl=ON' "${da_user_path}/${da_user}/domains/${root_domain}.conf"; then
                    msg "$(s cyan)Writing ssl=ON for ${da_user_path}/${da_user}/domains/${root_domain}.conf ...$(e)" --caller="${SCRIPT_NAME}"
                    echo 'ssl=ON' >>"${da_user_path}/${da_user}/domains/${root_domain}.conf"
                    echo ""
                  fi
                  if ! grep -m1 -q '^SSLCACertificateFile=' "${da_user_path}/${da_user}/domains/${root_domain}.conf" && ! grep -m1 -q '^SSLCertificateFile=' ${da_user_path}/${da_user}/domains/${root_domain}.conf && ! grep -m1 -q '^SSLCertificateKeyFile=' ${da_user_path}/${da_user}/domains/${root_domain}.conf; then
                    msg "$(s cyan)Adding certificate links for ${da_user_path}/${da_user}/domains/${root_domain}.conf ...$(e)" --caller="${SCRIPT_NAME}"
                    perl -pi -e "s|^UseCanonicalName=|SSLCACertificateFile=${da_user_path}/${da_user}/domains/${root_domain}.cacert\nSSLCertificateFile=${da_user_path}/${da_user}/domains/${root_domain}.cert\nSSLCertificateKeyFile=${da_user_path}/${da_user}/domains/${root_domain}.key\nUseCanonicalName=|g" "${da_user_path}/${da_user}/domains/${root_domain}.conf"
                    rewrite=true
                  fi
                  if ${rewrite}; then
                    msg "$(s cyan)Writing rewrite values in task.queue ...$(e)" --caller="${SCRIPT_NAME}"
                    echo "action=rewrite&value=httpd&user=${da_user}" >>/usr/local/directadmin/data/task.queue
                    echo "action=rewrite&value=mail_sni&domain=${root_domain}" >>/usr/local/directadmin/data/task.queue
                    echo ""
                  fi
                fi
              }
            done
          }
        done
      fi
    else
      msg "$(s yellow)[Skipped]: Warning DA Auto SSL is not enabled. The SSL restoration is skipped$(e)"

    fi

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}
# Note latest DA installer gave letsencrypt SSL certificate for hostname
# Use below to have the ability to use another certificate like zerossl
configure_da_hostname_ssl() {
  # OLD NOTES:
  # Interesting answer: https://serverfault.com/questions/602700/debian-ipv6-is-not-asssigned-to-interface
  # Nice reading: https://www.agwa.name/blog/post/beware_the_ipv6_dad_race_condition
  # https://serverfault.com/questions/421460/nginx-failed-to-start-cannot-assign-requested-address
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    if [ "${C_ENABLE_DA_HOST_SSL}" == "true" ]; then
      local da_bin da_cb_bin dataskq da_conf task_queue da_script_path lego_data_path retry_count max_retry is_ssl_enable
      max_retry=10
      da_bin="/usr/local/directadmin/directadmin"
      da_cb_bin="/usr/local/directadmin/custombuild/build"
      dataskq="/usr/local/directadmin/dataskq"
      da_conf="/usr/local/directadmin/conf/directadmin.conf"
      da_conf_path="/usr/local/directadmin/conf"
      da_script_path="/usr/local/directadmin/scripts"
      # This file does not exist by default
      task_queue="/usr/local/directadmin/data/task.queue.cb"

      msg "$(s cyan)Checking directadmin required files ...$(e)" --caller="${SCRIPT_NAME}"
      check_path "${da_bin}" "${da_cb_bin}" "${dataskq}" "${da_conf}" "${da_script_path}" "${da_conf_path}"
      echo ""

      # Check if zeroSSL is enabled
      if [ "${C_DA_ENABLE_ZEROSSL_CERTIFICATE}" == "true" ]; then
        msg "$(s cyan)Enabling zerossl certificate based on config file ...$(e)" --caller="${SCRIPT_NAME}"
        touch /root/.zerossl
      else
        msg "$(s cyan)Disabling zerossl certificate based on config file ...$(e)" --caller="${SCRIPT_NAME}"
        rm -f /root/.zerossl
      fi

      msg "$(s cyan)Configuring Directadmin SSL for host certificate ...$(e)" --caller="${SCRIPT_NAME}"
      # Set the ssl_redirect_host (remove later) :
      # This options is deprecated in directadmin 1.62+ https://www.directadmin.com/features.php?id=801 (it replaced with javascript redirection)
      # msg "Setting ssl_redirect_host to ${C_BOX_HOSTNAME_FQHN} in directadmin.conf config ..."
      # ${da_bin} set ssl_redirect_host "${C_BOX_HOSTNAME_FQHN}"

      # TODO recheck this: The first method is restore based on certificate offline file
      if [ "${C_DA_ENABLE_HOSTNAME_SSL_RESTORE}" == "true" ]; then

        # Note there is another script that can also use to restore previous certificate forked from Porallix here:
        # https://github.com/sofibox/directadmin-utils/blob/master/ssl/install_server_wide_cert.sh
        # It does the same thing, but mine is following exactly like what DA letsencrypt.sh does

        msg "$(s cyan)Restoring host SSL certificate (from previous backup) ...$(e)" --caller="${SCRIPT_NAME}"

        local key cert cacert eximkey eximcert lego_cert_path lego_data_path lego_key_path lego_issuer_cert_path set_da_cacert

        # This guide is based on directadmin letsencrypt.sh

        # By default the path .lego does not exist
        lego_data_path="/usr/local/directadmin/data/.lego"
        mkdir -p "${lego_data_path}/certificates"
        # This 3 files must be pushed from SSH into ${lego_data_path} then check them if they exist
        lego_cert_path="${lego_data_path}/certificates/${C_BOX_HOSTNAME_FQHN}.crt"
        lego_key_path="${lego_data_path}/certificates/${C_BOX_HOSTNAME_FQHN}.key"
        lego_issuer_cert_path=$(echo "${lego_cert_path}" | sed 's/\.crt/.issuer.crt/')
        lego_cert_json_path="${lego_data_path}/certificates/${C_BOX_HOSTNAME_FQHN}.json"

        check_path "${SSL_PATH}/certificates/${C_BOX_HOSTNAME_FQHN}.crt" "${SSL_PATH}/certificates/${C_BOX_HOSTNAME_FQHN}.key" "${SSL_PATH}/certificates/${C_BOX_HOSTNAME_FQHN}.issuer.crt" "${SSL_PATH}/certificates/${C_BOX_HOSTNAME_FQHN}.json"

        echo -n "Copying ${SSL_PATH}/certificates/${C_BOX_HOSTNAME_FQHN}.crt into ${lego_cert_path} ... "
        cp "${SSL_PATH}/certificates/${C_BOX_HOSTNAME_FQHN}.crt" "${lego_cert_path}"
        get_status_message "$?"
        echo -n "Copying ${SSL_PATH}/certificates/${C_BOX_HOSTNAME_FQHN}.key into ${lego_key_path} ... "
        cp "${SSL_PATH}/certificates/${C_BOX_HOSTNAME_FQHN}.key" "${lego_key_path}"
        get_status_message "$?"
        echo -n "Copying ${SSL_PATH}/certificates/${C_BOX_HOSTNAME_FQHN}.issuer.key into ${lego_issuer_cert_path} ... "
        cp "${SSL_PATH}/certificates/${C_BOX_HOSTNAME_FQHN}.issuer.crt" "${lego_issuer_cert_path}"
        get_status_message "$?"
        echo -n "Copying ${SSL_PATH}/certificates/${C_BOX_HOSTNAME_FQHN}.json into ${lego_cert_json_path} ... "
        cp "${SSL_PATH}/certificates/${C_BOX_HOSTNAME_FQHN}.json" "${lego_cert_json_path}"
        get_status_message "$?"
        msg "$(s cyan)Correcting permission of certificates ...$(e)" --caller="${SCRIPT_NAME}"
        chmod 600 "${lego_cert_path}" "${lego_key_path}" "${lego_issuer_cert_path}" "${lego_cert_json_path}"
        get_status_message "$?"
        echo ""
        msg "$(s cyan)Checking certificate path for ${C_BOX_HOSTNAME_FQHN} ...$(e)" --caller="${SCRIPT_NAME}"
        check_path "${lego_cert_path}" "${lego_key_path}" "${lego_issuer_cert_path}" "${lego_cert_json_path}"
        echo ""

        key=$(${da_bin} c | grep ^cakey= | cut -d= -f2)
        cert=$(${da_bin} c | grep ^cacert= | cut -d= -f2)
        cacert=$(${da_bin} c | grep ^carootcert= | cut -d= -f2)

        set_da_cacert=false
        if [ "${cacert}" = "" ] || [ "${cert}" = "${da_conf_path}/carootcert.pem" ]; then
          cert="${da_conf_path}/cacert.pem"
          cacert="${da_conf_path}/carootcert.pem"
          set_da_cacert=true
        fi

        if [ -s "${lego_cert_path}" ] && [ -s "${lego_key_path}" ]; then
          if [ $(grep -c "BEGIN CERTIFICATE" "${lego_cert_path}") -eq 1 ]; then
            cp -pf "${lego_cert_path}" ${cert}
          else
            openssl x509 -in "${lego_cert_path}" -out ${cert}
            get_status_message "$?"
          fi
          cp -pf "${lego_key_path}" ${key}
          if [ -s "${lego_issuer_cert_path}" ]; then
            cp -pfv "${lego_issuer_cert_path}" ${cacert}
            cat ${cert} ${cacert} >${cert}.combined
          else
            cp -pfv "${lego_cert_path}" ${cert}.combined
          fi
          date +%s >${cert}.creation_time
          chown diradmin:${C_DA_SECURE_ACCESS_GROUP} ${key} ${cert} ${cert}.combined ${cacert} ${cert}.creation_time
          # This file is the one that renew certificate, if this is deleted, renewal will be disable
          chmod 640 ${key} ${cert} ${cert}.combined ${cacert} ${cert}.creation_time
          echo "Certificate for ${C_BOX_HOSTNAME_FQHN} has been created successfully!"
        else
          echo "New key/certificate is empty. Exiting..."
          exit 1
        fi

        echo "DirectAdmin certificate for ${C_BOX_HOSTNAME_FQHN} has been setup."

        if grep -m1 -q "^cacert=${da_conf_path}/carootcert.pem$" /usr/local/directadmin/conf/directadmin.conf; then
          ${da_bin} set cacert ${da_conf_path}/cacert.pem
        fi
        if ${set_da_cacert}; then
          ${da_bin} set carootcert ${cacert}
        fi
        if ${da_bin} c | grep -m1 -q "^ssl=0$"; then
          ${da_bin} set ssl 1
        fi

        #Exim
        echo "Setting up cert for Exim..."
        if command -v exim &>/dev/null; then
          local eximkey eximcert
          eximkey="/etc/exim.key"
          eximcert="/etc/exim.cert"
          cp -fv ${key} ${eximkey}
          cat ${cert} ${cacert} >${eximcert}
          chown -v mail:mail ${eximkey} ${eximcert}
          chmod -v 600 ${eximkey} ${eximcert}

          echo "action=exim&value=restart" >>${task_queue}
          echo "action=dovecot&value=restart" >>${task_queue}
        fi
        echo ""
        #Apache
        if [ -d /etc/httpd/conf/ssl.key ] && [ -d /etc/httpd/conf/ssl.crt ]; then
          echo "Setting up cert for apache ..."
          local apachekey apachecert apachecacert apachecertcombined httpd_action graceful
          apachekey="/etc/httpd/conf/ssl.key/server.key"
          apachecert="/etc/httpd/conf/ssl.crt/server.crt"
          apachecacert="/etc/httpd/conf/ssl.crt/server.ca"
          apachecertcombined="${apachecert}.combined"

          cp -fv ${key} ${apachekey}
          cp -fv ${cert} ${apachecert}
          cp -fv ${cacert} ${apachecacert}
          cat ${apachecert} ${apachecacert} >${apachecertcombined}
          chown -v root:root ${apachekey} ${apachecert} ${apachecacert} ${apachecertcombined}
          chmod -v 600 ${apachekey} ${apachecert} ${apachecacert} ${apachecertcombined}

          httpd_action=restart
          graceful=$(${da_bin} c | grep ^graceful_restarts= | cut -d= -f2)
          if [ "${graceful}" = "1" ]; then
            local systemd
            systemd=$(${da_bin} c | grep ^systemd= | cut -d= -f2)
            if [ "${systemd}" = "1" ]; then
              httpd_action=reload
            else
              httpd_action=graceful
            fi
          fi
          echo "action=httpd&value=${httpd_action}&affect_php_fpm=no" >>${task_queue}
        fi
        echo ""
        #Nginx
        if [ -d /etc/nginx/ssl.key ] && [ -d /etc/nginx/ssl.crt ]; then
          echo "Setting up cert for nginx ..."
          local nginxkey nginxcert nginxcacert nginxcertcombined
          nginxkey="/etc/nginx/ssl.key/server.key"
          nginxcert="/etc/nginx/ssl.crt/server.crt"
          nginxcacert="/etc/nginx/ssl.crt/server.ca"
          nginxcertcombined="${nginxcert}.combined"
          cp -fv ${key} ${nginxkey}
          cp -fv ${cert} ${nginxcert}
          cp -fv ${cacert} ${nginxcacert}
          cat ${nginxcert} ${nginxcacert} >${nginxcertcombined}
          chown -v root:root ${nginxkey} ${nginxcert} ${nginxcacert} ${nginxcertcombined}
          chmod -v 600 ${nginxkey} ${nginxcert} ${nginxcacert} ${nginxcertcombined}
          echo "action=nginx&value=restart&affect_php_fpm=no" >>${task_queue}
        fi
        echo ""
        #OLS
        if [ -d /usr/local/lsws/ssl.key ] && [ -d /usr/local/lsws/ssl.crt ]; then
          echo "Setting up cert for openlitespeed ..."
          local olskey olscer olscacert olscertcombined
          olskey="/usr/local/lsws/ssl.key/server.key"
          olscert="/usr/local/lsws/ssl.crt/server.crt"
          olscacert="/usr/local/lsws/ssl.crt/server.ca"
          olscertcombined="${olscert}.combined"
          cp -fv ${key} ${olskey}
          cp -fv ${cert} ${olscert}
          cp -fv ${cacert} ${olscacert}
          cat ${olscert} ${olscacert} >${olscertcombined}
          chown -v root:root ${olskey} ${olscert} ${olscacert} ${olscertcombined}
          chmod -v 600 ${olskey} ${olscert} ${olscacert} ${olscertcombined}
          echo "action=openlitespeed&value=restart&affect_php_fpm=no" >>${task_queue}
        fi
        echo ""
        #FTP
        if command -v pure-ftpd &>/dev/null; then
          echo "Setting up certificate for FTP server..."
          cat ${key} ${cert} ${cacert} >/etc/pure-ftpd.pem
          chmod -v 600 /etc/pure-ftpd.pem
          chown -v root:root /etc/pure-ftpd.pem
          if ${da_bin} c | grep -m1 -q "^pureftp=1\$"; then
            echo "action=pure-ftpd&value=restart" >>${task_queue}
          else
            echo "action=proftpd&value=restart" >>${task_queue}
          fi
        fi

        echo ""
        msg "$(s cyan)Enabling ssl=1 in directadmin.conf config...$(e)" --caller="${SCRIPT_NAME}"
        ${da_bin} set ssl 1
        echo ""
        # This is to redirect hostname automatically to https
        msg "$(s cyan)Setting redirect_host_https yes in Directadmin options.conf config ...$(e)" --caller="${SCRIPT_NAME}"
        ${da_cb_bin} set redirect_host_https yes
        echo ""
        # if you want everyone to be redirected on hostname use this
        msg "$(s cyan)Setting use_hostname_for_alias yes in Directadmin options.conf config ...$(e)" --caller="${SCRIPT_NAME}"
        ${da_cb_bin} set use_hostname_for_alias yes
        echo ""

        echo "action=directadmin&value=restart" >>${task_queue}
        echo "The services will be restarted in about 1 minute via the dataskq."
        ${dataskq} --custombuild

      else
        # If the site is valid ssl, then we skip
        if is_valid ssl_site "${C_BOX_HOSTNAME_FQHN}:${C_DA_PORT}"; then
          msg "$(s cyan)Notice, skipped requesting new certificate because the SSL for hostname is valid! ...$(e)" --
          _pause 5
          msg "$(s cyan)Enabling ssl=1 in directadmin.conf config...$(e)" --caller="${SCRIPT_NAME}"
          ${da_bin} set ssl 1
          msg "$(s cyan)Restarting directadmin after changing directadmin.conf ...$(e)" --caller="${SCRIPT_NAME}"
          restart_da
          echo ""
          # Ensure everything is working after requesting certificate
          while :; do
            local test_login
            msg "$(s cyan)Testing login into directadmin API using the main admin username ...$(e)" --caller="${SCRIPT_NAME}"
            # shellcheck disable=SC2046
            test_login=$(da_api_admin test-login --username $(get_current_da_owner_username) --scripting | grep "error=0")
            if [ -n "${test_login}" ]; then
              msg "$(s green) OK$(e)"
              break
            else
              msg "$(s red) FAILED$(e)"
              ensure_internet_connected
              ensure_domain_server_resolved
              ensure_fqhn_server_resolved
              echo ""
              msg "$(s cyan)Retrying login into directadmin API using the main admin username ...$(e)" --caller="${SCRIPT_NAME}"
            fi
            sleep 3
          done

        else

          retry_count=0
          # Below for requesting new certificate with staging test request first
          echo ""
          msg "$(s cyan)Enabling cacert in directadmin.conf config...$(e)" --caller="${SCRIPT_NAME}"
          ${da_bin} set cacert /usr/local/directadmin/conf/cacert.pem
          echo ""
          msg "$(s cyan)Enabling cakey in directadmin.conf config...$(e)" --caller="${SCRIPT_NAME}"
          ${da_bin} set cakey /usr/local/directadmin/conf/cakey.pem
          echo ""
          # Add wellknown-alias by rewrite_confs
          msg "$(s cyan)Creating dummy acme-challenge texts through custombuild rewrite_confs ...$(e)" --caller="${SCRIPT_NAME}"
          ${da_cb_bin} rewrite_confs
          echo ""

          # Make sure IP and domain are resolved
          ensure_domain_server_resolved
          ensure_fqhn_server_resolved

          echo ""
          # Staging call first
          has_ecc_certificates=$(grep "^ecc_certificates=" "${da_conf}" | cut -d= -f2)
          while :; do
            msg "$(s cyan)Staging request SSL certificate for ${C_BOX_HOSTNAME_FQHN} ...$(e)" --caller="${SCRIPT_NAME}"

            if [ -n "${has_ecc_certificates}" ]; then
              staging=yes ${da_script_path}/letsencrypt.sh request_single "${C_BOX_HOSTNAME_FQHN}" "${C_DA_CERTIFICATE_SIZE}"
            else
              staging=yes ${da_script_path}/letsencrypt.sh request_single "${C_BOX_HOSTNAME_FQHN}"
            fi
            retval=$?

            echo "Return value for certificate staging request is: ${retval}"

            if [ "${retval}" -eq 0 ]; then
              msg "$(s green)OK, certificate staging request test return success code$(e)" --caller="${SCRIPT_NAME}"
              break
            else
              ((retry_count++))
              msg "$(s red)Error, certificate staging request does not return success code!$(e)" --caller="${SCRIPT_NAME}"

              # The new directadmin installer automatically called letsencrypt for hostname and it then enables the ssl=1
              # The problem is when ssl=1, we cannot request certificate, we have to check if the option is enable, we disable it
              # This fixed a hung status acme: Trying to solve HTTP-01
              is_ssl_enable=$(${da_bin} config | grep '^ssl=')
              if [ "${is_ssl_enable}" == "ssl=1" ]; then
                msg "$(s cyan)Found ssl=1 in directadmin.conf config. Setting ssl=0 before requesting certificate ...$(e)" --caller="${SCRIPT_NAME}"
                ${da_bin} set ssl 0
                get_status_message "$?"
                echo ""
                msg "$(s cyan)Restarting directadmin after changing directadmin.conf ...$(e)" --caller="${SCRIPT_NAME}"
                restart_da
                echo ""
              fi
              msg "$(s cyan)Retrying for the $(get_ordinal "${retry_count}") time(s) within 1 minute ...$(e)" --caller="${SCRIPT_NAME}"
              _pause 60
              if [ "${retry_count}" -ge ${max_retry} ]; then
                msg "$(s red)Error, certificate staging request does not return success code for the $(get_ordinal ${max_retry}) time(s)!$(e)" --caller="${SCRIPT_NAME}"
                exit 1
              fi

            fi

          done

          echo ""
          #7) Now let's request the real certificate after staging is completed without error

          has_ecc_certificates=$(grep "^ecc_certificates=" "${da_conf}" | cut -d= -f2)
          retry_count=0
          while :; do
            msg "$(s cyan)Requesting SSL certificate for ${C_BOX_HOSTNAME_FQHN} ...$(e)" --caller="${SCRIPT_NAME}"
            if [ -n "${has_ecc_certificates}" ]; then
              ${da_script_path}/letsencrypt.sh request_single "${C_BOX_HOSTNAME_FQHN}" "${C_DA_CERTIFICATE_SIZE}"
            else
              ${da_script_path}/letsencrypt.sh request_single "${C_BOX_HOSTNAME_FQHN}"
            fi

            retval=$?
            echo "Return value for real certificate request is: ${retval}"
            if [ "${retval}" -eq 0 ]; then
              msg "$(s green)OK, certificate request return success code$(e)" --caller="${SCRIPT_NAME}"
              echo ""
              msg "$(s cyan)Enabling ssl=1 in directadmin.conf config...$(e)" --caller="${SCRIPT_NAME}"
              ${da_bin} set ssl 1
              echo ""

              # This fixed http protocol problem if cert has been requested as I reported here https://forum.directadmin.com/threads/might-be-bug-api-http-protocol-is-not-working-after-requesting-certificate.64408/
              # I also have another workaround to let the script select http or https (if available). To use this workaround enable this setting:
              # C_DA_AUTO_SELECT_API_PROTOCOL=true (remember this is beta feature. When directadmin released bug fixed, this feature will be disabled by default)

              # If I disable ssl below (set ssl=0 in directadmin.conf and restart), I can use both http and https on API for host domain:
              # BUT at this point, I decided to use my workaround using C_DA_AUTO_SELECT_API_PROTOCOL=true (so, I don't have to disable ssl option below. Only uncomment below if this failed)
              #msg "$(s cyan)Disabling ssl=0 in directadmin.conf config...$(e)" --caller="${SCRIPT_NAME}"
              #${da_bin} set ssl 0

              # This is to redirect hostname automatically to https
              msg "$(s cyan)Setting redirect_host_https yes in Directadmin options.conf config ...$(e)" --caller="${SCRIPT_NAME}"
              ${da_cb_bin} set redirect_host_https yes
              echo ""
              # if you want everyone to be redirected on hostname use this
              msg "$(s cyan)Setting use_hostname_for_alias yes in Directadmin options.conf config ...$(e)" --caller="${SCRIPT_NAME}"
              ${da_cb_bin} set use_hostname_for_alias yes
              echo ""
              # Always a good idea to restart directadmin after changing directadmin.conf
              msg "$(s cyan)Restarting directadmin after changing directadmin.conf ...$(e)" --caller="${SCRIPT_NAME}"
              restart_da
              echo ""
              # Ensure everything is working after requesting certificate
              while :; do
                local test_login
                msg "$(s cyan)Testing login into directadmin API using the main admin username ...$(e)" --caller="${SCRIPT_NAME}"
                # shellcheck disable=SC2046
                test_login=$(da_api_admin test-login --username $(get_current_da_owner_username) --scripting | grep "error=0")
                if [ -n "${test_login}" ]; then
                  msg "$(s green) OK$(e)"
                  break
                else
                  msg "$(s red) FAILED$(e)"
                  ensure_internet_connected
                  ensure_domain_server_resolved
                  ensure_fqhn_server_resolved
                  echo ""
                  msg "$(s cyan)Retrying login into directadmin API using the main admin username ...$(e)" --caller="${SCRIPT_NAME}"
                fi
                sleep 3
              done
              break
            else

              ((retry_count++))
              msg "$(s red)Error, certificate request does not return success code!$(e)" --caller="${SCRIPT_NAME}"

              # This fixed a hung status acme: Trying to solve HTTP-01 if ssl=0 is set automatically by DA
              is_ssl_enable=$(${da_bin} config | grep '^ssl=')
              if [ "${is_ssl_enable}" == "ssl=1" ]; then
                msg "$(s cyan)Found ssl=1 in directadmin.conf config. Setting ssl=0 before requesting certificate ...$(e)" --caller="${SCRIPT_NAME}"
                ${da_bin} set ssl 0
                get_status_message "$?"
                echo ""
                msg "$(s cyan)Restarting directadmin after changing directadmin.conf ...$(e)" --caller="${SCRIPT_NAME}"
                restart_da
                echo ""
              fi
              msg "$(s cyan)Retrying for the $(get_ordinal ${retry_count}) time(s) within 1 minute ...$(e)" --caller="${SCRIPT_NAME}"
              _pause 60
              if [ "${retry_count}" -ge ${max_retry} ]; then
                msg "$(s red)Error, certificate request does not return success code for the $(get_ordinal ${max_retry}) time(s)!$(e)" --caller="${SCRIPT_NAME}"
                exit 1
              fi
            fi

          done
        fi

      fi
    else
      msg "$(s yellow)Warning, skipped requesting certificate for ${C_BOX_HOSTNAME_FQHN} because C_ENABLE_DA_HOST_SSL is not set to true $(e)" --caller="${SCRIPT_NAME}"
      sleep 5
    fi

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This is a directadmin way to add IP into the interface
add_da_ip() {
  # This is to add DA script to add IP into device.
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local addip_script
    addip_script="/usr/local/directadmin/scripts/addip"
    msg "Adding ipv6 address for Directadmin using DA addip official script ..."
    #echo "Usage: $0 <ip> (<netmask> (<eth dev> (<broadcast>)))";
    #echo "example: $0 1.2.3.4 255.255.255.0 eth0";
    if [ -f ${addip_script} ]; then
      "${addip_script}" "${C_IPV6_ADD0}" "255.255.255.0" "${C_NIC_INTERFACE_NAME}"
    else
      msg "Warning, the directadmin script file ${addip_script} was not found. Bye!"
      exit 1
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_hook_scripts() {
  :
}

# This maxibox is only used for backup purpose
configure_maxibox() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    ###
    # TODO: Add maxibox backup script here (PENDING)
    msg "$(s yellow)Warning, this function is not yet implemented!$(e)" --caller="${SCRIPT_NAME}"
    ###
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_rclone() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    curl https://rclone.org/install.sh | sudo bash

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_blcheck() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local blcheck_bin script_install_path
    script_install_path="/usr/local/opencode/blcheck"
    msg "Configuring blcheck installation in maxicode ..."

    maxibuild --include blcheck
    echo ""

    msg "Running blcheck -V ${blcheck_bin} ..."
    blcheck -V
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_ipcalc() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local caller ipcalc_bin script_install_path
    caller="$(basename -- "$0")->${FUNCNAME[0]}"
    script_install_path="/usr/local/opencode/ipcalc"

    msg "Configuring ipcalc installation in maxicode ..." --caller="${caller}->${FUNCNAME[0]}" --msg-type="info"
    maxibuild --include ipcalc
    echo ""

    # Do extra option here for ipcalc

    echo "[${caller}]: Copying sample config file ..."
    cp "${script_install_path}/ipcalc.conf.sample" "${script_install_path}/ipcalc.conf"
    echo ""

    # Do extra here before running ipcalc

    echo "[${caller}]: Running ipcalc --version  ..."
    ipcalc --version
    get_status_message "$?"
    echo ""

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_grepaddr() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local grepaddr_bin script_install_path
    script_install_path="/usr/local/opencode/grepaddr"

    msg "Configuring grepaddr installation in maxicode ..." --caller="${SCRIPT_NAME}->${FUNCNAME[0]}" --msg-type="info"
    maxibuild --include "grepaddr"
    echo ""

    msg "Copying sample config file ..."
    cp "${script_install_path}/grepaddr.conf.sample" "${script_install_path}/grepaddr.conf"
    get_status_message "$?"

    # Check if python 3 is installed, if yes run grepaddr -h

    if [[ -f "/usr/bin/python3" ]]; then
      msg "Running grepaddr -h ${grepaddr_bin} ..."
      grepaddr -h
      get_status_message "$?"
    else
      msg "Python 3 is not installed, skipping grepaddr -h ..."
    fi

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This will be the place for open source code
configure_opencode() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    configure_ipcalc --run
    configure_grepaddr --run
    configure_blcheck --run
    configure_wpcli --run
    configure_rclone --run
    configure_yq --run
    # TODO skip gotify at this moment because this need advance configuration for security
    configure_gotify --skip
    configure_aipdb --run
    configure_greynoise --run
    configure_virustotal --run
    configure_mysqltuner --run # TODO should create maxidb binary that manage this instead of mysqltuner
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# maxicode will be the place to upgrade maxicode binaries (even when script finished running).
# example running maxibox --update-maxicode or maxibox --checkout-all maxibox
# usage: maxicode --update <package_name> or maxicode -u <package_name>
# eg: To update all package: maxicode -u all. To update just maxiwall: maxicode -u maxiwall
# TODO this is a very old function. I will update later
# TODO this function will be used to update maxicode binary (maxigpg, maxiaide)
configure_maxicode() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local maxicode_bin script_install_path

    script_install_path="/usr/local/maxicode/maxicode"
    msg "Configuring maxicode installation in maxicode ..."
    maxibuild --include "git"
    mkdir -p "${script_install_path}"
    maxicode_bin="${script_install_path}/maxicode"

    msg "$(s cyan)Setting up maxicode for host ...$(e)" --caller="${SCRIPT_NAME}"
    msg "$(s cyan)Removing old maxicode installation ...$(e)" --caller="${SCRIPT_NAME}"
    rm -rf "${script_install_path}" "/usr/local/bin/maxicode" "/usr/bin/maxicode"
    get_status_message "$?"

    msg "$(s cyan)Cloning maxicode from github ...$(e)" --caller="${SCRIPT_NAME}"
    git clone https://github.com/sofibox/maxicode_public "${script_install_path}"
    get_status_message "$?"

    msg "$(s cyan)Giving executable permission to maxicode ...$(e)" --caller="${SCRIPT_NAME}"
    chmod +x ${maxicode_bin}
    get_status_message "$?"

    msg "$(s cyan)Creating symlink for maxicode ...$(e)" --caller="${SCRIPT_NAME}"
    ln -s ${maxicode_bin} /usr/local/bin
    get_status_message "$?"

    msg "$(s cyan) Copying sample config file ...$(e)" --caller="${SCRIPT_NAME}"
    cp "${script_install_path}/maxicode.conf.sample" "${script_install_path}/maxicode.conf"
    get_status_message "$?"

    msg "Configuring API authentication ..."
    sed -i "s|^GIT_TOKEN\=.*|GIT_TOKEN=\"${C_GIT_TOKEN}\"|" "${script_install_path}/maxicode.conf"
    sed -i "s|^SETUP_GIT_URL\=.*|SETUP_GIT_URL=\"${C_SETUP_GIT_URL}\"|" "${script_install_path}/maxicode.conf"
    get_status_message "$?"

    msg "$(s cyan) Running maxicode version ...$(e)" --caller="${SCRIPT_NAME}"
    maxicode -V
    get_status_message "$?"

    configure_maxiaide --run
    configure_maxigpg --run
    configure_maxipi --run
    configure_maxiperm --run
    configure_maxida --run
    # TODO improve this script
    configure_maxibox --run
    # TODO improve this script
    configure_maxinis --run
    configure_maxiclam --run # TODO this needs to be inside maxibuild
    configure_maxiwall --run

    echo "=====================TODO until here!!!!!! =============================="
    # TODO improve below scripts above script already improve a bit
    configure_maxicloud --skip # skip first need to implement on github
    configure_maxipass --skip  # skip first need to implement on github
    configure_maxicron --run

    # 2) Install rsync and copy maxinet files (make sure it works)
    # 4) Copy maxicbuild

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_maxibuild() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi

  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local maxibuild_bin script_install_path
    script_install_path="/usr/local/maxicode/maxibuild"
    msg "Configuring maxibuild installation in maxicode ..."
    mkdir -p "${script_install_path}"
    maxibuild_bin="${script_install_path}/maxibuild"

    msg "$(s cyan)Setting up maxibuild (Package management) for host ...$(e)" --caller="${SCRIPT_NAME}"
    rm -rf "${script_install_path}" "/usr/local/bin/maxibuild" "/usr/bin/maxibuild"
    get_status_message "$?"

    [[ "$(get_linux_os id)" == +(debian|ubuntu) ]] && {
      msg "$(s cyan)Installing git ...$(e)" --caller="${SCRIPT_NAME}"
      apt-get install -y git
    }

    [[ "$(get_linux_os id)" == +(centos|rhel|almalinux|rockylinux) ]] && {
      msg "$(s cyan)Installing git ...$(e)" --caller="${SCRIPT_NAME}"
      yum install -y git
    }

    msg "$(s cyan)Cloning maxibuild from github ...$(e)" --caller="${SCRIPT_NAME}"
    git clone https://github.com/sofibox/maxibuild_public "${script_install_path}"
    get_status_message "$?"

    msg "Giving executable permission to maxibuild ..."
    chmod +x ${maxibuild_bin}
    get_status_message "$?"

    msg "Creating symlink for maxibuild ..."
    ln -s ${maxibuild_bin} /usr/local/bin
    get_status_message "$?"

    msg "Copying sample config file ..."
    cp "${script_install_path}/maxibuild.conf.sample" "${script_install_path}/maxibuild.conf"
    get_status_message "$?"

    msg "Running maxibuild -V ${maxibuild_bin} ..."
    maxibuild -V
    get_status_message "$?"

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_maxipi() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi

  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local script_install_path
    script_install_path="/usr/local/maxicode/maxipi"

    msg "Configuring maxipi installation in maxicode ..."
    maxibuild --include "maxipi"
    echo ""
    msg "Copying sample config file ..."
    cp "${script_install_path}/maxipi.conf.sample" "${script_install_path}/maxipi.conf"
    get_status_message "$?"
    echo ""

    msg "Configuring API authentication ..."
    sed -i "s|^LINODE_API_KEY\=.*|LINODE_API_KEY=\"${C_LINODE_API_KEY}\"|" "${script_install_path}/maxipi.conf"
    sed -i "s|^LINODE_API_URL\=.*|LINODE_API_URL=\"${C_LINODE_API_URL}\"|" "${script_install_path}/maxipi.conf"
    sed -i "s|^LINODE_API_PORT\=.*|LINODE_API_PORT=\"${C_LINODE_API_PORT}\"|" "${script_install_path}/maxipi.conf"
    get_status_message "$?"

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_maxiperm() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local script_install_path
    script_install_path="/usr/local/maxicode/maxiperm"
    msg "Configuring maxiperm installation in maxicode ..."

    maxibuild --include "maxiperm"

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Harden server based on lynis suggestion
configure_maxinis() {
  # Here we do extra hardening for SSHD (based on lynis suggestion)
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local lynis_latest_version maxinis_bin lynis_bin
    script_install_path="/usr/local/maxicode/maxinis"
    msg "Configuring maxinis installation in maxicode ..."
    maxibuild --include "git"
    mkdir -p "${script_install_path}"
    maxinis_bin="${script_install_path}/maxinis"
    lynis_bin="/usr/local/lynis/lynis"

    msg "$(s cyan)Setting up maxinis (security scanner) for host ...$(e)" --caller="${SCRIPT_NAME}"

    msg "Removing old lynis and maxinis installation ..."
    rm -rf "${script_install_path}" "/usr/local/lynis" "/usr/local/bin/maxinis" "/usr/local/bin/lynis" "/usr/bin/maxinis" "/usr/bin/lynis"
    get_status_message "$?"

    msg "Getting latest version of lynis ..."
    lynis_latest_version=$(curl 'https://downloads.cisofy.com/lynis/' | grep -oP 'href="lynis-\K[0-9]+\.[0-9]+\.[0-9]+' | sort -t. -rn -k1,1 -k2,2 -k3,3 | head -1)
    msg "Latest version detected as ${lynis_latest_version}. Downloading lynis version ${lynis_latest_version} ..."
    mkdir -p /usr/local/lynis

    navigate_to "/usr/local"

    wget --no-verbose "https://cisofy.com/files/lynis-${lynis_latest_version}.tar.gz"
    msg "Extracting lynis.tar.gz ..."
    tar xfvz "lynis-${lynis_latest_version}.tar.gz"
    rm -f "lynis-${lynis_latest_version}.tar.gz"
    navigate_to "lynis"

    # Lynis original installation
    msg "Giving executable permission for ${lynis_bin} ..."
    chmod +x ${lynis_bin}
    get_status_message "$?"
    msg "Creating symlink for ${lynis_bin} ..."
    ln -s ${lynis_bin} /usr/local/bin
    get_status_message "$?"

    msg "Cloning maxinis from github ..."
    git clone https://github.com/sofibox/maxinis_public "${script_install_path}"
    get_status_message "$?"

    msg "Giving executable permission for ${maxinis_bin} ..."
    chmod +x ${maxinis_bin}
    get_status_message "$?"

    msg "Creating symlink and executable for ${maxinis_bin} ..."
    ln -s ${maxinis_bin} /usr/local/bin
    get_status_message "$?"

    msg "Copying sample config file for ${maxinis_bin} ..."
    cp "${script_install_path}/maxinis.conf.sample" "${script_install_path}/maxinis.conf"
    get_status_message "$?"

    msg "Running maxinis -V ${maxipi_bin} ..."
    maxinis -V
    get_status_message "$?"

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_maxigpg() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi

  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local script_install_path
    script_install_path="/usr/local/maxicode/maxigpg"
    msg "Configuring maxigpg installation in maxicode ..."
    maxibuild --include "maxigpg"

    if [ "${C_GPG_USE_EXISTING_KEY}" == "true" ]; then
      msg "$(s cyan)Note: Using existing GPG key because C_GPG_USE_EXISTING_KEY variable is set to true in config file  ...$(e)" --caller="${SCRIPT_NAME}"

      gpg_private_key="${SCRIPT_PATH}/gpg/gpg_private_key"
      if ! [ -f "${gpg_private_key}.gpg" ]; then
        msg "Error, the encrypted gpg private key file doesn't exist at ${gpg_private_key}.gpg !"
        _exit 1
      fi

      msg "Importing gpg private key from ${gpg_private_key}.gpg ..."
      maxigpg import-key --key-file "${gpg_private_key}.gpg" --passphrase "${C_GPG_PASSPHRASE}" --email "${C_GPG_OWNER_EMAIL}" --trust-key --test-key
      get_status_message "$?"
      echo ""

    else

      msg "Generating new GPG key ..."
      maxigpg create-key --key-type "RSA" --key-size "4096" --expire-date "0" --name "${C_ADMIN_NAME}" --email "${C_GPG_OWNER_EMAIL}" --passphrase "${C_GPG_PASSPHRASE}" --trust-key
      get_status_message "$?"
      echo ""
    fi

    msg "Setting up cache duration ..."
    maxigpg set-cache-duration --duration "${C_GPG_CACHE_DURATION}"
    get_status_message "$?"
    echo ""
    msg "Running maxigpg --init ..."
    maxigpg init --without-prompt
    get_status_message "$?"

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_maxiaide() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local script_install_path
    script_install_path="/usr/local/maxicode/maxiaide"

    msg "Configuring maxiaide installation in maxicode ..."
    maxibuild --include "maxiaide"

    # Check to make sure the custom_rules in maxiaide folder exist
    msg "$(s cyan)Checking if AIDE custom_rules file exist in maxiaide folder ...$(e)" --caller="${SCRIPT_NAME}"
    maxiaide_custom_rules="${SCRIPT_PATH}/maxiaide/custom_rules"
    check_path "${maxiaide_custom_rules}"

    # Copy custom_rules from secure folder:
    msg "$(s cyan)Copying AIDE custom_rules from secure folder into ${script_install_path}/conf/custom_rules ...$(e)" --caller="${SCRIPT_NAME}"
    cp "${maxiaide_custom_rules}" ${script_install_path}/conf/custom_rules
    get_status_message $?
    # Update rule
    msg "$(s cyan)Updating maxiaide new rule ...$(e)" --caller="${SCRIPT_NAME}"
    maxiaide update-rule
    get_status_message $?
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_wpcli() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    msg "Configuring wpcli installation in maxicode ..."

    maxibuild --include "wpcli"

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# maxida is used to manage directadmin functionalities including APIs.
# This is a very important tool if installed with directadmin
# the alias binary name is dacli
configure_maxida() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local script_install_path
    script_install_path="/usr/local/maxicode/maxida"
    msg "Configuring maxida installation in maxicode ..."

    maxibuild --include maxida

    echo ""
    check_finish_reboot "${func_name}"

  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_maxicron() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local maxicron_bin script_install_path
    script_install_path="/usr/local/maxicode/maxicron"
    msg "Configuring maxicron installation in maxicode ..."
    maxibuild --include "git"
    mkdir -p "${script_install_path}"
    maxicron_bin="${script_install_path}/maxicron"

    msg "$(s cyan)Setting up maxicron (cronjob management) for host ...$(e)" --caller="${SCRIPT_NAME}"
    rm -rf "${script_install_path}" "/usr/local/bin/maxicron" "/usr/bin/maxicron"
    get_status_message "$?"

    msg "$(s cyan)Cloning maxicron from github ...$(e)" --caller="${SCRIPT_NAME}"
    git clone https://github.com/sofibox/maxicron_public "${script_install_path}"
    get_status_message "$?"

    msg "Giving executable permission to maxicron ..."
    chmod +x ${maxicron_bin}
    get_status_message "$?"

    msg "Creating symlink for maxicron ..."
    ln -s ${maxicron_bin} /usr/local/bin
    get_status_message "$?"

    msg "Copying sample config file ..."
    cp "${script_install_path}/maxicron.conf.sample" "${script_install_path}/maxicron.conf"
    get_status_message "$?"

    msg "Running maxicron -V ${maxicron_bin} ..."
    maxicron -V
    get_status_message "$?"

    echo ""
    check_finish_reboot "${func_name}"

    # Stopping some services to reduce memory usage like clamav:
    # This is not needed anymore because configure_services() function will manage this at the end of script
    # maxicron stop-some-services

    # 23 */12 * * * /usr/local/subcode/centmin/csfcf.sh csf >/dev/null 2>&1
    # Add the above command in crontab so it will run on startup
    {
      echo "# Stop some high memory processes 180 seconds (or 3 minutes) for each system reboot"
      echo "@reboot sleep 180 && maxicron stop-some-services"
    } >>/etc/crontab

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This maxiclam will manage both clamav and maldet
# TODO make this inside maxibuild
configure_maxiclam() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local maxiclam_bin script_install_path
    script_install_path="/usr/local/maxicode/maxiclam"
    msg "Configuring maxiclam installation in maxicode ..."
    maxibuild --include "git"
    mkdir -p "${script_install_path}"
    maxiclam_bin="${script_install_path}/maxiclam"

    msg "$(s cyan)Removing old maxiclam installation ...$(e)" --caller="${SCRIPT_NAME}"
    rm -rf "${script_install_path}" "/usr/local/bin/maxiclam" "/usr/bin/maxiclam"
    get_status_message "$?"

    msg "$(s cyan)Cloning maxiclam from github ...$(e)" --caller="${SCRIPT_NAME}"
    git clone https://github.com/sofibox/maxiclam_public "${script_install_path}"
    get_status_message "$?"

    msg "Giving executable permission to maxiclam ..."
    chmod +x ${maxiclam_bin}
    get_status_message "$?"

    msg "Creating symlink for maxiclam ..."
    ln -s ${maxiclam_bin} /usr/local/bin
    get_status_message "$?"

    msg "Copying sample config file ..."
    cp "${script_install_path}/maxiclam.conf.sample" "${script_install_path}/maxiclam.conf"
    get_status_message "$?"

    msg "Running maxiclam -V ..."
    maxiclam -V
    get_status_message "$?"

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This will configure maxiwall and suricata installation
configure_maxiwall() {
  #Fixed bug from this helpful solution:
  #https://forum.suricata.io/t/latest-suricata-6-0-2-with-rustc-has-trouble-installing-with-error-could-not-compile-lexical-core/1461/3
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    msg "Installing maxiwall ..."
    maxibuild install "maxiwall"
    echo ""

    msg "$(s cyan)Testing maxiwall ...$(e)" --caller="${SCRIPT_NAME}"

    maxiwall --version

    retval=$?
    if [ ${retval} -eq 0 ]; then
      msg "$(s green)OK, maxiwall has been successfully installed!$(e)" --caller="${SCRIPT_NAME}"
    else
      msg "$(s red)Error, maxiwall has error!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    echo ""
    check_finish_reboot "${func_name}"

  else

    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# For managing cloud storage. Like mounting cloud storage, send file or receive file from cloud. maxicloud will handle that.
# Todo configure maxicloud for backup in DA
configure_maxicloud() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local maxiaide_bin
    local maxicloud_bin maxicloud_conf maxicloud_conf_sample
    maxicloud_bin="/usr/local/maxicode/maxicloud/maxicloud"
    maxicloud_conf="/usr/local/maxicode/maxicloud/maxicloud.conf"
    maxicloud_conf_sample="/usr/local/maxicode/maxicloud/maxicloud.conf.sample"

    if [ -f ${maxicloud_conf_sample} ]; then
      msg "Copying maxicloud sample config into ${maxicloud_conf} ..."
      cp -f ${maxicloud_conf_sample} ${maxicloud_conf}
    else
      msg "Warning, the sample config file ${maxicloud_conf_sample} does not exist. Please inspect the file!"
      exit 1
    fi
    if [ -f ${maxicloud_bin} ]; then
      msg "Creating symlink and executable for ${maxicloud_bin} ..."
      sleep 1
      chmod +x ${maxicloud_bin}
      # Symbolic name
      ln -s ${maxicloud_bin} /usr/local/bin
    else
      msg "Warning, maxicloud doesn't exist in /usr/local/maxicode !"
      exit 1
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This function configure password management of maxipass
configure_maxipass() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local maxipass_bin maxipass_conf maxipass_conf_sample #maxipass_da_conf maxipass_da_conf_sample
    maxipass_bin="/usr/local/maxicode/maxipass/maxipass"
    maxipass_conf="/usr/local/maxicode/maxipass/maxipass.conf"
    maxipass_conf_sample="/usr/local/maxicode/maxipass/maxipass.conf.sample"
    #maxipass_da_conf="/usr/local/maxicode/maxipass/secure/da/da.conf"
    #maxipass_da_conf_sample="/usr/local/maxicode/maxipass/secure/da/da.conf.sample"

    if [ -f ${maxipass_conf_sample} ]; then
      msg "Copying maxipass sample config into ${maxipass_conf} ..."
      cp -f ${maxipass_conf_sample} ${maxipass_conf}
    else
      msg "Warning, the sample config file ${maxipass_conf_sample} does not exist. Please inspect the file!"
      exit 1
    fi

    #if [ -f ${maxipass_da_conf_sample} ]; then
    #  msg "Copying maxipass-da sample config into ${maxipass_da_conf} ..."
    #  cp -f ${maxipass_da_conf_sample} ${maxipass_da_conf}
    #  sleep 1
    # Put admin authentication (this should be encrypted and only accessed by GPG agent):
    #  sed -i "s/^API_USERNAME=.*/API_USERNAME=\"${C_DA_OWNER_USERNAME1}\"/" ${maxipass_da_conf}
    #  sed -i "s/^API_USERPASS=.*/API_USERPASS=\"${C_DA_OWNER_USERPASS1}\"/" ${maxipass_da_conf}
    #else
    #  msg "Warning, the sample config file ${maxipass_da_conf_sample} does not exist. Please inspect the file!"
    #  exit 1
    #fi

    if [ -f ${maxipass_bin} ]; then
      msg "Creating symlink and executable for ${maxipass_bin} ..."
      sleep 1
      chmod +x ${maxipass_bin}
      # Symbolic name
      ln -s ${maxipass_bin} /usr/local/bin
    else
      msg "Warning, maxipass doesn't exist in /usr/local/maxicode !"
      exit 1
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Configure mysqltuner
configure_mysqltuner() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local script_install_path
    script_install_path="/usr/local/opencode/mysqltuner"
    msg "$(s cyan)Creating mysqltuner directory ...$(e)" --caller="${SCRIPT_NAME}"
    maxibuild install mysqltuner
    echo ""

    if command -v mysqltuner &>/dev/null; then
      msg "$(s green)OK, mysqltuner has been installed$(e)" --caller="${SCRIPT_NAME}"
    else
      msg "$(s red)Error, mysqltuner command is missing. Please inspect manually and re-run this script to continue$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi
    echo ""

    msg "$(s cyan)Checking mysqltuner related files ...$(e)" --caller="${SCRIPT_NAME}"
    check_path "/usr/local/opencode/mysqltuner" "/usr/local/opencode/mysqltuner/basic_passwords.txt" "/usr/local/opencode/mysqltuner/vulnerabilities.csv"
    echo ""
    msg "$(s cyan)Scanning mysqltuner ...$(e)" --caller="${SCRIPT_NAME}"
    mysqltuner --passwordfile "${script_install_path}/basic_passwords.txt" --cvefile "${script_install_path}/vulnerabilities.csv"

    # TODO will auto fix mysqltuner suggestion
    #  https://stackoverflow.com/questions/47082865/mariadb-optimization-and-mysqltuner-pl-ram-and-tuning
    #when you execute mysqltuner, you will get suggestion what to tweak for your sql.
    #The mysqltuner will read directadmin mysql.conf password that you have specified before.
    #In case it cannot read and trigger an error.
    #Make sure the password doesn't contain this character > or < because mysqltuner does not support it.
    # Mysqltuner also does not accept this password: )

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_log() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local grep_count

    # The server will be filled with such non intrusive log from /var/log/auth.log:
    # CRON: pam_unix(cron:session): session opened for user root by (uid=0)
    # CRON: pam_unix(cron:session): session closed for user root
    # This will disable the PAM log for user session:
    msg "$(s cyan)Disabling PAM log for user session at /etc/pam.d/common-session-noninteractive ...$(e)" --caller="${SCRIPT_NAME}"
    check_path "/etc/pam.d/common-session-noninteractive"
    echo ""
    msg "$(s cyan)Checking for existing entry ...$(e)" --caller="${SCRIPT_NAME}"
    grep_count=$(grep -ic '^session.*.[success=1 default=ignore].*.pam_succeed_if.so.*.service.*.in.*.cron.*.quiet.*.use_uid' "/etc/pam.d/common-session-noninteractive")
    if [ "${grep_count}" -gt 0 ]; then
      msg "$(s green)OK, existing entry found$(e)" --caller="${SCRIPT_NAME}"
    else
      # This will add a new entry before session required pam_unix.so
      msg "$(s cyan)Notice, existing entry does not exist. Adding new entry ...$(e)" --caller="${SCRIPT_NAME}"
      sed -i 's/^session.*.required.*.pam_unix\.so/session [success=1 default=ignore] pam_succeed_if.so service in cron quiet use_uid\n&/' /etc/pam.d/common-session-noninteractive
      get_status_message "$?"
      echo ""
      msg "$(s cyan)Restarting system cron ...$(e)" --caller="${SCRIPT_NAME}"
      service cron restart
    fi

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Note: it's best not to use owner. Use admin instead to manage DA user for security purpose
# There is no official documentation how to upload a directadmin logo using API through bash/curl.
# It's a a bit tricky how to do this. This is my own method also written in here:
# https://forum.directadmin.com/threads/cmd_api_skins-upload-skin-logo-via-curl-issue.63127/
configure_da_owner_skins() {
  # We can customize this skin evolution based on this file /usr/local/directadmin/data/users/username/skin_customization/evolution/user_options.json
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_conf_file da_temp_dir logo_path default_logo_file dark_mode_logo_file
    da_conf_file="/usr/local/directadmin/conf/directadmin.conf"
    if [ ! -f "${da_conf_file}" ]; then
      msg "$(s red)Error, the directadmin configuration file does not exist!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi
    msg "$(s cyan)Setting directadmin skin setting with recommend values for owner1 ...$(e)" --caller="${SCRIPT_NAME}"
    da_api_admin set-da-skin-settings --skin-name "evolution" --recommend-values
    echo ""

    # This is the part to upload logo
    # Directadmin needs this home temporary folder to hold upload file (this is a must)
    da_temp_dir=$(grep "^tmpdir" "${da_conf_file}" | cut -d= -f2)
    if [ -z "${da_temp_dir}" ]; then
      da_temp_dir="/home/tmp"
    fi
    mkdir -p "${da_temp_dir}"
    logo_path="${LATEST_OS_CODE_PATH}/usr/local/directadmin/logo"

    msg "$(s cyan)Setting directadmin default logo owner1 ...$(e)" --caller="${SCRIPT_NAME}"
    if [[ -f "${logo_path}/default_logo.png" ]]; then
      da_api_admin set-da-logo --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/default_logo.png"
    else
      msg "$(s yellow)Warning, missing logo file default_logo.png. Make sure this file exist in ${logo_path}/default_logo.png!" --caller="${SCRIPT_NAME}"
      msg "$(s yellow)If you want to have this logo, just put it at ${logo_path}/default_logo.png$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""

    msg "$(s cyan)Setting directadmin dark logo owner1 ...$(e)" --caller="${SCRIPT_NAME}"
    if [[ -f "${logo_path}/dark_mode_logo.png" ]]; then
      da_api_admin set-da-logo --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/dark_mode_logo.png"
    else
      msg "$(s yellow)Warning, missing logo file dark_mode_logo.png. Make sure this file exist in ${logo_path}/dark_mode_logo.png!" --caller="${SCRIPT_NAME}"
      msg "$(s yellow)If you want to have this logo, just put it at ${logo_path}/dark_mode_logo.png$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""

    msg "$(s cyan)Setting directadmin favourite icon logo owner1 ...$(e)" --caller="${SCRIPT_NAME}"
    if [[ -f "${logo_path}/favicon.png" ]]; then
      da_api_admin set-da-logo --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/favicon.png"
    else
      msg "$(s yellow)Warning, missing logo file favicon.png. Make sure this file exist in ${logo_path}/favicon.png!" --caller="${SCRIPT_NAME}"
      msg "$(s yellow)If you want to have this logo, just put it at ${logo_path}/favicon.png$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""

    msg "$(s cyan)Setting directadmin default symbol logo owner1 ...$(e)" --caller="${SCRIPT_NAME}"
    if [[ -f "${logo_path}/default_symbol.png" ]]; then
      da_api_admin set-da-logo --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/default_symbol.png"
    else
      msg "$(s yellow)Warning, missing logo file default_symbol.png. Make sure this file exist in ${logo_path}/default_symbol.png!" --caller="${SCRIPT_NAME}"
      msg "$(s yellow)If you want to have this logo, just put it at ${logo_path}/default_symbol.png$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""

    msg "$(s cyan)Setting directadmin dark symbol logo owner1 ...$(e)" --caller="${SCRIPT_NAME}"
    if [[ -f "${logo_path}/dark_symbol.png" ]]; then
      da_api_admin set-da-logo --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/dark_symbol.png"
    else
      msg "$(s yellow)Warning, missing logo file dark_symbol.png. Make sure this file exist in ${logo_path}/dark_symbol.png!" --caller="${SCRIPT_NAME}"
      msg "$(s yellow)If you want to have this logo, just put it at ${logo_path}/dark_symbol.png$(e)" --caller="${SCRIPT_NAME}"
    fi

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Configure DA skins like set the time format, set logo (focus on Evolution Skin)
configure_da_admin_skins() {
  # We can customize this skin evolution based on this file /usr/local/directadmin/data/users/username/skin_customization/evolution/user_options.json
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_conf_file da_temp_dir logo_path default_logo_file dark_mode_logo_file
    da_conf_file="/usr/local/directadmin/conf/directadmin.conf"
    if [ ! -f "${da_conf_file}" ]; then
      msg "$(s red)Error, the directadmin configuration file does not exist!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi
    msg "$(s cyan)Setting directadmin skin setting with recommend values for admin1...$(e)" --caller="${SCRIPT_NAME}"
    da_api_admin set-da-skin-settings --sign-as "admin1" --skin-name "evolution" --recommend-values
    echo ""
    # There is no official documentation how to upload a directadmin logo using API. This is my own method also written in here:
    # https://forum.directadmin.com/threads/cmd_api_skins-upload-skin-logo-via-curl-issue.63127/

    # This is the part to upload logo
    # Directadmin needs this home temporary folder to hold upload file (this is a must)
    da_temp_dir=$(grep "^tmpdir" "${da_conf_file}" | cut -d= -f2)
    if [ -z "${da_temp_dir}" ]; then
      da_temp_dir="/home/tmp"
    fi
    mkdir -p "${da_temp_dir}"
    logo_path="${LATEST_OS_CODE_PATH}/usr/local/directadmin/logo"

    msg "$(s cyan)Setting directadmin default logo for admin1 ...$(e)" --caller="${SCRIPT_NAME}"
    if [[ -f "${logo_path}/default_logo.png" ]]; then
      da_api_admin set-da-logo --sign-as "admin1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/default_logo.png"
    else
      msg "$(s yellow)Warning, missing logo file default_logo.png. Make sure this file exist in ${logo_path}/default_logo.png!" --caller="${SCRIPT_NAME}"
      msg "$(s yellow)If you want to have this logo, just put it at ${logo_path}/default_logo.png$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""

    msg "$(s cyan)Setting directadmin dark logo for admin1 ...$(e)" --caller="${SCRIPT_NAME}"
    if [[ -f "${logo_path}/dark_mode_logo.png" ]]; then
      da_api_admin set-da-logo --sign-as "admin1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/dark_mode_logo.png"
    else
      msg "$(s yellow)Warning, missing logo file dark_mode_logo.png. Make sure this file exist in ${logo_path}/dark_mode_logo.png!" --caller="${SCRIPT_NAME}"
      msg "$(s yellow)If you want to have this logo, just put it at ${logo_path}/dark_mode_logo.png$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""

    msg "$(s cyan)Setting directadmin favourite icon logo for admin1 ...$(e)" --caller="${SCRIPT_NAME}"
    if [[ -f "${logo_path}/favicon.png" ]]; then
      da_api_admin set-da-logo --sign-as "admin1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/favicon.png"
    else
      msg "$(s yellow)Warning, missing logo file favicon.png. Make sure this file exist in ${logo_path}/favicon.png!" --caller="${SCRIPT_NAME}"
      msg "$(s yellow)If you want to have this logo, just put it at ${logo_path}/favicon.png$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""

    msg "$(s cyan)Setting directadmin default symbol logo for admin1 ...$(e)" --caller="${SCRIPT_NAME}"
    if [[ -f "${logo_path}/default_symbol.png" ]]; then
      da_api_admin set-da-logo --sign-as "admin1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/default_symbol.png"
    else
      msg "$(s yellow)Warning, missing logo file default_symbol.png. Make sure this file exist in ${logo_path}/default_symbol.png!" --caller="${SCRIPT_NAME}"
      msg "$(s yellow)If you want to have this logo, just put it at ${logo_path}/default_symbol.png$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""

    msg "$(s cyan)Setting directadmin dark symbol logo for admin1 ...$(e)" --caller="${SCRIPT_NAME}"
    if [[ -f "${logo_path}/dark_symbol.png" ]]; then
      da_api_admin set-da-logo --sign-as "admin1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/dark_symbol.png"
    else
      msg "$(s yellow)Warning, missing logo file dark_symbol.png. Make sure this file exist in ${logo_path}/dark_symbol.png!" --caller="${SCRIPT_NAME}"
      msg "$(s yellow)If you want to have this logo, just put it at ${logo_path}/dark_symbol.png$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_reseller_skins() {
  # We can customize this skin evolution based on this file /usr/local/directadmin/data/users/username/skin_customization/evolution/user_options.json
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_conf_file da_temp_dir logo_path default_logo_file dark_mode_logo_file
    da_conf_file="/usr/local/directadmin/conf/directadmin.conf"
    if [ ! -f "${da_conf_file}" ]; then
      msg "$(s red)Error, the directadmin configuration file does not exist!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi
    msg "$(s cyan)Setting directadmin skin setting with recommend values for admin1...$(e)" --caller="${SCRIPT_NAME}"
    da_api_admin set-da-skin-settings --sign-as "reseller1" --skin-name "evolution" --recommend-values
    echo ""
    # There is no official documentation how to upload a directadmin logo using API. This is my own method also written in here:
    # https://forum.directadmin.com/threads/cmd_api_skins-upload-skin-logo-via-curl-issue.63127/

    # This is the part to upload logo
    # Directadmin needs this home temporary folder to hold upload file (this is a must)
    da_temp_dir=$(grep "^tmpdir" "${da_conf_file}" | cut -d= -f2)
    if [ -z "${da_temp_dir}" ]; then
      da_temp_dir="/home/tmp"
    fi
    mkdir -p "${da_temp_dir}"
    logo_path="${LATEST_OS_CODE_PATH}/usr/local/directadmin/logo"

    msg "$(s cyan)Setting directadmin default logo for reseller1 ...$(e)" --caller="${SCRIPT_NAME}"
    if [[ -f "${logo_path}/default_logo.png" ]]; then
      da_api_admin set-da-logo --sign-as "reseller1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/default_logo.png"
    else
      msg "$(s yellow)Warning, missing logo file default_logo.png. Make sure this file exist in ${logo_path}/default_logo.png!" --caller="${SCRIPT_NAME}"
      msg "$(s yellow)If you want to have this logo, just put it at ${logo_path}/default_logo.png$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""

    msg "$(s cyan)Setting directadmin dark logo for reseller1 ...$(e)" --caller="${SCRIPT_NAME}"
    if [[ -f "${logo_path}/dark_mode_logo.png" ]]; then
      da_api_admin set-da-logo --sign-as "reseller1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/dark_mode_logo.png"
    else
      msg "$(s yellow)Warning, missing logo file dark_mode_logo.png. Make sure this file exist in ${logo_path}/dark_mode_logo.png!" --caller="${SCRIPT_NAME}"
      msg "$(s yellow)If you want to have this logo, just put it at ${logo_path}/dark_mode_logo.png$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""

    msg "$(s cyan)Setting directadmin favourite icon logo for reseller1 ...$(e)" --caller="${SCRIPT_NAME}"
    if [[ -f "${logo_path}/favicon.png" ]]; then
      da_api_admin set-da-logo --sign-as "reseller1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/favicon.png"
    else
      msg "$(s yellow)Warning, missing logo file favicon.png. Make sure this file exist in ${logo_path}/favicon.png!" --caller="${SCRIPT_NAME}"
      msg "$(s yellow)If you want to have this logo, just put it at ${logo_path}/favicon.png$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""

    msg "$(s cyan)Setting directadmin default symbol logo for reseller1 ...$(e)" --caller="${SCRIPT_NAME}"
    if [[ -f "${logo_path}/default_symbol.png" ]]; then
      da_api_admin set-da-logo --sign-as "reseller1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/default_symbol.png"
    else
      msg "$(s yellow)Warning, missing logo file default_symbol.png. Make sure this file exist in ${logo_path}/default_symbol.png!" --caller="${SCRIPT_NAME}"
      msg "$(s yellow)If you want to have this logo, just put it at ${logo_path}/default_symbol.png$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""

    msg "$(s cyan)Setting directadmin dark symbol logo for reseller1 ...$(e)" --caller="${SCRIPT_NAME}"
    if [[ -f "${logo_path}/dark_symbol.png" ]]; then
      da_api_admin set-da-logo --sign-as "reseller1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/dark_symbol.png"
    else
      msg "$(s yellow)Warning, missing logo file dark_symbol.png. Make sure this file exist in ${logo_path}/dark_symbol.png!" --caller="${SCRIPT_NAME}"
      msg "$(s yellow)If you want to have this logo, just put it at ${logo_path}/dark_symbol.png$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_admin_admin_settings() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    ###
    # TODO
    ###

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Remember that all record created here need to wait for propagation time before they become available
configure_da_reseller_wildcard_domains() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local reseller_count da_reseller_usernames_count
    reseller_count=1
    da_reseller_usernames_count=$(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w)
    while [ ${reseller_count} -le "${da_reseller_usernames_count}" ]; do
      local da_reseller_username da_reseller_wildcard_domains da_reseller_wildcard_domains_count wildcard_domain_count
      typeset -n "da_reseller_username=C_DA_RESELLER_USERNAME${reseller_count}"
      typeset -n "da_reseller_wildcard_domains=C_DA_RESELLER_WILDCARD_DOMAIN${reseller_count}"
      da_reseller_wildcard_domains_count="${#da_reseller_wildcard_domains[@]}"
      msg "$(s newline)"
      msg "$(s yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"
      msg "Reseller domain wildcard details:" --caller="${SCRIPT_NAME}"
      msg "Reseller count ${reseller_count} out of ${da_reseller_usernames_count}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_username: ${da_reseller_username}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_wildcard_domains: ${da_reseller_wildcard_domains[*]}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_wildcard_domains_count: ${da_reseller_wildcard_domains_count}" --caller="${SCRIPT_NAME}"
      msg "$(s newline)"

      wildcard_domain_count=0
      while [ ${wildcard_domain_count} -le $((da_reseller_wildcard_domains_count - 1)) ]; do
        for wildcard_domain in ${da_reseller_wildcard_domains}; do
          msg "Wildcard domain for reseller: ${da_reseller_username}" --caller="${SCRIPT_NAME}"
          msg "Wildcard domain: ${wildcard_domain}" --caller="${SCRIPT_NAME}"
          msg "$(s newline)"
          msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"
          msg "$(s cyan)Creating wildcard entry for domain ${wildcard_domain} for IPv4 in directadmin ...$(e)" --caller="${SCRIPT_NAME}"
          # By default DA don't create wildcard entry for this domain (unless wildcard option is enabled)
          # Note, if record already exist, it won't create in directadmin DNS record
          da_api_admin create-dns-record --sign-as "${da_reseller_username}" --domain "${wildcard_domain}" --record-type "A" --record-name "*" --record-value "${C_IPV4_ADD0}" --record-ttl 30 --affect-pointers yes
          echo ""
          msg "$(s cyan)Creating wildcard entry for domain ${wildcard_domain} for IPv6 in directadmin ...$(e)" --caller="${SCRIPT_NAME}"
          # For directadmin need to convert IPv6 address, else it will not accept
          da_api_admin create-dns-record --sign-as "${da_reseller_username}" --domain "${wildcard_domain}" --record-type "AAAA" --record-name "*" --record-value "$(ipv6calc --addr2uncompaddr "${C_IPV6_ADD0}")" --record-ttl 30 --affect-pointers yes
          echo ""

          if [ "${C_DNS_PROVIDER_NAME}" == "linode" ]; then
            msg "$(s cyan)Notice, DNS provider is set to linode. Using linode API ...$(e)" --caller="${SCRIPT_NAME}"
            # We do not need to delete existing record in linode because we ran the --rebuild command to create this domain.
            msg "$(s cyan)Adding wildcard domain ${wildcard_domain} record for IPv4 in linode$(e)" --caller="${SCRIPT_NAME}"
            maxipi linode create-dns-record --for-domain "${wildcard_domain}" --record-type "A" --record-name "*" --record-value "${C_IPV4_ADD0}" --record-ttl 30
            get_status_message "$?"
            echo ""
            msg "$(s cyan)Adding wildcard domain ${wildcard_domain} record for IPv6 in linode$(e)" --caller="${SCRIPT_NAME}"
            maxipi linode create-dns-record --for-domain "${wildcard_domain}" --record-type "AAAA" --record-name "*" --record-value "${C_IPV6_ADD0}" --record-ttl 30
            get_status_message "$?"
            echo ""
          elif [ "${C_DNS_PROVIDER_NAME}" == "digitalocean" ]; then
            msg "$(s cyan)Notice, DNS provider is set to digitalocean$(e)" --caller="${SCRIPT_NAME}"
            # Call digitalocean_api_admin
            # elif other provider
          elif [ "${C_DNS_PROVIDER_NAME}" == "local" ]; then
            msg "$(s cyan)Notice, DNS provider is set to local (Internal DNS)$(e)" --caller="${SCRIPT_NAME}"
            # Do nothing
          fi
        done
        ((wildcard_domain_count++))
      done
      ((reseller_count++))
    done
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_reseller_email_accounts() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local reseller_count da_reseller_usernames_count
    da_reseller_usernames_count=$(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w)
    reseller_count=1
    while [[ ${reseller_count} -le ${da_reseller_usernames_count} ]]; do
      local da_reseller_username da_reseller_mail_accounts da_reseller_mail_accounts_count
      typeset -n "da_reseller_username=C_DA_RESELLER_USERNAME${reseller_count}"
      typeset -n "da_reseller_mail_accounts=C_DA_RESELLER_MAIL_ACCOUNT${reseller_count}"
      da_reseller_mail_accounts_count="${#da_reseller_mail_accounts[@]}"

      msg "$(s newline)"
      msg "$(s yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"
      msg "Reseller email details:" --caller="${SCRIPT_NAME}"
      msg "Reseller count ${reseller_count} out of ${da_reseller_usernames_count}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_username: ${da_reseller_username}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_mail_accounts: ${da_reseller_mail_accounts[*]}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_mail_accounts_count: ${da_reseller_mail_accounts_count}" --caller="${SCRIPT_NAME}"

      if [ "${da_reseller_mail_accounts_count}" -eq 0 ]; then
        msg "$(s yellow)Notice, this reseller ${da_reseller_username} does not have email set$(e)" --caller="${SCRIPT_NAME}"
      else
        mail_count=1
        while [ ${mail_count} -le ${da_reseller_mail_accounts_count} ]; do
          local mail_user_domain mail_user mail_domain mail_password
          mail_user_domain=$(echo "${da_reseller_mail_accounts[mail_count - 1]}" | awk -F'\|\|\|' '{ print $1 }')
          mail_user=$(echo "${mail_user_domain}" | awk -F'@' '{ print $1 }')
          mail_domain=$(echo "${mail_user_domain}" | awk -F'@' '{ print $2 }')
          mail_password=$(echo "${da_reseller_mail_accounts[mail_count - 1]}" | awk -F'\|\|\|' '{ print $2 }')
          msg "$(s newline)"
          msg "Reseller email count ${mail_count}/$((da_reseller_mail_accounts_count))" --caller="${SCRIPT_NAME}"
          msg "Reseller_username: ${da_reseller_username}" --caller="${SCRIPT_NAME}"
          msg "mail_user_domain (full email): ${mail_user_domain}" --caller="${SCRIPT_NAME}"
          msg "mail_user (without @domain.com): ${mail_user}" --caller="${SCRIPT_NAME}"
          msg "mail_domain: ${mail_domain}" --caller="${SCRIPT_NAME}"
          msg "mail_password: ${mail_password}" --caller="${SCRIPT_NAME}"
          msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"

          # da_api_admin create-user-email --mail-domain "maxibi.com" --mail-user "webmaster" --mail-password "1232123" --mail-quota "0" --mail-limit "200"
          msg "$(s cyan)Creating new reseller email ${mail_user_domain} ...$(e)" --caller="${SCRIPT_NAME}"
          da_api_admin create-user-email --sign-as ${da_reseller_username} --mail-domain "${mail_domain}" --mail-user "${mail_user}" --mail-password "${mail_password}" --mail-quota "0" --mail-limit "200"

          ((mail_count++))
        done
      fi
      ((reseller_count++))
    done

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Deprecated function
configure_da_reseller_emails() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local reseller_count da_reseller_usernames_count
    da_reseller_usernames_count=$(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w)
    reseller_count=1
    while [[ ${reseller_count} -le ${da_reseller_usernames_count} ]]; do

      local da_reseller_username da_reseller_mail_users da_reseller_mail_passwords

      typeset -n "da_reseller_username=C_DA_RESELLER_USERNAME${reseller_count}"
      typeset -n "da_reseller_mail_users=C_DA_RESELLER_MAIL_USER${reseller_count}"
      typeset -n "da_reseller_mail_passwords=C_DA_RESELLER_MAIL_PASSWORD${reseller_count}"
      da_reseller_mail_users_count="${#da_reseller_mail_users[@]}"

      msg "$(s newline)"
      msg "$(s yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"
      msg "Reseller email details:" --caller="${SCRIPT_NAME}"
      msg "Reseller count ${reseller_count} out of ${da_reseller_usernames_count}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_username: ${da_reseller_username}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_mail_users: ${da_reseller_mail_users[*]}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_mail_passwords: ${da_reseller_mail_passwords[*]}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_mail_users_count: ${da_reseller_mail_users_count}" --caller="${SCRIPT_NAME}"
      msg "$(s newline)"
      mail_count=1

      while [ ${mail_count} -le ${da_reseller_mail_users_count} ]; do
        mail_user=$(echo "${da_reseller_mail_users[mail_count - 1]}" | awk -F'@' '{ print $1 }')
        mail_domain=$(echo "${da_reseller_mail_users[mail_count - 1]}" | awk -F'@' '{ print $2 }')
        mail_password=${da_reseller_mail_passwords[mail_count - 1]}
        msg "Reseller email count ${mail_count}/$((da_reseller_mail_users_count))" --caller="${SCRIPT_NAME}"
        msg "Reseller_username: ${da_reseller_username}" --caller="${SCRIPT_NAME}"
        msg "Reseller full user email address: [${mail_count}]: ${da_reseller_mail_users[mail_count - 1]}" --caller="${SCRIPT_NAME}"
        msg "Reseller user email address (without @domain.com): ${mail_user}" --caller="${SCRIPT_NAME}"
        msg "Reseller email domain: ${mail_domain}" --caller="${SCRIPT_NAME}"
        msg "Reseller email password:[${mail_count}]: ${da_reseller_mail_passwords[mail_count - 1]}" --caller="${SCRIPT_NAME}"
        msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"

        ## da_api_admin create-user-email --mail-domain "maxibi.com" --mail-user "webmaster" --mail-password "1232123" --mail-quota "0" --mail-limit "200"
        msg "$(s cyan)Creating new user email ${da_reseller_mail_users[mail_count - 1]} ...$(e)" --caller="${SCRIPT_NAME}"
        da_api_admin create-user-email --sign-as ${da_reseller_username} --mail-domain "${mail_domain}" --mail-user "${mail_user}" --mail-password "${mail_password}" --mail-quota "0" --mail-limit "200"

        ((mail_count++))
      done
      ((reseller_count++))
    done

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Function to create all reseller databases
configure_da_reseller_databases() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local reseller_count da_reseller_usernames_count
    da_reseller_usernames_count=$(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w)
    reseller_count=1
    while [[ ${reseller_count} -le ${da_reseller_usernames_count} ]]; do
      typeset -n "da_reseller_username=C_DA_RESELLER_USERNAME${reseller_count}"
      typeset -n "da_reseller_db_accounts=C_DA_RESELLER_DB_ACCOUNT${reseller_count}"
      msg "$(s newline)"
      msg "$(s yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"
      msg "Reseller database details:" --caller="${SCRIPT_NAME}"
      msg "Reseller count ${reseller_count} out of ${da_reseller_usernames_count}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_username: ${da_reseller_username}" --caller="${SCRIPT_NAME}"
      msg "da_reseller_db_accounts: ${da_reseller_db_accounts[*]}" --caller="${SCRIPT_NAME}"
      da_reseller_db_accounts_count="${#da_reseller_db_accounts[@]}"
      database_count=1

      if [[ "${#da_reseller_db_accounts}" == 0 ]]; then
        msg "$(s yellow)[skipped]: Value defined for this reseller ${da_reseller_username} database is empty$(e)" --caller="${SCRIPT_NAME}"
      else
        while [ ${database_count} -le ${da_reseller_db_accounts_count} ]; do
          db_domain_name_user=$(echo "${da_reseller_db_accounts[database_count - 1]}" | awk -F'\|\|\|' '{ print $1 }')
          db_password=$(echo "${da_reseller_db_accounts[database_count - 1]}" | awk -F'\|\|\|' '{ print $2 }')
          db_domain=$(echo "${db_domain_name_user}" | awk -F':' '{ print $1 }')
          db_name=$(echo "${db_domain_name_user}" | awk -F':' '{ print $2 }')
          db_user=$(echo "${db_domain_name_user}" | awk -F':' '{ print $3 }')
          sql_users=$(mysql -e "SELECT USER FROM mysql.user;" | jq -rR .)
          sql_user_exist=$(echo "${sql_users}" | grep "${da_reseller_username}_${db_user}")

          msg "Reseller database count ${database_count}/$((da_reseller_db_accounts_count))" --caller="${SCRIPT_NAME}"
          [[ -n "${sql_user_exist}" ]] && msg "sql_user_exist in mysql system: ${sql_user_exist}" --caller="${SCRIPT_NAME}"
          msg "db_domain: ${db_domain}" --caller="${SCRIPT_NAME}"
          msg "db_name: ${db_name}" --caller="${SCRIPT_NAME}"
          msg "db_user: ${db_user}" --caller="${SCRIPT_NAME}"
          msg "db_password: ${db_password}" --caller="${SCRIPT_NAME}"
          msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"
          msg "$(s newline)"

          #da_api_admin create-user-database --db-domain "maxibi.com" --db-name abc --db-user maxibi --db-password 12321aa (create new user database)

          #da_api_admin --db-domain "maxibi.com" create-user-database --db-name abc --existing-user maxibi  (create database with existing user)

          if [[ -z "${sql_user_exist}" ]]; then
            msg "$(s cyan)Creating new database name ${db_name} for reseller ${da_reseller_username} on domain ${db_domain} ...$(e)" --caller="${SCRIPT_NAME}"
            da_api_admin create-user-database --sign-as "${da_reseller_username}" --db-domain "${db_domain}" --db-name "${db_name}" --db-user "${db_user}" --db-password "${db_password}"
          else
            msg "$(s cyan)Creating new database name ${db_name} for reseller ${da_reseller_username} on domain ${db_domain} using existing username ${db_user} ...$(e)" --caller="${SCRIPT_NAME}"
            da_api_admin create-user-database --sign-as "${da_reseller_username}" --db-domain "${db_domain}" --db-name "${db_name}" --db-existing-user "${db_user}"
          fi

          ((database_count++))
        done
      fi
      ((reseller_count++))
    done

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This will create user accounts and domains
configure_da_user_accounts() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local da_user_packages_list count_user1 \
      da_user_creator da_user_role da_user_restore_user_backup da_user_uname da_user_password da_user_name da_user_system_email \
      da_user_mail_users da_user_mail_passwords da_user_domains da_user_ip_type da_user_package_name da_user_enable_domain_ssl \
      da_scripts_path da_bin da_cb_bin da_conf retval grep_count

    da_scripts_path="/usr/local/directadmin/scripts"
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    msg "$(s cyan)Checking if required files are presents ...$(e)" --caller="${SCRIPT_NAME}"
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}" "${da_scripts_path}/decrypt_file.sh"
    echo ""
    # This file contains list of user packages (use this file for checking existing package)
    da_user_packages_list="/usr/local/directadmin/data/users/${C_DA_RESELLER_USERNAME1}/packages.list"

    # Skip this
    # We can restart directadmin to clear pending Directadmin cron
    #msg "$(s cyan)Requesting directadmin to restart before configuring directadmin accounts ...$(e)" --caller="${SCRIPT_NAME}"
    #restart_da
    #echo ""

    count_user1=1
    # !C_DA_USER_USERNAME@ = Assign all user account based on the variable of C_DA_USER_USERNAME[N] :
    while [[ ${count_user1} -le $(echo "${!C_DA_USER_USERNAME@}" | wc -w) ]]; do
      msg "$(s cyan)Getting all required variables from config file ...$(e)" --caller="${SCRIPT_NAME}"
      typeset -n da_user_creator="C_DA_USER_CREATOR${count_user1}"
      typeset -n da_user_role="C_DA_USER_ROLE${count_user1}"
      typeset -n da_user_restore_user_backup="C_DA_USER_RESTORE_USER_BACKUP${count_user1}"
      typeset -n da_user_uname="C_DA_USER_USERNAME${count_user1}"
      typeset -n da_user_password="C_DA_USER_USERPASS${count_user1}"
      typeset -n da_user_name="C_DA_USER_NAME${count_user1}"
      typeset -n da_user_system_email="C_DA_USER_SYSTEM_EMAIL${count_user1}"
      typeset -n da_user_mail_users="C_DA_USER_MAIL_USER${count_user1}"
      typeset -n da_user_mail_passwords="C_DA_USER_MAIL_PASSWORD${count_user1}"
      typeset -n da_user_domains="C_DA_USER_DOMAIN${count_user1}"
      typeset -n da_user_wildcard_domains="C_DA_USER_WILDCARD_DOMAIN${count_user1}"
      typeset -n da_user_package_name="C_DA_USER_PACKAGE_NAME${count_user1}"
      typeset -n da_user_enable_domain_ssl="C_DA_USER_ENABLE_DOMAIN_SSL${count_user1}"

      msg "$(s cyan)Checking if user package name ${da_user_package_name} was created by previous admin before ...$(e)" --caller="${SCRIPT_NAME}"
      grep_count=$(grep -ic "${da_user_package_name}" "${da_user_packages_list}")
      if [ "${grep_count}" -gt 0 ]; then
        msg "$(s green)OK, user package name ${da_user_package_name} found$(e)" --caller="${SCRIPT_NAME}"
        echo ""
      else
        msg "$(s yellow)Warning, ${da_user_package_name} does not exist in ${da_user_packages_list}. Please inspect why!$(e)" --caller="${SCRIPT_NAME}"
        exit 1
      fi

      # Get the total domain count for this user
      da_user_domain_count="${#da_user_domains[@]}"
      # The first domain in array is used to create account (default domain for that user)
      da_user_domain_first_raw=$(echo "${da_user_domains[@]}" | awk '{ print $1 }')
      da_user_domain_first=$(echo "${da_user_domains[@]}" | awk '{ print $1 }' | awk -F':' '{print $1}')

      msg "$(s newline)"
      msg "$(s yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"
      msg "User config variables:" --caller="${SCRIPT_NAME}"
      msg "User count ${count_user1}/$(echo "${!C_DA_USER_USERNAME@}" | wc -w)" --caller="${SCRIPT_NAME}"
      msg "da_user_creator: ${da_user_creator}" --caller="${SCRIPT_NAME}"
      msg "da_user_role: ${da_user_role}" --caller="${SCRIPT_NAME}"
      msg "da_user_restore_user_backup: ${da_user_restore_user_backup}" --caller="${SCRIPT_NAME}"
      msg "da_user_uname: ${da_user_uname}" --caller="${SCRIPT_NAME}"
      msg "da_user_password: ${da_user_password}" --caller="${SCRIPT_NAME}"
      msg "da_user_name: ${da_user_name}" --caller="${SCRIPT_NAME}"
      msg "da_user_system_email: ${da_user_system_email}" --caller="${SCRIPT_NAME}"
      msg "da_user_mail_users: ${da_user_mail_users[*]}" --caller="${SCRIPT_NAME}"
      msg "da_user_mail_passwords: ${da_user_mail_passwords}" --caller="${SCRIPT_NAME}"
      msg "da_user_domains_with_subdomains: ${da_user_domains[*]}" --caller="${SCRIPT_NAME}"
      msg "da_user_domain_count: ${da_user_domain_count}" --caller="${SCRIPT_NAME}"
      msg "da_user_domain_first_raw: ${da_user_domain_first_raw}" --caller="${SCRIPT_NAME}"
      msg "da_user_domain_first: ${da_user_domain_first}" --caller="${SCRIPT_NAME}"
      msg "da_user_package_name: ${da_user_package_name}" --caller="${SCRIPT_NAME}"
      msg "da_user_enable_domain_ssl: ${da_user_enable_domain_ssl}" --caller="${SCRIPT_NAME}"
      msg "$(s newline)"

      msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s newline)"

      if [[ "${da_user_restore_user_backup}" == "true" && "${C_DA_ENABLE_USER_BACKUP_RESTORE}" == "true" ]]; then
        local backup_source_location backup_source_location_encrypted da_owner_backup_location
        if [[ -f "${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar" ]]; then
          backup_source_location="${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar"
        elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar.enc" ]]; then
          # This is the case if backup is encrypted
          backup_source_location="${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar"
          backup_source_location_encrypted="${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar.enc"
          msg "$(s cyan)Decrypting backup file ${backup_source_location_encrypted} ...$(e)" --caller="${SCRIPT_NAME}"
          echo "${C_DA_USER_BACKUP_PASSWORD}" >"${SECURE_PATH}/backup_file"
          ${da_scripts_path}/decrypt_file.sh "${backup_source_location_encrypted}" "${backup_source_location}" "${SECURE_PATH}/backup_file"
          get_status_message "$?"
          echo ""
          msg "$(s cyan)Removing backup password file ${SECURE_PATH}/backup_file ...$(e)" --caller="${SCRIPT_NAME}"
          rm -f "${SECURE_PATH}/backup_file"
          get_status_message "$?"
          echo ""
        elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar.gz" ]]; then
          # This is the case if backup is not encrypted (and file type is .tar.gz)
          backup_source_location="${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar.gz"
        elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar.gz.enc" ]]; then
          # This is the case if backup is encrypted
          backup_source_location="${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar.gz"
          backup_source_location_encrypted="${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar.gz.enc"
          # Note when I use API with supplying decryption password (even the password is decoded), it will not work (this might be bug in DA):
          # Decryption of /home/....tar.gz.enc has failed: Either dest_file, encrypted_file, or encryption_password variables are missing or empty.
          # Alternatively I will use the decryption script to decrypt the file manually in Directadmin
          msg "$(s cyan)Decrypting backup file ${backup_source_location_encrypted} ...$(e)" --caller="${SCRIPT_NAME}"
          echo "${C_DA_USER_BACKUP_PASSWORD}" >"${SECURE_PATH}/backup_file"
          ${da_scripts_path}/decrypt_file.sh "${backup_source_location_encrypted}" "${backup_source_location}" "${SECURE_PATH}/backup_file"
          get_status_message "$?"
          echo ""
          msg "$(s cyan)Removing backup password file ${SECURE_PATH}/backup_file ...$(e)" --caller="${SCRIPT_NAME}"
          rm -f "${SECURE_PATH}/backup_file"
          get_status_message "$?"
          echo ""
        elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar.zst" ]]; then
          # This is the case if backup is not encrypted (and file type is .tar.zst)
          backup_source_location="${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar.zst"
        elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar.zst.enc" ]]; then
          # This is the case if backup is encrypted
          backup_source_location="${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar.zst"
          backup_source_location_encrypted="${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar.zst.enc"
          msg "$(s cyan)Decrypting backup file ${backup_source_location_encrypted} ...$(e)" --caller="${SCRIPT_NAME}"
          echo "${C_DA_USER_BACKUP_PASSWORD}" >"${SECURE_PATH}/backup_file"
          ${da_scripts_path}/decrypt_file.sh "${backup_source_location_encrypted}" "${backup_source_location}" "${SECURE_PATH}/backup_file"
          get_status_message "$?"
          echo ""
          msg "$(s cyan)Removing backup password file ${SECURE_PATH}/backup_file ...$(e)" --caller="${SCRIPT_NAME}"
          rm -f "${SECURE_PATH}/backup_file"
          get_status_message "$?"
          echo ""
        else
          echo "Backup file does not exist for this user ${da_user_uname}. If you want to ignore this backup, disable this user backup restoration from config file "
          _confirm
        fi

        if [ -f "${backup_source_location}" ]; then
          msg "$(s green)OK, backup source location exist: ${backup_source_location}$(e)" --caller="${SCRIPT_NAME}"
        else
          msg "$(s red)Error, no backup file exist in ${backup_source_location}$(e)" --caller="${SCRIPT_NAME}"
          exit 1
        fi
        echo ""

        da_owner_backup_location=/home/$(get_current_da_owner_username)/admin_backups/$(basename -- ${backup_source_location})
        msg "$(s cyan)Copying backup from ${backup_source_location} to ${da_owner_backup_location}... $(e)" --caller="${SCRIPT_NAME}"
        cp -fp "${backup_source_location}" "${da_owner_backup_location}"
        get_status_message "$?"
        if [ -f "${da_owner_backup_location}" ]; then
          msg "$(s green)OK, the user backup file was copied in owner backup location at ${da_owner_backup_location}$(e)" --caller="${SCRIPT_NAME}"
        else
          msg "$(s red)Error, the user backup file does not exist in owner backup location at ${da_owner_backup_location} after performed a copy operation$(e)" --caller="${SCRIPT_NAME}"
          exit 1
        fi
        echo ""
        msg "$(s cyan)Changing file owner permission for ${da_owner_backup_location} ...$(e)" --caller="${SCRIPT_NAME}"
        chown "$(get_current_da_owner_username):$(get_current_da_owner_username)" "${da_owner_backup_location}"
        get_status_message "$?"
        echo ""
        msg "$(s cyan)Changing file permission for ${da_owner_backup_location} ...$(e)" --caller="${SCRIPT_NAME}"
        chmod 640 "${da_owner_backup_location}"
        get_status_message "$?"
        echo ""
        da_api_admin restore-user-backup --backup-ip "${C_IPV4_ADD0}" --backup-path "$(dirname ${da_owner_backup_location})" --backup-file-name "$(basename -- ${da_owner_backup_location})" --backup-password ${C_DA_USER_BACKUP_PASSWORD}
        echo ""
        # We knew it will generate this /etc/virtual/domainowners after we have restored the backup file
        msg "$(s cyan) Getting list of all domains created from backup ...$(e)" --caller="${SCRIPT_NAME}"
        readarray -t da_domains <<<"$(grep -w "${da_user_uname}" "/etc/virtual/domainowners" | cut -d ":" -f 1)"
        echo ""
        if [ -n "${da_domains}" ]; then
          echo "Domains list for ${da_user_uname}:"
          echo "${da_domains[*]}"
          echo ""
          for da_domain in "${da_domains[@]}"; do
            msg "$(s cyan)Writing all DNS record for domain ${da_domain} to external DNS ...$(e)" --caller="${SCRIPT_NAME}"
            copy_local_dns_to_external_dns "${da_domain}"
            echo ""
          done
        else
          msg "$(s yellow)[Skipped]: The user ${da_owner_username} does not have any domain record$(e)" --caller="${SCRIPT_NAME}"
        fi
      else
        # Note 1: To create a user, we need to use an reseller account:
        msg "$(s cyan)Creating a new user account ${da_user_uname} ${count_user1} out of $(echo "${!C_DA_USER_USERNAME@}" | wc -w) user(s) ... $(e)" --caller="${SCRIPT_NAME}"
        # da_api_admin create-user-account --username abc --email abc@dsa.com --password 12321aa --domain maxibi.com --package_name USER_UNLIMITED --ip-address "${C_IPV4_ADD0}"
        da_api_admin create-user-account --sign-as reseller1 --username "${da_user_uname}" --email "${da_user_system_email}" --password "${da_user_password}" \
          --domain "${da_user_domain_first}" --package-name "${da_user_package_name}" --ip-address "${C_IPV4_ADD0}"
        echo ""
        msg "$(s cyan)Renaming user account name to ${da_user_name} ...$(e)" --caller="${SCRIPT_NAME}"
        da_api_admin modify-user --sign-as reseller1 --where-username-is "${da_user_uname}" --caller="${SCRIPT_NAME}" "${da_user_name}"
        echo ""
        # Now login as user and enable its own email DKIM. We can use user account to configure its own user-level variable settings like DKIM or DNS records
        msg "$(s cyan)Enabling email/domain DKIM for user ${da_user_uname} with default domain of ${da_user_domain_first} ...$(e)" --caller="${SCRIPT_NAME}"
        # Note 1: We dont use user1 because currently user can have 1 or more (this script support multiple creation of user)
        # eg: --sign-as ${da_user_uname}
        da_api_admin enable-email-dkim --sign-as "${da_user_uname}" --domain "${da_user_domain_first}"
        echo ""

        # Use user above and create TXT record _domainkey for DKIM signing policy (this should have have been done using dns_txt.conf but it has bug)
        # so, we manually add this using API here: https://forum.directadmin.com/threads/possible-bug-when-using-dns_txt-conf-with-api-include-step-to-reproduce.63247/
        msg "$(s cyan)Creating DKIM signing policy TXT record for ${da_user_domain_first} ...$(e)" --caller="${SCRIPT_NAME}"
        # This value "o%3D%7E%3B+r%3Dwebmaster%40${da_user_domain_first}" (encoded) is equal to "_domainkey="o=~; r=webmaster@${da_user_domain_first}"
        # No need to encode the value, it's working it seems like directadmin know how to handle this data in API, in debug mode it added extra quote for the value
        da_api_admin create-dns-record --sign-as "${da_user_uname}" --domain "${da_user_domain_first}" --record-type TXT --record-name "_domainkey" --record-value "o=~; r=webmaster@${da_user_domain_first}" --record-ttl 30 --affect-pointers yes
        echo ""
        msg "$(s cyan)Creating Mail MX record for ${da_user_domain_first} without subdomain ...$(e)" --caller="${SCRIPT_NAME}"
        da_api_admin create-dns-record --sign-as "${da_user_uname}" --domain "${da_user_domain_first}" --record-type MX --record-domain "${da_user_domain_first}." --record-priority "10" --record-subdomain "${da_reseller_domain_first}." --record-ttl 30 --affect-pointers yes
        echo ""

        # Adding extra subdomain starting here for first domain
        #
        local da_user_domain_first_sub_domains
        readarray -t da_user_domain_first_sub_domains <<<"$(echo ${da_user_domain_first_raw} | awk -F':' '{print $2}' | awk -F',' '{for (i=1;i<=NF;i++)print $i}')"

        echo "da_user_domain_first_sub_domains: ${da_user_domain_first_sub_domains}"

        if [ -n "${da_user_domain_first_sub_domains}" ]; then
          for da_user_subdomain_first in "${da_user_domain_first_sub_domains[@]}"; do
            msg "$(s cyan)Creating user ${da_user_uname} subdomain ${da_user_subdomain_first}.${da_user_domain_first}$(e)" --caller="${SCRIPT_NAME}"
            da_api_admin create-user-subdomain --sign-as "${da_user_uname}" --domain "${da_user_domain_first}" --subdomain "${da_user_subdomain_first}"
            echo ""
          done
        else
          msg "$(s yellow)Notice: Skipped creating subdomain for domain ${da_user_domain_first} because it does not have subdomains defined in config file$(e)" --caller="${SCRIPT_NAME}"
        fi

        copy_local_dns_to_external_dns "${da_user_domain_first}"
        echo ""
        # This will be executed if user has more than 1 domains. We add the extra domains here and skipped the default domain:
        if [ "${da_user_domain_count}" -gt 1 ]; then
          msg "$(s cyan)Notice, this user ${da_user_uname} has ${da_user_domain_count} domains$(e)" --caller="${SCRIPT_NAME}"
          for extra_domain_raw in "${da_user_domains[@]}"; do
            local extra_domain extra_subdomains_raw extra_subdomains
            # Here, we don't add the first domain, we did that before when we first create user user account where directadmin automatically add this default or first domain
            extra_domain=$(echo "${extra_domain_raw}" | awk -F':' '{ print $1 }')
            extra_subdomains_raw=$(echo "${extra_domain_raw}" | awk -F':' '{ print $2 }')
            readarray -t extra_subdomains <<<"$(echo "${extra_subdomains_raw}" | awk -F',' '{for (i=1;i<=NF;i++)print $i}')"
            echo "extra_domain_raw:${extra_domain_raw}"
            echo "extra_domain: ${extra_domain}"
            echo "extra_subdomains_raw: ${extra_subdomains_raw}"
            echo "extra_subdomains: ${extra_subdomains[*]}"
            echo "================================================"
            if [[ "${extra_domain}" == "${da_user_domain_first}" ]]; then
              # Skip the domain that has been added before
              msg "$(s cyan)Skipped adding the default domain: ${da_user_domain_first}$(e)" --caller="${SCRIPT_NAME}"
              continue
            fi
            msg "$(s cyan)Creating extra domain ${extra_domain} for user ${da_user_uname} ...$(e)" --caller="${SCRIPT_NAME}"
            da_api_admin create-domain --sign-as "${da_user_uname}" --domain "${extra_domain}" --recommend-values
            echo ""
            msg "$(s cyan)Enabling email/domain DKIM for user ${da_user_uname} with extra domain of ${extra_domain} ...$(e)" --caller="${SCRIPT_NAME}"
            da_api_admin enable-email-dkim --sign-as "${da_user_uname}" --domain "${extra_domain}"
            echo ""
            msg "$(s cyan)Creating DKIM signing policy TXT record for extra domain ${extra_domain} ...$(e)" --caller="${SCRIPT_NAME}"
            da_api_admin create-dns-record --sign-as "${da_user_uname}" --domain "${extra_domain}" --record-type TXT --record-name "_domainkey" --record-value "o=~; r=webmaster@${extra_domain}" --record-ttl 30 --affect-pointers yes
            echo ""
            msg "$(s cyan)Creating Mail MX record for ${extra_domain} without subdomain ...$(e)" --caller="${SCRIPT_NAME}"
            da_api_admin create-dns-record --sign-as "${da_user_uname}" --domain "${extra_domain}" --record-type MX --record-domain "${extra_domain}." --record-priority "10" --record-subdomain "${da_reseller_domain_first}." --record-ttl 30 --affect-pointers yes
            echo ""
            # Adding extra subdomains starting here
            if [ -n "${extra_subdomains}" ]; then
              for extra_subdomain in "${extra_subdomains[@]}"; do
                #  echo "extra_subdomain: ${extra_subdomain}"
                msg "$(s cyan)Creating user ${da_user_uname} subdomain ${extra_subdomain}.${extra_domain}$(e)" --caller="${SCRIPT_NAME}"
                da_api_admin create-user-subdomain --sign-as "${da_user_uname}" --domain "${extra_domain}" --subdomain "${extra_subdomain}"
                echo ""
                # End looping for adding extra subdomains
              done
            else
              msg "$(s yellow)Notice: Skipped creating subdomain for domain ${extra_domain} because it does not have subdomains defined in config file$(e)" --caller="${SCRIPT_NAME}"
            fi
            echo ""
            copy_local_dns_to_external_dns "${extra_domain}"
          done # End looping for adding extra domains
        fi
      fi
      ((count_user1++))
      echo ""
    done
    echo ""

    if [[ "${da_user_restore_user_backup}" == "true" && "${C_DA_ENABLE_USER_BACKUP_RESTORE}" == "true" ]]; then
      :
    else
      # Run additional step because we don't restore from backup for this user
      # configure_da_user_skins --run-force (This user skin function does not exist but put this here and implement later if I need)
      configure_da_user_wildcard_domains --skip #(Skipped: Do not use wildcard for security purpose)
      configure_da_user_email_accounts --run-force
      configure_da_user_databases --run-force
    fi
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_user_wildcard_domains() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_user_wildcard_domains da_user_wildcard_domains_count this_da_user_username this_da_user_userpass \
      this_da_user_wildcard_domains this_da_user_wildcard_domains_count
    local count_x count_n count_o wildcard_domain wildcard_domains
    # Get list of all user wildcard domains
    da_user_wildcard_domains="${!C_DA_USER_WILDCARD_DOMAIN@}"
    # Count the total subdomains
    da_user_wildcard_domains_count=$(echo "${da_user_wildcard_domains}" | wc -w)
    # Debug:
    echo "da_user_wildcard_domains: ${da_user_wildcard_domains}"
    echo "da_user_wildcard_domains_count ${da_user_wildcard_domains_count}"
    # initial value to loop
    count_x=1
    while [[ ${count_x} -le ${da_user_wildcard_domains_count} ]]; do
      echo "=~=~=~=~=~=~=~=~=~+~+~+~=~=~"
      echo "count_user_wildcard_domain_loop = ${count_x}"
      echo ""
      typeset -n "this_da_user_username"="C_DA_USER_USERNAME${count_x}"
      typeset -n "this_da_user_userpass"="C_DA_USER_USERPASS${count_x}"
      typeset -n "this_da_user_wildcard_domains"="C_DA_USER_WILDCARD_DOMAIN${count_x}"

      # Debug:
      echo "this_da_user_username: ${this_da_user_username}"
      echo "this_da_user_userpass: ${this_da_user_userpass}"
      echo "this_da_user_wildcard_domains: ${this_da_user_wildcard_domains[*]}"
      this_da_user_wildcard_domains_count="${#this_da_user_wildcard_domains[@]}"

      count_n=0
      while [ ${count_n} -le $((this_da_user_wildcard_domains_count - 1)) ]; do
        echo "------------------------"
        echo "Total count: ${count_n}"

        wildcard_domains=$(echo "${this_da_user_wildcard_domains}" | awk -F':' '{for (i=1;i<=NF;i++)print $i}') #or tr ":" "\n"
        count_o=0
        for wildcard_domain in ${wildcard_domains}; do
          echo "count_o: ${count_o}"
          # Debug
          echo "wildcard_domain is set for domain: ${wildcard_domain}"
          echo ""

          msg "Creating wildcard entry for domain ${wildcard_domain} for both IPv4 and IPv6 ..."
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
          da_api_admin "signas+${this_da_user_username}+${this_da_user_userpass}"
          # By default DA don't create wildcard entry for this domain (unless wildcard option is enabled)
          # Note if record exist, it won't create in DA
          da_api_admin "create-dns-record" "${wildcard_domain}" "A" "*" "${C_IPV4_ADD0}"
          da_api_admin "create-dns-record" "${wildcard_domain}" "AAAA" "*" "$(ipv6calc --addr2uncompaddr "${C_IPV6_ADD0}")"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
          echo ""
          if [ "${C_DNS_PROVIDER_NAME}" == "linode" ]; then
            # In linode DNS record are duplicated, we don't want so must delete previous record first before adding new
            msg "DNS provider is set to linode. Using linode API"

            msg "Deleting subdomain ${wildcard_domain} record for IPv4 and IPv6 from linode"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
            # TODO update this for maxipi delete
            #linode_api_admin "delete-dns-record" "${wildcard_domain}" "*" "A"
            #linode_api_admin "delete-dns-record" "${wildcard_domain}" "*" "AAAA"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
            echo ""

            # Also add wildcard domain for linode API here
            msg "Adding wildcard domain ${wildcard_domain} record for IPv4 and IPv6 from linode"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"

            # TODO update this for maxipi delete
            #linode_api_admin "add-dns-record" "${wildcard_domain}" "A" "*" "${C_IPV4_ADD0}" "5"
            #linode_api_admin "add-dns-record" "${wildcard_domain}" "AAAA" "*" "${C_IPV6_ADD0}" "5"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
            echo ""
          elif [ "${C_DNS_PROVIDER_NAME}" == "digitalocean" ]; then
            msg "DNS provider is set to digitalocean"
            # Call digitalocean_api_admin
            #elif other provider
          elif [ "${C_DNS_PROVIDER_NAME}" == "local" ]; then
            msg "DNS provider is set to local (Internal DNS)"
            # Do nothing
          fi
          ((count_o++))
        done
        ((count_n++))
      done
      ((count_x++))
    done
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_user_email_accounts() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local user_count da_user_usernames_count
    da_user_usernames_count=$(echo "${!C_DA_USER_USERNAME@}" | wc -w)
    user_count=1
    while [[ ${user_count} -le ${da_user_usernames_count} ]]; do

      local da_user_username da_user_mail_accounts da_user_mail_accounts_count

      typeset -n "da_user_username=C_DA_USER_USERNAME${user_count}"
      typeset -n "da_user_mail_accounts=C_DA_USER_MAIL_ACCOUNT${user_count}"

      da_user_mail_accounts_count="${#da_user_mail_accounts[@]}"

      msg "$(s newline)"
      msg "$(s yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"
      msg "User email details:" --caller="${SCRIPT_NAME}"
      msg "User count ${user_count} out of ${da_user_usernames_count}" --caller="${SCRIPT_NAME}"
      msg "da_user_username: ${da_user_username}" --caller="${SCRIPT_NAME}"
      msg "da_user_mail_accounts: ${da_user_mail_accounts[*]}" --caller="${SCRIPT_NAME}"
      msg "da_user_mail_accounts_count: ${da_user_mail_accounts_count}" --caller="${SCRIPT_NAME}"

      if [ "${da_user_mail_accounts_count}" -eq 0 ]; then
        msg "$(s yellow)[Skipped]: Notice, this user ${da_user_username} does not have email set$(e)" --caller="${SCRIPT_NAME}"
      else
        mail_count=1
        while [ ${mail_count} -le ${da_user_mail_accounts_count} ]; do
          local mail_user_domain mail_user mail_domain mail_password
          mail_user_domain=$(echo "${da_user_mail_accounts[mail_count - 1]}" | awk -F'\|\|\|' '{ print $1 }')
          mail_user=$(echo "${mail_user_domain}" | awk -F'@' '{ print $1 }')
          mail_domain=$(echo "${mail_user_domain}" | awk -F'@' '{ print $2 }')
          mail_password=$(echo "${da_user_mail_accounts[mail_count - 1]}" | awk -F'\|\|\|' '{ print $2 }')
          msg "$(s newline)"
          msg "User email count ${mail_count}/$((da_user_mail_accounts_count))" --caller="${SCRIPT_NAME}"
          msg "User_username: ${da_user_username}" --caller="${SCRIPT_NAME}"
          msg "mail_user_domain (full email): ${mail_user_domain}" --caller="${SCRIPT_NAME}"
          msg "mail_user (without @domain.com): ${mail_user}" --caller="${SCRIPT_NAME}"
          msg "mail_domain: ${mail_domain}" --caller="${SCRIPT_NAME}"
          msg "mail_password: ${mail_password}" --caller="${SCRIPT_NAME}"
          msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"

          # da_api_admin create-user-email --mail-domain "maxibi.com" --mail-user "webmaster" --mail-password "1232123" --mail-quota "0" --mail-limit "200"
          msg "$(s cyan)Creating new user email ${mail_user_domain} ...$(e)" --caller="${SCRIPT_NAME}"
          da_api_admin create-user-email --sign-as ${da_user_username} --mail-domain "${mail_domain}" --mail-user "${mail_user}" --mail-password "${mail_password}" --mail-quota "0" --mail-limit "200"

          ((mail_count++))
        done
      fi
      ((user_count++))
    done

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Deprecated function
configure_da_user_emails() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local user_count da_user_usernames_count
    da_user_usernames_count=$(echo "${!C_DA_USER_USERNAME@}" | wc -w)
    user_count=1
    while [[ ${user_count} -le ${da_user_usernames_count} ]]; do

      local da_user_username da_user_mail_users da_user_mail_passwords

      typeset -n "da_user_username=C_DA_USER_USERNAME${user_count}"
      typeset -n "da_user_mail_users=C_DA_USER_MAIL_USER${user_count}"
      typeset -n "da_user_mail_passwords=C_DA_USER_MAIL_PASSWORD${user_count}"
      da_user_mail_users_count="${#da_user_mail_users[@]}"

      msg "$(s newline)"
      msg "$(s yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"
      msg "User email details:" --caller="${SCRIPT_NAME}"
      msg "User count ${user_count} out of ${da_user_usernames_count}" --caller="${SCRIPT_NAME}"
      msg "da_user_username: ${da_user_username}" --caller="${SCRIPT_NAME}"
      msg "da_user_mail_users: ${da_user_mail_users[*]}" --caller="${SCRIPT_NAME}"
      msg "da_user_mail_passwords: ${da_user_mail_passwords[*]}" --caller="${SCRIPT_NAME}"
      msg "da_user_mail_users_count: ${da_user_mail_users_count}" --caller="${SCRIPT_NAME}"
      msg "$(s newline)"
      mail_count=1

      while [ ${mail_count} -le ${da_user_mail_users_count} ]; do
        mail_user=$(echo "${da_user_mail_users[mail_count - 1]}" | awk -F'@' '{ print $1 }')
        mail_domain=$(echo "${da_user_mail_users[mail_count - 1]}" | awk -F'@' '{ print $2 }')
        mail_password=${da_user_mail_passwords[mail_count - 1]}
        msg "User email count ${mail_count}/$((da_user_mail_users_count))" --caller="${SCRIPT_NAME}"
        msg "User_username: ${da_user_username}" --caller="${SCRIPT_NAME}"
        msg "User full user email address: [${mail_count}]: ${da_user_mail_users[mail_count - 1]}" --caller="${SCRIPT_NAME}"
        msg "User user email address (without @domain.com): ${mail_user}" --caller="${SCRIPT_NAME}"
        msg "User email domain: ${mail_domain}" --caller="${SCRIPT_NAME}"
        msg "User email password:[${mail_count}]: ${da_user_mail_passwords[mail_count - 1]}" --caller="${SCRIPT_NAME}"
        msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"

        ## da_api_admin create-user-email --mail-domain "maxibi.com" --mail-user "webmaster" --mail-password "1232123" --mail-quota "0" --mail-limit "200"
        msg "$(s cyan)Creating new user email ${da_user_mail_users[mail_count - 1]} ...$(e)" --caller="${SCRIPT_NAME}"
        da_api_admin create-user-email --sign-as ${da_user_username} --mail-domain "${mail_domain}" --mail-user "${mail_user}" --mail-password "${mail_password}" --mail-quota "0" --mail-limit "200"

        ((mail_count++))
      done
      ((user_count++))
    done

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Function to create all user databases
configure_da_user_databases() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local user_count da_user_usernames_count

    da_user_usernames_count=$(echo "${!C_DA_USER_USERNAME@}" | wc -w)
    user_count=1
    while [[ ${user_count} -le ${da_user_usernames_count} ]]; do
      local da_user_username da_user_db_accounts da_user_db_accounts_count database_count
      typeset -n "da_user_username=C_DA_USER_USERNAME${user_count}"
      typeset -n "da_user_db_accounts=C_DA_USER_DB_ACCOUNT${user_count}"
      msg "$(s newline)"
      msg "$(s yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"
      msg "User database details:" --caller="${SCRIPT_NAME}"
      msg "User count ${user_count} out of ${da_user_usernames_count}" --caller="${SCRIPT_NAME}"
      msg "da_user_username: ${da_user_username}" --caller="${SCRIPT_NAME}"
      msg "da_user_db_accounts: ${da_user_db_accounts[*]}" --caller="${SCRIPT_NAME}"
      da_user_db_accounts_count="${#da_user_db_accounts[@]}"
      database_count=1
      if [[ "${#da_user_db_accounts}" == 0 ]]; then
        msg "$(s yellow)[skipped]: Value defined for this user ${da_user_username} database is empty$(e)" --caller="${SCRIPT_NAME}"
      else
        while [ ${database_count} -le ${da_user_db_accounts_count} ]; do
          local db_domain_name_user db_password db_domain db_name db_user sql_users sql_user_exist

          db_domain_name_user=$(echo "${da_user_db_accounts[database_count - 1]}" | awk -F'\|\|\|' '{ print $1 }')
          db_password=$(echo "${da_user_db_accounts[database_count - 1]}" | awk -F'\|\|\|' '{ print $2 }')
          db_domain=$(echo "${db_domain_name_user}" | awk -F':' '{ print $1 }')
          db_name=$(echo "${db_domain_name_user}" | awk -F':' '{ print $2 }')
          db_user=$(echo "${db_domain_name_user}" | awk -F':' '{ print $3 }')
          sql_users=$(mysql -e "SELECT USER FROM mysql.user;" | jq -rR .)
          sql_user_exist=$(echo "${sql_users}" | grep "${da_user_username}_${db_user}")

          msg "User database count ${database_count}/$((da_user_db_accounts_count))" --caller="${SCRIPT_NAME}"
          [[ -n "${sql_user_exist}" ]] && msg "sql_user_exist in mysql system: ${sql_user_exist}" --caller="${SCRIPT_NAME}"
          msg "db_domain: ${db_domain}" --caller="${SCRIPT_NAME}"
          msg "db_name: ${db_name}" --caller="${SCRIPT_NAME}"
          msg "db_user: ${db_user}" --caller="${SCRIPT_NAME}"
          msg "db_password: ${db_password}" --caller="${SCRIPT_NAME}"
          msg "$(s magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(e)" --caller="${SCRIPT_NAME}"
          msg "$(s newline)"

          #da_api_admin create-user-database --db-domain "maxibi.com" --db-name abc --db-user maxibi --db-password 12321aa (create new user database)

          #da_api_admin --db-domain "maxibi.com" create-user-database --db-name abc --existing-user maxibi  (create database with existing user)

          if [[ -z "${sql_user_exist}" ]]; then
            msg "$(s cyan)Creating new database name ${db_name} for user ${da_user_username} on domain ${db_domain} ...$(e)" --caller="${SCRIPT_NAME}"
            da_api_admin create-user-database --sign-as "${da_user_username}" --db-domain "${db_domain}" --db-name "${db_name}" --db-user "${db_user}" --db-password "${db_password}"
          else
            msg "$(s cyan)Creating new database name ${db_name} for user ${da_user_username} on domain ${db_domain} using existing username ${db_user} ...$(e)" --caller="${SCRIPT_NAME}"
            da_api_admin create-user-database --sign-as "${da_user_username}" --db-domain "${db_domain}" --db-name "${db_name}" --db-existing-user "${db_user}"
          fi

          ((database_count++))
        done
      fi
      ((user_count++))
    done

    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_user_web_configs() {
  # Note make sure do not run this if backup restore is enabled because backup always contain updated data.
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local user_count da_user_usernames_count

    da_user_usernames_count=$(echo "${!C_DA_USER_USERNAME@}" | wc -w)
    user_count=1

    while [[ ${user_count} -le ${da_user_usernames_count} ]]; do
      local da_user_username da_user_db_accounts da_user_db_accounts_count database_count
      typeset -n "da_user_username=C_DA_USER_USERNAME${user_count}"
      typeset -n "da_user_custom_web_configs=C_DA_USER_CUSTOM_WEB_CONFIG${user_count}"

      msg "da_user_username: ${da_user_username}" --caller="${SCRIPT_NAME}"
      msg "da_user_custom_web_configs: ${da_user_custom_web_configs[*]}" --caller="${SCRIPT_NAME}"

      for da_user_web_config in "${da_user_custom_web_configs[@]}"; do
        local platform_domain platform_name platform_version
        platform_domain=$(echo "${da_user_web_config}" | awk -F: '{ print $1 }')
        platform_name=$(echo "${da_user_web_config}" | awk -F: '{ print $2 }')
        platform_version=$(echo "${da_user_web_config}" | awk -F: '{ print $3 }')

        #echo ${platform_domain}
        #echo ${platform_name}
        #echo ${platform_version}

        if [[ "${platform_name^^}" == "WORDPRESS" ]]; then
          if [[ "${platform_version}" == "5.7" ]]; then
            :
            # Do nothing seems wordpress work with PHP 8.0 and default setting
          fi
          # Look at the prestashop requirement and write based on that here:
        elif [[ "${platform_name^^}" == "PRESTASHOP" ]]; then
          if [[ "${platform_version}" == "1.7.8.0" ]]; then
            echo "Platform is set to Prestashop version 1.7.8.0"
            php_compatible_version="7.4"
            # First change PHP version here for this domain:
            echo "Changing PHP version for domain ${platform_domain} ..."
            da_api_admin change-php-version --sign-as ${da_user_username} --domain "${platform_domain}" --php-version "${php_compatible_version}"

            # TODO add this API
            echo "Changing PHP setting"
            da_api_admin change-php-setting --sign-as ${da_user_username} --domain "${platform_domain}" --prestashop-recommend-php-settings "${platform_version}"

            # TODO add this in API
            # if [ "${prestashop_recommend_php_settings}" == "1.7.8.0" ]; then
            #   CMD_API_PHP_SETTINGS
            #   data="domain=${domain}&json=yes&action=add&allow_url_fopen=On&save_allow_url_fopen=On&max_input_vars=20000&save_max_input_vars=20000&memory_limit=256M&save_memory_limit=256M&post_max_size=128M&save_post_max_size=128M&upload_max_filesize=128M&save_upload_max_filesize=128M"
            # fi

          fi
        fi
      done
      ((user_count++))
    done
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This is a custom function used to modify user websites configuration based on the type of website
configure_da_custom_webs() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    if [ "${C_USE_CUSTOM_WEB_CONFIG}" == "true" ]; then
      local websetup_bin
      websetup_bin="${DATA_PATH}/maxinet/storage/webapps/websetup"
      if [ -f "${websetup_bin}" ]; then
        chmod +x "${websetup_bin}"
        navigate_to "${DATA_PATH}/maxinet/storage/webapps"
        ./websetup
      else
        msg "Unable to find websetup script at maxinet data storage"
        exit 1
      fi
    else
      msg "[Skipped]: Custom websetup is not enabled in config file"
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_os_services() {

  # Disabling some daemon processes to reduce server load
  if [ "${C_ENABLE_CLAMAV_SERVICE}" == "no" ]; then
    # TODO disable clamav here if exist to reduce server load
    # TODO Write disable service <<EOF
    :
  fi

  # check services.status from directadmin
  # clamd=OFF
  #csf=ON
  #da-popb4smtp=OFF
  #directadmin=ON
  #dovecot=ON
  #exim=ON
  #freshclam=ON
  #httpd=ON
  #lfd=ON
  #memcached=ON
  #mysqld=ON
  #named=ON
  #nginx=ON
  #php-fpm72=ON
  #php-fpm73=ON
  #php-fpm74=ON
  #pure-ftpd=OFF
  #rspamd=ON
  #sshd=ON
  #
  # !/bin/bash
  #
  ## STOP STARTUP LIST #
  ## ================= #
  ## stop and disable clamav and freshclam on startup
  ## useful when clamav is updated with the new version, it will re-enable startup
  #echo "stopping services please wait... "
  #sleep 2m
  ##stop clamav / clamd
  #sudo systemctl stop clamd
  #sudo systemctl disable clamav-freshclam.service
  #sudo systemctl disable clamav-daemon.service
  #sudo systemctl disable clamav-daemon.socket
  #sudo systemctl disable clamd
  ##stop freshclam
  #sudo systemctl stop freshclam
  #sudo systemctl disable freshclam
  ##stop da-popb4smtp
  #sudo systemctl stop da-popb4smtp
  #sudo systemctl disable da-popb4smtp
  ##stop pure-ftpd
  #sudo systemctl stop pure-ftpd
  #sudo systemctl disable pure-ftpd
  #echo "services stopped successfully..."
  ##===================#

}

# This is used to get A+ rating for SSL and increase security
configure_da_domain_security() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    if [ "${C_DA_ENABLE_DOMAIN_SECURITY_HEADER}" == "true" ]; then
      local da_bin da_cb_bin da_template_custom_path retval test_count
      da_bin="/usr/local/directadmin/directadmin"
      da_cb_bin="/usr/local/directadmin/custombuild/build"
      da_template_custom_path="/usr/local/directadmin/data/templates/custom"
      if [[ "${C_DA_CB_WEBSERVER_SOFTWARE}" == "nginx" || "${C_DA_CB_WEBSERVER_SOFTWARE}" == "nginx_apache" ]]; then

        msg "$(s cyan)Writing hsts rule for ${C_DA_CB_WEBSERVER_SOFTWARE} into ${da_template_custom_path}/cust_nginx.CUSTOM.post ...$(e)" --caller="${SCRIPT_NAME}"
        mkdir -p "${da_template_custom_path}"
        {
          # Note 1
          # Below can be added into the 3rd box of custom nginx (need testing) for individual domain
          # add_header Strict-Transport-Security "max-age=63072000; includeSubdomains; preload";
          # https://forum.directadmin.com/threads/enable-strict-transport-security-hsts.51351/

          # This if for global domain (every domain will have this header except host):
          # For host, it use option hsts=${second}
          echo -e "\t# ===============================================\n"
          echo -e "\t# This security header section was automatically generated by ${SCRIPT_NAME}\n"
          echo -e "\t# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}\n"
          echo -e "\t# ===============================================\n"
          echo -e "\tadd_header X-Content-Type-Options \"nosniff\";\n"
          echo -e "\tadd_header X-Frame-Options \"SAMEORIGIN\" always;\n"
          echo -e "\tadd_header X-XSS-Protection \"1\";\n"
          echo -e "\tadd_header X-Download-Options \"noopen\";\n"
          echo -e "\tadd_header X-Permitted-Cross-Domain-Policies \"master-only\";\n"
          echo -e "\tadd_header X-DNS-Prefetch-Control \"on\";\n"
          echo -e "\tadd_header Referrer-Policy \"no-referrer-when-downgrade\";\n"
          echo -e "\n"
          if [ "${C_DA_ENABLE_DOMAIN_HSTS}" != "false" ]; then
            local enable_type hsts_max_age
            enable_type=$(echo "${C_DA_ENABLE_DOMAIN_HSTS}" | awk -F':' '{ print $1 }')
            hsts_max_age=$(echo "${C_DA_ENABLE_DOMAIN_HSTS}" | awk -F':' '{ print $2 }')
            if [ "${enable_type}" == "global" ]; then
              echo -e "\t|*if SSL_TEMPLATE=\"1\"|\n"
              # The preload part is important, so that after you have submitted the domain into preload list https://hstspreload.org/,
              # people will not able to delete your domain there. This preload list must be included so people in Google know you want to
              # redirect people to https.
              echo -e "\tadd_header Strict-Transport-Security \"max-age=${hsts_max_age}; includeSubDomains; preload\";\n"
              echo -e "\t|*endif|\n"
            else
              :
              # TODO add hsts based on user ROLE config (let the other header global) (planned feature)
            fi
          fi
          echo -e "\n"
          echo -e "\tadd_header Content-Security-Policy \"block-all-mixed-content\";"
          echo -e "\tadd_header Permissions-Policy 'geolocation=*, midi=(), sync-xhr=(self \"https://|DOMAIN|\" \"https://www.|DOMAIN|\"), \
microphone=(), camera=(), magnetometer=(), gyroscope=(), payment=(), fullscreen=(self \"https://|DOMAIN|\" \"https://www.|DOMAIN|\" )';\n"
          # This is the extra condition to first redirect (if I dont put this, I will have problem submitting preload hsts):
          # Related to my post here: https://forum.directadmin.com/threads/problem-with-ssl-on-hostname-and-da-and-hsts-with-other-aplications-on-other-ports.64137/post-335495
          echo -e "\n"
          echo -e "\t|*if SSL_TEMPLATE=\"0\"|\n"
          echo -e "\treturn 301 https://\$host\$request_uri;\n"
          echo -e "\t|*endif|\n"
        } >"${da_template_custom_path}/cust_nginx.CUSTOM.post"
        get_status_message "$?"
        echo ""

      elif [[ "${C_DA_CB_WEBSERVER_SOFTWARE}" == "apache" ]]; then
        msg "$(s cyan)Writing hsts rule for ${C_DA_CB_WEBSERVER_SOFTWARE} into ${da_template_custom_path}/cust_httpd.CUSTOM.post ...$(e)" --caller="${SCRIPT_NAME}"
        {
          # Reference: https://docs.directadmin.com/webservices/apache/virtualhost-level.html#adding-security-headers-to-get-an-a-rating
          echo -e "\t# ===============================================\n"
          echo -e "\t# This security header section was automatically generated by ${SCRIPT_NAME}\n"
          echo -e "\t# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}\n"
          echo -e "\t# ===============================================\n"
          echo -e "\t<IfModule mod_headers.c>\n"
          echo -e "\tHeader always set X-Content-Type-Options \"nosniff\"\n"
          echo -e "\t<FilesMatch \"\\.(php|html)quot;>\n"
          echo -e "\tHeader always unset X-Powered-By\n"
          echo -e "\tHeader unset X-Powered-By\n"
          echo -e "\tHeader set X-Frame-Options \"SAMEORIGIN\"\n"
          echo -e "\tHeader set X-XSS-Protection \"1\"\n"
          echo -e "\tHeader set X-Download-Options \"noopen\"\n"
          echo -e "\tHeader set X-Permitted-Cross-Domain-Policies \"master-only\"\n"
          echo -e "\tHeader set X-DNS-Prefetch-Control \"on\"\n"
          echo -e "\tHeader set Referrer-Policy \"no-referrer-when-downgrade\"\n"
          echo -e "\n"
          if [ "${C_DA_ENABLE_DOMAIN_HSTS}" != "false" ]; then
            local enable_type hsts_max_age
            enable_type=$(echo "${C_DA_ENABLE_DOMAIN_HSTS}" | awk -F':' '{ print $1 }')
            hsts_max_age=$(echo "${C_DA_ENABLE_DOMAIN_HSTS}" | awk -F':' '{ print $2 }')
            if [ "${enable_type}" == "global" ]; then
              echo -e "\t|*if SSL_TEMPLATE=\"1\"|\n"
              echo -e "\tHeader set Strict-Transport-Security \"max-age=${hsts_max_age}\" includeSubDomains; preload\n"
              echo -e "\t|*endif|\n"
            else
              :
              # TODO add hsts based on user ROLE config (let the other header global) (planned feature)
            fi
          fi
          echo -e "\n"
          echo -e "\tHeader set Content-Security-Policy \"block-all-mixed-content\"\n"
          echo -e "\tHeader Set Permissions-Policy 'geolocation=*, midi=(), sync-xhr=(self \"https://|DOMAIN|\" \"https://www.|DOMAIN|\"), \
    microphone=(), camera=(), magnetometer=(), gyroscope=(), payment=(), fullscreen=(self \"https://|DOMAIN|\" \"https://www.|DOMAIN|\")'\n"
          echo -e "\n"
          echo -e "\t|*if SSL_TEMPLATE=\"0\"|\n"
          echo -e "\treturn 301 https://\$host\$request_uri;\n"
          echo -e "\t|*endif|\n"
          echo -e "\t</FilesMatch>\n"
          echo -e "\t</IfModule>\n"
        } >"${da_template_custom_path}/cust_httpd.CUSTOM.post"
      fi
      # Important, since the above 2 written in global custom virtual host, some headers can be unset via .htaccess for specific domain:
      # eg: Header always unset X-Frame-Options
      # Or I can enable this via specific domain only (TODO)
      msg "$(s cyan)Rewriting virtual host config ...$(e)" --caller="${SCRIPT_NAME}"
      ${da_cb_bin} rewrite_confs
      get_status_message "$?"
      echo ""
      sleep 5
      # Test the first user domain for header
      test_count=0
      while :; do
        local first_domain
        ((test_count++))
        first_domain=$(echo "${C_DA_USER_DOMAIN1[0]}" | awk -F':' '{ print $1 }')
        msg "$(s cyan)Testing header message for domain ${first_domain}...$(e)" --caller="${SCRIPT_NAME}"
        curl -s -D- "https://${first_domain}" | grep -i Strict
        retval=$?
        if [ "${retval}" -eq 0 ]; then
          echo "Success"
          break
        else
          echo "Failed"
        fi
        echo ""

        first_domain=$(echo "${C_DA_RESELLER_DOMAIN1[0]}" | awk -F':' '{ print $1 }')
        msg "$(s cyan)Testing another header message for domain ${first_domain}...$(e)" --caller="${SCRIPT_NAME}"
        curl -s -D- "https://${first_domain}" | grep -i Strict
        retval=$?
        if [ "${retval}" -eq 0 ]; then
          echo "Success"
          break
        else
          echo "Failed"
        fi
        echo ""
        # This will not happen in the future when I have obtained SSL and put in backup, I will always have valid SSL
        if [ "${test_count}" -gt 3 ]; then
          msg "$(s cyan)Notice, skipped testing because it might be issue with SSL rate limit (this will be fixed automatically with DA auto SSL)$(e)" --caller="${SCRIPT_NAME}"
          sleep 2
          break
        fi
        msg "$(s cyan)Re-testing in 10 seconds ...$(e)" --caller="${SCRIPT_NAME}"
        _pause 10
      done
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}
# This is an alias function of setup_post
post_setup() {
  setup_post "$@"
}

# This is used to install extra packages like ncdu, htop and more
setup_post() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}_${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    if [ "${DISTRO_ID}" == "debian" ]; then
      # Install speedtest-cli
      curl -s https://packagecloud.io/install/repositories/ookla/speedtest-cli/script.deb.sh | sudo bash
      apt-get install speedtest
      apt-get -y install ncdu htop gpg vim mutt retry
    else
      echo "Warning, check the setup_post installation for ${DISTRO_ID}, it's only available for debian!"
    fi
    maxicron_bin="/usr/local/maxicode/maxicron/maxicron"

    if command -v maxicron &>/dev/null; then
      msg "$(s cyan)Enabling some system services ...$(e)" --caller="${SCRIPT_NAME}"
      maxicron enable-services "lfd" "rsyslog" "csf" "suricata" "rspamd" "sshd" "mysqld" "gotify" "maldet"
      echo ""
      msg "$(s cyan)Disabling some system services ...$(e)" --caller="${SCRIPT_NAME}"
      maxicron disable-services "clamd" "clamav-daemon" "freshclam" "clamav-freshclam" "da-popb4smtp" "pure-ftpd" "memcached"
      echo ""
    else
      msg "$(s cyan)Notice, maxicron is not installed, skipping ...$(e)" --caller="${SCRIPT_NAME}"
    fi

    # 1) TODO: Audit system here with maxinis:
    # maxinis --audit system

    # 2) TODO: This is the linode suggestion add here more
    # Still need to add more based on lynis suggestion
    # Suggested by lynis to disable core dump
    local limitsconf="/etc/security/limits.conf"
    local limit_append="*                hard    core          0"
    read -ra line_array <<<"${limit_append}"
    line_domain=${line_array[0]}
    line_type=${line_array[1]}
    line_item=${line_array[2]}
    line_value=${line_array[3]}
    gr=$(grep "$line_domain *$line_type  *$line_item *$line_value" "${limitsconf}")

    if [[ -z "${gr}" ]]; then
      msg "Disabling core dump with the following options:"
      echo "${limit_append}"
      echo "${limit_append}" >>"${limitsconf}"
    else
      msg "[Skipped]: Found core dump config is already disabled"
    fi

    echo "# This line disables core dumps for all users" >>/etc/profile
    echo "ulimit -S -c 0 > /dev/null 2>&1" >>/etc/profile
    echo ""
    # END of lynis suggestion

    # Enable all websites if dacli binary exist
    if command -v dacli &>/dev/null; then
      msg "$(s cyan)Turning all websites into live mode using the following command $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s cyan)dacli maintain-web --set-status online$(e)" --caller="${SCRIPT_NAME}"
      dacli maintain-web --set-status online
    else
      msg "$(s cyan)Notice, dacli is not installed, skipping ...$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""

    # make the first AIDE scan using maxiaide
    if command -v maxiaide &>/dev/null; then
      msg "$(s cyan)Scanning file system for the first time using the following command $(e)" --caller="${SCRIPT_NAME}"
      msg "$(s cyan)maxiaide scan --update --verbose$(e)" --caller="${SCRIPT_NAME}"
      maxiaide scan --update --verbose # or maxiaide scan -uv
    else
      msg "$(s cyan)Notice, maxiaide is not installed, skipping ...$(e)" --caller="${SCRIPT_NAME}"
    fi
    echo ""

    check_finish_reboot "${func_name}"
  else
    msg "$(s yellow)[Skipped by system]: $(s magenta)${func_name}$(e) $(s yellow)with current option ${run_mode} has ran before $(e)" --caller="${SCRIPT_NAME}"
    msg "$(s yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(e)"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi

  # TODO note, at the end of setup_post, must put PermitRootLogin to no to maximum security, previously PermitRootLogin was prohibited-password
}

# syntax: maxinet clean full

clean_setup_files() {
  local full_clean="$2"
  if [[ "$(hostname)" == "${C_BOX_HOSTNAME_FQHN}" ]]; then

    if [[ "${full_clean}" == "full" || "${full_clean}" == "all" ]]; then
      full_clean="full"
      _confirm "Warning! This will remove everything including setup config files and logs. You will not be able to resume script installation and view previous logs!! Continue? [Y/y] or Cancel [CTRL +C]:"
    fi
    # Destroy the setup config deeply
    if [ "${C_AUTO_DESTROY_CONFIG}" == "true" ]; then
      msg "Warning, destroying setup configuration information in ${CONFIG_FILE} within 120 seconds ..."
      _pause 120
      shred -uvz "${CONFIG_FILE}"
      get_status_message "$?"
    else
      msg "Warning, C_AUTO_DESTROY_CONFIG is not set to auto destroy config file. Please manually backup and destroy the setup configuration information in ${CONFIG_FILE}"
      sleep 5
    fi

    # Remove all setup information except CONF_PATH because CONF_PATH and CODE_PATH
    echo ""
    msg "Cleaning installation log files"
    rm -vrf "${DATA_PATH}"
    # CODE_PATH contains autogenerated file/script ending with _ag.extension (but can be removed if triggering setup)
    rm -vrf "${CODE_PATH}"
    rm -vrf "${TEMP_PATH}"
    rm -vrf "${INST_TEMP_DIR}"
    rm -vrf "${SECURE_PATH}"
    rm -vrf "${STORAGE_PATH}"
    rm -vrf "${ISO_PATH}"
    rm -vrf "${SSL_PATH}"
    rm -vrf "${DOWNLOAD_PATH}"
    rm -vrf "${BACKUP_PATH}"
    if [ "${full_clean}" == "full" ]; then
      rm -vrf "${CONF_PATH}"
      rm -vrf "${LOG_PATH}"
    fi

    # extra remove temp files in root folders
    rm -vrf "${SCRIPT_PATH}/admin_backups"
    rm -vrf "${SCRIPT_PATH}/gpg"
    rm -vrf "${SCRIPT_PATH}/maxinet.log"
    rm -vrf "${SCRIPT_PATH}/readme.txt"
    rm -vrf "${SCRIPT_PATH}/os_initialize.sh"
    rm -vrf "${SCRIPT_PATH}/user_${C_SSH_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub"
    rm -vrf "${SCRIPT_PATH}/maxiaide"
    rm -vrf "${SCRIPT_PATH}/maxiclam"
    rm -vrf "${SCRIPT_PATH}/directadmin"
    echo ""
    # Clear bash history
    msg "Cleaning bash history"
    history -c
    get_status_message "$?"
    echo ""

    msg "Destroying main script at ${SCRIPT_PATH}/${SCRIPT_NAME} ..."
    rm -vf "${SCRIPT_PATH}/${SCRIPT_NAME}"
    echo "######### DONE ! #########"
  else
    msg "Error, cannot execute this action because the hostname does not match with the config file"
    msg "This is a dangerous function and can be only run on a remote server defined in config file"
    exit 1
  fi
}

#############################
# Setup function begin here #
#############################
setup() {

  echo "host type is: ${C_HOST_TYPE}"
  echo "Box_hostname is: ${C_BOX_HOSTNAME_FQHN}"
  # Just prevent running setup action if set to local, the other value still run this
  if [[ "${C_HOST_TYPE}" == "remote" ]]; then

    script_header
    # This is needed for installing missing packages

    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    option="$1"
    #if [ "${option}" == "remote" ];  then
    #  msg 'yellow' "Notice, remote setup is set"
    #  :
    #else
    # ==== Locking mechanism ====
    PID=$(pidof -x "${SCRIPT_NAME}")
    # USE ATOMIC LOCK
    LOCK_DIR="/var/lock/${SCRIPT_NAME}"
    LOCK_PID="${LOCK_DIR}/pid"

    # THIS WILL CHECK ONLY ONE INSTANCE OF SCRIPT SHOULD RUN
    if ! mkdir "${LOCK_DIR}" 2>/dev/null; then
      PID=$(cat "${LOCK_PID}")
      if ! kill -0 "${PID}" 2>/dev/null; then
        msg "Removing stale lock of nonexistent PID ${PID}"
        rm -rf "${LOCK_DIR}"
        msg "Restarting (${SCRIPT_NAME})"
        exec "$0" "$@"
      fi
      msg "Warning, another instance of this script is already running with PID [${PID}]"
      msg "Please wait or clear the current running session to re-run this script"
      exit 147
    else
      # LOCK SUCCESS NOW SAVE INFORMATION IN PID
      echo $$ >"${LOCK_PID}"

      CTRL_C_COUNT=0
      # IF SCRIPT EXIT UNSUCCESSFULLY, THEN WE CALL cleanup function
      traps script_exit QUIT INT TERM EXIT
    fi
    # ============End of locking===============

    if [[ ${DISTRO_ID} == "centos" || ${DISTRO_ID} == "debian" ]]; then
      #msg "OK, this operating system [${DISTRO_ID}] is supported!"
      :
    else
      msg "$(s red)Sorry, this operating system [${DISTRO_ID}] is not supported!$(e)" --caller="${SCRIPT_NAME}"
      exit 1
    fi

    if compgen -G "${OS_TEMP_PATH}/${C_BOX_HOSTNAME_FQHN}*_executed" >/dev/null; then
      msg "$(s red)Resuming $(s cyan)server installation for ${C_BOX_HOSTNAME_FQHN} ...$(e)" --caller="${SCRIPT_NAME}"
      _pause 5
    else
      msg "$(s red)Starting $(s cyan)server installation for ${C_BOX_HOSTNAME_FQHN} ...$(e)" --caller="${SCRIPT_NAME}"
    fi

    echo ""

    ############ Setup function call starts here ############
    # Call function documentation #
    # SYNTAX:
    # function_name +<option>
    # + means optional
    # EXAMPLE:
    # eg: secure_os --run-force
    # DESCRIPTION:
    # <option> lists:
    # --run - normal run, after it has finished executed, it is marked as executed and continue to the next function_name call
    # --run-exit - normal run, after it has finished executed, it is marked as executed and then exit or halt (no next function_name call)
    # --run--force - force run (even after being executed previously), after it has finished executed, it is marked as executed and continue to the next function_name call
    # --run--force-exit - force run (even after being executed previously), after it has finished executed, it is marked as executed and then exit or halt (no next function_name call)
    # --skip - do not run the current function_name and do not mark it as executed
    # --skip-exit - do not run the current function_name, do not mark it as executed and then exit or halt (no next function_name call)
    # --skip-mark - do not run the current function_name but mark it as executed
    # --skip-mark-exit - do not run the current function_name but mark it as executed and then exit or halt (no next function_name call)
    # EXTRA INFO:
    # Without <option> argument it is similar to using --run
    # eg: configure_net is equivalent to configure_net --run
    #####################################################

    # Note 1: setup_pre can be used to install screen, disable Selinux in CentOS or other necessary pre install components
    setup_pre --run
    # Upgrade system
    upgrade_os --run
    # Note 1: Clone all setup script from git (recommend to run as --run-force instead of --run so we always get the latest security update)
    get_latest_code --run
    # Note 1: This call contains security hardening server
    secure_os --run
    # Note 1: This is used to configure all open source scripts
    configure_opencode --run
    # Note 1: This is used to configure maxicode scripts
    configure_maxicode --run
    # Note 1: This will configure grub such as setting up password for grub bootloader
    # Note 2: Grub bootloader password can also be used in preseed file, but having preseed file during installation is a bad idea.
    configure_grub --run
    # Note 1: This will configure the basic network such as the LAN interface
    # Note 2: Special note: When this function is executed, when it detects the current LAN interface is not eth0, and C_NIC_INTERFACE_NAME value is not eth0 then
    # the script will use the background script to rename LAN interface using ip link command. In this case, before the background script is executed, it will first
    # call the next function configure_net2 to configure the network files that use network interface based $C_NIC_INTERFACE_NAME value from config file
    # The reason is to prevent the system from network locked out due to unfinished configuration files between network files by using ip link down command.
    # Note 3: That means, configure_net2 will only run once if that is the case. If you still need configure_net2 to run for technical reason, use the option --run-force
    configure_net --run # This is optional because it was set in debian preseed file but we still can run this
    # Must run configure_net first before running configure_net2 because we need interface to be ${C_NIC_INTERFACE_NAME} first #OK
    configure_net2 --run # The important part is the /etc/hosts
    # This is where we can configure mount option for disk
    configure_fstab --run
    # Tweaking swap for production server
    configure_kernel_swap --run
    # Tweaking file system kernel etc ..
    configure_kernel_filesystem --run
    # Tweaking IPv4 or Ipv6 in kernel
    configure_kernel_ips --run
    if [[ "${C_SERVER_TYPE}" == "directadmin" ]]; then
      # Validate directadmin users from config files
      validate_config
      if [[ "${C_DA_INSTALL_TYPE}" == "custom" ]]; then
        install_da_pre --run
        install_da --run
        install_da_post --run
        configure_da_scripts --run
        configure_da_auth --run
        configure_bind --run
        install_da_csf --run
        configure_csf --run
        # Add da ipv6 and linking with ipv4 and vice versa (this option has --init argument)
        configure_da_ips --run
        configure_da_sql --run
        configure_da_sql_security --run
        configure_da_mail --run
        configure_da_mail_security --run
        configure_da_ftp --run
        configure_server_security --run
        configure_da_custom_configs --run
        configure_web_apps --run
        configure_da_settings --run
        configure_da_cb_settings --run
        configure_da_redis --run
        # This is only useful for prestashop platform
        configure_da_memcached --run
        # (skip temporarily until found useful)
        configure_da_geoip --skip
        # Important to run configure_da_dns_templates first before creating any domains
        # so that the DNS record can use new template automatically
        configure_da_dns_templates --run
        # " -- host --"
        configure_da_fqhn_server --run
        configure_da_ssl_pre --run
        configure_da_hostname_ssl --run
        # " -- owner --"
        configure_da_owner_accounts --run
        # " -- admin --"
        configure_da_admin_accounts --run
        # " -- reseller --"
        configure_da_reseller_accounts --run
        # " -- user ---"
        configure_da_user_accounts --run
        # TODO might put inside configure_da_user_accounts
        configure_da_user_web_configs --skip
        # " -- others ---"
        configure_da_user_domain_ssl --run
        configure_da_domain_security --run
        # TODO rewrite
        configure_da_custom_webs --skip
        setup_post --run
      elif [[ "${C_DA_INSTALL_TYPE}" == "auto" ]]; then
        install_da_pre --run
        install_da --run
        install_da_post --run
        configure_da_scripts --run
        configure_da_auth --run
        configure_bind --run
        configure_csf --run
        # Add da ipv6 and linking with ipv4 and vice versa (this option has --init argument)
        configure_da_ips --run
        configure_da_sql --run
        configure_da_mail --run
        configure_da_ftp --run
        configure_server_security --run
        configure_da_custom_configs --run
        configure_web_apps --run
        configure_da_settings --run
        configure_da_cb_settings --run
        configure_da_redis --run
        configure_da_memcached --run # (Prestashop only support this cache)
        configure_da_geoip --skip    # (skip temporarily until found useful)
        # Important to run configure_da_dns_templates first before creating any domains so that the DNS record can use new template automatically
        configure_da_dns_templates --run
        # " -- host --"
        configure_da_fqhn_server --run
        configure_da_ssl_pre --run
        configure_da_hostname_ssl --run
      fi
    elif [[ "${C_SERVER_TYPE}" == "general" ]]; then
      install_da_pre --run
      install_da --run
      install_da_post --run
      install_general_csf --run
      configure_csf --run
    elif [[ "${C_SERVER_TYPE}" == "prestashop" ]]; then
      :
    fi
    ############ Setup function call end here ############

    echo ""
    if [ "${C_SERVER_TYPE}" == "directadmin" ]; then
      echo "=============="
      echo "Directadmin now can be accessed through this URL: "
      echo "http://${C_IPV4_ADD0}:${C_DA_PORT} or http://${C_BOX_HOSTNAME_FQHN}:${C_DA_PORT}"
      echo "Username: ${C_DA_OWNER_USERNAME1}"
      echo "Password: ${C_DA_OWNER_USERPASS1}"
      echo "=============="
      echo ""
      echo ""
    elif [ "${C_SERVER_TYPE}" == "general" ]; then
      :
    fi
    # Show script running time

    script_time
    msg "$(s green)========== Installation Completed ==========$(e)"
    echo ""

    clean_setup_files
  else
    msg "$(s red)Error, cannot execute setup action because the hostname in this machine does not match with the hostname config in file$(e)" --caller="${SCRIPT_NAME}"
    msg "$(s red)You can only run this function on a remote server$(e)" --caller="${SCRIPT_NAME}"
    exit 1
  fi
  return 0
}

temp1() {
  :
}

test1() {
  :
}

############# End of function #############

# -------------- MAIN FUNCTION --------------#
# Obtain current running script name. eg: maxinet
SCRIPT_NAME=$(basename -- "$0")

# Make sure this script is executed with root permission
if [[ "${EUID}" -ne 0 ]]; then
  msg "Error, this script must be run as root!"
  exit 147
fi

# Obtain current script path location eg: /root/execute/
SCRIPT_PATH="$(dirname "$(readlink -f "$0")")"

# Unix timestamp (non-UTC)
TIMESTAMP=$(date +%s)

# Unix timestamp (UTC)
TIMESTAMP_UTC=$(date -u +%s)

# SSL certificate well-known path (letsencrypt)
WELLKNOWN_PATH="/var/www/html/.well-known/acme-challenge"

# Define each directory's location to be created
LOG_PATH="${SCRIPT_PATH}/log"
CONF_PATH="${SCRIPT_PATH}/conf"
DATA_PATH="${SCRIPT_PATH}/data"
CODE_PATH="${SCRIPT_PATH}/code"
ISO_PATH="${SCRIPT_PATH}/iso"
DOWNLOAD_PATH="${SCRIPT_PATH}/download"
BACKUP_PATH="${SCRIPT_PATH}/backup"
SECURE_PATH="${SCRIPT_PATH}/secure"
STORAGE_PATH="${SCRIPT_PATH}/storage"
TEMP_PATH="${SCRIPT_PATH}/temp"
OS_TEMP_PATH="/tmp"
SSL_PATH="${SCRIPT_PATH}/ssl"
INST_TEMP_DIR="${TEMP_PATH}/src"

# Create all important directories if they are not exist
mkdir -p "${LOG_PATH}"
mkdir -p "${CONF_PATH}"
mkdir -p "${DATA_PATH}"
mkdir -p "${CODE_PATH}"
mkdir -p "${ISO_PATH}"
mkdir -p "${DOWNLOAD_PATH}"
mkdir -p "${BACKUP_PATH}"
mkdir -p "${SECURE_PATH}"
mkdir -p "${STORAGE_PATH}"
mkdir -p "${TEMP_PATH}"
mkdir -p "${SSL_PATH}"
mkdir -p "${INST_TEMP_DIR}"

# A global variable to determine whether the current host is a local OS or remote server
HOST_TYPE=""

# A global variable that holds the number of progress spin occurrences
PROGRESS_SPIN_COUNT=0

# A global variable that temporarily holds initial seconds value
HOLD_SECONDS=0

# A global variable that hold installation count
INSTALL_COUNT=1

# A global variable that holds the switch whether to run a function based on argument
FUNCTION_RUN=false

# A global variable that holds the switch whether to to skip run a function based on argument
SKIP_RUN=false

# This global variable that temporarily hold the current execution time
EXEC_START=$(date +%s.%N)

# A global variable that temporarily holds the current path
OLD_PATH="${PWD}"

# Get the distro ID. eg: ubuntu
DISTRO_ID=$(get_linux_os "id")

# Get the distro Version. eg: 20.04
DISTRO_VERSION=$(get_linux_os "version")

# Get the distro Codename, eg: bullseye
DISTRO_CODENAME=$(get_linux_os "codename")

#eg: 31-03-2020_11-56-16.12345
DATE_TIME_RANDSTR="$(date '+%d-%m-%Y_%H-%M-%S').${RANDOM}"
#eg: 31-03-2020_11-56-16
DATE_TIME_NOW="$(date '+%d-%m-%Y_%H-%M-%S')"

# This is the latest path for the code (the content of this path will be always up to date when get_latest_code() is executed with --run-force
LATEST_CODE_PATH="${DATA_PATH}/latest_${SCRIPT_NAME}"

LATEST_OS_CODE_PATH="${LATEST_CODE_PATH}/storage/os/${DISTRO_ID}"

CONFIG_TEST=""
# for setting up multi servers:
CONFIG_FILE="${SCRIPT_PATH}/${SCRIPT_NAME}.conf"
#CONFIG_FILE="${SCRIPT_PATH}/maxinet_sun.sofibox.com.conf"
#CONFIG_FILE="${SCRIPT_PATH}/maxinet_mars.sofibox.com.conf"

if [ ! -f "${CONFIG_FILE}" ]; then
  C_LOG_VERBOSITY_LEVEL="3"
  msg "$(s red)Error, could not find config file ${CONFIG_FILE}$(e)" --caller="${SCRIPT_NAME}"
  exit 1
fi

# This will only allow sourcing one time
if [ -z "${C_CONFIG_VERSION}" ]; then
  if [ -s "${CONFIG_FILE}" ]; then

    if [[ "${C_USE_MULTI_LOG_FILE}" == "true" ]]; then
      # set to use multiple log files with different random date. eg: maxinet-31-03-2020_11-56-16.12345-report.log
      REPORT_FILE="${LOG_PATH}/${SCRIPT_NAME}-${DATE_TIME_RANDSTR}-report.log"
    else
      # set to use one log file with only one name. eg: maxinet-report.log
      REPORT_FILE="${LOG_PATH}/${SCRIPT_NAME}-report.log"
    fi

    # TODO Logging start here with exec after the REPORT_FILE is created

    # This report path is for storing error report
    # REPORT_FILE_ERROR="${LOG_PATH}/${SCRIPT_NAME}-${DATE_TIME_RANDSTR}-error-report.log"
    # CONFIG file must follow this regex.
    # eg: 1) abc=2 #OK 2) abc= #NOT-OK 3) abc #NOT-OK 4) @ok=abc #NOT-OK 5) .ok=abc #NOT-OK 6) _ok=abc #OK
    # It will ignore white spaces, blank-lines and comments.
    #CONFIG_TEST=$(grep -Evn '^[A-Za-z0-9_].+=.+$|^[[:space:]]*$|^#' "${CONFIG_FILE}")
    #  if [ -n "${CONFIG_TEST}" ]; then
    #    C_LOG_VERBOSITY_LEVEL="3"
    #    msg "$(s red)Error, there is one or more problems found in config file in ${CONFIG_FILE}$(e)" --caller="${SCRIPT_NAME}"
    #    msg ""
    #    msg "$(s red)Error lines:$(e)" --caller="${SCRIPT_NAME}"
    #    msg "$(s red)${CONFIG_TEST}$(e)"
    #  else
    source_errs=$(source "${CONFIG_FILE}" 2>&1 >/dev/null)
    # get the return code of the test source
    retval=$?
    if [ ${retval} = 0 ]; then
      # Let's do the weird thing on string:
      if [ -n "${source_errs}" ]; then
        # Need this C_LOG_VERBOSITY_LEVEL=3 here because if config file error, this will not have value to display error
        C_LOG_VERBOSITY_LEVEL="3"
        msg "$(s red)Error, there is one or more problems found in config file in ${CONFIG_FILE}$(e)" --caller="${SCRIPT_NAME}"
        msg ""
        msg "$(s red)Error details:$(e)" --caller="${SCRIPT_NAME}"
        msg "$(s red)${source_errs}\n$(e)"
        exit 1
      else
        #If no error then we source the environment file from ${CONFIG_FILE} ..."
        source "${CONFIG_FILE}"
        retval=$?
        if [ ${retval} = 0 ]; then
          #C_LOG_VERBOSITY_LEVEL="7" # Do not use this, because we are overwriting the log
          # We do not need to show if config is valid, just care about the error.
          :
          #msg "$(s green)[${retval}] OK, config file is valid$(e)" --caller="${SCRIPT_NAME}"
        else
          # In case something is wrong when sourcing it then tell here
          # We need this C_LOG_VERBOSITY_LEVEL=4 here because if config file error, this will not have value to show warning
          C_LOG_VERBOSITY_LEVEL="4"
          msg "$(s yellow)Warning, config file is valid but it does not return valid code when sourcing it$(e)" --caller="${SCRIPT_NAME}"
          exit 1
        fi
        #msg ""
      fi
    else
      # Need this C_LOG_VERBOSITY_LEVEL=3 here because if config file error, this will not have value to display error
      C_LOG_VERBOSITY_LEVEL="3"
      msg "$(s red)Error, the source command returns an error code of ${retval} when sourcing ${CONFIG_FILE}$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)Error details:$(e)" --caller="${SCRIPT_NAME}"
      msg "$(s red)${source_errs}\n$(e)"
      exit 1
    fi
    #fi
  else
    msg "$(s red)Error, ${CONFIG_FILE} does not exist or empty. Need this configuration file$(s red)" --caller="${SCRIPT_NAME}"
    exit 1
  fi

  # Start logging here after successfully validated config if C_LOG_VERBOSITY_LEVEL from config file is set to 8
  [[ ${C_LOG_VERBOSITY_LEVEL} == "8" ]] && set -x

  # Configuring or creating autogenerate extra scripts and adding autogenerate setup readme
  create_file "ssh-push-scripts setup-readme"

  C_BOX_HOSTNAME=$(echo "${C_BOX_HOSTNAME_FQHN}" | awk -F'.' '{ print $1 }')

  # Copy ssh keys from secure folder to /root/.ssh because some SSH client in linux depend only on this path and must have permission
  # In Windows WSL, secure folder has permission global 777, lish connection will not allow using this ssh key.
  #msg "$(s cyan)Copying RSA key public key for login purpose without prompt to replace ...$(e)" --caller="${SCRIPT_NAME}"
  # The ssh folder /root/.ssh/* will always have certificate from ${SECURE_PATH}/ssh

  # Must make sure that this command exist in the system
  if ! command -v maxibuild &>/dev/null; then
    msg "$(s cyan)Warning, maxibuild is missing. Installing maxibuild ...$(e)" --caller="${SCRIPT_NAME}"
    configure_maxibuild --run-force
  fi

  if [[ "$(hostname)" == "${C_BOX_HOSTNAME_FQHN}" || "$(hostname)" == "${C_BOX_HOSTNAME}" ]]; then
    :
    # run all remote things
  else

    update_local_os --run --silent-if-executed

    echo ""

    # Install required commands after maxibuild is installed
    maxibuild --include "git sudo nmap psmisc unzip zip dnsutils net-tools rsync dos2unix ncdu htop wget curl ipcalc"

    # This check is not compulsory because it only run once (marked as executed)
    if ! command -v maxipi &>/dev/null; then
      msg "$(s cyan)Warning, maxipi command is missing. Installing maxipi ...$(e)" --caller="${SCRIPT_NAME}"
      configure_maxipi --run-force
    fi

    # This check is not compulsory because it only run once (marked as executed)
    if ! command -v dbxcli &>/dev/null; then
      msg "$(s cyan)Warning, dbxcli command is missing. Installing dbxcli ...$(e)" --caller="${SCRIPT_NAME}"
      configure_dropbox_cli --run-force
    fi

    # This is to ensure that we always have the public key copied (fixed issue on WSL2 permission)
    ssh_api copy-public-keys --without-prompt
  fi
else
  # Config has source
  # Do something
  :
fi

# if C_HOST_PUBLIC_IP is not set in config file, we retrieve this host IP automatically
# If you want to disable this check, supply the host IP for variable C_HOST_PUBLIC_IP manually in config file ...

if [ -n "${C_HOST_PUBLIC_IP}" ]; then
  C_HOST_PUBLIC_IP="${C_HOST_PUBLIC_IP}"
else

  # msg "Getting a new host public IP ..." --caller="${SCRIPT_NAME}" --msg-type=info
  # Get the current host public IP
  TEST_C_HOST_PUBLIC_IP=$(dig TXT +short o-o.myaddr.l.google.com @ns1.google.com | awk -F'"' '{ print $2}')
  if is_valid ipv4 "${TEST_C_HOST_PUBLIC_IP}" || is_valid ipv6 "${TEST_C_HOST_PUBLIC_IP}"; then
    C_HOST_PUBLIC_IP="${TEST_C_HOST_PUBLIC_IP}"

  else

    msg "Error, the current host IP '${TEST_C_HOST_PUBLIC_IP}' is invalid. Please insert a valid host public IP manually for C_HOST_PUBLIC_IP variable in config file" --caller="${SCRIPT_NAME}" --msg-type=error
    exit 1
  fi

fi

# msg "Current host public IP is: ${C_HOST_PUBLIC_IP}" --caller="${SCRIPT_NAME}" --msg-type=info

if is_valid domain "${C_BOX_HOSTNAME_FQHN}"; then
  #msg "Current host FQHN is: ${C_BOX_HOSTNAME_FQHN}" --caller="${SCRIPT_NAME}" --msg-type=info

  if [ -n "${C_HOST_TYPE}" ]; then
    C_HOST_TYPE="${C_HOST_TYPE}"
  else

    #msg "Getting a new host type ..." --caller="${SCRIPT_NAME}" --msg-type=info

    if [[ "$(hostname)" == "${C_BOX_HOSTNAME_FQHN}" || "$(hostname)" == "${C_BOX_HOSTNAME}" ]]; then

      TEST_C_HOST_TYPE="remote"
    else
      TEST_C_HOST_TYPE="local"
    fi

    C_HOST_TYPE="${TEST_C_HOST_TYPE}"

  fi
else
  msg "Error, the host FQHN '${C_BOX_HOSTNAME_FQHN}' is invalid. Please insert a valid host FQHN manually for C_BOX_HOSTNAME_FQHN variable in config file" --caller="${SCRIPT_NAME}" --msg-type=error
  exit 1
fi

#msg "Current host type is: ${C_HOST_TYPE}" --caller="${SCRIPT_NAME}" --msg-type=info

ACTION="$1"
ARGNUM="$#"

if [ $ARGNUM -eq 0 ]; then
  msg "$(s red)Error, no argument is supplied. Use $(s yellow)[ ${SCRIPT_NAME} --help ]$(s red) to see the valid options$(e)" --caller="${SCRIPT_NAME}"
  exit 1
fi

# This option handler method does not require getopt
# because the first argument can be treated as normal action without -- or -
while [ "$#" -gt 0 ]; do
  case "${ACTION}" in
  -t | --test)
    configure_gotify --run-force-exit
    echo "test"
    exit 0
    break
    ;;
  -t2 | --test2)
    da_api_admin monitor-user-backup
    exit 0
    break
    ;;
  -h | --help)
    help
    exit 0
    ;;
  # Display program version
  -V | --version)
    script_header
    break
    exit 0
    ;;
  # This one is for configuring script, for example supplying config file through terminal (TODO)
  -c | --configure)
    shift
    msg "Configuring ${_APP_SPECIFIC_NAME} ..." --caller="${SCRIPT_NAME}"
    break
    exit 0
    ;;
  --ct | --config-test)
    validate_config
    break
    exit 0
    ;;
    # Clear all paths (dangerous)
  clear | clean | --clear | --clean)
    clean_setup_files "$@"
    exit 0
    break
    ;;
  dadebug)
    da_api_admin debug
    break
    ;;
  # STARTING BELOW IS ACTION (no symbol --)
  setup | install)
    shift
    setup "$@"
    exit 0
    break
    ;;
  # This option is the starting point for initializing server.
  # It will setup disk from scratch (eg: from linode), call necessary functions and you will get secured server
  # maxinet --init-server <options>
  # Deprecated documentation below (update later):
  # maxinet --init-server optional <init-all> optional <rebuild-iso>
  # Note 1: Only use init-all to remove and start re-creating all partitions
  # Note 2: If you run like this maxinet --init-server init-all
  #   :This will remove all existing partitions including rescue disk and profile. No rescue disk and profile is created
  # Note3: If you run like this (without argument): maxinet --init-server
  #   :This will remove and re-create system related partitions. It will not disturb the rescue option
  init-server | deploy-server | build-server | create-server | setup-server)
    shift
    script_header
    # Make sure internet is OK
    ensure_internet_connected
    init_server "$@"
    exit 0
    break
    ;;
  update-script-only | update-da-script | update-da-scripts | update-maxinet-remote-script | update-remote-scripts | update-remote-script | update-remote-code | update-script | update-scripts)
    ensure_internet_connected
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    shift

    update_remote "setup-script-only"
    exit 0
    break
    ;;
  update-da-hookscript | update-da-hook-script | update-da-hookscripts | update-da-hook-scripts)
    ensure_internet_connected
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    shift

    update_remote "da-hook-script"
    exit 0
    break
    ;;
  update-remote-data | upload-setup-files | update-setup-files | push-setup-files | push-setup-file)
    ensure_internet_connected
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    shift

    update_remote "all"
    exit 0
    break
    ;;
  # This will list out what domain or subdomain that will have problem when request certificate
  srt | ssl-request-test | request-ssl-test)
    # Beta test
    validate_config
    exit 0
    break
    ;;
  # This will request certificate
  sr | ssl-request | request-ssl)
    validate_config
    configure_da_user_domain_ssl --run-force
    exit 0
    break
    ;;
  lui | linode-upload-iso)
    ensure_internet_connected
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    # This is a way to upload iso file from local to remote using scp
    shift
    cp "${SCRIPT_PATH}"/secure/ssh/*.id_rsa* /root/.ssh/
    chmod -R 600 /root/.ssh/
    ssh -i /root/.ssh/linode_lish.id_rsa -tt "${C_LINODE_API_USERNAME}@${C_LINODE_TERMINAL_SERVER}" "${C_BOX_HOSTNAME_FQHN}" <linode/permit_root.sh
    echo "Script executed"
    # sleep 30
    #exit 147
    echo "Uploading ISO file into ~/ at ${C_IPV4_ADD0} using SCP protocol ..."
    iso_file="${SCRIPT_PATH}/storage/os/debian/deb10mod-final.iso"
    scp "${iso_file}" root@"${C_IPV4_ADD0}":~/mini.iso
    echo "Cloning setup file mini.iso into /dev/sda"
    ssh "root@${C_IPV4_ADD0}" 'bash -s' <<"ENDSSH"
      dd if=mini.iso of=/dev/sda
ENDSSH
    exit 0
    break
    ;;

  lu | luks-unlock | unlock-luks | ssh-luks-unlock | unlock-server)
    ensure_internet_connected
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    shift
    ssh_api luks-unlock "$@"
    exit 0
    break
    ;;
  push-ssh-script | run-ssh-script)
    ensure_internet_connected
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    shift
    ssh_api push-script "$@"
    exit 0
    break
    ;;
  get-remote-log)
    ensure_internet_connected
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    shift
    echo "Download setup log file into ${SCRIPT_PATH}/log/${SCRIPT_NAME}.log ..."
    ssh_api file-download --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user root:root --remote-path ~/maxinet.log --local-path "${SCRIPT_PATH}/log"
    retval=$?
    if [ "${retval}" -eq 0 ]; then
      msg "$(s green)Success, now you can view this log file at ${SCRIPT_PATH}/log/${SCRIPT_NAME}.log$(e)" --caller="${SCRIPT_NAME}"
    else
      msg "$(s red)Error, something is wrong when trying to retrieve the log file at ${SCRIPT_PATH}/log/${SCRIPT_NAME}.log$(e)" --caller="${SCRIPT_NAME}"
    fi
    exit 0
    break
    ;;
  # maxinet get-remote-files "~/maxinet.log"
  get-remote-files | download-remote-files | get-remote-file | download-remote-file | get-server-files)
    ensure_internet_connected
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    shift
    #eg: ~/maxinet.log
    remote_files_path="$1"
    echo "Downloading file(s) from ${remote_files_path} into ${DOWNLOAD_PATH}/ ..."
    ssh_api file-download --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user root:root --remote-path "${remote_files_path}" --local-path "${DOWNLOAD_PATH}/"
    retval=$?
    if [ "${retval}" -eq 0 ]; then
      msg "$(s green)Success, file ${remote_files_path} downloaded into ${DOWNLOAD_PATH}/$(basename -- "${remote_files_path}")$(e)" --caller="${SCRIPT_NAME}"
    else
      msg "$(s red)Error, something is wrong when trying to download remote file$(e)" --caller="${SCRIPT_NAME}"
    fi
    exit 0
    break
    ;;

  # maxinet backup-server "/opt /usr/local/maxicode"
  # Make admin_backup here
  # maxinet backup-server admin_backup
  # 1) It will put all user sites in maintenance mode
  # 2) It will use da admin backup function, (must be an API or something to check the status of backup)
  # 3) It will download the backup
  backup-server | server-backup | backup-full-server)
    # TODO check backup exclusion list, might not work properly
    ensure_internet_connected
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    shift
    remote_files_path="$1"
    if [ -z "${remote_files_path}" ]; then
      remote_files_path="/home /boot /etc /root /usr /var /mnt /media /opt /srv"
    fi
    echo ""
    set_linux_crlf "${SECURE_PATH}/backup/backup_exclude_list.txt"
    echo "Downloading file(s) from ${remote_files_path} into ${BACKUP_PATH}/system_backup ..."
    echo ""
    ssh_api file-download --options "-avx --exclude-from '${SECURE_PATH}/backup/backup_exclude_list.txt'" --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user root:root --remote-path "${remote_files_path}" --local-path "${BACKUP_PATH}/${C_BOX_HOSTNAME_FQHN}_system_backups"
    retval=$?
    if [ "${retval}" -eq 0 ]; then
      msg "$(s green)Success, file ${remote_files_path} downloaded into ${BACKUP_PATH}/system_backup$(e)" --caller="${SCRIPT_NAME}"
    else
      msg "$(s red)Error, something is wrong when trying to download remote file$(e)" --caller="${SCRIPT_NAME}"
    fi
    exit 0
    break
    ;;

    # ./maxinet ssh-login <optional_hostname> <optional_port> <optional_user>
    # If hostname or port are not provided, they will use the default ones from config file
  generate-port)
    shift
    generate_unused_port
    exit 0
    break
    ;;
  get-listening-port)
    shift
    get_listening_port "$@"
    exit 0
    break
    ;;
  ssh-login | login-to-server | login)
    ensure_internet_connected
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    time ssh_api login
    shift
    exit 0
    break
    ;;
  ssh-api | ssh)
    shift
    ssh_api "$@"
    exit 0
    break
    ;;
  ssh-transfer)
    shift
    ssh_api transfer-files "$@"
    exit 0
    break
    ;;
  boot-linode | boot-server | start-server)
    shift
    if [ "${C_DNS_PROVIDER_NAME}" == "linode" ]; then
      :
      #linode_api_admin boot-linode "$@"
    elif [ "${C_DNS_PROVIDER_NAME}" == "digitalocean" ]; then
      :
      #digitalocean_api_admin boot-do "$@"
    #elif "Other provider"
    else
      msg "$(s red)Error, unknown DNS provider to execute boot command! $(e)" -- name
    fi
    exit 0
    break
    ;;
  check-server-port)
    shift
    check_server_port "$@"
    exit 0
    break
    ;;
  rs | shutdown-server)
    shift
    _shutdown "$@"
    exit 0
    break
    ;;
  # lish-login <option>
  ll | lish-console | lish | lish-login)
    shift
    lish_console "$@"
    exit 0
    break
    ;;
  # This will generate a modified operating system ISO file that can be used to automatically install OS when booting.
  iso-api | iso-api-admin | iso | manage-iso)
    shift
    iso_api "$@"
    exit 0
    break
    ;;
  remove-da-domain)
    shift
    domain="$1"
    echo "Removing domain from /etc/virtual/domains ..."
    grep -v "^${domain}" /etc/virtual/domains >tmpfile
    cat tmpfile >/etc/virtual/domains
    echo ""
    echo "Removing domain from /etc/virtual/domainowners ..."
    grep -v "^${domain}" /etc/virtual/domainowners >tmpfile
    cat tmpfile >/etc/virtual/domainowners
    echo ""
    echo "Removing domain from /etc/virtual/${domain} ..."
    rm -rf "/etc/virtual/${domain}"
    echo ""
    exit 0
    break
    ;;
  remove-da-user)
    # New method: Manually delete a user
    #-
    #rm -fr /usr/local/directadmin/data/users/examplereseller
    #mv -f /usr/local/directadmin/data/admin/show_all_users.cache /root/show_all_users.cache
    #rm -fr /home/examplereseller
    #userdel examplereseller  (gets the user off from passwd, shadow, group & gshadow files)
    #rm -fr /var/spool/mail/examplereseller
    #locate examplereseller  (delete all occurrences)
    #\cp -a /root/show_all_users.cache /usr/local/directadmin/data/admin/
    #
    #---
    #
    #(one liner ; just change the username)
    #rm -fr /usr/local/directadmin/data/users/examplereseller && mv -f /usr/local/directadmin/data/admin/show_all_users.cache /root/show_all_users.cache && rm -fr /home/examplereseller && userdel examplereseller && rm -fr /var/spool/mail/examplereseller && locate examplereseller (delete all occurrences)
    #and finally:
    #\cp -a /root/show_all_users.cache /usr/local/directadmin/data/admin/show_all_users.cache
    shift
    username="$1"
    user_directory="/usr/local/directadmin/data/users/${username}"
    echo "Removing user directadmin directory at ${user_directory} ..."
    if [ -d "${user_directory}" ]; then
      rm -rf "${user_directory}"
    else
      echo "Warning, path ${user_directory} not found"
    fi
    echo ""
    all_user_cache="/usr/local/directadmin/data/admin/show_all_users_cache"
    echo "Removing all directadmin user cache at ${user_directory} ..."
    if [ -f "${all_user_cache}" ]; then
      rm -rf "${all_user_cache}"
    else
      echo "Warning, path ${all_user_cache} not found"
    fi
    echo ""
    quotaoff_bin="$(command -v quotaoff)"
    msg "$(s cyan)Turning off system quota ...$(e)" --caller="${SCRIPT_NAME}"
    ${quotaoff_bin} -a
    echo ""
    user_home_directory="/home/${user}"
    echo "Removing user home directory at ${user_home_directory} ..."
    if [ -d "${user_home_directory}" ]; then
      rm -rf "${user_home_directory}"
    else
      echo "Warning, path ${user_home_directory} not found"
    fi
    echo ""
    exit 0
    echo "Removing user or group ${user} from system ..."
    deluser ${user}
    echo ""
    break
    ;;
    # Test or user linode API here
  # eg: maxinet --linode-api "get-linode-id" "sun.sofibox.com"
  linode-api | linode | manage-linode)
    shift
    :
    # Not using anymore
    # linode_api_admin "$@"
    break
    exit 0
    ;;
  create-server-backup | pull-server-backup | create-backup | create-admin-backup)
    echo "Creating and pulling server backup ..."
    break
    exit 0
    ;;
  da-api | da | directadmin-api | directadmin | manage-da | manage-directadmin)
    shift
    da_api_admin "$@"
    exit 0
    break
    ;;
  build | build-package)
    shift
    package_name="$1"
    navigate_to "${HOME}"
    if [ "${package_name}" == "go" ]; then
      maxibuild --include "golang-go"
    elif [ "${package_name}" == "dbxcli" ]; then
      maxibuild --include "git golang-go gox"
      mkdir -p "${HOME}/go"
      go get github.com/dropbox/dbxcli
      navigate_to "${HOME}/go/src/github.com/dropbox/dbxcli"
      # To be continued ...
    elif [ "${package_name}" == "dbx" ]; then
      :
    else
      echo "No known package!"
    fi
    exit 0
    break
    ;;
  *) ;;
  esac
  msg "$(s red)Error, invalid action or option [ $1 ]. Use --help to see the valid actions or options$(e)" --caller="${SCRIPT_NAME}"
  exit 147
done

[[ ${C_LOG_VERBOSITY_LEVEL} == "8" ]] && set +x

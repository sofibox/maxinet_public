#!/bin/bash
# =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
# Author: Arafat Ali | Email: webmaster@sofibox.com | Website: sofibox.com

_APP_SPECIFIC_NAME="Maxinet"
# Note that some minor versions are not published
_APP_VERSION="0.7.0"
_APP_STATUS="alpha"
_APP_VERSION_STATUS="${_APP_VERSION}-${_APP_STATUS}"

### START TEMPORARY NOTE
### END TEMPORARY NOTE

# This is a personal project that I wrote for server automation to reduce server configuration time.
# The aim is this project is to have everything automated when deploying a new server without wasting a lot of time.
# For example setting up a secured server from scratch with hardened configs might take few days (I've experienced this) but this script will reduce that longer period to about 1 hour with one command!
# I focused a lot of security enhancements in this script for a new server deployment in order to reduce server malicious attack.

# Warning, you should not use this script if you dont know the purpose of this script. This script might contain bug (especially this public version)
# There is another private version without _public name URL that always have the latest code and features.
# Running example:

# maxinet create-server --rebuild-all --backup

# For example if everything is configured correctly for Directadmin and Linode in maxinet.conf,
# the above command will configure a new server disk and config in linode, it will then create custom ISO file for Debian, then it will install this operating system.
# then do a lot of thing behind ... bla2 bla2 ... (read the code to understand what it does because it is huge to write what it does) ... and finally you will get a fully working server with live websites. So, with only a single command, you will get a clean server with security hardened features
# The feature is currently huge to list out.
# It might contain bugs for other distributions. This script is fully tested on Debian 10, Debian 11 and with Directadmin custom and auto installation. This script compatible with linode + directadmin
# Author: Arafat Ali | Email: arafat@sofibox.com | Personal Blog: arafatx.com
# See maxinet --help for more information

#######################
# FUNCTION BEGIN HERE #
#######################

# This function is used to handle exit trap that can accept multiple trap arguments
# syntax: traps <traps_cleanup_function> SIG1 SIG2 SIG3 ... SIGN[N]
# eg: traps exit_function QUIT INT TERM EXIT
traps() {
  local clean_function
  clean_function="$1"
  shift
  for sig; do
    trap "${clean_function} ${sig}" "${sig}"
  done
}
# This function is used by traps() function to clean exit
script_exit() {
  # The first argument will have the name of the trap signal executed:
  # eg: echo "Trapped: $1"
  # This variable hold the count of key press of CTRL+C
  ((CTRL_C_COUNT++))
  # Check if the locking directory is exist, if yes, remove it
  if [ -d "${LOCK_DIR}" ]; then
    rm -rf "${LOCK_DIR}"
    #echo ""
    #echo "[${SCRIPT_NAME}]: OK, locked flag removed from ${LOCK_DIR}"
  fi
  # this if condition will determine that this cleanup function is only called a single time CTRL_C_COUNT=1
  # this function might be called several times because we passed long arguments for trap to call this function
  if [[ ${CTRL_C_COUNT} == 1 ]]; then
    local signal
    signal="$1"
    echo ""
    # if the trapped signal is INT (or interactive) then we know this is interactive exit executed by a user.
    if [ "${signal}" == "INT" ]; then
      # so print the current user who terminated this script
      _echo "$(msg yellow)*** Warning, this script has been terminated by user: $(msg red)${USER}!$(msg end) $(msg yellow)***$(msg end)" --name
      # Check if trap with other signal here
      #elif [ "${signal}" == "OTHER_SIGNAL" ]; then
      :
    else
      # for other trap signals that we don't care, we just print out the trap signal type
      _echo "$(msg cyan)This script has been terminated with signal:$(msg end) $(msg red)${signal}$(msg end)" --name
    fi
    echo ""
    echo "-------------------------------END-----------------------------------------"
    echo ""
    echo "Remember you can always resume installation with the following command:"
    echo "For local installation: ${SCRIPT_NAME} setup 2>&1 | tee ${SCRIPT_NAME}.log"
    echo "For remote installation: ${SCRIPT_NAME} --push-ssh-script --sp ${LABEL_C_BOX_HOSTNAME_FQHN}:${LABEL_C_SSH_PORT} --gu root:${LABEL_C_ROOT_USERNAME} --push-maxinet-setup-script"
    echo ""
    echo "SSH user login guide:"
    echo "To login as root user: ${SCRIPT_NAME} ssh-login ${LABEL_C_ROOT_USERNAME} or ${SCRIPT_NAME} login"
    echo "To login as SSH user: ${SCRIPT_NAME} ssh-login ${LABEL_C_SSH_USERNAME}"
    echo ""
    echo "Server LUKS unlock guide:"
    echo "To unlock LUKS Disk encryption: ${SCRIPT_NAME} --luks-unlock"
    echo ""
    script_time
    echo ""
  fi
  # clean exit
  exit 1
}

get_listening_port() {
  local port
  port="$1"
  netstat -na | grep "${port}"
}

generate_unused_port() {
  local port
  read lowerport upperport </proc/sys/net/ipv4/ip_local_port_range
  while :; do
    port="$(shuf -i ${lowerport}-${upperport} -n 1)"
    ss -lpn | grep -q ":${port} " || break
  done
  echo "${port}"
}
# Directadmin debug exit trap
da_debug_exit() {
  # echo "Trapped: $1"
  ((CTRL_C_COUNT++))
  if [[ $CTRL_C_COUNT == 1 ]]; then
    local signal
    signal="$1"
    echo ""
    if [ "${signal}" == "INT" ]; then
      echo "[${SCRIPT_NAME}]: *** Warning, Directadmin debug mode has been terminated by ${USER}! ***"
    fi
    echo "[${SCRIPT_NAME}]: Starting directadmin in normal mode ..."
    systemctl restart directadmin
    echo "[${SCRIPT_NAME}]: Directadmin running status is: $(systemctl is-active directadmin)"
    echo ""
    echo "                             **END DEBUG**                        "
    echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
  fi
  # clean exit
  exit 1
}

# This function will read current status of the last script passed to the first argument whether it is return 0 or not
# If it returns 0, display [ OK ] else display [ FAILED ] and exit
get_status_message() {
  local retval
  retval="$1"
  if [[ "${retval}" -eq 0 ]]; then
    echo " [ OK ]"
  else
    echo " [ FAILED ]"
    exit 1
  fi
}

get_ordinal() {
  local integer
  integer="$1"
  case "${integer}" in
  *1[0-9] | *[04-9]) echo "${integer}"th ;;
  *1) echo "${integer}"st ;;
  *2) echo "${integer}"nd ;;
  *3) echo "${integer}"rd ;;
  esac
}

# _echo "hello $(msg red)this is red $(msg end)" --report --timestamp --name
# _echo "hello $(msg red)this is red $(msg end) and $(msg underline)$(msg -b yellow)$(msg green)this is underline with yellow background and green color $(msg end)" --report --timestamp --name
# Default value for verbose should be 6, so if we dont' specify verbose value, it will use this
# To turn off echo (but still ...
# Remember if you want to pass any character but begin with single or double hypens, you cannot do this: _echo "------" or _echo "-test". You need to use the following:
#_echo -- "------" or _echo -- "-test"
# Can be used with gotify: _echo "How are you" | gotify
_echo() {
  local long_opts short_opts options retval report timestamp name verbose plain start_spin stop_spin push_notification silent push_notification_silent
  declare -A LOG_LEVELS

  short_opts="vqsprtn"
  long_opts="verbose:,quiet,silent,plain,report,timestamp,name,start-spin,stop-spin,push-notification,push-notification-silent,progress-style:"

  options=$(getopt -a -o "${short_opts}" --long "${long_opts}" -n "${FUNCNAME[0]} ${SCRIPT_NAME}" -- "$@")
  retval=$?
  if [ ${retval} != 0 ]; then
    _echo "$(msg red)Error, invalid options. Terminating...$(msg end)" --name
    exit 1
  fi

  # Must quote this option variable
  eval set -- "${options}"
  LOG_LEVELS=([0]="emerg" [1]="alert" [2]="crit" [3]="err" [4]="warning" [5]="notice" [6]="info" [7]="debug" [8]="expert")
  verbose=6 # Default is 6 if not specified
  report=false
  timestamp=false
  name=false
  plain=false
  start_spin=false
  stop_spin=false
  push_notification=false
  push_notification_silent=false
  silent=false
  progress_style=""
  while true; do
    case "$1" in
    -v | --verbose)
      verbose="$2"
      shift 2
      ;;
    -q | --quiet)
      verbose=-1
      shift
      ;;
    -s | --silent)
      silent=true
      verbose=-1
      shift
      ;;
    # This plain does not care what verbosity level is, it just displays the text normally (useful for writing info label)
    -p | --plain)
      #verbose=-1
      plain=true
      shift
      ;;
    -r | --report)
      report=true
      #echo "report is set to true"
      shift
      ;;
    -t | --timestamp)
      timestamp=true
      #echo "timestamp is set to true"
      shift
      ;;
    -n | --name)
      name=true
      #echo "name is set to true"
      shift
      ;;
    --start-spin)
      start_spin=true
      shift
      ;;
    --stop-spin)
      stop_spin=true
      shift
      ;;
    --push-notification)
      push_notification=true
      shift
      ;;
    --push-notification-silent)
      push_notification_silent=true
      shift
      ;;
    --progress-style)
      progress_style="$2"
      shift 2
      ;;
    --)
      shift
      break
      ;;
    -*)
      echo "Error, unknown option: $1"
      _exit 147
      ;;
    *)
      break
      ;;
    esac
  done

  if [[ ${start_spin} == "true" && ${stop_spin} == "true" ]]; then
    echo "Warning the option --start-spin and --stop-spin cannot appear at the same time!"
    exit 1
  fi
  msg="$*"
  # Specifying name automatically use report file
  if [[ ${report} == "true" || ${name} == "true" ]]; then
    report_path="${REPORT_FILE}"
  else
    report_path=/dev/null
  fi

  if [[ ${timestamp} == "true" && ${name} == "true" ]]; then
    msg="[${SCRIPT_NAME}|$(date +'%d-%m-%Y %H:%M:%S')]: ${msg}"
  elif [[ ${timestamp} == "true" && ${name} == "false" ]]; then
    msg="[$(date +'%d-%m-%Y %H:%M:%S')]: ${msg}"
  elif [[ ${timestamp} == "false" && ${name} == "true" ]]; then
    msg="[${SCRIPT_NAME}]: ${msg}"
  fi

  if [[ ${start_spin} == "true" ]]; then
    if [[ -z "${progress_style}" ]]; then
      progress_style="${C_SPIN_PROGRESS}"
    fi
    echo -ne "\r\e[0K${msg} [${progress_style:SPIN_COUNT++:1}]"
    ((SPIN_COUNT == ${#progress_style})) && SPIN_COUNT=0
    # hide cursor
    tput civis
  elif [[ ${stop_spin} == "true" ]]; then
    echo -ne "\r\e[0K${msg}\n"
    # restore cursor
    tput cnorm
  elif [[ "${plain}" == "true" ]]; then
    # When using --plain option, only display if verbosity level is higher than what is set (if not just dont display anything)
    if [[ "${C_LOG_VERBOSITY_LEVEL}" -ge "${verbose}" && "${verbose}" -ne -1 ]]; then
      echo -e "${msg}" 2>&1 | tee -a ${report_path}
    fi
    # Send push notification here if --push-notification is set.
    # _echo "
  elif [[ "${push_notification}" == "true" || "${push_notification_silent}" == "true" ]]; then
    # Only send notification if gotify is installed
    if command -v gotify &>/dev/null; then
      local push_msg
      #priority 10 will make the phone vibrate and has high volume
      push_msg=$(echo -e "${msg}" | gotify push -p "${C_GOTIFY_PUSH_PRIORITY}")
      retval=$?
      if [[ "${retval}" -eq 0 ]]; then
        if [[ "${push_notification_silent}" == "false" ]]; then
          echo -e "${msg} [PUSH NOTIFICATION SENT]"
        else
          echo -e "[PUSH NOTIFICATION SENT]"
        fi
        return 0
      else
        echo "[${SCRIPT_NAME}]: Warning, failed to send push notification to gotify for the following text:"
        echo "${msg}"
        echo ""
        echo "[${SCRIPT_NAME}]: Reason of failed:"
        echo "${push_msg}"
        echo ""
        return "${retval}"
      fi
    else
      echo "[${SCRIPT_NAME}]: Warning, gotify is not installed. The option --push-notification does nothing"
    fi
  elif [[ "${C_LOG_VERBOSITY_LEVEL}" -ge "${verbose}" && "${verbose}" -ne -1 ]]; then
    echo -e "[${LOG_LEVELS[${verbose}]}] ${msg}" 2>&1 | tee -a ${report_path}
  else # Meaning this is quiet but still we write report in file
    if [ ${report} == "true" ]; then
      echo -e "[${LOG_LEVELS[${verbose}]}] ${msg}" >>${report_path} 2>&1
    fi
  fi

}

# Deprecated function, use _echo with improved version instead
#  This function is used to print log file with timestamp
# syntax: _log <color> <message> <optional_log_file_path>
# _log red "hello wassup" "${REPORT_FILE}"
# Without color: _log "default" "hello there"
_log() {
  local color info log_file
  color=$1
  info=$2
  log_file=$3

  if [[ $# -eq 3 ]]; then
    if [ -f "${log_file}" ]; then
      _echo "${color}" "[${SCRIPT_NAME}|$(date +'%d-%m-%Y %H:%M:%S')]: ${info}" | tee "${log_file}"
    else
      _echo yellow "[${SCRIPT_NAME}|$(date +'%d-%m-%Y %H:%M:%S')]: Warning log file [${log_file}] does not exist! Creating the log file [${log_file}] for the first time ..."
      touch "${log_file}"
      chmod 644 "${log_file}"
      #_exit 1
    fi
  elif [[ $# -eq 2 ]]; then
    if [ -f "${log_file}" ]; then
      :
    else
      _echo "${color}" "[${SCRIPT_NAME}|$(date +'%d-%m-%Y %H:%M:%S')]: ${info}"
    fi
  else
    _echo "red" "[${SCRIPT_NAME}|$(date +'%d-%m-%Y %H:%M:%S')]: Invalid number of argument in _log() function call"
    # log_file="${REPORT_FILE}"
  fi
  #_echo "${color}" "[${SCRIPT_NAME}|$(date +'%d-%m-%Y %H:%M:%S')]: ${info}" | tee "${log_file}"
}

# This function will pause the current running terminal
# It will interactively ask to press enter or wait within <duration_in_seconds> to continue the next command
# syntax: _pause <optional_duration>
# eg: _pause | no timeout means we need to press enter to continue
# eg: _pause 10 | wait 10 seconds or press enter to continue
_pause() {
  echo ""
  local duration=$1
  # If argument is not an integer, we disable read timeout
  # TODO validate this statement again
  if [[ ${duration} =~ ^[0-9]+$ ]]; then
    read -t "${duration}" -r -s -n 1 -p "[${SCRIPT_NAME}]: Press any key or wait within ${duration} second(s) to continue or press (Ctrl+c) to cancel ..."
  else
    read -r -s -n 1 -p "[${SCRIPT_NAME}]: Terminal is paused! Press any key to continue or press (Ctrl+c) to cancel ..."
  fi
  echo ""
}

# This function will display a confirmation to continue (force continue; no exit function)
_confirm() {
  # call with a prompt string or use a default
  read -r -p "[${SCRIPT_NAME}]: ${1:-Continue? [y] Exit? [CTRL+C]} " response
  case "$response" in
  [yY][eE][sS] | [yY])
    return 0
    ;;
  *)
    echo "[${SCRIPT_NAME}]: Invalid response to the question!"
    _confirm "$1"
    ;;
  esac
}
# This function is used to terminate a current running script.
# pass the normal exit code
# syntax: _exit <exit_code>
# eg: _exit 3
_exit() {
  exit "$1"
}

# This function is used to reboot the system using force reboot -r now without any arguments
# syntax _reboot
_reboot() {
  # an exit ASCII symbol invented by MaXi32
  echo "[${SCRIPT_NAME}]: Rebooting system ..."
  echo "--<]--"
  shutdown -r now
}

# This function is used to shutdown the system using force shutdown -h now without any arguments
# syntax _shutdown
_shutdown() {
  # a shutdown ASCII symbol invented by MaXi32
  echo "[${SCRIPT_NAME}]: Shutting down system ..."
  echo "--[]--"
  shutdown -h now
}

# decode URL, use with echo -n "string" | urldecode or printf %s "string" | urldecode
urldecode() {
  printf '%b\n' "$(sed 's/+/ /g;s/%\(..\)/\\x\1/g;')"
}
# encode URL, use with echo -n "string" | urlencode or printf %s "string" | urlencode
urlencode() {
  required "debian@@apt:jq" "ubuntu@@apt:jq"
  printf '%b\n' "$(jq -sRr @uri)"
}

# This function will print all text as multiple row separated by separator symbol. Usage example:
# echo "Test=19-&Hello=2+" | awksep '&'
# output:
# Test=19-
# Hello=2+
awksep() {
  local separator="$1"
  printf '%b\n' "$(awk -F"${separator}" '{for(i=1;i<=NF;++i)print $i }')"
}

# This function set_linux_crlf will automatically remove CRLF character in file to make sure file is compatible with linux
# It does not return error if the file is already in unix format before
set_linux_crlf() {
  local files retval
  files="$1"
  required "debian@@apt:dos2unix" "ubuntu@@apt:dos2unix"
  for file in ${files}; do
    echo "Checking and converting file [ ${file} ] into unix compatible file ..."
    dos2unix <"${file}" | cmp - "${file}" 2>&1
    retval=$?
    if [ "${retval}" -ne 0 ]; then
      dos2unix "${file}"
    fi
    echo ""
  done
}

script_header() {
  # This is script header
  _echo "$(msg red)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --plain
  _echo "$(msg cyan)Welcome to $(msg red)${_APP_SPECIFIC_NAME}$(msg cyan) Automated Script (${EXECUTION_ENV})$(msg end)" --plain
  _echo "$(msg blue)This powerful script is part of Sofibox/MaxiNet scripts$(msg end)" --plain
  _echo "$(msg green)For script help: $(msg yellow)${SCRIPT_NAME} --help$(msg end)" --plain
  _echo "$(msg green)Script official URL: $(msg yAellow)http://sofibox.com/maxinet$(msg end)" --plain
  _echo "$(msg green)Version: $(msg yellow)${SCRIPT_NAME}-${_APP_VERSION_STATUS}$(msg end)" --plain
  _echo "$(msg green)Distro ID: $(msg yellow)${DISTRO_ID}$(msg end) | $(msg green) Distro Version: $(msg yellow)${DISTRO_VERSION}$(msg end)" --plain
  _echo "$(msg cyan)$(msg bold)(C) Author: Arafat Ali | Email: arafat@sofibox.com$(msg end)" --plain
  _echo "$(msg red)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --plain
  _echo "$(msg yellow)Running date and time: ${DATE_TIME_NOW}$(msg end)" --name
  _echo "" --plain
}

help() {
  # This help section is deprecated, will update time to time when the code finish
  echo ""
  echo "Welcome to help section!"
  echo "------------------------"
  echo "Run initialize installation with log output: ${SCRIPT_NAME} create-server --rebuild-all --backup 2>&1 | tee ${SCRIPT_NAME}.log"
  echo ""
  echo "To start/resume local installation: "
  echo "eg:"
  echo "${SCRIPT_NAME} setup"
  echo "OR"
  echo "${SCRIPT_NAME} setup 2>&1 | tee ${SCRIPT_NAME}.log"
  echo ""
  echo "To start/resume remote installation:"
  echo "Syntax: ${SCRIPT_NAME} ssh-login <fqdn>:<ssh_port> <user_role>:<user_name> <local_script_to_push_for_installation>"
  echo "eg:"
  echo "${SCRIPT_NAME} ssh-login \"${LABEL_C_BOX_HOSTNAME_FQHN}:${LABEL_C_SSH_PORT}\" \"root:${LABEL_C_ROOT_USERNAME}\" \"${CODE_PATH}/ssh_scripts/maxinet_setup.sh\""
  echo ""
  echo "To unlock LUKS Disk encryption:"
  echo "Syntax: ${SCRIPT_NAME} --ssh-luks-unlock <DROP_BEAR_PORT> \"<LUKS_PASS>\""
  echo "eg:"
  echo "${SCRIPT_NAME} --ssh-luks-unlock ${LABEL_C_DROP_BEAR_PORT} \"${LABEL_C_LUKS_PASS}\""
  echo ""
  echo "To login as root user: ${SCRIPT_NAME} ssh-login \"${LABEL_C_BOX_HOSTNAME_FQHN}:${LABEL_C_SSH_PORT}\" \"user:root\""
  echo ""
  echo "To login as SSH user: ${SCRIPT_NAME} ssh-login \"${LABEL_C_BOX_HOSTNAME_FQHN}:${LABEL_C_SSH_PORT}\" \"root:${LABEL_C_SSH_USERNAME}\""

}

manual() {
  # This help section is deprecated, will update time to time when the code finish
  local manual_name="$1"
  if [ "${manual_name}" == "init_server" ]; then
    local lopt="--init-server"
    echo "----------------------------------------------"
    echo "Help section for ${SCRIPT_NAME}/${manual_name}"
    echo "----------------------------------------------"
    echo "CALL METHOD"
    echo ""
    echo "FOR EXTERNAL CALL: ${SCRIPT_NAME} ${lopt} --help"
    echo "FOR INTERNAL CALL: ${manual_name} --help"
    echo ""
    echo "SYNTAX 1: "
    echo ""
    echo "${SCRIPT_NAME} ${lopt} *<long-option1> +<long-option2> ... +<long-optionN>"
    echo ""
    echo "EXAMPLE SYNTAX 1: "
    echo ""
    echo "${SCRIPT_NAME} ${lopt} --rebuild-iso --backup-ssh-key --backup-iso"
    echo "EXAMPLE SYNTAX 2: "
    echo ""
    echo "${SCRIPT_NAME} ${lopt} --rebuild-all --backup-all"
    echo ""
    echo "DESCRIPTION"
    echo ""
    echo "1) <LONG OPTIONS>"
    echo "--rebuild-iso  -  rebuild server OS ISO image from scratch"
    echo "--rebuild-partition  -  rebuild server disk partition from scratch"
    echo "--rebuild-config - rebuild server config from scratch"
    echo "--rebuild-all  -  rebuild everything from the above"
    echo "--backup-ssh-key - backup server previous ssh key file (both private and public keys)"
    echo "--backup-iso  -  backup server previous OS ISO image file"
    echo "--backup-all  -  backup everything from the above"
    echo ""
    echo "NOTE 1:"
    echo ""
    echo "${SCRIPT_NAME} --init-server --rebuild-iso --rebuild-partition --rebuild-config"
    echo "is equivalent to"
    echo "${SCRIPT_NAME} --rebuild-all"

    echo ""
    echo "NOTE 2:"
    echo ""
    echo "${SCRIPT_NAME} --init-server --backup-ssh-key --backup-iso"
    echo "is equivalent to"
    echo "${SCRIPT_NAME} --backup-all"
    echo ""
    echo "NOTE 3:"
    echo ""
    echo "Can only accept long options that begins with 2 dashes --. eg: --rebuild-iso"
    echo ""
  fi
  if [ "${manual_name}" == "linode_api_admin" ]; then
    local lopt="--linode-api"
    echo "----------------------------------------------"
    echo "Help section for ${SCRIPT_NAME}/${manual_name}"
    echo "----------------------------------------------"
    echo "$(msg yellow)CALL METHOD$(msg end)"
    echo ""
    echo "$(msg yellow)FOR EXTERNAL CALL: ${SCRIPT_NAME} ${lopt} --help"
    echo "$(msg yellow)FOR INTERNAL CALL: ${manual_name} --help"
    echo ""
    echo "$(msg yellow)SYNTAX 1:$(msg end)"
    echo "${SCRIPT_NAME} ${lopt} *<ACTION> +<--verbose/-v> +<--scripting/-s> +<long-option2> ... +<long-optionN>"
    echo ""
    echo "$(msg yellow)EXAMPLE 1:$(msg end)"
    echo "${SCRIPT_NAME} ${lopt} get-domain-id -verbose --domain maxibi.com"
    echo ""
    echo "$(msg yellow)DESCRIPTION$(msg end)"
    echo ""
    echo "1) $(msg yellow)<ACTION>$(msg end)"
    echo ""
    echo "1.1) $(msg cyan)get-linode-id$(msg end)  -  get the linode id for a given label"
    echo "$(msg yellow)SYNTAX 1: $(msg end)"
    echo "${SCRIPT_NAME} ${lopt} get-linode-id --linode-label <linode_label>"
    echo "$(msg yellow)EXAMPLE SYNTAX 1:$(msg end)"
    echo "${SCRIPT_NAME} ${lopt} get-linode-id --linode-label server.test.com"
    echo "$(msg yellow)EXAMPLE OUTPUT 1:$(msg end)"
    echo "12344422"
    echo ""
    echo "1.2) $(msg cyan)get-linode-status$(msg end)  -  get the linode status for a given label"
    echo "$(msg yellow)SYNTAX 1: $(msg end)"
    echo "${SCRIPT_NAME} ${lopt} get-linode-status --linode-label <linode_label>"
    echo "$(msg yellow)EXAMPLE SYNTAX 1:$(msg end)"
    echo "${SCRIPT_NAME} ${lopt} get-linode-status --linode-label server.test.com"
    echo "$(msg yellow)EXAMPLE OUTPUT 1:$(msg end)"
    echo "running"
    echo ""
    echo "1.4) $(msg cyan)get-domain-id$(msg end)  -  get the linode domain id for a given domain"
    echo "$(msg yellow)SYNTAX 1:$(msg end)"
    echo "${SCRIPT_NAME} ${lopt} get-domain-id --domain <domain_name>"
    echo "$(msg yellow)EXAMPLE SYNTAX 1:$(msg end)"
    echo "${SCRIPT_NAME} ${lopt} get-domain-id --domain test.com"
    echo "$(msg yellow)EXAMPLE OUTPUT 1:$(msg end)"
    echo "12322"
    echo ""

  fi
}

# Create dynamic variable
# variable_api <required action> <required VARIABLE --name> <optional --value>
# variable_api create-variable --name myvariable --value hello | this creates variable name with value hello
# variable_api create-variable --name testvariable | this creates a variable name testvariable without value
# variable_api get-variable-value --name testvariable | this will display the variable testvariable value
variable_api() {
  local action argnum options retval name value
  action="$1"
  argnum="$#"
  if [ ${argnum} -eq 0 ]; then
    echo "Error, no argument is supplied. Use [ ${SCRIPT_NAME} --create-var --help ] to see the valid options"
    exit 1
  fi
  short_opts=""
  long_opts="help,name:,value:"
  options=$(getopt -o "${short_opts}" --long "${long_opts}" -n "${FUNCNAME[0]} in ${SCRIPT_NAME}" -- "$@")
  retval=$?
  if [ "${retval}" != 0 ]; then
    echo "Error, invalid parse data. Terminating..."
    exit 1
  fi

  # Must quote this option variable
  eval set -- "${options}"

  name=""
  value=""
  while true; do
    case "$1" in
    --help)
      manual "${FUNCNAME[0]}"
      shift
      exit 0
      ;;
    --name)
      name="$2"
      shift 2
      ;;
    --value)
      value="$2"
      shift 2
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
    esac
  done
  if [ "${action}" == "create-variable" ]; then
    if [ -z "${name}" ]; then
      echo "Error, the option --name is required!"
      _exit 1
    fi
    # Put option -g for global variable
    if [ -n "${value}" ]; then
      declare -g "VAR_${name}=${value}"
    else
      declare -g "VAR_${name}"
    fi
  elif [ "${action}" == "get-variable-value" ]; then
    local dv
    if [ -z "${name}" ]; then
      echo "Error, the option --name is required!"
      _exit 1
    fi
    dv="VAR_${name}"
    echo "${!dv}"
  else
    echo "Error, invalid action for variable_api!"
    exit 147
  fi
}

# This function validate all data argument. Eg: check if the domain name provided is FQDN or valid
# is_valid server_record_type <data>
is_valid() {
  local type data1 data2 retval distro_id
  type="$1"
  data1="$2"
  data2="$3"
  distro_id="${DISTRO_ID}"

  required "debian@@apt:iproute2"
  # is_valid version_required  <required_version> <current_version>
  if [[ "${type}" == "version_required" || "${type}" == "version_needed" ]]; then
    local current_version required_version
    required_version="${data1}"
    current_version="${data2}"
    if [ "$(printf '%s\n' "${required_version}" "${current_version}" | sort -V | head -n1)" = "${required_version}" ]; then
      return 0
    else
      return 1
    fi
  # is_valid ipv4-resolved 1.1.1.1 sun.server.com
  # is_valid ipv4_resolved
  elif [[ "${type}" == "ipv4-resolved" || "${type}" == "ipv4_resolved" ]]; then
    local ipv4 ipv4_propagated domain
    ipv4="${data1}"
    domain="${data2}"
    if [ -z "${domain}" ]; then
      domain="${C_BOX_HOSTNAME_FQHN}"
    fi
    ipv4_propagated=$(dig ${domain} A +short)
    if [ "${ipv4_propagated}" = "${ipv4}" ]; then
      return 0
    else
      return 1
    fi

    # is_valid ipv6-resolved 1.1.1.1 sun.server.com
    # is_valid ipv6_resolved
  elif [[ "${type}" == "ipv6-resolved" || "${type}" == "ipv6_resolved" ]]; then
    local ipv6 ipv6_propagated domain
    ipv6="${data1}"
    domain="${data2}"
    if [ -z "${domain}" ]; then
      domain="${C_BOX_HOSTNAME_FQHN}"
    fi
    ipv6_propagated=$(dig ${domain} AAAA +short)
    if [ "${ipv6_propagated}" == "${ipv6}" ]; then
      return 0
    else
      return 1
    fi

  elif
    [[ "${type}" == "ipv6_prefix" || "${type}" == "ipv6_subnet" ]]
  then
    local ipv6_prefix ipv6_prefix_pattern
    ipv6_prefix="${data1}"
    #ipv6_prefix_pattern='^(\/)\b([1-9]|[1-5][0-9]|6[0-4])\b'
    ipv6_prefix_pattern='^(\/)\b(1?[1-9]{1,2}|2[0-4][0-9]|25[0-5])\b'
    if [[ ${ipv6_prefix} =~ ${ipv6_prefix_pattern} ]]; then
      return 0
    else
      return 1
    fi
    #if is_valid ssl_site "${C_BOX_HOSTNAME_FQHN}:${C_DA_PORT}"; then
  elif [[ "${type}" == "ssl_site" ]]; then
    local url final_hostname status
    url="${data1}"
    # echo "url: ${url}
    host "${url}" >/dev/null 2>&1
    retval=$?
    if [ "${retval}" -eq 0 ]; then
      #echo "Link is valid"
      # Use timeout 3 instead of the built-in function because the built in function --max-wait does not work
      # This will get the final redirection for a hostname
      final_hostname=$(timeout 3 curl "${url}" -s -L -I -o /dev/null -w '%{url_effective}' | awk -F[/:] '{print $4}')
      #echo "URL: ${url}"
      #echo "FINAL_HOSTNAME: ${final_hostname}"
      #echo "PORT: ${port}"
      status=$(curl --cert-status -v https://${final_hostname} 2>&1 | awk 'BEGIN { cert=0 } /^\* Server certificate:/ { cert=1 } /^\*/ { if (cert) print }' | grep "*  SSL certificate verify ok.")
      #status=$(timeout 3 openssl s_client -connect "${final_hostname}:${port}" </dev/null 2>/dev/null | grep 'Verify return code: 0 (ok)')
      if [ -n "${status}" ]; then
        #echo "Site ${final_hostname} with port ${port} is valid https"
        return 0
      else
        return 1
        #echo "Site ${final_hostname} with port ${port} is not valid https"
      fi
    else
      #echo "Link is not valid"
      return 1
    fi

  # is_valid available_port <server> <port>
  # This function will check if defined server and port is available (in a listening state)
  # Usage: available_port <server> <port>
  # eg: available_port test.sofibox.com 22
  # It will return 0 (if available), and other return codes (if listening state for the port is not available)
  elif [[ "${type}" == "available_port" ]]; then
    local server port retval
    server="${data1}"
    port="${data2}"
    nc -z -v -w5 "${server}" "${port}" 2>/dev/null
    retval=$?
    return ${retval}

  elif [[ "${type}" == "integer" ]]; then
    if [[ ${data1} =~ [0-9] ]]; then
      return 0
    else
      return 1
    fi
  elif [[ "${type}" == "domain" ]]; then
    if grep -oP '(?=^.{4,253}$)(^(?:[a-zA-Z0-9](?:(?:[a-zA-Z0-9\-]){0,61}[a-zA-Z0-9])?\.)+([a-zA-Z]{2,}|xn--[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])$)' <<<"${data1}" >/dev/null 2>&1; then
      #if grep -oP '^((?!-)[A-Za-z0-9-]{1,63}(?<!-)\.)+[A-Za-z]{2,6}$' <<< "$1" >/dev/null 2>&1;then
      return 0
      # do another check using host if regex above detected as false and return either true or false
    else
      host "${data1}" >/dev/null 2>&1
      retval=$?
      return "${retval}"
    fi

  elif [[ "${type}" == "domain_type" ]]; then
    # Convert to capital with ^^ and compare with capital letters
    if [[ "${data1^^}" == +(MASTER|SLAVE) ]]; then
      return 0
    else
      return 1
    fi
    # For linode case ttl
    #  record_ttl="300" # 300(5m), 3600(1h), 7200(2h), 14400(4h), 28800(8h), 57600(16h), 0/86400(1d)-Default, 172800(2d), 345600(4d), 691200(8d), 604800(1w), 1209600(2w), 2419200(4w).
  elif [[ "${type}" == "domain_ttl" ]]; then
    if [[ ${data1} -ge 30 && ${data1} -le 2419200 && ${data1} =~ ^[0-9]+$ ]]; then
      return 0
    else
      return 1
    fi
  elif [[ "${type}" == "record_ttl" ]]; then
    if [[ ${data1} -ge 30 && ${data1} -le 2419200 && ${data1} =~ ^[0-9]+$ ]]; then
      return 0
    else
      return 1
    fi
  elif [[ "${type}" == "record_type" ]]; then
    # Convert to capital with ^^ and compare with capital letters
    if [[ "${data1^^}" == +(NS|MX|A|AAAA|TXT|CNAME|SRV|CAA) ]]; then
      return 0
    else
      return 1
    fi
  elif [[ "${type}" == "record_priority" ]]; then
    if [[ ${data1} -ge 0 && ${data1} -le 255 && ${data1} =~ ^[0-9]+$ ]]; then
      return 0
    else
      return 1
    fi
  elif [[ "${type}" == "email" ]]; then
    if [[ "${data1}" =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$ ]]; then
      return 0
    else
      return 1
    fi
  elif [[ "${type}" == "server_record_valid_character" ]]; then

    if ! [[ ${data1} == *['!'@#\$%^\&*()+]* ]]; then
      return 0
    else
      return 1
    fi
    #Check ipv4
  elif [[ "${type}" == "ipv4" ]]; then
    local ipv4="${data1}" ipv4_pattern='^(([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))\.){3}([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))$'

    if [[ "${ipv4}" =~ ${ipv4_pattern} ]]; then
      retval=0
      # Using this command will check IP is reachable ( do not use )
      #if command -v ip &>/dev/null; then
      #method_bin=$(command -v ip)
      #"${method_bin}" route get "${ipv4}" >/dev/null 2>&1
      #retval=$?

      #else
      #  #_echo "$(msg yellow)Warning, unable to find suitable binary for checking ipv4 or ipv6 address. $(msg end)" --name --verbose 4
      #  retval=1
      #fi
    else
      retval=1
    fi

    return ${retval}
    # Check ipv6
  elif [[ "${type}" == "ipv6" ]]; then
    local ipv6="${data1}" ipv6_pattern method_bin retval
    ipv6_pattern='^([0-9a-fA-F]{0,4}:){1,7}[0-9a-fA-F]{0,4}$'
    if [[ ${ipv6} =~ ${ipv6_pattern} ]]; then
      retval=0
      # Using this command will check IP is reachable ( do not use )
      #if command -v ip &>/dev/null; then
      #  method_bin=$(command -v ip)
      #  "${method_bin}" route get "${ipv6}" >/dev/null 2>&1
      #  retval=$?
      #else
      #  #_echo "$(msg yellow)Warning, unable to find suitable binary for checking ipv4 or ipv6 address. $(msg end)" --name --verbose 4
      #  retval=1
      #fi

    else
      retval=1
    fi

    return ${retval}
    # Check both ipv4 and ipv6 (does not work if ip is not reachable)
  elif [[ "${type}" == "ipv46" ]]; then
    local ip="${data1}" method_bin retval

    if command -v ip &>/dev/null; then
      method_bin=$(command -v ip)
      ${method_bin} route get "${ip}" >/dev/null 2>&1
      retval=$?
    else
      #_echo "$(msg yellow)Warning, unable to find suitable binary for checking ipv4 or ipv6 address. $(msg end)" --name --verbose 4
      retval=1
    fi
    return ${retval}

  elif [[ "${type}" == "not-empty-string" ]]; then
    if [ -n "${data1}" ]; then
      return 0
    else
      return 1
    fi

  elif [[ "${type}" == "valid-linode-disk-filetype" ]]; then
    if [[ "${data1^^}" == +(RAW|SWAP|EXT3|EXT4|INITRD) ]]; then
      return 0
    else
      return 1
    fi
    # if is_valid sha256sum data1 data2; then
  elif [[ "${type}" == "sha256sum" ]]; then
    local retval
    echo "${data1}" "${data2}" | sha256sum --check &>/dev/null
    retval=$?
    return ${retval}
  fi
}

init_server_rebuild_config() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    #_echo "=== Delete specific config .... ====" --plain --name
    # Delete existing Boot_Config profile
    #linode_api_admin "delete-config" --linode-label "${C_BOX_HOSTNAME_FQHN}" --linode-config-label "${C_LINODE_BOOT_CONFIG_LABEL}"
    # Delete existing OS_Config profile
    #linode_api_admin "delete-config" --linode-label "${C_BOX_HOSTNAME_FQHN}" --linode-config-label "${C_LINODE_OS_CONFIG_LABEL}"

    _echo "=== Delete all configs .... ====" --plain --name
    linode_api_admin "delete-configs" --linode-label "${C_BOX_HOSTNAME_FQHN}"

    _echo "=== Creating linode config Boot_Config ====" --plain --name
    linode_api_admin "create-config" --linode-label "${C_BOX_HOSTNAME_FQHN}" \
      --linode-config-label "${C_LINODE_BOOT_CONFIG_LABEL}" --linode-config-comments "The installer boot configuration" \
      --linode-config-kernel "linode/direct-disk" --linode-config-rootdev "/dev/sdb" \
      --label-devsda "disk:${C_LINODE_OS_DISK_LABEL}" --label-devsdb "disk:${C_LINODE_BOOT_DISK_LABEL}"

    _echo "=== Creating linode config OS_Config ====" --plain --name
    linode_api_admin "create-config" --linode-label "${C_BOX_HOSTNAME_FQHN}" \
      --linode-config-label "${C_LINODE_OS_CONFIG_LABEL}" --linode-config-comments "The operating boot configuration" \
      --linode-config-kernel "linode/direct-disk" --linode-config-rootdev "/dev/sda" \
      --label-devsda "disk:${C_LINODE_OS_DISK_LABEL}"

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

init_server_rebuild_partition() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    ((box_os_disk = server_main_disk_raw_size - server_boot_disk_raw_size))
    server_main_disk_raw_size="${C_BOX_MAIN_DISK_RAW_SIZE}"
    server_boot_disk_raw_size="${C_BOX_BOOT_DISK_RAW_SIZE}"
    # Note this required linode to be turned off
    # ------ Delete and recreate specific disk from linode ------
    # Delete existing Boot Disk that boot the operating system installer
    #linode_api_admin delete-disk --linode-label "${C_BOX_HOSTNAME_FQHN}" --linode-disk-label "${C_LINODE_BOOT_DISK_LABEL}"
    # Delete existing OS Disk that hold the operating system for the server
    #linode_api_admin delete-disk --linode-label "${C_BOX_HOSTNAME_FQHN}" --linode-disk-label "${C_LINODE_OS_DISK_LABEL}"
    # ------ To delete all disks from linode (plural with s)------
    _echo "=== Deleting all linode disks ====" --plain --name
    # TODO delete disk that have label name with spaces
    linode_api_admin delete-disks --linode-label "${C_BOX_HOSTNAME_FQHN}"
    # Create Boot Disk that boot the operating system installer with raw format
    _echo "=== Creating linode Boot_Disk ====" --plain --name

    linode_api_admin create-disk --linode-label "${C_BOX_HOSTNAME_FQHN}" --linode-disk-label "${C_LINODE_BOOT_DISK_LABEL}" --linode-disk-filetype "raw" --linode-disk-size "${server_boot_disk_raw_size}"
    # Example to allow duplicate entry as above:
    #linode_api_admin create-disk --linode-label "${C_BOX_HOSTNAME_FQHN}" --linode-disk-label "${C_LINODE_BOOT_DISK_LABEL}" --linode-disk-filetype "raw" --linode-disk-size "${server_boot_disk_raw_size}" --allow-duplicate-entry
    # Create OS Disk that hold the operating system for the server
    _echo "=== Creating linode OS_Disk ====" --plain --name
    linode_api_admin create-disk --linode-label "${C_BOX_HOSTNAME_FQHN}" --linode-disk-label "${C_LINODE_OS_DISK_LABEL}" --linode-disk-filetype "raw" --linode-disk-size "${box_os_disk}"

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_dropbox_cli() {
  # Public git:
  rm -rf "${INST_TEMP_DIR}/dropbox_cli"
  mkdir -p "${INST_TEMP_DIR}/dropbox_cli"
  _echo "$(msg cyan)Installing new version of dropbox-CLI forked from andreafabrizi/Dropbox-Uploader ... $(msg end)" --name
  required "debian@@apt:git" "ubuntu@@apt:git"
  git clone https://github.com/sofibox/Dropbox-Uploader.git "${INST_TEMP_DIR}/dropbox_cli"
  mv "${INST_TEMP_DIR}/dropbox_cli/dropbox_uploader.sh" "${INST_TEMP_DIR}/dropbox_cli/dbxcli"
  chmod +x "${INST_TEMP_DIR}/dropbox_cli/dbxcli"
  cp "${INST_TEMP_DIR}/dropbox_cli/dbxcli" /usr/local/bin
  touch "/root/.dropbox_uploader"
  {
    echo "CONFIGFILE_VERSION=${C_DROPBOX_CONFIGFILE_VERSION}"
    echo "OAUTH_APP_KEY=${C_DROPBOX_OAUTH_APP_KEY}"
    echo "OAUTH_APP_SECRET=${C_DROPBOX_OAUTH_APP_SECRET}"
    echo "OAUTH_REFRESH_TOKEN=${C_DROPBOX_OAUTH_REFRESH_TOKEN}"
  } >"/root/.dropbox_uploader"

  if ! command -v dbxcli &>/dev/null; then
    _echo "$(msg red)Error, missing binary dbxcli. It should exist!$(msg end)" --name
    _exit 147
  else
    dbxcli info
    echo ""
    dbxcli space
  fi
}

ensure_internet_connected() {
  if curl -s --head --request GET www.google.com | grep "200 OK" >/dev/null; then
    #echo "OK, connected to the internet"
    return 0
  else
    echo "Error, could not connect to the internet"
    exit 147
  fi
}

ensure_linode_label_ipv4_valid() {
  # Because labelling is important, it must be unique to represent that node is a hostname (1 node = 1 hostname)
  echo -n "Checking if linode label is matched with the host domain name ${C_LINODE_LABEL} ... "
  while :; do
    # linode_api_admin get-linode-ipv4 --scripting
    readarray -t linode_current_ipv4s <<<$(linode_api_admin get-linode-ipv4 --scripting)
    match_label=false
    match_ip=false
    count_ip=0
    while [[ ${count_ip} -lt $(echo "${!C_IPV4_ADD@}" | wc -w) ]]; do
      typeset -n "c_ipv4_add=C_IPV4_ADD${count_ip}"
      for linode_current_ipv4 in "${linode_current_ipv4s[@]}"; do
        if [[ "${linode_current_ipv4}" == "${c_ipv4_add}" ]]; then
          match_ip=true
          #  linode_current_label=$(linode-cli --pretty --json linodes list | jq -r ".[] | select(.ipv4 | .[] == \"${c_ipv4_add}\") | .label")
          linode_current_label=$(linode_api_admin get-linode-label --ip-address "${c_ipv4_add}" --scripting)
          # echo "Checking linode_current_label for IP ${linode_current_ipv4} if match with ${linode_current_label} (linked with IPv4)"
          # Since this script manage only 1 host name pertime, so we need to make sure it is matched with C_LINODE_LABEL and break
          if [ "${linode_current_label}" == "${C_LINODE_LABEL}" ]; then
            _echo "$(msg green) [OK]$(msg end)" --plain
            count_ip=$(echo "${!C_IPV4_ADD@}" | wc -w) # Stop the outer loop
            match_label=true
            break
          fi
        fi
      done
      ((count_ip++))
    done
    if [ "${match_ip}" == "false" ]; then
      echo ""
      echo "warning no ipv4 from config file match in linode, please check at least one IPv4 is correctly defined in config file"
      _exit 147
    fi
    if [ "${match_label}" == "false" ]; then
      _echo "$(msg red) [FAILED]$(msg end)" --plain
      echo ""
      _echo "$(msg cyan)The current linode label value is ${linode_current_label} ...$(msg end)" --name
      _echo "$(msg cyan)Updating the current linode label to ${C_LINODE_LABEL} ...$(msg end)" --name
      linode_api_admin update-linode --linode-label "${linode_current_label}" --new-linode-label "${C_LINODE_LABEL}"
      echo ""
      echo -n "Re-checking if linode label is matched with the host domain name ${C_LINODE_LABEL} ... "
    else
      break
    fi
  done
}

ensure_linode_rdns_resolved() {
  echo -n "Checking if IPv4 reverse DNS value matched with the host domain name ${LABEL_C_BOX_HOSTNAME_FQHN} for IP ${LABEL_C_IPV4_ADD0} ... "
  while :; do
    local current_ipv4_reverse_dns
    current_ipv4_reverse_dns=$(linode_api_admin ip-address-view --ip-address ${C_IPV4_ADD0} --get-value rdns --scripting)
    if [[ "${current_ipv4_reverse_dns}" == "${C_BOX_HOSTNAME_FQHN}" ]]; then
      _echo "$(msg green) [OK]$(msg end)" --plain
      break
    else
      _echo "$(msg red) [FAILED]$(msg end)" --plain
      echo ""
      _echo "$(msg cyan)The current IPv4 reverse DNS value is ${current_ipv4_reverse_dns} ...$(msg end)" --name
      _echo "$(msg cyan)Updating reverse dns for IPv4 ${LABEL_C_IPV4_ADD0} to ${LABEL_C_BOX_HOSTNAME_FQHN} ...$(msg end)" --name
      linode_api_admin update-reverse-dns --ip-address "${C_IPV4_ADD0}" --domain "${C_BOX_HOSTNAME_FQHN}"
      echo ""
      echo -n "Rechecking if IPv4 reverse DNS value matched with the host domain name ${LABEL_C_BOX_HOSTNAME_FQHN} for IP ${LABEL_C_IPV4_ADD0} ... "
    fi
  done
  echo -n "Checking if IPv6 reverse DNS value matched with the host domain name ${LABEL_C_BOX_HOSTNAME_FQHN} for IP ${LABEL_C_IPV6_ADD0} ... "
  while :; do
    local current_ipv6_reverse_dns
    current_ipv6_reverse_dns=$(linode_api_admin ip-address-view --ip-address ${C_IPV6_ADD0} --get-value rdns --scripting)
    if [[ "${current_ipv6_reverse_dns}" == "${C_BOX_HOSTNAME_FQHN}" ]]; then
      _echo "$(msg green) [OK]$(msg end)" --plain
      break
    else
      _echo "$(msg red) [FAILED]$(msg end)" --plain
      echo ""
      _echo "$(msg cyan)The current IPv6 reverse DNS value is ${current_ipv6_reverse_dns} ...$(msg end)" --name
      _echo "$(msg cyan)Updating reverse dns for IPv6 ${LABEL_C_IPV6_ADD0} to ${LABEL_C_BOX_HOSTNAME_FQHN} ...$(msg end)" --name
      linode_api_admin update-reverse-dns --ip-address "${C_IPV6_ADD0}" --domain "${C_BOX_HOSTNAME_FQHN}"
      echo ""
      echo -n "Checking if IPv6 reverse DNS value matched with the host domain name ${LABEL_C_BOX_HOSTNAME_FQHN} for IP ${LABEL_C_IPV6_ADD0} ... "
    fi
  done
}
ensure_domain_server_resolved() {
  local failed_check_count count_check_duration

  failed_check_count=0
  count_check_duration=30

  echo -n "Checking ${LABEL_C_BOX_DOMAIN} A record resolves with IPv4 ${LABEL_C_IPV4_ADD0} ... "
  while :; do
    if is_valid ipv4_resolved "${C_IPV4_ADD0}" "${C_BOX_DOMAIN}"; then
      _echo "$(msg green) [OK]$(msg end)" --plain
      break
    else
      local check_duration
      _echo "$(msg red) [FAILED]$(msg end)" --plain
      ((failed_check_count++))
      if [[ "${failed_check_count}" -eq 1 ]]; then
        if [ "${DNS_PROVIDER_NAME}" == "linode" ]; then
          _echo "$(msg cyan)Creating domain ${LABEL_C_BOX_DOMAIN} in linode if does not exist ...$(msg end)" --name
          linode_api_admin create-domain --domain-type "master" --domain "${C_BOX_DOMAIN}" --domain-email "webmaster@${C_BOX_DOMAIN}" --domain-ttl 30
          echo ""
          _echo "$(msg cyan)Creating dns A record ${LABEL_C_BOX_DOMAIN} in linode...$(msg end)" --name
          linode_api_admin add-dns-record --domain "${C_BOX_DOMAIN}" --record-type "A" --record-name "${C_BOX_DOMAIN}" --record-value "${C_IPV4_ADD0}" --record-ttl 30
        elif [ "${DNS_PROVIDER_NAME}" == "local" ]; then
          echo "[${SCRIPT_NAME}]: External DNS provider for domain ${C_BOX_DOMAIN} is set to local"
          # Do nothing because it's local DNS managed by Directadmin
        fi
      fi

      #_echo "$(msg red)Please create / check for domain ${LABEL_C_BOX_DOMAIN} that it must have an A record pointing to ${LABEL_C_IPV4_ADD0}$(msg end)" --name
      #_exit 147

      if [[ "${failed_check_count}" -eq 4 ]]; then
        _echo "$(msg yellow)Warning, failed to propagate domain ${LABEL_C_BOX_DOMAIN} ...$(msg end)" --name
        _echo "$(msg cyan)Creating domain ${LABEL_C_BOX_DOMAIN} in linode with rebuild option ...$(msg end)" --name
        linode_api_admin create-domain --domain-type "master" --domain "${C_BOX_DOMAIN}" --domain-email "webmaster@${C_BOX_DOMAIN}" --domain-ttl 30 --rebuild
        echo ""
        _echo "$(msg cyan)Creating dns A record ${LABEL_C_BOX_DOMAIN} in linode...$(msg end)" --name
        linode_api_admin add-dns-record --domain "${C_BOX_DOMAIN}" --record-type "A" --record-name "${C_BOX_DOMAIN}" --record-value "${C_IPV4_ADD0}" --record-ttl 30
      fi

      # Increase the check 30 seconds when failed on the 5th times and a above
      if [[ "${failed_check_count}" -ge 15 && "${failed_check_count}" -le 100 ]]; then
        ((count_check_duration = count_check_duration + 30))
      else
        count_check_duration=30
      fi
      check_duration="${count_check_duration}"
      while :; do
        ((check_duration--))
        _echo "[${failed_check_count}]: Re-checking ${LABEL_C_BOX_DOMAIN} A record resolves with IPv4 ${LABEL_C_IPV4_ADD0} within ${check_duration} seconds ... " --name --start-spin
        if [ "${check_duration}" -le 0 ]; then
          # echo -n "Re-checking ${LABEL_C_BOX_DOMAIN} A record resolves with IPv4 ${LABEL_C_IPV4_ADD0} in 120 seconds ... "
          break
        fi
        sleep 1
      done
    fi
  done

  failed_check_count=0
  count_check_duration=30
  echo -n "Checking ${LABEL_C_BOX_DOMAIN} AAAA record resolves with IPv4 ${LABEL_C_IPV6_ADD0} ... "
  while :; do
    if is_valid ipv6_resolved "${C_IPV6_ADD0}" "${C_BOX_DOMAIN}"; then
      _echo "$(msg green) [OK]$(msg end)" --plain
      break
    else
      local check_duration
      _echo "$(msg red) [FAILED]$(msg end)" --plain
      ((failed_check_count++))
      if [[ "${failed_check_count}" -eq 1 ]]; then
        if [ "${DNS_PROVIDER_NAME}" == "linode" ]; then
          _echo "$(msg cyan)Creating domain ${LABEL_C_BOX_DOMAIN} in linode if does not exist ...$(msg end)" --name
          linode_api_admin create-domain --domain-type "master" --domain "${C_BOX_DOMAIN}" --domain-email "webmaster@${C_BOX_DOMAIN}" --domain-ttl 30
          echo ""
          _echo "$(msg cyan)Creating dns AAAA record ${LABEL_C_BOX_DOMAIN} in linode...$(msg end)" --name
          linode_api_admin add-dns-record --domain "${C_BOX_DOMAIN}" --record-type "AAAA" --record-name "${C_BOX_DOMAIN}" --record-value "${C_IPV6_ADD0}" --record-ttl 30
        elif [ "${DNS_PROVIDER_NAME}" == "local" ]; then
          echo "[${SCRIPT_NAME}]: External DNS provider for domain ${C_BOX_DOMAIN} is set to local"
          # Do nothing because it's local DNS managed by Directadmin
        fi
      fi

      #_echo "$(msg red)Please create / check for domain ${LABEL_C_BOX_DOMAIN} that it must have an AAAA record pointing to ${LABEL_C_IPV4_ADD0}$(msg end)" --name
      #_exit 147

      # Increase the check 30 seconds when failed on the 5th times and a above
      if [[ "${failed_check_count}" -ge 15 && "${failed_check_count}" -le 100 ]]; then
        ((count_check_duration = count_check_duration + 2))
      else
        count_check_duration=30
      fi
      check_duration="${count_check_duration}"
      while :; do
        ((check_duration--))
        _echo "[${failed_check_count}]: Re-checking ${LABEL_C_BOX_DOMAIN} AAAA record resolves with IPv6 ${LABEL_C_IPV6_ADD0} within ${check_duration} seconds ... " --name --start-spin
        if [ "${check_duration}" -le 0 ]; then
          # echo -n "Re-checking ${LABEL_C_BOX_DOMAIN} AAAA record resolves with IPv4 ${LABEL_C_IPV6_ADD0} in 120 seconds ... "
          break
        fi
        sleep 1
      done
    fi
  done
}
############## FOR HOSTNAME test.server.com ################
ensure_fqhn_server_resolved() {
  local failed_check_count count_check_duration

  failed_check_count=0
  count_check_duration=30
  echo -n "Checking ${LABEL_C_BOX_HOSTNAME_FQHN} A record resolves with IPv4 ${LABEL_C_IPV4_ADD0} ... "
  while :; do
    if is_valid ipv4_resolved "${C_IPV4_ADD0}" "${C_BOX_HOSTNAME_FQHN}"; then
      _echo "$(msg green) [OK]$(msg end)" --plain
      break
    else
      local check_duration
      _echo "$(msg red) [FAILED]$(msg end)" --plain
      ((failed_check_count++))
      if [[ "${failed_check_count}" -eq 1 ]]; then
        if [ "${DNS_PROVIDER_NAME}" == "linode" ]; then
          _echo "$(msg cyan)Creating domain ${LABEL_C_BOX_HOSTNAME_FQHN} in linode if does not exist ...$(msg end)" --name
          linode_api_admin create-domain --domain-type "master" --domain "${C_BOX_HOSTNAME_FQHN}" --domain-email "webmaster@${C_BOX_HOSTNAME_FQHN}" --domain-ttl 30
          echo ""
          _echo "$(msg cyan)Creating dns A record ${LABEL_C_BOX_HOSTNAME_FQHN} in linode...$(msg end)" --name
          linode_api_admin add-dns-record --domain "${C_BOX_HOSTNAME_FQHN}" --record-type "A" --record-name "${C_BOX_HOSTNAME_FQHN}" --record-value "${C_IPV4_ADD0}" --record-ttl 30
        elif [ "${DNS_PROVIDER_NAME}" == "local" ]; then
          echo "[${SCRIPT_NAME}]: External DNS provider for domain ${domain} is set to local"
          # Do nothing because it's local DNS managed by Directadmin
        fi
      fi

      #_echo "$(msg red)Please create / check for domain ${C_BOX_HOSTNAME_FQHN} that it must have an A record pointing to ${LABEL_C_IPV4_ADD0}$(msg end)" --name
      #_exit 147
      # 30,4, 15 ,100,30
      # If failed for the 3rd time, readd domain with --force
      if [[ "${failed_check_count}" -eq 30 ]]; then
        _echo "$(msg yellow)Warning, failed to propagate domain ${LABEL_C_BOX_HOSTNAME_FQHN} ...$(msg end)" --name
        _echo "$(msg cyan)Creating domain ${LABEL_C_BOX_HOSTNAME_FQHN} in linode with rebuild option ...$(msg end)" --name
        linode_api_admin create-domain --domain-type "master" --domain "${C_BOX_HOSTNAME_FQHN}" --domain-email "webmaster@${C_BOX_HOSTNAME_FQHN}" --domain-ttl 30 --rebuild
        echo ""
        _echo "$(msg cyan)Creating dns A record ${LABEL_C_BOX_HOSTNAME_FQHN} in linode...$(msg end)" --name
        linode_api_admin add-dns-record --domain "${C_BOX_HOSTNAME_FQHN}" --record-type "A" --record-name "${C_BOX_HOSTNAME_FQHN}" --record-value "${C_IPV4_ADD0}" --record-ttl 30
      fi

      # Increase the check 30 seconds when failed on the 5th times and a above
      if [[ "${failed_check_count}" -ge 4 && "${failed_check_count}" -le 100 ]]; then
        ((count_check_duration = count_check_duration + 2))
      else
        count_check_duration=30
      fi
      check_duration="${count_check_duration}"
      while :; do
        ((check_duration--))
        _echo "[${failed_check_count}]: Re-checking ${LABEL_C_BOX_HOSTNAME_FQHN} A record resolves with IPv4 ${LABEL_C_IPV4_ADD0} within ${check_duration} seconds ... " --name --start-spin
        if [ "${check_duration}" -le 0 ]; then
          # echo -n "Re-checking ${LABEL_C_BOX_HOSTNAME_FQHN} A record resolves with IPv4 ${LABEL_C_IPV4_ADD0} in 120 seconds ... "
          break
        fi
        sleep 1
      done
    fi
  done

  failed_check_count=0
  count_check_duration=30
  echo -n "Checking ${LABEL_C_BOX_HOSTNAME_FQHN} AAAA record resolves with IPv4 ${LABEL_C_IPV6_ADD0} ... "
  while :; do
    if is_valid ipv6_resolved "${C_IPV6_ADD0}" "${C_BOX_HOSTNAME_FQHN}"; then
      _echo "$(msg green) [OK]$(msg end)" --plain
      break
    else
      local check_duration
      _echo "$(msg red) [FAILED]$(msg end)" --plain
      ((failed_check_count++))
      if [[ "${failed_check_count}" -eq 1 ]]; then
        if [ "${DNS_PROVIDER_NAME}" == "linode" ]; then
          _echo "$(msg cyan)Creating domain ${LABEL_C_BOX_HOSTNAME_FQHN} in linode if does not exist ...$(msg end)" --name
          linode_api_admin create-domain --domain-type "master" --domain "${C_BOX_HOSTNAME_FQHN}" --domain-email "webmaster@${C_BOX_HOSTNAME_FQHN}" --domain-ttl 30
          echo ""
          _echo "$(msg cyan)Creating dns AAAA record ${LABEL_C_BOX_HOSTNAME_FQHN} in linode...$(msg end)" --name
          linode_api_admin add-dns-record --domain "${C_BOX_HOSTNAME_FQHN}" --record-type "AAAA" --record-name "${C_BOX_HOSTNAME_FQHN}" --record-value "${C_IPV6_ADD0}" --record-ttl 30
        elif [ "${DNS_PROVIDER_NAME}" == "local" ]; then
          echo "[${SCRIPT_NAME}]: External DNS provider for domain ${LABEL_C_BOX_HOSTNAME_FQHN} is set to local"
          # Do nothing because it's local DNS managed by Directadmin
        fi
      fi
      #_echo "$(msg red)Please create / check for domain ${LABEL_C_BOX_HOSTNAME_FQHN} that it must have an AAAA record pointing to ${LABEL_C_IPV6_ADD0}$(msg end)" --name
      #_exit 147

      # Increase the check 30 seconds when failed on the 5th times and a above
      if [[ "${failed_check_count}" -ge 15 && "${failed_check_count}" -le 100 ]]; then
        ((count_check_duration = count_check_duration + 2))
      else
        count_check_duration=30
      fi
      check_duration="${count_check_duration}"
      while :; do
        ((check_duration--))
        _echo "[${failed_check_count}]: Re-checking ${LABEL_C_BOX_HOSTNAME_FQHN} AAAA record resolves with IPv6 ${LABEL_C_IPV6_ADD0} within ${check_duration} seconds ... " --name --start-spin
        if [ "${check_duration}" -le 0 ]; then
          break
        fi
        sleep 1
      done
    fi
  done

}

# This function initialize or deploy server installation from scratch with few options
# See <script_name> --init-server --help or look at manual() section under "init_server" for more information
init_server() {
  local argnum options retval rebuild_iso rebuild_partition rebuild_config rebuild_all backup max_wait wait_count
  argnum="$#"
  # We should allow empty argument for creating server without rebuild or backup option
  #if [ ${argnum} -eq 0 ]; then
  #  echo "Error, no argument is supplied. Use [ ${SCRIPT_NAME} --init-server --help ] to see the valid options"
  #  exit 1
  #fi
  short_opts=""
  long_opts="help,rebuild-iso,rebuild-partition,rebuild-config,rebuild-all,backup"
  options=$(getopt -o "${short_opts}" --long "${long_opts}" -n "${FUNCNAME[0]} in ${SCRIPT_NAME}" -- "$@")
  retval=$?
  if [ ${retval} != 0 ]; then
    echo "Error, invalid parse data. Terminating..." >&2
    exit 1
  fi

  # Must quote this option variable
  eval set -- "${options}"

  rebuild_iso=false
  rebuild_partition=false
  rebuild_config=false
  rebuild_all=false
  backup=false
  while true; do
    case "$1" in
    --help)
      manual "${FUNCNAME[0]}"
      shift
      exit 0
      ;;
    --rebuild-iso)
      rebuild_iso=true
      shift
      ;;
    --rebuild-partition)
      rebuild_partition=true
      shift
      ;;
    --rebuild-config)
      rebuild_config=true
      shift
      ;;
    --rebuild-all)
      rebuild_all=true
      rebuild_iso=true
      rebuild_partition=true
      rebuild_config=true
      shift
      ;;

    --backup)
      backup=true
      shift
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
    esac
  done

  _echo "$(msg cyan)Creating a new server for ${LABEL_C_BOX_HOSTNAME_FQHN} ...$(msg end)" --name

  echo "Server Physical Information:"
  # Get all of this from provider
  echo "Provider: ${DNS_PROVIDER_NAME}"
  echo "Provider type: ${LABEL_C_BOX_TYPE^^}"
  echo "IPv4 address: ${LABEL_C_IPV4_ADD0}"
  echo "IPv6 address: ${LABEL_C_IPV6_ADD0}"
  echo "============="
  echo ""
  #echo "Disk space: "
  #echo "Memory/RAM: "

  # This will make sure that the hostname resolved
  ensure_internet_connected
  ensure_domain_server_resolved
  ensure_fqhn_server_resolved
  echo ""

  sleep 1
  if [ ${backup} == "true" ]; then
    _echo "$(msg blue)Notice, the option --backup-all is set. The following backup events will be triggered automatically: $(msg end)" --name --plain
    _echo "$(msg blue)1) Previous iso image will be backed up automatically $(msg end)" --name --plain
    _echo "$(msg blue)2) Previous RSA SSH key will be backed up automatically $(msg end)" --name --plain
  fi

  _echo "$(msg newline)" --plain
  if [ ${rebuild_all} == "true" ]; then
    _echo "$(msg yellow)Warning, --rebuild-all is set. The following options are enabled by default: $(msg end)" --name --verbose 4
    _echo "$(msg yellow)Warning, --rebuild-iso is set. Hence new ISO will be rebuilt $(msg end)" --name --verbose 4
    _echo "$(msg yellow)Warning, --rebuild-partition is set. Hence, all disk partitions will be rebuilt $(msg end)" --name --verbose 4
    _echo "$(msg yellow)Warning, --rebuild-config is set. Hence, all configs will be rebuilt $(msg end)" --name --verbose 4
  else
    if [ ${rebuild_iso} == "true" ]; then
      _echo "$(msg yellow)Warning, --rebuild-iso is set. Hence new ISO will be rebuilt $(msg end)" --name --verbose 4
    fi

    if [ ${rebuild_partition} == "true" ]; then
      _echo "$(msg yellow)Warning, --rebuild-partition is set. Hence, all disk partitions will be rebuilt $(msg end)" --name --verbose 4
    fi

    if [ ${rebuild_config} == "true" ]; then
      _echo "$(msg yellow)Warning, --rebuild-config is set. Hence, all configs will be rebuilt $(msg end)" --name --verbose 4
    fi
  fi
  _pause 3

  if [ "${DNS_PROVIDER_NAME}" == "linode" ]; then
    # This will make sure rdns in external DNS is matched with value of hostname (Note: this will take 24 hours to propagate!)
    ensure_linode_rdns_resolved

    # This will check if the current hostname in linode matched with the config file and also it will check if IPv4 in config file (even multiple IP) match the label.
    # This is a very important check for external DNS
    ensure_linode_label_ipv4_valid

    server_main_disk_raw_size="${C_BOX_MAIN_DISK_RAW_SIZE}"
    server_boot_disk_raw_size="${C_BOX_BOOT_DISK_RAW_SIZE}"

    ((box_os_disk = server_main_disk_raw_size - server_boot_disk_raw_size))

    _echo "Configuring ${DNS_PROVIDER_NAME} server for ${LABEL_C_BOX_HOSTNAME_FQHN} ..." --name --plain
    _echo "" --plain

    # Turn off linode if it's running
    _echo "=== Shutting down linode ====" --plain --name
    linode_api_admin shutdown-linode --linode-label "${C_BOX_HOSTNAME_FQHN}"
    # Delete all existing disks (if exist)
    echo ""

    # Rebuild linode disks if set (delete and create)

    if [ ${rebuild_partition} == "true" ]; then
      init_server_rebuild_partition --run-force
    fi

    if [ ${rebuild_config} == "true" ]; then
      init_server_rebuild_config --run-force
    fi

    _echo "$(msg cyan)Booting linode ${LABEL_C_BOX_HOSTNAME_FQHN} into Finnix rescue mode ...$(msg end)" --name
    linode_api_admin reboot-to-rescue --linode-label "${C_BOX_HOSTNAME_FQHN}" --label-devsda "disk:${C_LINODE_BOOT_DISK_LABEL}" --label-devsdb "disk:${C_LINODE_OS_DISK_LABEL}"
    echo ""
    # Installing dropbox_cli here

    if [ "${rebuild_iso}" == "true" ]; then
      if [ "${backup}" == "true" ]; then
        _echo "$(msg yellow)Warning, the option --rebuild-iso is set. Hence the existing ISO will be replaced with the new one $(msg green)but do not worry this ISO file will be backed up because --backup option is set$(msg end)" --name
      else
        _echo "$(msg yellow)Warning, the option --rebuild-iso is set. Hence the existing ISO will be replaced with the new one!$(msg end)" --name
      fi
      _pause 5
      _echo "$(msg cyan)Creating ISO file ...$(msg end)" --name
      # Create ISO type for Hard disk boot, pull from web, upload to dropbox and write an automation script for installation
      # TODO seems like delete ISO after using, make the download faster. Maybe dropbox limit download for specific file.
      if [ "${backup}" == "true" ]; then
        iso_api create-os-iso --iso-type hdd-boot --iso-base web --upload-to-dropbox --write-script --backup
      else
        iso_api create-os-iso --iso-type hdd-boot --iso-base web --upload-to-dropbox --write-script
      fi

    else
      _echo "$(msg yellow)Notice, linode will install server operating system using existing automated ISO because the option rebuild-iso is not set$(msg end)" --name
      # If the rebuild_iso is set to false, we delay this for 7 seconds more
      sleep 7
    fi
    _echo "$(msg cyan)Writing OS into ${C_LINODE_BOOT_DISK_LABEL} Partition via SSH background (this will be completed until linode is turned off automatically) ...$(msg end)" --name
    # ssh -q -o "StrictHostKeyChecking no" -i /root/.ssh/linode_lish.id_rsa -tt "${DNS_PROVIDER_USER}@${C_DNS_PROVIDER_TERMINAL_SERVER}" "${C_BOX_HOSTNAME_FQHN}" <"${CODE_PATH}/ssh_scripts/os_write_ag.sh" >/dev/null 2>&1 &
    # This above lish ssh command is equivalent to below using --push-iso-write-script option and other config will be used the default values from config file:
    ssh_api lish-push-script --push-iso-write-script
    #ssh -q -o "StrictHostKeyChecking no" -i /root/.ssh/linode_lish.id_rsa -tt "${DNS_PROVIDER_USER}@${C_DNS_PROVIDER_TERMINAL_SERVER}" "${C_BOX_HOSTNAME_FQHN}" <"${CODE_PATH}/ssh_scripts/os_write_ag.sh" >/dev/null 2>&1 &
    # Wait until linode status is offline
    linode_api_admin wait-linode-status --linode-label "${C_BOX_HOSTNAME_FQHN}" --until-status offline

    # After system shutdown, then we can execute the following
    # Note I can use reboot-linode or boot-linode (boot-linode is used if the linode status is offline, if it's running you cannot use it)
    linode_api_admin reboot-linode --linode-label "${C_BOX_HOSTNAME_FQHN}" --linode-config-label "${C_LINODE_BOOT_CONFIG_LABEL}"

    _echo "$(msg cyan)Installing operating system automatically using preseed configuration (approx 7 minutes. Server will turned off automatically when finish): $(msg end)" --name
    # Do not over call the API, use sleep 5 minutes (300 seconds). The installation approximate time is  + minutes.
    # For debian 11 installation time take more than 300 seconds .. so we wait at this duration
    if [[ "${C_BOX_ISO_OS_NAME}" == "debian" ]]; then
      max_wait=300
    else
      max_wait=120
    fi

    wait_count=0
    while :; do
      ((wait_count++))
      _echo "$(msg cyan)Waiting for initial installation ... Maximum wait of ${wait_count}/${max_wait} seconds ...$(msg end)" --start-spin --name
      sleep 1
      if [[ "${wait_count}" -ge "${max_wait}" ]]; then
        echo ""
        _echo "$(msg cyan)Please wait ...$(msg end)" --stop-spin --name
        break
      fi
    done

    linode_api_admin wait-linode-status --linode-label "${C_BOX_HOSTNAME_FQHN}" --until-status offline
    # Boot into the new OS
    _echo "Booting into operating system (make sure to unlock LUKS)" --name
    linode_api_admin boot-linode --linode-label "${C_BOX_HOSTNAME_FQHN}" --linode-config-label "${C_LINODE_OS_CONFIG_LABEL}"

    # Better to execute this here to give time for system startup above
    # Remove the Boot_Config, we do not need this anymore
    linode_api_admin delete-config --linode-label "${C_BOX_HOSTNAME_FQHN}" --linode-config-label "${C_LINODE_BOOT_CONFIG_LABEL}"

    # TODO Remove the ISO file here

    if [ "${C_DISK_ENCRYPTION}" == "true" ]; then
      _echo "$(msg cyan)Checking if initial boot port ${LABEL_C_DROP_BEAR_PORT} is open from --server ${LABEL_C_BOX_HOSTNAME_FQHN} ...$(msg end)" --name
      count=0
      while :; do
        sleep 1
        ((count++))
        _echo "$(msg yellow) Waiting for LUKS boot port ${LABEL_C_DROP_BEAR_PORT} to be available ...$(msg end)" --start-spin --name

        if is_valid available_port "${C_BOX_HOSTNAME_FQHN}" "${C_DROP_BEAR_PORT}"; then
          _echo "$(msg green)OK, LUKS boot port ${LABEL_C_DROP_BEAR_PORT} is now available. Unlocking encrypted LUKS disk on boot ...$(msg end)" --stop-spin --name
          # Wait 10 seconds
          sleep 5
          ssh_api unlock-luks --port "${C_DROP_BEAR_PORT}" --password "${C_LUKS_PASS}"
          # This is very important wait, file copy will have trouble if startup is late
          _echo "$(msg cyan)Waiting 5 seconds to finish start operating system after finished unlocking LUKS partition ...$(msg end)" --stop-spin --name
          sleep 5
          break
        fi

        if [ "${count}" -gt 60 ]; then
          _echo "$(msg red)Error, failed to detect drop bear port ${LABEL_C_DROP_BEAR_PORT} because the port is closed. Please inspect this manually (make sure firewall is not blocking this port)!$(msg end)" --name
          _exit 1
        fi
      done
    fi

    _echo "$(msg cyan)Copying maxinet, maxinet.conf gpg_private_key.gpg and readme.txt into remote server ... $(msg end)" --name
    local file_to_transfer hostname_certificate_to_transfer
    file_to_transfer="${SECURE_PATH}/gpg/gpg_private_key.gpg ${SCRIPT_PATH}/maxinet ${SCRIPT_PATH}/maxinet.conf ${SCRIPT_PATH}/readme.txt"

    if [[ "${C_DA_RESTORE_PREVIOUS_HOSTNAME_SSL}" == "true" ]]; then
      hostname_certificate_to_transfer="${SECURE_PATH}/ssl/.lego/certificates/${C_BOX_HOSTNAME_FQHN}.crt ${SECURE_PATH}/ssl/.lego/certificates/${C_BOX_HOSTNAME_FQHN}.issuer.crt \
      ${SECURE_PATH}/ssl/.lego/certificates/${C_BOX_HOSTNAME_FQHN}.key ${SECURE_PATH}/ssl/.lego/certificates/${C_BOX_HOSTNAME_FQHN}.json"
      file_to_transfer="${file_to_transfer} ${hostname_certificate_to_transfer}"
    fi

    ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" --local-files "${file_to_transfer}" --remote-path ~/
    sleep 2

    if [ "${C_PRE_AUTORUN_SETUP}" == "false" ]; then
      _echo "$(msg yellow)Warning, C_PRE_AUTORUN_SETUP is not set in config file. Hence, remote auto installation script is now halt! $(msg end)" --name
      echo ""
      _echo "$(msg yellow)Note: The server will be turned off, if you want to continue remote setup, trigger the following commands: $(msg end)" --name
      _echo "$(msg magenta)1) Turn on the server: maxinet --start-server$(msg end)" --plain
      _echo "$(msg magenta)2) Unlock server LUKS disk encrypted: maxinet --luks-unlock$(msg end)" --plain
      _echo "$(msg magenta)3) Automatically execute setup action on remote server: maxinet --ssh-api push-script --server-port ${LABEL_C_BOX_HOSTNAME_FQHN}:${LABEL_C_SSH_PORT} --group-user root:${LABEL_C_SSH_USERNAME} --push-maxinet-setup-script$(msg end)" --plain
      echo ""
      _echo "OR login into remote server and manually run setup action with the following command:" --name
      _echo "$(msg magenta)1) Turn on server: maxinet ssh-login root$(msg end)" --plain
      _echo "$(msg magenta)2) cd ~$(msg end)" --plain
      _echo "$(msg magenta)3) ./${SCRIPT_NAME} setup 2>&1 | tee ${SCRIPT_NAME}.log ~$(msg end)" --plain
      _echo "$(msg magenta)4) See ~/readme.txt for more information$(msg end)" --plain
      linode_api_admin shutdown-linode --linode-label "${C_BOX_HOSTNAME_FQHN}"
      _exit 0
    fi

    _echo "$(msg cyan)Setup will automatically execute remote maxinet script and start installation of the server ... (it might take some time)$(msg end)" --name
    # ssh_api push-script --server ${C_BOX_HOSTNAME_FQHN} --port ${C_SSH_PORT} --group root --username ${C_ROOT_USERNAME} --local-script-path "${CODE_PATH}/ssh_scripts/maxinet_setup.sh"
    ssh_api push-script --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" --local-script-path "${CODE_PATH}/ssh_scripts/maxinet_setup.sh"
    # After installation above, the system must restart once, so we execute next script to reopen LUKS

    # After the above script is executed, now we wait for it to shutdown (executed by the script installation) properly before booting
    linode_api_admin wait-linode-status --linode-label "${C_BOX_HOSTNAME_FQHN}" --until-status offline

    _echo "$(msg cyan)Booting into operating system (LUKS console might be appeared and unlocked automatically) ...$(msg end)" --name
    linode_api_admin reboot-linode --linode-label "${C_BOX_HOSTNAME_FQHN}" --linode-config-label "${C_LINODE_OS_CONFIG_LABEL}"

    if [ "${C_DISK_ENCRYPTION}" == "true" ]; then
      # check server and port if available in order to auto unlock it
      _echo "$(msg cyan)Checking if dropbear port ${LABEL_C_DROP_BEAR_PORT} is open from --server ${LABEL_C_BOX_HOSTNAME_FQHN} ...$(msg end)" --name
      count=0
      while :; do
        sleep 1
        ((count++))
        _echo "$(msg yellow) Waiting for dropbear port ${LABEL_C_DROP_BEAR_PORT} to be available ...$(msg end)" --start-spin --name
        if is_valid available_port "${C_BOX_HOSTNAME_FQHN}" "${C_DROP_BEAR_PORT}"; then
          _echo "$(msg green)OK, dropbear port ${LABEL_C_DROP_BEAR_PORT} is now available. Unlocking encrypted LUKS disk on boot ...$(msg end)" --stop-spin --name
          # Wait 5 seconds
          sleep 5
          ssh_api unlock-luks --port "${C_DROP_BEAR_PORT}" --password "${C_LUKS_PASS}"
          break
        fi
        if [ "${count}" -gt 60 ]; then
          _echo "$(msg red)Error, failed to detect drop bear port ${LABEL_C_DROP_BEAR_PORT} because the port is closed. Please inspect this manually (make sure firewall is not blocking this port)!$(msg end)" --name
          _exit 1
        fi
      done
    fi
    if [ "${C_PRE_AUTORUN_SETUP}" == "false" ]; then
      _echo "$(msg cyan) Notice, C_PRE_AUTORUN_SETUP variable is not set in config file. Hence, auto installation script is disabled! Please run setup action manually$(msg end)" --name
    else
      _echo "$(msg cyan)Resuming server installation installation by executing ${SCRIPT_NAME} script on remote server...$(msg end)" --name
      ssh_api push-script --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" --local-script-path "${CODE_PATH}/ssh_scripts/maxinet_setup.sh"
    fi
    echo ""
    _echo "$(msg green)======================== FINISH ========================$(msg end)" --plain
  elif [ "${DNS_PROVIDER_NAME}" == "digitalocean" ]; then
    :
  elif [ "${DNS_PROVIDER_NAME}" == "amazonaws" ]; then
    :
  elif [ "${DNS_PROVIDER_NAME}" == "local" ]; then
    :
  fi

}
# This function is used to manage SSH key (create, get, copy)
# Usage: ssh_api create-key|create-key-with-putty| copy-pubkeys <group_name> <user> <comment>
# Note 1: create-key will create normal ssh key
# Note 2: create-key-with-putty will create ssh key with putty format
# eg: ssh_api create-key-with-putty --group-name admin --username maxi32 --comment "This is a comment"
# eg: ssh_api get-pubkey --group-name admin --username maxi32
# eg: ssh_api "copy-all-pubkeys"
# eg: ssh_api "clear-known-host"
# group_name = user, admin, root, rescue, backup, os, diradmin ...
ssh_api() {
  local action argnum options long_opts retval key_path group user comment server_label server port destination rsa_key \
    linode_label local_script_path remote_script_path remote_path local_path push_iso_write_script push_shutdown_script push_reboot_script \
    push_maxinet_setup_script password local_files silent_push silent

  action="$1"
  argnum="$#"
  # We allow empty argument. For example for faster login use maxinet ssh-login (by default it will login as root)
  #echo "argnum: ${argnum}"
  #if [ ${argnum} -le 1 ]; then
  #  echo "Error, no option is supplied for action ${action}. Use [ ${SCRIPT_NAME} --iso --help ] to see the valid options"
  #  exit 1
  #fi
  long_opts="help,key-path:,group:,user:,comment:,server-label:,server:,port:,destination:,without-prompt,rsa-key:,linode-label:, \
  local-script-path:,remote-script-path:,remote-path:,local-path:,local-files:,push-iso-write-script,push-shutdown-script,push-reboot-script,push-maxinet-setup-script, \
  sp:,server-port:,gu:,group-user:,password:,silent-push,silent"
  options=$(getopt -o '' --long "${long_opts}" -n "${FUNCNAME[0]} in ${SCRIPT_NAME}" -- "$@")
  retval=$?
  if [ ${retval} != 0 ]; then
    _echo "$(msg red)Error, invalid parse data. Terminating...$(msg end)" >&2
    _exit 147
  fi

  # Must quote this option variable
  eval set -- "${options}"
  # Can change using --key-path option but this location is best practice
  key_path="${SCRIPT_PATH}/secure/ssh"
  group=""
  user=""
  comment=""
  server_label="${C_BOX_HOSTNAME_FQHN}" # If not specified, use the default value from config file sun.sofibox.com
  destination="/root/.ssh/"             # If not specified, the default location is /root/.ssh/
  without_prompt=false
  server="${C_DNS_PROVIDER_TERMINAL_SERVER}" #If not specified default to the lish server from config file eg: singapore-lish.linode.com
  linode_label="${C_BOX_HOSTNAME_FQHN}"      # If not specified, use the default value from config file sun.sofibox.com
  rsa_key=""
  local_script_path=""
  remote_script_path=""
  remote_path=""
  local_path=""
  local_files=""
  push_iso_write_script=false
  push_shutdown_script=false
  push_reboot_script=false
  push_maxinet_setup_script=false
  port="22" #If not specified the default is port 22
  password=""
  silent_push=false
  silent=false
  while true; do
    case "$1" in
    --help)
      manual "${FUNCNAME[0]}"
      shift
      exit 0
      ;;
    --key-path)
      key_path="$2"
      shift 2
      ;;
    --group)
      group="$2"
      shift 2
      ;;
    --user)
      user="$2"
      shift 2
      ;;
    --comment)
      comment="$2"
      shift 2
      ;;
    --server)
      server="$2"
      # TODO implement check if server is not propagated, we use IP address instead for server
      shift 2
      ;;
    --port)
      port="$2"
      shift 2
      ;;
    --server-label)
      server_label="$2"
      shift 2
      ;;
    --rsa-key)
      rsa_key="$2"
      shift 2
      ;;
    --linode-label)
      linode_label="$2"
      shift 2
      ;;
    --local-script-path)
      local_script_path="$2"
      shift 2
      ;;
    --remote-script-path)
      remote_script_path="$2"
      echo "remote_script_path: ${remote_script_path}"
      shift 2
      ;;
    --remote-path)
      remote_path="$2"
      shift 2
      ;;
    --local-path)
      local_path="$2"
      shift 2
      ;;
    --local-files)
      local_files="$2"
      shift 2
      ;;
    # This one we can combine server:port
    --sp | --server-port)
      server_port="$2"
      server=$(echo "${server_port}" | awk -F':' '{ print $1 }')
      port=$(echo "${server_port}" | awk -F':' '{ print $2 }')
      shift 2
      ;;
    # This one we can combine group:user
    --gu | --group-user)
      group_user="$2"
      group=$(echo "${group_user}" | awk -F':' '{ print $1 }')
      user=$(echo "${group_user}" | awk -F':' '{ print $2 }')
      shift 2
      ;;
    --without-prompt)
      without_prompt=true
      shift
      ;;
    --push-iso-write-script)
      push_iso_write_script=true
      if [[ "${push_shutdown_script}" == "true" || "${push_reboot_script}" == "true" || "${push_maxinet_setup_script}" == "true" ]]; then
        _echo "$(msg red)Error, only one push script can be called at one time!$(msg end)" --name --verbose 3
        _exit 147
      fi
      shift
      ;;
    --push-shutdown-script)
      push_shutdown_script=true
      if [[ "${push_iso_write_script}" == "true" || "${push_reboot_script}" == "true" || "${push_maxinet_setup_script}" == "true" ]]; then
        _echo "$(msg red)Error, only one push script can be called at one time!$(msg end)" --name --verbose 3
        _exit 147
      fi
      shift
      ;;
    --push-reboot-script)
      push_reboot_script=true
      if [[ "${push_iso_write_script}" == "true" || "${push_shutdown_script}" == "true" || "${push_maxinet_setup_script}" == "true" ]]; then
        _echo "$(msg red)Error, only one push script can be called at one time!$(msg end)" --name --verbose 3
        _exit 147
      fi
      shift
      ;;
    --push-maxinet-setup-script)
      push_maxinet_setup_script=true
      if [[ "${push_iso_write_script}" == "true" || "${push_shutdown_script}" == "true" || "${push_reboot_script}" == "true" ]]; then
        _echo "$(msg red)Error, only one push script can be called at one time!$(msg end)" --name --verbose 3
        _exit 147
      fi
      shift
      ;;
    --password)
      password="$2"
      shift 2
      ;;
    --silent-push)
      silent_push=true
      shift
      ;;
    --silent)
      silent=true
      shift
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
    esac
  done
  # ssh_api login --server sun.sofibox.com --port 893 --group root --user root
  # This is equivalent to the above:
  # ssh_api login -sp sun.sofibox.com:893 --gu root:root

  # Special login short form
  # ssh_api login root
  # ssh_api login my_ssh_user
  # ssh_api push-script
  # Example of downloading log file from the remote to local path/log
  # ssh_api file-download --server-port test.server.com:444 --group-user root:root --remote-path ~/maxinet.log --local-path "${SCRIPT_PATH}/log"
  if [[ "${action}" == "file-download" || "${action}" == "download-files" || "${action}" == "get-files" || "${action}" == "get-file" || "${action}" == "file-retrieve" || "${action}" == "files-retrieve" ]]; then
    local private_key_name private_key_file
    if [ -z "${rsa_key}" ]; then
      private_key_name="${group}_${user}_${server}.id_rsa"
      private_key_file="/root/.ssh/${private_key_name}"
      rsa_key="${private_key_file}"
    fi

    # Do not quote local_path to enable multiple file transfers
    _echo "$(msg cyan)Getting remote files(s) from remote path ${remote_path} to ${local_path} via SSH ...$(msg end)" --name
    scp -r -o "StrictHostKeyChecking no" -P "${port}" -i "${rsa_key}" "${user}@${server}:${remote_path}" "${local_path}" 2> >(grep -v 'Permanently' 1>&2)

  elif [[ "${action}" == "file-upload" || "${action}" == "upload-files" || "${action}" == "transfer-files" || "${action}" == "transfer-file" || "${action}" == "file-transfer" || "${action}" == "files-transfer" ]]; then
    # ssh_api transfer-files/file-transfer/transfer-file --server-port ${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT} --group-user root:${C_ROOT_USERNAME}
    # --local-files "/tmp/file1 /var/file2" --remote-path ~/
    #ssh_api transfer-files/file-transfer/transfer-file --server ${C_BOX_HOSTNAME_FQHN} ---port ${C_SSH_PORT} --group root --user ${C_ROOT_USERNAME} --local-files "/tmp/file1 /var/file2" --remote-path ~/
    local private_key_name private_key_file

    if [ -z "${rsa_key}" ]; then
      private_key_name="${group}_${user}_${server}.id_rsa"
      private_key_file="/root/.ssh/${private_key_name}"
      rsa_key="${private_key_file}"
    fi

    # Do not quote local_path to enable multiple file transfers
    _echo "$(msg cyan)Transferring file local files(s) [ ${local_files} ] into remote SSH ${remote_path} using rsync ...$(msg end)" --name
    # Old method using scp
    #scp -o "StrictHostKeyChecking no" -P "${port}" -i "${rsa_key}" ${local_files} "${user}@${server}:${remote_path}" 2> >(grep -v 'Permanently' 1>&2)
    #retval=$?
    #echo "status is ${retval}"

    # New method using rsync (this method required the remote has rsync installed)
    # Important, I must use --chown=root:root to make sure that remote uploaded files have root permission by default (for security)
    rsync -og --chown=root:root -Pav -e "ssh -q -o 'StrictHostKeyChecking no' -i '${rsa_key}' -p '${port}'" ${local_files} "${user}@${server}:${remote_path}"
    retval=$?

    if [ "${retval}" -ne 0 ]; then
      _echo "$(msg cyan)Warning, failed to use rsync to transfer file. Transferring using scp method ... $(msg end)" --name
      _echo "$(msg cyan)Transferring file local files(s) [ ${local_files} ] into remote SSH ${remote_path} using scp ...$(msg end)" --name
      # Old method using scp
      scp -o "StrictHostKeyChecking no" -P "${port}" -i "${rsa_key}" ${local_files} "${user}@${server}:${remote_path}" 2> >(grep -v 'Permanently' 1>&2)
      retval=$?
    fi

    echo "File transfer status is ${retval}"

    # ssh_api luks-unlock --port 8922 --password 1234
    # or without argument ssh_api luks-unlock (it will get the default values from config file)
    # This function is used to unlock LUKS disk encryption on boot via terminal
    # Usage: ssh_api luks-unlock --port <drop_bear_port> --password <disk_luks_password>
    # Note 1: The drop_bear_port is setup using dropbear-initramfs (This is set in OS preseed-file and config file)
    # Note 2: The disk_luks_password is the OS LUKS encryption password (This is set in OS preseed-file and config file)
    # Note 3: The unlock method required a port and a password. It will use a normal SSH with certificate (Certificate is set in OS preseed-file)
    # Note 4: After it has successfully logged into the system via SSH, we write the disk_luks_password using this code and the OS will automatically unlock it: "echo -ne \"${pass}\" > /lib/cryptsetup/passfifo"
    # eg calling within code: ssh_api luks-unlock --port 8922 --password 1234
    # eg calling outside code: <script_name> --ssh-luks-unlock --port 8922 --password 1234
    # Guide: https://www.arminpech.de/2019/12/23/debian-unlock-luks-root-partition-remotely-by-ssh-using-dropbear/
    # Guide 2: https://www.gandalfk7.it/posts/20200914_02_Debian_9_and_10_boot_luks_unlock/
  elif [[ "${action}" == "luks-unlock" || "${action}" == "ssh-luks-unlock" || "${action}" == "unlock-luks" ]]; then

    # This means if the argument is only 1 (with action argument)
    if [[ "${argnum}" -le 1 ]]; then
      linode_label="${C_BOX_HOSTNAME_FQHN}"
      port="${C_DROP_BEAR_PORT}"
      password="${C_LUKS_PASS}"
    fi

    if [ -z "${rsa_key}" ]; then
      private_key_name="root_${C_ROOT_USERNAME}_${linode_label}.id_rsa"
      private_key_file="/root/.ssh/${private_key_name}"
      rsa_key="${private_key_file}"
    fi
    if [ "${C_HIDE_SENSITIVE_TEXT}" == "true" ]; then
      _echo "$(msg cyan)Unlocking LUKS encrypted disk on boot via SSH with port *hidden_port* ...$(msg end)" --name
    else
      _echo "$(msg cyan)Unlocking LUKS encrypted disk on boot via SSH port ${port} ...$(msg end)" --name
    fi
    if [ -f "${rsa_key}" ]; then
      # Do not use -q, need verbose for this connection to debug error
      ssh -o "StrictHostKeyChecking no" -oAddressFamily=inet -p "${port}" -i "${rsa_key}" "${linode_label}" "echo -ne \"${password}\" > /lib/cryptsetup/passfifo" 2> >(grep -v 'Permanently added' 1>&2)
      retval=$?
      if [ ${retval} -eq 0 ]; then
        _echo "$(msg green)Success, LUKS disk unlocked with return code 0 $(msg end)" --name
      else
        _echo "$(msg yellow)Warning, failed to unlock LUKS disk [return code ${retval}]$(msg end)" --name
      fi
    else
      _echo "$(msg red)Error, private key ${rsa_key} does not exist!$(msg end)" --name --verbose 3
      _exit 147
    fi

  elif [ "${action}" == "login" ]; then
    local option ssh_pid private_key_name private_key_file
    option="$2"
    # This is special login based on user from config file (for faster login)
    if [[ ${argnum} -le 1 || "${option}" == "${C_ROOT_USERNAME}" ]]; then
      private_key_name="root_${C_ROOT_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa"
      private_key_file="/root/.ssh/${private_key_name}"
      rsa_key="${private_key_file}"

      # This will check available port even if NO LUKS encrypted
      _echo "$(msg cyan)Checking whether ${LABEL_C_BOX_HOSTNAME_FQHN}'s port ${LABEL_C_SSH_PORT} is online ...$(msg end)" --name
      if is_valid available_port "${C_BOX_HOSTNAME_FQHN}" "${C_SSH_PORT}"; then
        _echo "$(msg green)OK, the port ${LABEL_C_SSH_PORT} is available at ${LABEL_C_BOX_HOSTNAME_FQHN}$(msg end)" --name
      else
        _echo "$(msg yellow)Warning, the --server-port ${LABEL_C_BOX_HOSTNAME_FQHN}:${LABEL_C_SSH_PORT} is not available!$(msg end)" --name

        _echo "$(msg cyan)Checking server ${C_BOX_HOSTNAME_FQHN}'s online status ...$(msg end)" --name
        linode_status=$(linode_api_admin get-linode-status --linode-label "${C_BOX_HOSTNAME_FQHN}" --scripting)
        if [ "${linode_status}" == "offline" ]; then
          _echo "$(msg yellow)Warning, linode is offline!$(msg end)" --name
          linode_api_admin boot-linode --linode-label "${C_BOX_HOSTNAME_FQHN}" --linode-config-label "${C_LINODE_OS_CONFIG_LABEL}" --scripting
        fi
        ssh_api luks-unlock --port "${C_DROP_BEAR_PORT}" --password "${C_LUKS_PASS}"
        sleep 7
        if is_valid available_port "${C_BOX_HOSTNAME_FQHN}" "${C_SSH_PORT}"; then
          _echo "$(msg green)OK, the port ${LABEL_C_SSH_PORT} is available at ${LABEL_C_BOX_HOSTNAME_FQHN} $(msg end)" --name
        else
          _echo "$(msg red)Error, the --server-port ${LABEL_C_BOX_HOSTNAME_FQHN}:${LABEL_C_SSH_PORT} is not available (make sure server is online or port ${LABEL_C_SSH_PORT} is available)$(msg end)" --name
          # TODO can retry here with option --max-retry N
          #ssh_api login
          _exit 147
        fi
      fi
      _echo "$(msg cyan)Logging into SSH server at ${LABEL_C_ROOT_USERNAME}@${LABEL_C_BOX_HOSTNAME_FQHN}:${LABEL_C_SSH_PORT}... $(msg end)" --name
      ssh -o "StrictHostKeyChecking no" -i "${rsa_key}" -p "${C_SSH_PORT}" "${C_ROOT_USERNAME}@${C_BOX_HOSTNAME_FQHN}"
    elif [ "${option}" == "${C_SSH_USERNAME}" ]; then
      private_key_name="user_${C_SSH_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa"
      private_key_file="/root/.ssh/${private_key_name}"
      rsa_key="${private_key_file}"

      # This will check available port even if NO LUKS encrypted
      _echo "$(msg cyan)Checking whether ${LABEL_C_BOX_HOSTNAME_FQHN}'s port ${LABEL_C_SSH_PORT} is online ...$(msg end)" --name
      if is_valid available_port "${C_BOX_HOSTNAME_FQHN}" "${C_SSH_PORT}"; then
        _echo "$(msg green)OK, the port ${LABEL_C_SSH_PORT} is available at ${LABEL_C_BOX_HOSTNAME_FQHN} $(msg end)" --name
      else
        _echo "$(msg yellow)Warning, the --server-port ${LABEL_C_BOX_HOSTNAME_FQHN}:${LABEL_C_SSH_PORT} is not available!$(msg end)" --name
        _echo "$(msg cyan)Checking server ${LABEL_C_BOX_HOSTNAME_FQHN}'s online status ...$(msg end)" --name
        linode_status=$(linode_api_admin get-linode-status --linode-label "${C_BOX_HOSTNAME_FQHN}" --scripting)
        if [ "${linode_status}" == "offline" ]; then
          _echo "$(msg yellow)Warning, linode is offline!$(msg end)" --name
          linode_api_admin boot-linode --linode-label "${C_BOX_HOSTNAME_FQHN}" --linode-config-label "${C_LINODE_OS_CONFIG_LABEL}" --scripting
        fi

        ssh_api luks-unlock --port "${C_DROP_BEAR_PORT}" --password "${C_LUKS_PASS}"
        sleep 7
        if is_valid available_port "${C_BOX_HOSTNAME_FQHN}" "${C_SSH_PORT}"; then
          _echo "$(msg green)OK, the port ${LABEL_C_SSH_PORT} is available at ${LABEL_C_BOX_HOSTNAME_FQHN} $(msg end)" --name
        else
          _echo "$(msg red)Error, the --server-port ${LABEL_C_BOX_HOSTNAME_FQHN}:${LABEL_C_SSH_PORT} is not available (make sure server is online or port ${LABEL_C_SSH_PORT} is available)$(msg end)" --name
          _exit 147
        fi
      fi
      _echo "$(msg cyan)Logging into SSH server at ${LABEL_C_SSH_USERNAME}@${LABEL_C_BOX_HOSTNAME_FQHN}:${LABEL_C_SSH_PORT}... $(msg end)" --name
      _echo "$(msg yellow)Note: After successfully logged in as non-root user, use command [ sudo su - ] to login as root user$(msg end)" --name
      ssh -o "StrictHostKeyChecking no" -i "${rsa_key}" -p "${C_SSH_PORT}" "${C_SSH_USERNAME}@${C_BOX_HOSTNAME_FQHN}"
    else
      if [[ -z "${group}" ]]; then
        _echo "$(msg red)Error, the option --group is required to have value$(msg end)" --name
        _exit 147
      elif [[ -z "${user}" ]]; then
        _echo "$(msg red)Error, the option --user is required to have value$(msg end)" --name
        _exit 147
      elif [[ -z "${server}" ]]; then
        _echo "$(msg red)Error, the option --server is required to have value$(msg end)" --name
        _exit 147
      elif [[ -z "${port}" ]]; then
        _echo "$(msg red)Error, the option --port is required to have value$(msg end)" --name
        _exit 147
      fi

      # This will check available port even if NO LUKS encrypted
      _echo "$(msg cyan)Checking whether ${server}'s port ${port} is online ...$(msg end)" --name
      if is_valid available_port "${server}" "${port}"; then
        _echo "$(msg green)OK, the port ${port} is available at ${server} $(msg end)" --name
      else
        _echo "$(msg yellow)Warning, the --server-port ${server}:${port} is not available!$(msg end)" --name
        _echo "$(msg cyan)Checking server ${server}'s online status ...$(msg end)" --name
        linode_status=$(linode_api_admin get-linode-status --linode-label "${server}" --scripting)
        if [ "${linode_status}" == "offline" ]; then
          _echo "$(msg yellow)Warning, linode is offline!$(msg end)" --name
          linode_api_admin boot-linode --linode-label "${server}" --linode-config-label "${C_LINODE_OS_CONFIG_LABEL}" --scripting
        fi
        ssh_api luks-unlock --port "${C_DROP_BEAR_PORT}" --password "${C_LUKS_PASS}"
        sleep 7
        if is_valid available_port "${server}" "${port}"; then
          _echo "$(msg green)OK, the port ${port} is available at ${server} $(msg end)" --name
        else
          _echo "$(msg red)Error, the --server-port ${server}:${port} is not available (make sure server is online or port ${port} is available)$(msg end)" --name
          _exit 147
        fi
      fi

      if [ -z "${rsa_key}" ]; then
        private_key_name="${group}_${user}_${server}.id_rsa"
        private_key_file="/root/.ssh/${private_key_name}"
        rsa_key="${private_key_file}"
      fi

      if [ ! -f "${rsa_key}" ]; then
        _echo "$(msg red)Error, invalid public RSA key file at ${rsa_key}. Please make sure the file exist$(msg end)" --name --verbose 3
        _exit 147
      fi

      _echo "$(msg cyan)Logging into SSH server at ${user}@${server}:${port}... $(msg end)" --name
      ssh -o "StrictHostKeyChecking no" -i "${rsa_key}" -p "${port}" "${user}${server}"
      #ssh_pid=$?
      #{ kill -9 ${ssh_pid} && wait ${ssh_pid}; } 2>/dev/null
    fi
  # For linode LISH login
  # ssh_api lish-login --key /root/.ssh/linode_lish.id_rsa --user maxibi --server lish-singapore.linode.com --port 22 --linode-label sun.sofibox.com
  elif [ "${action}" == "lish-login" ]; then
    local ssh_pid
    # This is not a normal SSH (it uses Pseudo-TTY)
    # Normal: ssh_api lish-login
    if [ -z "${rsa_key}" ]; then
      rsa_key="/root/.ssh/linode_lish.id_rsa"
    fi

    if [ -z "${user}" ]; then
      user="${DNS_PROVIDER_USER}"
    fi

    if [ ! -f "${rsa_key}" ]; then
      _echo "$(msg red)Error, invalid RSA key file at ${rsa_key}. Please make sure the file exist$(msg end)" --name --verbose 3
      _exit 147
    fi

    _echo "$(msg cyan)Logging into lish console ${user}@${server}... $(msg end)" --name
    # In Windows WSL linux, there will be error log saying: setsockopt IPV6_TCLASS 16: Operation not permitted: (this message can be ignored)
    # Note 2 linode lish requires to use -t option to login. -t option means pseudo-tty (some suggested to use double -tt)
    ssh -o "StrictHostKeyChecking no" -i "${rsa_key}" -p "${port}" -tt "${user}@${server}" "${linode_label}" 2> >(grep -v "Permanently added" 1>&2)
    ssh_pid=$?
    { kill -9 ${ssh_pid} && wait ${ssh_pid}; } 2>/dev/null

  # For SSH push script
  elif [ "${action}" == "push-script" ]; then
    local private_key_name private_key_file ssh_pid
    # ssh_api push-script --server ${C_BOX_HOSTNAME_FQHN} --port ${C_SSH_PORT} --group root --user ${C_ROOT_USERNAME} --local-script-path "${CODE_PATH}/ssh_scripts/maxinet_setup.sh"
    # The above is equivalent to below (shortest form)
    # ssh_api push-script --server-port sun.sofibox.com:893 --group-user root:root --push-maxinet-setup-script

    if [[ -z "${group}" ]]; then
      _echo "$(msg red)Error, the option --group is required to have value$(msg end)" --name
      _exit 147
    elif [[ -z "${user}" ]]; then
      _echo "$(msg red)Error, the option --user is required to have value$(msg end)" --name
      _exit 147
    elif [[ -z "${server}" ]]; then
      _echo "$(msg red)Error, the option --server is required to have value$(msg end)" --name
      _exit 147
    elif [[ -z "${port}" ]]; then
      _echo "$(msg red)Error, the option --port is required to have value$(msg end)" --name
      _exit 147
    fi

    if [ -z "${rsa_key}" ]; then
      private_key_name="${group}_${user}_${server}.id_rsa"
      private_key_file="/root/.ssh/${private_key_name}"
      rsa_key="${private_key_file}"
    fi

    if [ ! -f "${rsa_key}" ]; then
      _echo "$(msg red)Error, invalid public RSA key file at ${rsa_key}. Please make sure the file exist$(msg end)" --name --verbose 3
      _exit 147
    fi

    # Shortest form
    if [ -z "${local_script_path}" ]; then
      if [ "${push_maxinet_setup_script}" == "true" ]; then
        local_script_path="${CODE_PATH}/ssh_scripts/maxinet_setup.sh"
      elif [ "${push_shutdown_script}" == "true" ]; then
        # This script can be used as normal SSH
        local_script_path="${CODE_PATH}/ssh_scripts/shutdown_command.sh"
      elif [ "${push_reboot_script}" == "true" ]; then
        # This script can be used as normal SSH
        local_script_path="${CODE_PATH}/ssh_scripts/reboot_command.sh"
      else
        _echo "$(msg red)Error. the option --local-script-path requires to have a valid script path to be pushed into SSH server or use predefined push script option such as --push-shutdown-script$(msg end)" --name --verbose 3
      fi
    fi

    if [ "${C_HIDE_SENSITIVE_TEXT}" == "true" ]; then
      _echo "$(msg cyan)Pushing script ${local_script_path} into SSH console ... $(msg end)" --name
    else
      _echo "$(msg cyan)Pushing script ${local_script_path} into SSH console ${user}@${server}... $(msg end)" --name
    fi
    if [ "${silent_push}" == "true" ]; then
      ssh -q -o "StrictHostKeyChecking no" -i "${rsa_key}" -p "${port}" "${user}@${server}" <"${local_script_path}" >/dev/null 2>&1 &
    else
      # Must pass the value -tt (else the terminal color won't work)
      ssh -o "StrictHostKeyChecking no" -i "${rsa_key}" -p "${port}" -tt "${user}@${server}" <"${local_script_path}"
    fi
    # Test kill after 10 seconds
    #sleep 10
    #ssh_pid=$?
    #{ kill -9 ${ssh_pid} && wait ${ssh_pid}; } 2>/dev/null
    # For linode LISH push script
    # Note that lish-push-script only can be used on recovery mode because in recovery mode, it doesn't have authentication.
  elif [ "${action}" == "lish-push-script" ]; then
    local ssh_pid

    if [ -z "${rsa_key}" ]; then
      rsa_key="/root/.ssh/linode_lish.id_rsa"
    fi

    if [ -z "${user}" ]; then
      user="${DNS_PROVIDER_USER}"
    fi

    if [ ! -f "${rsa_key}" ]; then
      _echo "$(msg red)Error, invalid RSA key file at ${rsa_key}. Please make sure the file exist$(msg end)" --name --verbose 3
      _exit 147
    fi

    #Shortest form
    # if dont specify local_script_path, i can specify option such as --push-os-write, --push-shutdown, --push-reboot
    if [ -z "${local_script_path}" ]; then
      if [ "${push_iso_write_script}" == "true" ]; then
        # This is dangerous script that can wipe partition
        local_script_path="${CODE_PATH}/ssh_scripts/os_write_ag.sh"
      elif [ "${push_shutdown_script}" == "true" ]; then
        local_script_path="${CODE_PATH}/ssh_scripts/shutdown_command.sh"
      elif [ "${push_reboot_script}" == "true" ]; then
        local_script_path="${CODE_PATH}/ssh_scripts/reboot_command.sh"
      else
        _echo "$(msg red)Error. the option --local-script-path requires to have a valid script path to be pushed into SSH server or use predefined push script option such as --push-shutdown-script$(msg end)" --name --verbose 3
      fi
    fi

    if [ "${C_HIDE_SENSITIVE_TEXT}" == "true" ]; then
      _echo "$(msg cyan)Pushing script ${local_script_path} into lish console... $(msg end)" --name
    else
      _echo "$(msg cyan)Pushing script ${local_script_path} into lish console ${user}@${server}... $(msg end)" --name
    fi

    #ssh -q -o "StrictHostKeyChecking no" -i /root/.ssh/linode_lish.id_rsa -tt "${DNS_PROVIDER_USER}@${C_DNS_PROVIDER_TERMINAL_SERVER}" "${C_BOX_HOSTNAME_FQHN}" <"${SCRIPT_PATH}/dns/linode/os_write.sh" >/dev/null 2>&1 &

    # push script: ssh_api lish-push-script --key rsa_key.id.rsa --user maxibi --server member.linode.com --linode-label sun.sofibox.com --local-script-path /tmp/os_write.sh
    ssh -o "StrictHostKeyChecking no" -i "${rsa_key}" -p "${port}" -tt "${user}@${server}" "${linode_label}" <"${local_script_path}" >/dev/null 2>&1 &
    #ssh_pid=$?
    # Test kill after 10 seconds
    #sleep 10

    #{ kill -9 ${ssh_pid} && wait ${ssh_pid}; } 2>/dev/null
  elif [ "${action}" == "create-key" ]; then
    local private_key_name
    mkdir -p "${key_path}"
    if [[ -z "${group}" ]]; then
      _echo "$(msg red)Error, the option --group is required to have value$(msg end)" --name
      _exit 147
    elif [[ -z "${user}" ]]; then
      _echo "$(msg red)Error, the option --user is required to have value$(msg end)" --name
      _exit 147
    elif [[ -z "${server_label}" ]]; then
      _echo "$(msg red)Error, the option --server-label is required to have value$(msg end)" --name
      _exit 147
    else
      private_key_name="${group}_${user}_${server_label}.id_rsa"

    fi

    # This key will be stored in secure folder first not /root/.ssh
    if [[ "${silent}" == "true" || "${C_HIDE_SENSITIVE_TEXT}" == "true" ]]; then
      _echo "$(msg cyan)Creating private and public key RSA SSH key authentication ...$(msg end)" --name
      ssh-keygen -q -f "${key_path}/${private_key_name}" -t rsa -b 4096 -P "" -C "${comment}" <<<y
    else
      _echo "$(msg cyan)Creating private and public key RSA SSH key authentication at ${key_path}/${private_key_name} ...$(msg end)" --name
      ssh-keygen -f "${key_path}/${private_key_name}" -t rsa -b 4096 -P "" -C "${comment}" <<<y
    fi
  elif [ "${action}" == "create-key-with-putty" ]; then
    local private_key_name private_key_putty_name
    mkdir -p "${key_path}"
    if [[ -z "${group}" ]]; then
      _echo "$(msg red)Error, the option --group is required to have value$(msg end)" --name
      _exit 147
    elif [[ -z "${user}" ]]; then
      _echo "$(msg red)Error, the option --user is required to have value$(msg end)" --name
      _exit 147
    elif [[ -z "${server_label}" ]]; then
      _echo "$(msg red)Error, the option --server-label is required to have value$(msg end)" --name
      _exit 147
    else
      private_key_name="${group}_${user}_${server_label}.id_rsa"
      private_key_putty_name="${group}_${user}_${server_label}.ppk"
    fi
    # This key will be stored in secure folder first not /root/.ssh
    if [[ "${silent}" == "true" || "${C_HIDE_SENSITIVE_TEXT}" == "true" ]]; then
      _echo "$(msg cyan)Creating private and public key RSA SSH key authentication ...$(msg end)" --name
      ssh-keygen -f "${key_path}/${private_key_name}" -t rsa -b 4096 -P "" -C "${comment}" <<<y >/dev/null 2>&1
    else
      _echo "$(msg cyan)Creating private and public key RSA SSH key authentication at ${key_path}/${private_key_name} ...$(msg end)" --name
      ssh-keygen -f "${key_path}/${private_key_name}" -t rsa -b 4096 -P "" -C "${comment}" <<<y
    fi
    echo ""
    required "debian@@apt:putty-tools" "ubuntu@@apt:putty-tools"
    if [[ "${silent}" == "true" || "${C_HIDE_SENSITIVE_TEXT}" == "true" ]]; then
      _echo "$(msg cyan)Creating RSA SSH key authentication for Putty ...$(msg end)" --name
      puttygen -q "${key_path}/${private_key_name}" -o "${key_path}/${private_key_putty_name}"

    else
      _echo "$(msg cyan)Creating RSA SSH key authentication for Putty at ${key_path}/${private_key_putty_name} ...$(msg end)" --name
      puttygen "${key_path}/${private_key_name}" -o "${key_path}/${private_key_putty_name}"

    fi

  elif [[ "${action}" == "get-pubkey" || "${action}" == "get-public-key" ]]; then
    local public_key_name public_key_file
    if [[ -z "${group}" ]]; then
      _echo "$(msg red)Error, the option --group is required to have value$(msg end)" --name
      _exit 147
    elif [[ -z "${user}" ]]; then
      _echo "$(msg red)Error, the option --user is required to have value$(msg end)" --name
      _exit 147
    elif [[ -z "${server_label}" ]]; then
      _echo "$(msg red)Error, the option --server-label is required to have value$(msg end)" --name
      _exit 147
    else
      public_key_name="${group}_${user}_${server_label}.id_rsa.pub"
      # Note. This one should be the location of the secure path of script not the root path of ssh in the system such as /root/.ssh
      public_key_file="${SECURE_PATH}/ssh/${public_key_name}"
    fi

    if [ -f "${public_key_file}" ]; then
      cat "${public_key_file}"
      return 0
    else
      _echo "$(msg red)Error, RSA public key does not exist in ${public_key_file}. Please create it first$(msg end)" --name --verbose 3
      return 147
    fi
  elif [[ "${action}" == "get-prikey" || "${action}" == "get-private-key" ]]; then
    local private_key_name private_key_file
    if [[ -z "${group}" ]]; then
      _echo "$(msg red)Error, the option --group is required to have value$(msg end)" --name
      _exit 147
    elif [[ -z "${user}" ]]; then
      _echo "$(msg red)Error, the option --user is required to have value$(msg end)" --name
      _exit 147
    elif [[ -z "${server_label}" ]]; then
      _echo "$(msg red)Error, the option --server-label is required to have value$(msg end)" --name
      _exit 147
    else
      private_key_name="${group}_${user}_${server_label}.id_rsa"
      private_key_file="/root/.ssh/${private_key_name}"
    fi
    if [ -f "${private_key_file}" ]; then
      cat "${private_key_file}"
      return 0
    else
      _echo "$(msg red)Error, RSA private key does not exist in ${private_key_file}. Please create it first$(msg end)" --name --verbose 3
      return 147
    fi

    # Warning this will replace existing key

    # ssh_api copy-public-keys --destination /root/.ssh/
    # Haven't implemented --destination (not so important) default should be /root/.ssh/
  elif [[ "${action}" == "copy-pubkeys" || "${action}" == "copy-publickeys" || "${action}" == "copy-public-keys" ]]; then
    local response retval
    mkdir -p /root/.ssh
    if [ "${without_prompt}" == "true" ]; then
      if [ -f /root/.ssh/known_hosts ]; then
        # No need to display this message if using with option --without-prompt
        #_echo "$(msg cyan)Resetting known_hosts and copying all public key to /root/.ssh/* ...$(msg end)" --name
        echo >/root/.ssh/known_hosts
      fi
      cp "${key_path}"/*.id_rsa* /root/.ssh/
      _echo "Copying rsa key from ${key_path}/*.id_rsa* into /root/.ssh/ ..." --verbose 7
      chmod -R 600 /root/.ssh/
    else
      read -r -p "This will replace existing public key files (except putty format) from ${key_path} into /root/.ssh/. Are you sure? [Y/n]" response
      response=$(echo "${response}" | tr '[:upper:]' '[:lower:]')
      if [[ $response =~ ^(yes|y| ) ]] || [[ -z $response ]]; then
        _echo "$(msg cyan)Resetting known_hosts and copying all public key to /root/.ssh/* ...$(msg end)" --name
        echo >/root/.ssh/known_hosts
        cp "${key_path}"/*.id_rsa* /root/.ssh/
        chmod -R 600 /root/.ssh/
      else
        _echo "$(msg red)Operation aborted by user!$(msg end)" --name
        _exit 147
      fi
    fi

  elif [[ "${action}" == "clear-known-hosts" || "${action}" == "clear-known-host" ]]; then
    _echo "$(msg cyan)Resetting known_hosts and copying all public key .id_rsa from ${key_path}/ to /root/.ssh/* ...$(msg end)" --name
    echo >/root/.ssh/known_hosts
  else
    _echo "$(msg red)Error, unknown action ${action} argument specified when calling ssh_api function!$(msg end)" --name --verbose 3
    return 147
  fi
}
#maxinet lish-console <options>

#maxinet lish-console kill - kill stuck screen sessions
#maxinet lish-console exit - exit from lish
#maxinet lish-console help - this menu
#maxinet lish-console [return] - connect to console
#maxinet lish-console boot - boot last used (or the only) config profile
#maxinet lish-console boot N - boot the specified config profile. Where N is the profile number assigned as: N) Config Name
#maxinet lish-console reboot - shut down, then boot the last used config profile
#maxinet lish-console reboot N - shut down, then boot the specified config profile. Where N is the profile number assigned as: N) Config Name
#maxinet lish-console sysrq X - send SysRq X to your Linode. Where X is the sysrq code that can be found here: https://en.wikipedia.org/wiki/Magic_SysRq_key#Commands
#maxinet lish-console shutdown - shut down the Linode
#maxinet lish-console destroy - pulls the plug on a running Linode, no fs sync, no warning
#maxinet lish-console jobs - view the job queue for your Linode
#maxinet lish-console version - display running kernel version
#maxinet lish-console configs - view the configuration profiles for your Linode
#maxinet lish-console config N - view configuration profile details for profile N
#maxinet lish-console status - view the status of your Linode
#maxinet lish-console logview - view contents of console log

lish_console() {
  #exec_time start lish_console
  options="$*"
  # If we do not give value for option, it means we are using the return signal (means connect to console)
  if [ -z "${options}" ]; then
    _echo "$(msg cyan)Executing lish-console command [ RETURN - connect to console] ...$(msg end)" --name
  else
    _echo "$(msg cyan)Executing lish-console command [ ${options} ] ...$(msg end)" --name
  fi
  # Only run this in local machine
  # This will list out the number of lish config profile for OS_Config (currently this has bug in linode because it took longer to list out and has duplicated Rescue Mode entry)
  # Sent question to ticket waiting for answer to speedup this one
  #maxinet --lish configs 2>&1 | grep 'OS_Config' | awk -F')' '{ print $1 }' | xargs
  # I use 2>&1 to hide error output
  ssh -i "/root/.ssh/linode_lish.id_rsa" -o "StrictHostKeyChecking no" -oAddressFamily=inet -tt "${DNS_PROVIDER_USER}@${C_DNS_PROVIDER_TERMINAL_SERVER}" "${C_BOX_HOSTNAME_FQHN}" ${options}
  #exec_time end lish_console
}

# This function will validate if config is valid, if one of the variables missing, it will complain and exit
validate_config() {
  local count_user total_valid_user this_da_owner_name this_da_owner_uname this_da_owner_password this_da_owner_system_email this_da_owner_security_qna
  total_valid_user=0
  _echo "$(msg cyan)Checking directadmin users' variables ...$(msg end)" --name --verbose 7
  #--------------------#
  # Validate admin     #
  #--------------------#
  # Owner does not support multiple user creation. So checking is simple without loop
  typeset -n "this_da_owner_name=C_DA_OWNER_NAME1"
  typeset -n "this_da_owner_uname=C_DA_OWNER_USERNAME1"
  typeset -n "this_da_owner_password=C_DA_OWNER_USERPASS1"
  typeset -n "this_da_owner_system_email=C_DA_OWNER_SYSTEM_EMAIL1"
  typeset -n "this_da_owner_security_qna=C_DA_OWNER_SECURITY_QNA1"

  if [[ "${#this_da_owner_uname}" -lt 2 ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner username length is ${#this_da_owner_uname} but the it should be more or equal to 2. Please check configuration file"
    _exit 147
  elif [[ "${#this_da_owner_uname}" -gt ${C_DA_MAX_USERNAME_LENGTH} ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner username length is ${#this_da_owner_uname} but the it should be less or equal to ${C_DA_MAX_USERNAME_LENGTH}. Please check configuration file"
    _exit 147
  elif [[ -z "${this_da_owner_name+x}" ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner ${this_da_owner_uname} doesn't have name set in config file (missing or invalid variable). Please check configuration file"
    _exit 147
  elif [[ -z "${this_da_owner_password+x}" ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner ${this_da_owner_uname} doesn't have password set in config file (missing or invalid variable). Please check configuration file "
    _exit 147
  elif [[ "${#this_da_owner_password}" -lt 6 ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner ${this_da_owner_uname} has password set length of ${#C_DA_OWNER_USERPASS1} but the minimum is 6 characters. Please check configuration file"
    _exit 147
  elif [[ "${#this_da_owner_password}" -gt 64 ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner ${this_da_owner_uname} has password set length of ${#C_DA_OWNER_USERPASS1} but the maximum is 64 characters. Please check configuration file"
    _exit 147
  elif [[ "${this_da_owner_password}" =~ ['&+'] ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner ${this_da_owner_uname} has password set with forbidden special character [ &+ ] in config file. Please check configuration file"
    _exit 147
  elif [[ -z "${this_da_owner_system_email+x}" ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner ${this_da_owner_uname} doesn't have system email set in config file (missing or invalid variable). Please check configuration file "
    _exit 147
  elif ! is_valid "email" "${this_da_owner_system_email}"; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner ${this_da_owner_uname} has invalid email [ ${this_da_owner_system_email} ] set in config file. Please check configuration file "
    _exit 147
  elif [[ -z "${this_da_owner_security_qna+x}" ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning owner ${this_da_owner_uname} doesn't have security question and answer set in config file (missing or invalid variable). Please check configuration file "
    _exit 147
  elif [[ -n "${this_da_owner_security_qna}" && $(echo "${#this_da_owner_security_qna[@]}") -ne $(awk -F'\|\|\|' '{print NF-1}' <<<"${this_da_owner_security_qna[@]}") ]]; then
    echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin ${this_da_owner_uname} has invalid security question and answer format set in config file (invalid separator). Please check configuration file "
    _exit 147
  else
    _echo "$(msg green)OK, all variables for owner ${LABEL_C_DA_OWNER_USERNAME1} are valid.$(msg end)" --name --verbose 7
    ((total_valid_user++))
  fi

  #--------------------#
  # Validate admin     #
  #--------------------#
  local da_admin_unames this_da_admin_uname this_da_admin_password this_da_admin_name \
    this_da_admin_system_email this_da_admin_security_qna count_user

  da_admin_unames="${!C_DA_ADMIN_USERNAME@}"
  count_user=1
  while [[ ${count_user} -le $(echo "${da_admin_unames}" | wc -w) ]]; do
    typeset -n "this_da_admin_uname=C_DA_ADMIN_USERNAME${count_user}"
    typeset -n "this_da_admin_password=C_DA_ADMIN_USERPASS${count_user}"
    typeset -n "this_da_admin_name=C_DA_ADMIN_NAME${count_user}"
    typeset -n "this_da_admin_system_email=C_DA_ADMIN_SYSTEM_EMAIL${count_user}"
    typeset -n "this_da_admin_security_qna=C_DA_ADMIN_SECURITY_QNA${count_user}"

    if [[ "${#this_da_admin_uname}" -lt 2 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin username length is ${#this_da_admin_uname} but the it should be more or equal to 2. Please check configuration file"
      _exit 147
    elif [[ "${#this_da_admin_uname}" -gt ${C_DA_MAX_USERNAME_LENGTH} ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin username length is ${#this_da_admin_uname} but the it should be less or equal to ${C_DA_MAX_USERNAME_LENGTH}. Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_admin_password+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin ${this_da_admin_uname} doesn't have password set in config file (missing or invalid variable). Please check configuration file "
      _exit 147
    elif [[ "${#this_da_admin_password}" -lt 6 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin ${this_da_admin_uname} has password set length of ${#this_da_admin_password} but the minimum is 6 characters. Please check configuration file"
      _exit 147
    elif [[ "${#this_da_admin_password}" -gt 64 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin ${this_da_admin_uname} has password set length of ${#this_da_admin_password} but the maximum is 64 characters. Please check configuration file"
      _exit 147
    elif [[ "${this_da_admin_password}" =~ ['&+'] ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin ${this_da_admin_uname} has password set with forbidden special characters [ &+ ] in config file. Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_admin_name+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin ${this_da_admin_uname} doesn't have name set in config file (missing or invalid variable). Please check configuration file "
      _exit 147
    elif [[ -z "${this_da_admin_system_email+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin ${this_da_admin_uname} doesn't have system email set in config file (missing or invalid variable). Please check configuration file "
      _exit 147
    elif ! is_valid "email" "${this_da_admin_system_email}"; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin ${this_da_admin_uname} has invalid email [ ${this_da_admin_system_email} ] set in config file. Please check configuration file "
      _exit 147
    elif [[ -z "${this_da_owner_security_qna+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin ${this_da_admin_uname} doesn't have security question and answer set in config file (missing or invalid variable). Please check configuration file "
      _exit 147
    elif [[ -n "${this_da_admin_security_qna}" && $(echo "${#this_da_admin_security_qna[@]}") -ne $(awk -F'\|\|\|' '{print NF-1}' <<<"${this_da_admin_security_qna[@]}") ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning admin ${this_da_admin_uname} has invalid security question and answer format set in config file (invalid separator). Please check configuration file "
      _exit 147
    else
      _echo "$(msg green)OK, all variables for admin ${this_da_admin_uname} are valid.$(msg end)" --name --verbose 7
      ((total_valid_user++))
    fi
    ((count_user++))
  done

  #--------------------#
  # Validate resellers #
  #--------------------#
  local this_da_reseller_uname this_da_reseller_password this_da_reseller_name this_da_reseller_system_email \
    this_da_reseller_package_name this_da_reseller_domains this_da_reseller_wildcard_domains this_da_reseller_subdomains \
    this_c_da_reseller_ip_type this_da_reseller_enable_domain_ssl this_da_reseller_ssl_subdomains this_da_reseller_mail_accounts \
    this_da_reseller_security_qna this_da_reseller_db_accounts

  count_user=1

  while [[ ${count_user} -le $(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w) ]]; do

    typeset -n "this_da_reseller_uname=C_DA_RESELLER_USERNAME${count_user}"
    typeset -n "this_da_reseller_password=C_DA_RESELLER_USERPASS${count_user}"
    typeset -n "this_da_reseller_name=C_DA_RESELLER_NAME${count_user}"
    typeset -n "this_da_reseller_system_email=C_DA_RESELLER_SYSTEM_EMAIL${count_user}"
    typeset -n "this_da_reseller_package_name=C_DA_RESELLER_PACKAGE_NAME${count_user}"
    typeset -n "this_da_reseller_domains=C_DA_RESELLER_DOMAIN${count_user}"
    typeset -n "this_da_reseller_wildcard_domains=C_DA_RESELLER_WILDCARD_DOMAIN${count_user}"
    typeset -n "this_da_reseller_subdomains=C_DA_RESELLER_SUBDOMAIN${count_user}"
    typeset -n "this_c_da_reseller_ip_type=C_DA_RESELLER_IP_TYPE${count_user}"
    typeset -n "this_da_reseller_enable_domain_ssl=C_DA_RESELLER_ENABLE_DOMAIN_SSL${count_user}"
    typeset -n "this_da_reseller_ssl_subdomains=C_DA_RESELLER_SSL_SUBDOMAIN${count_user}"
    typeset -n "this_da_reseller_mail_accounts=C_DA_RESELLER_MAIL_ACCOUNT${count_user}"
    typeset -n "this_da_reseller_security_qna=C_DA_RESELLER_SECURITY_QNA${count_user}"
    typeset -n "this_da_reseller_db_accounts=C_DA_RESELLER_DB_ACCOUNT${count_user}"

    if [[ "${#this_da_reseller_uname}" -lt 2 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller username length is ${#this_da_reseller_uname} but the it should be more or equal to 2. Please check configuration file"
      _exit 147
    elif [[ "${#this_da_reseller_uname}" -gt ${C_DA_MAX_USERNAME_LENGTH} ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller username length is ${#this_da_reseller_uname} but the it should be less or equal to ${C_DA_MAX_USERNAME_LENGTH}. Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_reseller_password+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have password set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ "${#this_da_reseller_password}" -lt 6 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} has password set length of ${#this_da_reseller_password} but the minimum is 6 characters. Please check configuration file"
      _exit 147
    elif [[ "${#this_da_reseller_password}" -gt 64 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} has password set length of ${#this_da_reseller_password} but the maximum is 64 characters. Please check configuration file"
      _exit 147
    elif [[ "${this_da_reseller_password}" =~ ['&+'] ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} has password set with forbidden special characters [ &+ ] in config file. Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_reseller_name+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have name set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_reseller_system_email+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have system email set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_reseller_package_name+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have package name set in config file. Please check configuration file "
      _exit 147
    elif [[ -z "${this_da_reseller_mail_accounts+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have email account set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ -n "${this_da_reseller_mail_accounts}" && $(echo "${#this_da_reseller_mail_accounts[@]}") -ne $(awk -F'\|\|\|' '{print NF-1}' <<<"${this_da_reseller_mail_accounts[@]}") ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} has invalid email account format set in config file (invalid separator). Please check configuration file"
      _exit 147
      # Just use a normal variable to check (even it is array)
    elif [[ -z "${this_da_reseller_domains+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have domain set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_reseller_domains}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} must have at least one domain set in config file (domain is empty). Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_reseller_wildcard_domains+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have wildcard domain set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ -z "${this_c_da_reseller_ip_type+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have ip type set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_reseller_enable_domain_ssl+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have domain enable ssl set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_reseller_subdomains+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have subdomains set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ -n "${this_da_reseller_subdomains}" && $(awk -F':' '{print NF-1}' <<<"${this_da_reseller_subdomains[@]}") -ne ${#this_da_reseller_subdomains[@]} ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_user_uname} has invalid subdomains format set in config file (invalid separator). Please check configuration file "
      _exit 147
      # TODO check extra this_da_reseller_ssl_subdomains for format
    elif [[ -z "${this_da_reseller_ssl_subdomains+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have ssl subdomains set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_reseller_security_qna+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have security question and answer set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ -n "${this_da_reseller_security_qna}" && $(echo "${#this_da_reseller_security_qna[@]}") -ne $(awk -F'\|\|\|' '{print NF-1}' <<<"${this_da_reseller_security_qna[@]}") ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} has invalid security question and answer format set in config file (invalid separator). Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_reseller_db_accounts+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} doesn't have database account set in config file (missing or invalid variable). Please check configuration file "
      _exit 147
    elif [[ -n ${this_da_reseller_db_accounts} && $(echo "${#this_da_reseller_db_accounts[@]}") -ne $(awk -F'\|\|\|' '{print NF-1}' <<<"${this_da_reseller_db_accounts[@]}") ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning reseller ${this_da_reseller_uname} has invalid database account format set in config file (invalid separator). Please check configuration file"
      _exit 147
    else
      _echo "$(msg green)OK, all variables for reseller ${this_da_reseller_uname} are valid.$(msg end)" --name --verbose 7
      ((total_valid_user++))
    fi
    ((count_user++))
  done

  local this_da_user_uname this_da_user_password this_da_user_name this_da_user_system_email \
    this_da_user_package_name this_da_user_domains this_da_user_wildcard_domains this_da_user_subdomains \
    this_c_da_user_ip_type this_da_user_enable_domain_ssl this_da_user_ssl_subdomains this_da_user_mail_accounts \
    this_da_user_security_qna this_da_user_db_accounts

  count_user=1

  while [[ ${count_user} -le $(echo "${!C_DA_USER_USERNAME@}" | wc -w) ]]; do

    typeset -n "this_da_user_uname=C_DA_USER_USERNAME${count_user}"
    typeset -n "this_da_user_password=C_DA_USER_USERPASS${count_user}"
    typeset -n "this_da_user_name=C_DA_USER_NAME${count_user}"
    typeset -n "this_da_user_system_email=C_DA_USER_SYSTEM_EMAIL${count_user}"
    typeset -n "this_da_user_package_name=C_DA_USER_PACKAGE_NAME${count_user}"
    typeset -n "this_da_user_domains=C_DA_USER_DOMAIN${count_user}"
    typeset -n "this_da_user_wildcard_domains=C_DA_USER_WILDCARD_DOMAIN${count_user}"
    typeset -n "this_da_user_subdomains=C_DA_USER_SUBDOMAIN${count_user}"
    typeset -n "this_da_user_enable_domain_ssl=C_DA_USER_ENABLE_DOMAIN_SSL${count_user}"
    typeset -n "this_da_user_ssl_subdomains=C_DA_USER_SSL_SUBDOMAIN${count_user}"
    typeset -n "this_da_user_mail_accounts=C_DA_USER_MAIL_ACCOUNT${count_user}"
    typeset -n "this_da_user_security_qna=C_DA_USER_SECURITY_QNA${count_user}"
    typeset -n "this_da_user_db_accounts=C_DA_USER_DB_ACCOUNT${count_user}"

    if [[ "${#this_da_user_uname}" -lt 2 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user username length is ${#this_da_user_uname} but the it should be more or equal to 2. Please check configuration file"
      _exit 147
    elif [[ "${#this_da_user_uname}" -gt ${C_DA_MAX_USERNAME_LENGTH} ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user username length is ${#this_da_user_uname} but the it should be less or equal to ${C_DA_MAX_USERNAME_LENGTH}. Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_user_password+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have password set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ "${#this_da_user_password}" -lt 6 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} has password set length of ${#this_da_user_password} but the minimum is 6 characters. Please check configuration file"
      _exit 147
    elif [[ "${#this_da_user_password}" -gt 64 ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} has password set length of ${#this_da_user_password} but the maximum is 64 characters. Please check configuration file"
      _exit 147
    elif [[ "${this_da_user_password}" =~ ['&+'] ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} has password set with forbidden special characters [ &+ ] in config file. Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_user_name+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have name set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_user_system_email+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have system email set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_user_package_name+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have package name set in config file. Please check configuration file "
      _exit 147
    elif [[ -z "${this_da_user_mail_accounts+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have email account set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ -n "${this_da_user_mail_accounts}" && $(echo "${#this_da_user_mail_accounts[@]}") -ne $(awk -F'\|\|\|' '{print NF-1}' <<<"${this_da_user_mail_accounts[@]}") ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} has invalid email account format set in config file (invalid separator). Please check configuration file"
      _exit 147
      # Just use a normal variable to check (even it is array)
    elif [[ -z "${this_da_user_domains+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have domain set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_user_domains}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} must have at least one domain set in config file (domain is empty). Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_user_wildcard_domains+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have wildcard domain set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_user_enable_domain_ssl+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have domain enable ssl set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_user_subdomains+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have subdomains set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_user_subdomains}" && $(awk -F':' '{print NF-1}' <<<"${this_da_user_subdomains[@]}") -ne ${#this_da_user_subdomains[@]} ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} has invalid subdomains format set in config file (invalid separator). Please check configuration file "
      _exit 147
      # TODO check extra this_da_user_ssl_subdomains for format
    elif [[ -z "${this_da_user_ssl_subdomains+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have ssl subdomains set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_user_security_qna+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have security question and answer set in config file (missing or invalid variable). Please check configuration file"
      _exit 147
    elif [[ -n "${this_da_user_security_qna}" && $(echo "${#this_da_user_security_qna[@]}") -ne $(awk -F'\|\|\|' '{print NF-1}' <<<"${this_da_user_security_qna[@]}") ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} has invalid security question and answer format set in config file (invalid separator). Please check configuration file"
      _exit 147
    elif [[ -z "${this_da_user_db_accounts+x}" ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} doesn't have database account set in config file (missing or invalid variable). Please check configuration file "
      _exit 147
    elif [[ -n ${this_da_user_db_accounts} && $(echo "${#this_da_user_db_accounts[@]}") -ne $(awk -F'\|\|\|' '{print NF-1}' <<<"${this_da_user_db_accounts[@]}") ]]; then
      echo "[${SCRIPT_NAME}]: [Skipped]: Warning user ${this_da_user_uname} has invalid database account format set in config file (invalid separator). Please check configuration file"
      _exit 147
    else
      _echo "$(msg green)OK, all variables for user ${this_da_user_uname} are valid.$(msg end)" --name --verbose 7
      ((total_valid_user++))
    fi
    ((count_user++))
  done
  _echo "$(msg green)OK, total user with valid config is: ${total_valid_user}$(msg end)" --name --verbose 7
}

# This function gets the operating system ID and version number
# syntax: get_linux_os <id|version>
# eg: get_linux_os id | sample output: centos
get_linux_os() {
  local arg distro_id distro_version distro_codename
  arg="$1"
  # any new Linux distribution must have this (it is a standard file os checking for linux)
  if [ -e /etc/os-release ]; then
    # get the distro ID from /etc/os-release and make sure it is in lowercase format without any double quotations
    distro_id=$(awk -F= '$1 == "ID" {print $2}' /etc/os-release | LC_ALL=C tr '[:upper:]' '[:lower:]' | tr -d "\"")
    distro_version=$(awk -F= '$1 == "VERSION_ID" {print $2}' /etc/os-release | tr -d "\"")
    distro_codename=$(awk -F= '$1 == "VERSION_CODENAME" {print $2}' /etc/os-release | tr -d "\"")

  # but just in case (a small case) if it doesn't have this then we can use lsb_release command
  elif type lsb_release >/dev/null 2>&1; then
    # get the distro id using lsb_release function.
    # if the ID has uppercase letter, cover it to lowercase
    distro_id=$(lsb_release -si | LC_ALL=C tr '[:upper:]' '[:lower:]')
    distro_version=$(lsb_release -sr)
    distro_codename=$(lsb_release -sc)
  # else if that doesn't exist at all, we can use the standard checking version format: "Linux <version>"
  else
    # this will not printout a single distribution ID that we want (it prints out the Generic Linux kernel version)
    # but using this we should terminate this script because we only need single distribution ID (eg: debian)
    distro_id=$(uname -s)
    distro_version=$(uname -r)
    distro_codename=""
  fi
  # return values here with echo
  if [ "${arg}" == "id" ]; then
    echo "${distro_id}"
  elif [ "${arg}" == "version" ]; then
    echo "${distro_version}"
  elif [ "${arg}" == "codename" ]; then
    echo "${distro_codename}"
  fi

}

# This will install required component automatically if doesn't exist,
# It will do nothing if the component exist.
# eg:
#required "ubuntu@@apt:dos2unix,htop,nano+make:xxx,test,ok" \
#  "centos@@dnf:dos2unix,nano" "debian@@apt:dos2unix,htop"
#required "ubuntu@@apt:nano,htop,vim" \
#  "centos@@dnf:dos2unix,nano" "debian@@apt:dos2unix,htop,git,x"

required() {
  local required_cmds required_cmd detect_by dpkg_status distro_id distro_id_cmd install_commands install_method_commands install_method \
    install_packages missing_count install_success install_failed
  # Get the current distro ID from global variable DISTRO_ID
  distro_id="${DISTRO_ID}"
  # Get all the arguments passed for required() function and store in required_cmds
  required_cmds="$*"
  # Initialize these 3 variables to 0
  ((missing_count = install_success = install_failed = 0))
  # This variable holds the method to detect missing package, default value is unknown_method
  detect_by="unknown_method"
  # Loop through required_cmds
  for required_cmd in ${required_cmds[*]}; do
    # Get the distro_id value from the string before separator @@. eg: ubuntu
    distro_id_cmd=$(echo "${required_cmd}" | awk -F'@@' '{ print $1 }')
    # Condition if distro_id_cmd is ubuntu and it is the same value as current DISTRO_ID
    if [[ "${distro_id_cmd}" == "ubuntu" && "${distro_id_cmd}" == "${distro_id}" ]]; then
      # Get the string of install command after separator @@. eg: apt:htop,nano,git+make:suricata,dbxcli or dnf:dos2unix,nano+pip:linode-cli
      install_commands=$(echo "${required_cmd}" | awk -F'@@' '{ print $2 }')
      # Get the install method command and separate them by '+' symbol. eg: apt:htop,nano,git and make:suricata,dbxcli (separated)
      install_method_commands=$(echo "${install_commands}" | awk -F'+' '{for (i=1;i<=NF;i++)print $i}')
      # Loop through the separated installation method
      for install_method_command in ${install_method_commands[*]}; do
        # Get the install method. eg: dnf, make or pip
        install_method=$(echo "${install_method_command}" | awk -F':' '{ print $1 }')
        # Get the install packages listed as comma. eg: htop,nano,git or suricata,dbxcli
        install_packages=$(echo "${install_method_command}" | awk -F':' '{ print $2 }')
        # Condition if install_method is apt, then execute the apt method installation
        if [ "${install_method}" == "apt" ]; then
          # Get each of the installation package separated by ',' symbol. eg: htop,nano,git or dos2unix,nano
          install_package_commands=$(echo "${install_packages}" | awk -F',' '{for (i=1;i<=NF;i++)print $i}')
          # Loop through the installation package
          for install_package_command in ${install_package_commands[*]}; do
            # Find the status of the installation package whether it is installed or not
            dpkg_status=$(
              dpkg -s "${install_package_command}" 2>&1 | grep -qF "Status: install ok installed"
              echo $?
            )
            # If the package is not installed (return 1), then
            if [[ "${dpkg_status}" -eq 1 ]]; then
              # Add 1 to missing_count
              ((missing_count++))
              # This is for display purpose or filter for next version on how to detect missing package
              if [ "${dpkg_status}" -eq 1 ]; then
                detect_by="dpkg_status"
                # elif [ "${cmd_status}" = 1 ]; then
                #   detect_by="cmd_status"
                # elif [[ "${dpkg_status}" == 1 && "${cmd_status}" == 1 ]]; then
                #   detect_by="dpkg_status and cmd_status"
              fi

              # When the first missing package is triggered, then we display warning message, and for this first time, we trigger update command to refresh the expired cache
              if [ "${missing_count}" -eq 1 ]; then
                _echo "$(msg yellow)Warning, ${detect_by} detected one or more missing packages$(msg end)" --name
                echo ""
                _echo "$(msg cyan)Running ${install_method} update for the first missing package ...$(msg end)" --name
                apt-get -qq -y update
              fi

              _echo "$(msg cyan)${missing_count}) Installing $(msg magenta)${install_package_command}$(msg end) $(msg cyan)using ${install_method} method ...$(msg end)" --name
              echo ""
              apt-get -y install "${install_package_command}"
              retval=$?
              if [[ "${retval}" -eq 0 ]]; then
                ((install_success++))
              else
                ((install_failed++))
              fi

            fi

          done
        elif [ "${install_method}" == "make" ]; then
          echo "This installation method of make has not been implemented. Remove this from the syntax"
          _exit 147
          _echo "Installing using make ..."
          ((missing_count++))
          # for make find a way to detect installation (this is source installation)
          #make install command and return value retval;
          retval=1
          if [[ "${retval}" -eq 0 ]]; then
            ((install_success++))
          else
            ((install_failed++))
          fi
        else

          _echo "$(msg red)Error, invalid required installation method ${install_method} for ${distro_id_cmd}. Please check the required() syntax$(msg end)" --name
          _exit 147
        fi

      done

      if [ "${missing_count}" -gt 0 ]; then
        echo ""
        _echo "$(msg green)Total success installation: ${install_success} out of ${missing_count}$(msg end)" --name
        if [ "${install_failed}" -gt 0 ]; then
          _echo "$(msg red)Total failed installation: ${install_failed}$(msg end)" --name
        else
          :
          # _echo "Total failed installation: ${install_failed}"
        fi
        echo ""
      fi
    elif [[ "${distro_id_cmd}" == "debian" && "${distro_id_cmd}" == "${distro_id}" ]]; then
      # Get the string of install command after separator @@. eg: apt:htop,nano,git+make:suricata,dbxcli or dnf:dos2unix,nano+pip:linode-cli
      install_commands=$(echo "${required_cmd}" | awk -F'@@' '{ print $2 }')
      # Get the install method command and separate them by '+' symbol. eg: apt:htop,nano,git and make:suricata,dbxcli (separated)
      install_method_commands=$(echo "${install_commands}" | awk -F'+' '{for (i=1;i<=NF;i++)print $i}')
      # Loop through the separated installation method
      for install_method_command in ${install_method_commands[*]}; do
        # Get the install method. eg: dnf, make or pip
        install_method=$(echo "${install_method_command}" | awk -F':' '{ print $1 }')
        # Get the install packages listed as comma. eg: htop,nano,git or suricata,dbxcli
        install_packages=$(echo "${install_method_command}" | awk -F':' '{ print $2 }')
        # Condition if install_method is apt, then execute the apt method installation
        if [ "${install_method}" == "apt" ]; then
          # Get each of the installation package separated by ',' symbol. eg: htop,nano,git or dos2unix,nano
          install_package_commands=$(echo "${install_packages}" | awk -F',' '{for (i=1;i<=NF;i++)print $i}')
          # Loop through the installation package
          for install_package_command in ${install_package_commands[*]}; do
            # Find the status of the installation package whether it is installed or not
            dpkg_status=$(
              dpkg -s "${install_package_command}" 2>&1 | grep -qF "Status: install ok installed"
              echo $?
            )
            # If the package is not installed (return 1), then
            if [[ "${dpkg_status}" -eq 1 ]]; then
              # Add 1 to missing_count
              ((missing_count++))
              # This is for display purpose or filter for next version on how to detect missing package
              if [ "${dpkg_status}" -eq 1 ]; then
                detect_by="dpkg_status"
                # elif [ "${cmd_status}" = 1 ]; then
                #   detect_by="cmd_status"
                # elif [[ "${dpkg_status}" == 1 && "${cmd_status}" == 1 ]]; then
                #   detect_by="dpkg_status and cmd_status"
              fi

              # When the first missing package is triggered, then we display warning message, and for this first time, we trigger update command to refresh the expired cache
              if [ "${missing_count}" -eq 1 ]; then
                _echo "$(msg yellow)Warning, ${detect_by} detected one or more missing packages$(msg end)" --name
                echo ""
                _echo "$(msg cyan)Running ${install_method} update for the first missing package ...$(msg end)" --name
                apt-get -qq -y update
              fi

              _echo "$(msg cyan)${missing_count}) Installing $(msg magenta)${install_package_command}$(msg end) $(msg cyan)using ${install_method} method ...$(msg end)" --name
              echo ""
              apt-get -y install "${install_package_command}"
              retval=$?
              if [[ "${retval}" -eq 0 ]]; then
                ((install_success++))
              else
                ((install_failed++))
              fi

            fi

          done
        elif [ "${install_method}" == "make" ]; then
          echo "This installation method of make has not been implemented. Remove this from the syntax"
          _exit 147
          _echo "Installing using make ..."
          ((missing_count++))
          # for make find a way to detect installation (this is source installation)
          #make install command and return value retval;
          retval=1
          if [[ "${retval}" -eq 0 ]]; then
            ((install_success++))
          else
            ((install_failed++))
          fi
        else

          _echo "$(msg red)Error, invalid required installation method ${install_method} for ${distro_id_cmd}. Please check the required() syntax$(msg end)" --name
          _exit 147
        fi

      done

      if [ "${missing_count}" -gt 0 ]; then
        echo ""
        _echo "$(msg green)Total success installation: ${install_success} out of ${missing_count}$(msg end)" --name
        if [ "${install_failed}" -gt 0 ]; then
          _echo "$(msg red)Total failed installation: ${install_failed}$(msg end)" --name
        else
          :
          # _echo "Total failed installation: ${install_failed}"
        fi
        echo ""
      fi
    elif [[ "${distro_id_cmd}" == "centos" && "${distro_id_cmd}" == "${distro_id}" ]]; then
      # Get the string of install command after separator @@. eg: apt:htop,nano,git+make:suricata,dbxcli or dnf:dos2unix,nano+pip:linode-cli
      install_commands=$(echo "${required_cmd}" | awk -F'@@' '{ print $2 }')
      # Get the install method command and separate them by '+' symbol. eg: apt:htop,nano,git and make:suricata,dbxcli (separated)
      install_method_commands=$(echo "${install_commands}" | awk -F'+' '{for (i=1;i<=NF;i++)print $i}')
      # Loop through the separated installation method
      for install_method_command in ${install_method_commands[*]}; do
        # Get the install method. eg: dnf, make or pip
        install_method=$(echo "${install_method_command}" | awk -F':' '{ print $1 }')
        # Get the install packages listed as comma. eg: htop,nano,git or suricata,dbxcli
        install_packages=$(echo "${install_method_command}" | awk -F':' '{ print $2 }')
        # Condition if install_method is apt, then execute the apt method installation
        if [ "${install_method}" == "apt" ]; then
          # Get each of the installation package separated by ',' symbol. eg: htop,nano,git or dos2unix,nano
          install_package_commands=$(echo "${install_packages}" | awk -F',' '{for (i=1;i<=NF;i++)print $i}')
          # Loop through the installation package
          for install_package_command in ${install_package_commands[*]}; do
            # Find the status of the installation package whether it is installed or not
            dpkg_status=$(
              dpkg -s "${install_package_command}" 2>&1 | grep -qF "Status: install ok installed"
              echo $?
            )
            # If the package is not installed (return 1), then
            if [[ "${dpkg_status}" -eq 1 ]]; then
              # Add 1 to missing_count
              ((missing_count++))
              # This is for display purpose or filter for next version on how to detect missing package
              if [ "${dpkg_status}" -eq 1 ]; then
                detect_by="dpkg_status"
                # elif [ "${cmd_status}" = 1 ]; then
                #   detect_by="cmd_status"
                # elif [[ "${dpkg_status}" == 1 && "${cmd_status}" == 1 ]]; then
                #   detect_by="dpkg_status and cmd_status"
              fi

              # When the first missing package is triggered, then we display warning message, and for this first time, we trigger update command to refresh the expired cache
              if [ "${missing_count}" -eq 1 ]; then
                _echo "$(msg yellow)Warning, ${detect_by} detected one or more missing packages$(msg end)" --name
                echo ""
                _echo "$(msg cyan)Running ${install_method} update for the first missing package ...$(msg end)" --name
                dnf --quiet -y update
              fi

              _echo "$(msg cyan)${missing_count}) Installing $(msg magenta)${install_package_command}$(msg end) $(msg cyan)using ${install_method} method ...$(msg end)" --name
              echo ""
              dnf -y install "${install_package_command}"
              retval=$?
              if [[ "${retval}" -eq 0 ]]; then
                ((install_success++))
              else
                ((install_failed++))
              fi

            fi

          done
        elif [ "${install_method}" == "make" ]; then
          echo "This installation method of make has not been implemented. Remove this from the syntax"
          _exit 147
          _echo "Installing using make ..."
          ((missing_count++))
          # for make find a way to detect installation (this is source installation)
          #make install command and return value retval;
          retval=1
          if [[ "${retval}" -eq 0 ]]; then
            ((install_success++))
          else
            ((install_failed++))
          fi
        else

          _echo "$(msg red)Error, invalid required installation method ${install_method} for ${distro_id_cmd}. Please check the required() syntax$(msg end)" --name
          _exit 147
        fi

      done

      if [ "${missing_count}" -gt 0 ]; then
        echo ""
        _echo "$(msg green)Total success installation: ${install_success} out of ${missing_count}$(msg end)" --name
        if [ "${install_failed}" -gt 0 ]; then
          _echo "$(msg red)Total failed installation: ${install_failed}$(msg end)" --name
        else
          :
          # _echo "Total failed installation: ${install_failed}"
        fi
        echo ""
      fi
    else
      :
    fi
  done
}

# This is a random string that will return alphabet character (lower and uppercase)
# syntax: get_rnd_alpha <length>
# eg: get_rnd_alpha 10
get_rnd_alpha() {
  local length
  length="$1"
  tr -dc A-Za-z </dev/urandom | head -c "${length}"
  echo ''
}
# This function will transform a plain-text password into a hash encrypted password + salt generation which is more secure
# eg: test=$(get_hash_pwd "mypassword")
get_hash_pwd() {
  local password="$1" sha_pass
  sha_pass=$(mkpasswd -m sha-512 -S "$(pwgen -ns 16 1)" "$1")
  echo "${sha_pass}"
}

# This function contains string formatting for printing text into terminal (eg: use with echo, printf or my function _echo)
# echo "$(msg -c red)This is red$(msg -c end)"
# echo "$(msg -c red)$(msg -b yellow)This is red with yellow background$(msg end)"
# echo "This is default color but $(msg -c green)this is green$(msg end) and $(msg -m underline)this is underline$(msg end)
# For foreground color and mode, can omit both option -c (color) and -m (mode). For background need to specify -b (background) option
# eg: echo "$(msg bell)$(msg underline)This is $(msg red)$(msg -b yellow)red with yellow background and it is underlined and has bell sound!$(msg end)"
# Adding newline: echo "${msg newline 4}"
# Adding tab: echo "${msg tab 2}"
msg() {
  local mode="$1"
  shift
  # Set the foreground colour using ANSI escape
  # If first argument is color then use mode as color
  # Enable all cases matching for the following regular expression
  #shopt -s nocasematch
  if [[ "${mode^^}" == +(BLACK|RED|GREEN|YELLOW|BLUE|MAGENTA|CYAN) ]]; then
    if ! [[ ${mode} =~ ^[0-9]$ ]]; then
      case $(echo "${mode}" | tr '[:upper:]' '[:lower:]') in
      black) mode=0 ;;
      red) mode=1 ;;
      green) mode=2 ;;
      yellow) mode=3 ;;
      blue) mode=4 ;;
      magenta) mode=5 ;;
      cyan) mode=6 ;;
      end)
        tput sgr0
        return 0
        ;;
      white | *) mode=7 ;; # white or invalid color
      esac
    fi
    tput setaf ${mode}
    # Turn off all cases matching
    #shopt -u nocasematch
  elif [[ "${mode}" == "newline" || "${mode}" == "line" ]]; then
    local count=$1 str=""
    if [[ -z "${count}" || "${count}" -eq 0 || "${count}" -eq 1 ]]; then
      return 0
    fi
    for ((i = 1; i <= count - 1; i++)); do
      str="${str}\n"
    done
    if [ "$$" -eq "${BASHPID}" ]; then
      for ((i = 1; i <= count - 2; i++)); do
        str="${str}\n"
      done
      echo -e "${str}"
    else
      for ((i = 1; i <= count - 1; i++)); do
        str="${str}\n"
      done
      # Using -e option here will not work if call inside string such as echo.
      echo "${str}"
    fi
  elif [[ "${mode}" == "newtab" || "${mode}" == "tab" ]]; then
    local count=$1 str=""
    if [[ -z "${count}" || "${count}" -eq 0 || "${count}" -eq 1 ]]; then
      return 0
    fi

    if [ "$$" -eq "${BASHPID}" ]; then
      for ((i = 1; i <= count - 2; i++)); do
        str="${str}\t"
      done
      echo -e "${str}"
    else
      for ((i = 1; i <= count - 1; i++)); do
        str="${str}\t"
      done
      # Using -e option here will not work if call inside string such as echo.
      echo "${str}"
    fi
  elif [[ "${mode}" == "-c" || "${mode}" == "-f" || "${mode}" == "--color" || "${mode}" == "--foreground" ]]; then
    local color=$1
    if ! [[ $color =~ ^[0-9]$ ]]; then
      case $(echo "${color}" | tr '[:upper:]' '[:lower:]') in
      black) color=0 ;;
      red) color=1 ;;
      green) color=2 ;;
      yellow) color=3 ;;
      blue) color=4 ;;
      magenta) color=5 ;;
      cyan) color=6 ;;
      end)
        tput sgr0
        return 0
        ;;
      white | *) color=7 ;; # white or invalid color
      esac
    fi
    tput setaf ${color}
  # Set the background colour using ANSI escape
  elif [[ "${mode}" == "-b" || "${mode}" == "--background" ]]; then
    local color=$1
    if ! [[ $color =~ ^[0-9]$ ]]; then

      case $(echo "${color}" | tr '[:upper:]' '[:lower:]') in
      black) color=0 ;;
      red) color=1 ;;
      green) color=2 ;;
      yellow) color=3 ;;
      blue) color=4 ;;
      magenta) color=5 ;;
      cyan) color=6 ;;
      end)
        tput sgr0
        return 0
        ;;
      white | *) color=7 ;; # white or invalid color
      esac
    fi
    tput setab ${color}

  elif [[ ${mode} == +(bold|dim|invi|blink|reverse|uline|underline|xuline|focus|standout|xfocus|bell|alert|clr|end) ]]; then
    case $(echo "${mode}" | tr '[:upper:]' '[:lower:]') in
    bold) mode="bold" ;;
    dim) mode="dim" ;;
    invi) mode="invis" ;;
    blink) mode="blink" ;;
    reverse) mode="rev" ;;
    uline | underline) mode="smul" ;;
    xuline) mode="rmul" ;;
    focus | standout) mode="smso" ;;
    xfocus) mode="rmso" ;;
    bell | alert) mode="bel" ;;
    clr | end) mode="sgr0" ;;
    *)
      echo "Error, invalid argument supplied for mode: ${mode}!"
      exit 1
      ;;
    esac
    tput "${mode}"
    shopt -u nocasematch
  # Note: Not all modes work for every terminal especially, bold, dim, invi, blink
  elif [[ "${mode}" == "-m" || "${mode}" == "--mode" ]]; then
    local mode=$1
    case $(echo "${mode}" | tr '[:upper:]' '[:lower:]') in
    bold) mode="bold" ;;
    dim) mode="dim" ;;
    invi) mode="invis" ;;
    blink) mode="blink" ;;
    reverse) mode="rev" ;;
    uline | underline) mode="smul" ;;
    xuline) mode="rmul" ;;
    focus | standout) mode="smso" ;;
    xfocus) mode="rmso" ;;
    bell | alert) mode="bel" ;;
    clr | end) mode="sgr0" ;;
    *)
      echo "Error, invalid argument supplied for mode: ${mode}!"
      exit 1
      ;;
    esac

    tput "${mode}"
  elif [[ "${mode}" == "-x" || "${mode}" == "x" || "${mode}" == "end" ]]; then
    tput sgr0
  fi
}

# This function display the current time spent for running this script.
# It uses the built-in bash SECONDS to get the real execution statement
script_time() {
  local spent_secs hrs mins secs
  spent_secs=${SECONDS}
  hrs=$((spent_secs / 3600))
  mins=$(((spent_secs - hrs * 3600) / 60))
  secs=$((spent_secs - hrs * 3600 - mins * 60))
  printf "[${SCRIPT_NAME}]: Time spent for total script execution: %02d H:%02d M :%02d S\n" ${hrs} ${mins} ${secs}
}

# This function convert seconds to time in format d h m s
show_time() {
  local num=$1
  local min=0
  local hour=0
  local day=0
  if ((num > 59)); then
    ((sec = num % 60))
    ((num = num / 60))
    if ((num > 59)); then
      ((min = num % 60))
      ((num = num / 60))
      if ((num > 23)); then
        ((hour = num % 24))
        ((day = num / 24))
      else
        ((hour = num))
      fi
    else
      ((min = num))
    fi
  else
    ((sec = num))
  fi
  echo "${day}"d "${hour}"h "${min}"m "${sec}"s
}

# This function display the execution time for a script individually
# Syntax exec_time <start/total> <optional_unique_variable>
# To start tracking use: exec_time start "da_installation"
# To get the global current total runtime from the start: exec_time total or exec_time end
# To get the total runtime for specific variable use: exec_time() total "da_installation"
# To reset total running time, run again exec_time start <optional_unique_variable>
# Note: When this script runs for the first time, the global variable EXEC_START is calculated as current timestamp. So, no need to call exec_time start for the first time
exec_time() {
  local option runtime days hours minutes seconds title
  required "debian@@apt:bc"
  option=$1
  title=$2
  if [ "${option}" == "start" ]; then
    # Reset starting execution time as the current date
    if [ -n "${title}" ]; then
      # Use verbose 7 (debug) because this time tracking only useful during debugging
      _echo "Tracking execution time for $(msg red)[${title}]$(msg end) ..." --name --verbose 7
      variable_api create-variable --name "${title}" --value "$(date +%s.%N)"
    else
      EXEC_START=$(date +%s.%N)
      _echo "Tracking global execution time ..." --name --verbose 7
    fi
  elif [[ "${option}" == "total" || "${option}" == "end" ]]; then
    if [ -n "${title}" ]; then
      runtime=$(echo "$(date +%s.%N) - $(variable_api get-variable-value --name "${title}")" | bc -l)
    else
      runtime=$(echo "$(date +%s.%N) - ${EXEC_START}" | bc -l)
    fi
    # Test runtime
    #runtime=$(date --date='Sun Jun 20 17:07:39 2021' +"%s")
    #end=$(date +%s.%N)
    #runtime=$(echo "$end - $start" | bc)
    days=$(echo "${runtime}/86400" | bc)
    #rt2=$(echo "${runtime}-86400*${days}" | bc)
    hours=$(echo "$(echo "${runtime}-86400*${days}" | bc)/3600" | bc)
    #rt3=$(echo "$(echo "${runtime}-86400*${days}" | bc)-3600*$hours" | bc)
    minutes=$(echo "$(echo "$(echo "${runtime}-86400*${days}" | bc)-3600*${hours}" | bc)/60" | bc)
    seconds=$(echo "$(echo "$(echo "${runtime}-86400*${days}" | bc)-3600*${hours}" | bc)-60*${minutes}" | bc)
    #_echo blue "Total execution time: ${runtime} seconds"
    if [ -n "${title}" ]; then
      #_echo blue "Total runtime executed for ${title} was: "
      _echo "$(printf "Total runtime executed for $(msg red)[%s]$(msg end) was: %dd:%02dh:%02dm:%02.4fs\n" "${title}" "${days}" "${hours}" "${minutes}" "${seconds}")" --name --verbose 7
    else
      #_echo blue "Total runtime executed was: "
      _echo "$(printf "Total global runtime executed was: %dd:%02dh:%02dm:%02.4fs\n" "${days}" "${hours}" "${minutes}" "${seconds}")" --name --verbose 7
    fi
    #_echo blue "$(printf "Total runtime executed for %s was: %dd:%02dh:%02dm:%02.4fs\n" "${title}" "${days}" "${hours}" "${minutes}" "${seconds}")"

  else
    _echo "Warning, invalid option specified for exec_time() function!" --name --verbose 4
    return 1
  fi
}

check_path() {
  local paths
  paths="$*"
  for path in ${paths}; do
    if [ -f "${path}" ]; then
      echo "[${SCRIPT_NAME}]: $(msg green)OK, the file path [ ${path} ] exists$(msg end)"
    elif [ -d "${path}" ]; then
      echo "[${SCRIPT_NAME}]: $(msg green)OK, the directory path [ ${path} ] exists$(msg end)"
    elif [ -L "${path}" ]; then
      echo "[${SCRIPT_NAME}]: $(msg green)OK, the symlink path [ ${path} ] exists$(msg end)"
    elif [ -S "${path}" ]; then
      echo "[${SCRIPT_NAME}]: $(msg green)OK, the socket path [ ${path} ] exists$(msg end)"
    else
      echo "[${SCRIPT_NAME}]: $(msg red)Error, the path [ ${path} ] does not exist!$(msg end)"
      exit 1
    fi
  done
}

# This function will shift the current directory into another directory specified in argument
# it will terminate with return error code 1 if the specified path in argument given is not valid
# Usage: navigate_path <valid_path>
# or : navigate_path "pre" - to return to previous path after executing the previous navigate_path <valid_path>
navigate_path() {
  local to_path="$1"
  # PREPATH holds a previous path (see global variable of PREPATH in this script)
  if [[ "${to_path^^}" == "PRE" || "${to_path^^}" == "PREVIOUS" || "${to_path^^}" == "PREPATH" || "${to_path^^}" == "BACK" || "${to_path^^}" == "OLDPATH" || "${to_path^^}" == "OLDPWD" ]]; then
    to_path="${PREPATH}"
  else
    PREPATH="${PWD}"
  fi
  echo "[${SCRIPT_NAME}]: Entering directory ${to_path} ..."
  cd "${to_path}" || {
    echo "Failed to enter into directory ${to_path}"
    _exit 147
  }
}

# Store long file text creation in function to avoid duplication
# create_file "ssh-push-scripts"
# create_file <create_action> <optional_path>
create_file() {
  local create_actions path
  # Enable multiple create call. For eg: create_action "create1 create2 create3"
  create_actions="$1"
  path="$2"
  #create_file setup-readme

  for create_action in ${create_actions}; do

    if [[ "${create_action}" == "os-initialize" || "${create_action}" == "os_initialize" ]]; then
      {
        echo "#!/bin/bash"
        echo "# ==============================================="
        echo "# This script file was automatically generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# This is just a test script for os-initialize"
        echo "touch test_file1"
        echo "echo \"This is just a test file\" > test_file"
        echo "echo \"If you can read this, it means the test_script.sh script was running perfectly\" >> test_file"
        echo "# Put 2 times exit below to safely exit the script if the first exit is not executed"
        echo "exit"
        echo "exit"
      } >"${path}"
    # create_file "sensitive_label_hide" "${CONF_PATH}/sensitive_label"
    # create_file "sensitive_label_show" "${CONF_PATH}/sensitive_label"
    elif [[ "${create_action}" == "sensitive-label-hide" || "${create_action}" == "sensitive_label_hide" ]]; then
      {
        echo "# ==============================================="
        echo "# This sensitive_label file was automatically generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# This is the sensitive variable that hides its own value:"
        echo ""
      } >"${CONF_PATH}/sensitive_label"
      grep -E '^[A-Za-z0-9_].+=.+$' "${CONFIG_FILE}" | awk -F'=' '{ print "LABEL_"$1"=\""$1"\""}' >>"${CONF_PATH}/sensitive_label"
    elif [[ "${create_action}" == "sensitive-label-show" || "${create_action}" == "sensitive_label_show" ]]; then
      {
        echo "# ==============================================="
        echo "# This sensitive_label file was automatically generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# This is the sensitive variable that shows its value from config file:"
        echo ""
      } >"${CONF_PATH}/sensitive_label"
      grep -E '^[A-Za-z0-9_].+=.+$' "${CONFIG_FILE}" | awk -F'=' '{ print "LABEL_"$1"=\"${"$1"}\""}' >>"${CONF_PATH}/sensitive_label"
    elif [[ "${create_action}" == "setup-readme" ]]; then
      {
        echo "# ==============================================="
        echo "# This readme file was automatically generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# This is the remote setup readme file:"
        echo "Please make sure that the execution remote environment at ${SCRIPT_PATH}/execution_env contains remote flag before running setup action"
        echo "Run installation with log output: ./${SCRIPT_NAME} setup 2>&1 | tee ${SCRIPT_NAME}.log"
        echo "Run installation with log output: ./${SCRIPT_NAME} setup --installation-type directadmin 2>&1 | tee ${SCRIPT_NAME}.log"
      } >"${SCRIPT_PATH}/readme.txt"
    # Remember all push scripts need to have return 0 at the end so that we can terminate the SSH from local call
    elif [[ ${create_action} == "ssh-push-scripts" ]]; then
      ssh_scripts_path="${CODE_PATH}/ssh_scripts"
      mkdir -p "${ssh_scripts_path}"

      #test_script.sh
      {
        echo "#!/bin/bash"
        echo "# ==============================================="
        echo "# This script file was automatically generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# This is just a test script"
        echo "touch test_file"
        echo "echo \"This is just a test file\" > test_file"
        echo "echo \"If you can read this, it means the test_script.sh script was running perfectly\" >> test_file"
        echo "# Put 2 times exit below to safely exit the script if the first exit is not executed"
        echo "exit"
        echo "exit"
      } >"${ssh_scripts_path}/test_script.sh"
      chmod +x "${ssh_scripts_path}/test_script.sh"
      # reboot_command.sh
      {
        echo "#!/bin/bash"
        echo "# ==============================================="
        echo "# This script file was automatically generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# Using --force to ignore any prompts when rebooting. Such as the prompt to eject DISK and waiting for user input"
        echo "reboot --force"
        echo "# Put 2 times exit below to safely exit the script if the first exit is not executed"
        echo "exit"
        echo "exit"
      } >"${ssh_scripts_path}/reboot_command.sh"
      chmod +x "${ssh_scripts_path}/reboot_command.sh"
      # shutdown_command.sh
      {
        echo "#!/bin/bash"
        echo "# ==============================================="
        echo "# This script file was automatically generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# Using --force to ignore any prompts when shutting down. Such as the prompt to eject DISK and waiting for user input"
        echo "reboot --poweroff --force"
        echo "# Put 2 times exit below to safely exit the script if the first exit is not executed"
        echo "exit"
        echo "exit"
      } >"${ssh_scripts_path}/shutdown_command.sh"
      chmod +x "${ssh_scripts_path}/shutdown_command.sh"
      #maxinet_setup.sh
      {
        echo "#!/bin/bash"
        echo "# ==============================================="
        echo "# This script file was automatically generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# Using setup will trigger setup script from ${SCRIPT_NAME}"
        echo "cd /root || exit 1"
        echo "chmod +x maxinet"
        echo "touch maxinet.log"
        echo "./maxinet setup 2>&1 | tee maxinet.log"
        echo "# Put 2 times exit below to safely exit the script if the first exit is not executed"
        echo "return 0"
        echo "return 0"
      } >"${ssh_scripts_path}/maxinet_setup.sh"
      chmod +x "${ssh_scripts_path}/maxinet_setup.sh"
    # SSH banner
    elif [[ ${create_action} == "ssh-banner1" || ${create_action} == "ssh_banner1" ]]; then
      {
        echo "Legal Authentication Banner:"
        echo "---------------------------"
        echo "=~=~=~=~=~=~=~=~=~=~=~=~=~00000~=~=~=~=~=~=~=~=~+~=~=~=~=~+~="
        echo "Welcome to ${C_COMPANY_ID^} CH. This is the ${C_BOX_HOSTNAME^^} Server"
        echo "The ${C_BOX_HOSTNAME^^} consists of ENERGY where it has been created"
        echo "perfectly with a certain EQUATIONS from NOTHING. Human"
        echo "beings have changed the original EQUATIONS to their own"
        echo "EQUATIONS. The ENERGY consists of TIME where TIME is MONEY"
        echo "and MONEY is part of the RESOURCES. If you need SOMETHING,"
        echo "the most ethical way in the world of humanity is asking"
        echo "for SOMETHING instead of manipulating the RESOURCES."
        echo "Disconnect now if you are not one of the team at Sofibox"
        echo "=~=~=~=~=~=~=~=~=~=~=~=~=~00000~=~=~=~=~=~=~=~=~+~=~=~=~=~+~="
        echo "Do not waste your RESOURCES for NOTHING - MaXi32, 2001"
        echo "=============== We turned on 1 LiGHT DaRK =============="
        echo ""
        echo "SECURE TAG: access, legal, law, connect, enforce, system"
      } >"${path}"

    elif [[ ${create_action} == "debian-preseed" ]]; then

      required "debian@@apt:whois,pwgen" "ubuntu@@apt:whois,pwgen"
      touch "${path}"

      {
        # 1 Good reading: https://serverfault.com/questions/893483/what-means-3-numbers-in-manual-partitioning-of-hdd-in-preseed-for-ubuntu
        # 2 Useful setting for SSH: https://github.com/coreprocess/linux-unattended-installation/blob/master/ubuntu/20.04/custom/preseed.cfg
        # 3 This one contains setting for CD rom not in new documentation: https://images.validation.linaro.org/kvm/debian-8.3.0-cd1-preseed.cfg
        echo "# ==============================================="
        echo "# This debian configuration file was generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# Warning, this preseed configuration file contains sensitive information about a server. Do not share this file to public"
        echo "# ==============================================="
        if [ "${C_OS_SET_CODE_NAME}" == "buster" ]; then
          echo "#### Preseed preconfiguration file (for Debian buster)"
        elif [ "${C_OS_SET_CODE_NAME}" == "bullseye" ]; then
          echo "#### Preseed preconfiguration file (for Debian bullseye)"
        fi
        echo "### Partman early command"

        #echo "d-i partman/early_command \\"
        #echo "string sed -i.bak 's/-f \$id\/skip_erase/-d \$id/g' /lib/partman/lib/crypto-base.sh"

        echo "### Kernel parameter"
        echo "d-i debian-installer/add-kernel-opts string net.ifnames=0 biosdevname=0 console=ttyS0,19200n8"
        echo "### Localization"
        #echo "Test: Fixing no common CDROM on linode:"
        #=============================================
        #https://lists.debian.org/debian-boot/2011/01/msg00169.html
        #https://github.com/uweplonus/adia-install/blob/master/initrd/preseed.cfg#L3
        #https://serverfault.com/questions/685302/unattended-installation-of-ubuntu-from-usb-drive-not-mounted-correctly
        #echo "d-i partman/early_command string mount /dev/sdb /cdrom"
        #echo "d-i preseed/early_command string mount /dev/sdb /cdrom"
        #echo "d-i cdrom-detect/cdrom_device string /dev/sdb"
        #echo "d-i preseed/early_command string \\"
        #echo "umount /cdrom; \\"1
        #echo "mkdir -p /cdrom; \\"
        #echo "mount -t vfat /dev/sdb /cdrom;"
        # All above fixes are not working (left it as reference) because this ISO installer doesn't support booting from hard drive. Need to follow this:
        # https://www.debian.org/releases/buster/amd64/ch04s04.en.html (BOOTING WITH GRUB OR LILO)
        #================================================
        echo "d-i debian-installer/locale string ${C_BOX_LOCALE}"
        echo "d-i debian-installer/language string ${C_BOX_LANGUAGE_CODE}"
        echo "d-i debian-installer/country string ${C_BOX_COUNTRY_CODE}"
        echo ""
        echo "### Keyboard selection"
        echo "d-i keyboard-configuration/xkb-keymap select ${C_BOX_KEYBOARD}"
        echo ""
        echo "###  Network configuration"
        # This one has many bug reported in Debian forum, need to put in kernel parameter: netcfg/choose_interface eth0 (if not working)
        echo "d-i netcfg/choose_interface select eth0"
        echo "d-i netcfg/use_dhcp string false"
        # If I disable autoconfig, I will get mirror error if network is not configured correctly
        # Actually no need to set IP4 and IPv6 because I use late command is better.
        echo "d-i netcfg/disable_autoconfig boolean true"
        echo "d-i netcfg/dhcp_failed note"
        echo "d-i netcfg/dhcp_options select Configure network manually"
        echo "# IPv4 Static network configuration"
        echo "d-i netcfg/get_ipaddress string ${C_IPV4_ADD0}"
        echo "d-i netcfg/get_netmask string ${C_IPV4_NETMASK_IP0}"
        echo "d-i netcfg/get_gateway string ${C_IPV4_DEF_GATEWAY0}"
        echo "d-i netcfg/get_nameservers string ${C_NAME_SERVER1}"
        echo "d-i netcfg/confirm_static boolean true"
        echo ""
        # IPv6 will be set using late command below
        #echo "# IPv6 Static network configuration"
        #echo "d-i netcfg/get_ipaddress string ${C_IPV6_ADD0}"
        #echo "d-i netcfg/get_netmask string ${C_IPV6_NETMASK0}"
        #echo "d-i netcfg/get_gateway string ${C_IPV6_DEF_GATEWAY0}"
        #echo "d-i netcfg/get_nameservers string ${C_NAME_SERVER1}"
        #echo "d-i netcfg/confirm_static boolean true"
        #echo ""
        echo "# Set a hostname"
        echo "d-i netcfg/get_hostname string ${C_BOX_HOSTNAME}"
        echo "d-i netcfg/get_domain string ${C_BOX_DOMAIN}"
        echo "# Force a hostname"
        echo "d-i netcfg/hostname string ${C_BOX_HOSTNAME_FQHN}"
        echo "# Disable that annoying WEP key dialog"
        echo "d-i netcfg/wireless_wep string"
        echo ""
        echo "### Mirror settings"
        echo "d-i mirror/country string manual"
        echo "d-i mirror/http/hostname string deb.debian.org"
        echo "d-i mirror/http/directory string /debian"
        echo "d-i mirror/http/proxy string"
        echo ""
        echo "### Account setup"
        echo "# Skip creation of a normal user account"
        echo "d-i passwd/make-user boolean false"

        echo "# Set root password"
        #echo "d-i passwd/root-password password ${C_INITIAL_ROOT_PASSWORD}"
        #echo "d-i passwd/root-password-again password ${C_INITIAL_ROOT_PASSWORD}"
        echo "# or encrypted using a crypt(3)  hash."
        # Using the secured get_hash_pwd to encrypt root password
        echo "d-i passwd/root-password-crypted password $(get_hash_pwd "${C_INITIAL_ROOT_PASSWORD}")"
        echo ""
        echo "### Clock and time zone setup"
        echo "# Set hardware clock to UTC"
        echo "d-i clock-setup/utc boolean true"
        echo "# Set timezone"
        echo "d-i time/zone string ${C_BOX_TIMEZONE}"
        echo "# Use NTP clock during installation"
        echo "d-i clock-setup/ntp boolean true"
        echo ""
        echo "### Partitioning"
        # This is for normal disk method (not LUKS)
        # Good reading :https://gist.github.com/chuckn246/ca24d26c048b3cc4ffa8188708f5dccf
        # Another good one: https://www.linuxjournal.com/content/preseeding-full-disk-encryption (it has a way to disable wipe disk)
        # Very nice info: https://secopsmonkey.com/custom-partioning-using-preseed.html
        # Useful maybe https://github.com/uweplonus/adia-install/blob/master/initrd/preseed.cfg#L3
        # Updated very nice: https://gist.github.com/chuckn246/ca24d26c048b3cc4ffa8188708f5dccf
      } >>"${path}"
      if [[ "${C_DISK_ENCRYPTION}" == "true" ]]; then
        {
          # This is the section to create a custom LUKS partition here
          echo "# LVM LUKS method"

          #echo "# method to use: regular, lvm or crypto"
          echo "d-i partman-auto/method string crypto"

          #echo "# remove existing LVM"
          echo "d-i partman-lvm/device_remove_lvm boolean true"
          #echo "# remove existing RAID"
          echo "d-i partman-md/device_remove_md boolean true"

          #echo "# Confirm to write LVM partition"
          echo "d-i partman-lvm/confirm boolean true"
          #echo "# amount space to use with LVM"
          echo "d-i partman-auto-lvm/guided_size string max"
          echo "d-i partman-auto-lvm/new_vg_name string ${C_LVM_GROUP_NAME}"
          #echo "#select root disk to use"
          echo "d-i partman-auto/disk string ${C_BOX_MAIN_DISK}"

          echo "d-i partman-auto/choose_recipe select boot-crypto"
          echo "d-i partman-lvm/confirm_nooverwrite boolean true"

          echo "d-i partman-crypto/passphrase string ${C_LUKS_PASS}"
          echo "d-i partman-crypto/passphrase-again string ${C_LUKS_PASS}"
          echo "d-i partman-crypto/weak_passphrase boolean true"
          echo "d-i partman-crypto/confirm boolean true"
          echo "# When disk encryption is enabled, skip wiping the partitions beforehand."
          echo "d-i partman-auto-crypto/erase_disks boolean false"

          echo "d-i partman-auto/expert_recipe string \\"
          echo "boot-crypto :: \\"
          echo "  ${C_BOX_BOOT_SIZE} ${C_BOX_BOOT_SIZE} ${C_BOX_BOOT_SIZE} ext4 \\"
          echo "          \$primary{ } \$bootable{ } \\"
          echo "          method{ format } format{ } \\"
          echo "          use_filesystem{ } filesystem{ ext4 } \\"
          echo "          mountpoint{ /boot } \\"
          echo "          label{ boot } \\"
          echo "  . \\"
          echo "  ${C_BOX_ROOT_SIZE} ${C_BOX_ROOT_SIZE} ${C_BOX_ROOT_SIZE}  ext4 \\"
          echo "          \$lvmok{ } lv_name{ root } \\"
          echo "          in_vg { ${C_LVM_GROUP_NAME} } \\"
          #echo "          \$primary{ } \\"
          echo "          method{ format } format{ } \\"
          echo "          use_filesystem{ } filesystem{ ext4 } \\"
          echo "          mountpoint{ / } \\"
          echo "          label{ root } \\"
          echo "  . \\"
          echo "  ${C_BOX_TMP_SIZE} ${C_BOX_TMP_SIZE} ${C_BOX_TMP_SIZE} ext4 \\"
          echo "          \$lvmok{ } lv_name{ tmp } \\"
          echo "          in_vg { ${C_LVM_GROUP_NAME} } \\"
          #echo "          \$primary{ } \\"
          echo "          method{ format } format{ } \\"
          echo "          use_filesystem{ } filesystem{ ext4 } \\"
          echo "          mountpoint{ /tmp } \\"
          echo "          options/nosuid{ nosuid } \\"
          echo "          options/noexec{ noexec } \\"
          echo "          label{ tmp } \\"
          echo "  . \\"
          echo "  ${C_BOX_SWAP_SIZE} ${C_BOX_SWAP_SIZE} ${C_BOX_SWAP_SIZE} linux-swap \\"
          echo "          \$lvmok{ } lv_name{ swap } \\"
          echo "          in_vg { ${C_LVM_GROUP_NAME} } \\"
          #echo "          \$primary{ } \\"
          echo "          method{ swap } format{ } \\"
          echo "          label{ swap } \\"
          echo "  . \\"
          # The rest of the space
          echo "  40960 61440 ${C_BOX_HOME_SIZE} ext4 \\"
          echo "          \$lvmok{ } lv_name{ home } \\"
          echo "          in_vg { ${C_LVM_GROUP_NAME} } \\"
          #echo "          \$primary{ } \\"
          echo "          method{ format } format{ } \\"
          echo "          use_filesystem{ } filesystem{ ext4 } \\"
          echo "          mountpoint{ /home } \\"
          echo "          options/nosuid{ nosuid } \\"
          echo "          label{ home } \\"
          echo "  ."
        } >>"${path}"

      else
        {
          echo "# Normal partition method"
          echo "d-i partman-auto/disk string ${C_BOX_MAIN_DISK}"
          echo "d-i partman-auto/method string lvm"
          echo "d-i partman-auto-lvm/guided_size string max"
          echo "d-i partman-lvm/device_remove_lvm boolean true"
          echo "d-i partman-md/device_remove_md boolean true"
          echo "d-i partman-lvm/confirm boolean true"
          echo "d-i partman-lvm/confirm_nooverwrite boolean true"
          echo "d-i partman-auto/choose_recipe select atomic"
          echo "d-i partman-partitioning/confirm_write_new_label boolean true"
          echo "d-i partman/choose_partition select finish"
          echo "d-i partman/confirm boolean true"
          echo "d-i partman/confirm_nooverwrite boolean true"
          echo "d-i partman-md/confirm boolean true"
          echo "d-i partman-partitioning/confirm_write_new_label boolean true"
          echo "d-i partman/choose_partition select finish"
          echo "d-i partman/confirm boolean true"
          echo "d-i partman/confirm_nooverwrite boolean true"
        } >>"${path}"

      fi
      {
        echo "d-i partman-basicfilesystems/no_mount_point boolean false"
        echo "d-i partman-partitioning/confirm_write_new_label boolean true"
        echo "d-i partman/choose_partition select finish"
        echo "d-i partman/confirm boolean true"
        echo "d-i partman/confirm_nooverwrite boolean true"

        echo ""
        echo "### Apt setup"
        # Disable mirror will cause problem with software selection
        #echo "#d-i apt-setup/use_mirror boolean false"
        echo "d-i apt-setup/cdrom/set-first boolean false"
        echo "d-i apt-setup/cdrom/set-next boolean false"
        echo "d-i apt-setup/cdrom/set-failed boolean false"
        echo "d-i apt-setup/services-select multiselect security, updates"
        echo "d-i apt-setup/security_host string security.debian.org"
        #echo ""
        echo "### Package selection"
        echo "tasksel tasksel/first multiselect standard"
        echo "# Individual additional packages to install"
        echo "d-i pkgsel/include string openssh-server"
        echo "popularity-contest popularity-contest/participate boolean false"
        echo ""
        echo "### Boot loader installation"
        echo "# Grub location"
        echo "d-i grub-installer/only_debian boolean true"
        echo "d-i grub-installer/with_other_os boolean true"
        echo "d-i grub-installer/bootdev string ${C_BOX_MAIN_DISK}"
        echo ""
        echo "# Grub password"
        echo "#d-i grub-installer/password password r00tme"
        echo "#d-i grub-installer/password-again password r00tme"
        echo "# or encrypted using an MD5 hash, see grub-md5-crypt(8)."
        echo "#d-i grub-installer/password-crypted password [MD5 hash]"
        echo ""
        echo "### Finishing up the installation"
        echo "# Avoid that last message about the install being complete."
        echo "# This will skip the dialog box after installation finished"
        echo "d-i finish-install/reboot_in_progress note"
        echo "# This will shutdown after install"
        # Make sure to disable linode shutdown watchdog to turn off linode after installed else it will auto boot:
        echo "d-i debian-installer/exit/poweroff boolean true"
        # At this point, I can use API to determine if the system s shut down, then it means installation is finished.
        # Then if the port 893 is available I can use that port to login.
        # Good reading for executing script or store: https://github.com/uweplonus/adia-install/blob/master/initrd/preseed.cfg#L3
        echo "### Execute final scripts "
        # To install other package using late_command
        # new line separated by \
        echo "d-i preseed/late_command string \\"
        echo "in-target apt-get -y install htop wget git dropbear-initramfs resolvconf; \\"
        # For modifying fstab

        # Allow root login
        # For encryption https://stackoverflow.com/questions/33113363/debian-preseed-late-command-not-executed
        # Another tip: https://askubuntu.com/questions/364051/how-do-you-preseed-an-ssh-key
        # UNLOCK LUKS doc here: https://www.cyberciti.biz/security/how-to-unlock-luks-using-dropbear-ssh-keys-remotely-in-linux/
        #echo "in-target cp /cdrom/configure_box.sh /usr/local/bin/ ;\\"
        #echo "in-target chmod +x /usr/local/bin/configure.sh ;\\"
        #echo "in-target /usr/local/bin/configure_box.sh; \\"
        echo "mkdir -p /target/root/.ssh; \\"
        #echo "cat ${rsa_private_key} > /target/root/.ssh/authorized_keys; \\"
        echo "cp /cdrom/root_${C_ROOT_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub /target/root/.ssh/authorized_keys; \\"
        echo "cp /cdrom/user_${C_SSH_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub /target/root/user_${C_SSH_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub; \\"
        # Copy and run os_initialize.sh (this file contain initial script such as configuration of /etc/fstab)
        echo "cp /cdrom/os_initialize.sh /target/root/os_initialize.sh; \\"
        echo "in-target chmod +x /root/os_initialize.sh; \\"
        # TODO fix this (this is just a place holder but make sure it is executed for next feature)
        echo "in-target /root/os_initialize.sh; \\"
        # Configuring SSH
        echo "chmod -R go-rwx /target/root/.ssh; \\"
        echo "sed -i 's/^#PermitRootLogin.*/PermitRootLogin prohibit-password/g' /target/etc/ssh/sshd_config; \\"
        echo "sed -i 's/^#PubkeyAuthentication.*/PubkeyAuthentication yes/g' /target/etc/ssh/sshd_config; \\"
        echo "sed -i \"s/^#Port 22/Port ${C_SSH_PORT}/\" /target/etc/ssh/sshd_config; \\"
        # This fix error when message when client trying to send LOCAL to remote
        echo "sed -i \"s/^AcceptEnv LANG LC_*/#&/\" /target/etc/ssh/sshd_config; \\"
        # This will disable the interface name convention (just put in kernel line)
        #echo "in-target sed -i 's/GRUB_CMDLINE_LINUX=\"[^\"]*/&net.ifnames=0 biosdevname=0/' /etc/default/grub; \\"
        echo "echo \"GRUB_TERMINAL=serial\"  >> /target/etc/default/grub; \\"
        echo "echo \"GRUB_SERIAL_COMMAND=\\"\"serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1\\\"\" \>\> /target/etc/default/grub\; \\""
        echo "in-target update-grub; \\"
        # This will write a new static IP and use the default interface name from config file
        # This one fixed network issue with ipv6
        # echo "echo \"source /etc/network/interfaces.d/*\" > /target/etc/network/interfaces; \\"
        echo "echo \"# The loopback network interface\" > /target/etc/network/interfaces; \\"
        echo "echo \"auto lo\" >> /target/etc/network/interfaces; \\"
        echo "echo \"iface lo inet loopback\" >> /target/etc/network/interfaces; \\"
        echo "echo \"\" >> /target/etc/network/interfaces; \\"
        echo "echo \"# The primary network interface (IPv4)\" >> /target/etc/network/interfaces; \\"
        echo "echo \"auto ${C_NIC_INTERFACE_NAME}\" >> /target/etc/network/interfaces; \\"
        echo "echo \"iface ${C_NIC_INTERFACE_NAME} inet static\" >> /target/etc/network/interfaces; \\"
        echo "echo \"   address ${C_IPV4_ADD0}${C_IPV4_NETMASK0}\" >> /target/etc/network/interfaces; \\"
        echo "echo \"   gateway ${C_IPV4_DEF_GATEWAY0}\" >> /target/etc/network/interfaces; \\"
        echo "echo \"   dns-nameservers ${C_NAME_SERVER1} ${C_NAME_SERVER2}\" >> /target/etc/network/interfaces; \\"
        echo "echo \"\" >> /target/etc/network/interfaces; \\"
        echo "echo \"# The primary network interface (IPv6)\" >> /target/etc/network/interfaces; \\"
        echo "echo \"iface ${C_NIC_INTERFACE_NAME} inet6 static\" >> /target/etc/network/interfaces; \\"
        echo "echo \"   address ${C_IPV6_ADD0}${C_IPV6_NETMASK0}\" >> /target/etc/network/interfaces; \\"
        echo "echo \"   gateway ${C_IPV6_DEF_GATEWAY0}\" >> /target/etc/network/interfaces; \\"
        # This will write a new resolve at /etc/resolv.conf
        # If host is name server, this resolv.conf is needed
        # echo "echo \"search ${C_BOX_DOMAIN}\" > /target/etc/resolv.conf; \\"
        # The domain is for telling
        echo "echo \"domains ${C_BOX_HOSTNAME_FQHN}\" > /target/etc/resolvconf/resolv.conf.d/base; \\"
        #rotate lets resolver make use of all the name servers in resolv.conf
        echo "echo \"options rotate\" >> /target/etc/resolvconf/resolv.conf.d/base; \\"
        echo "echo \"nameserver ${C_NAME_SERVER1}\" >> /target/etc/resolvconf/resolv.conf.d/base; \\"
        echo "echo \"nameserver ${C_NAME_SERVER2}\" >> /target/etc/resolvconf/resolv.conf.d/base; \\"
        echo "echo \"nameserver ${C_NAME_SERVER3}\" >> /target/etc/resolvconf/resolv.conf.d/base; \\"
        echo "in-target resolvconf -u; \\"
        # For LUKS auto login
        echo "sed -i 's/^#DROPBEAR_OPTIONS=/DROPBEAR_OPTIONS=\"-I 180 -j -k -p ${C_DROP_BEAR_PORT} -s\"/' /target/etc/dropbear-initramfs/config; \\"
        echo "echo \"IP=${C_IPV4_ADD0}::${C_IPV4_DEF_GATEWAY0}:${C_IPV4_NETMASK_IP0}:${C_BOX_HOSTNAME}:${C_NIC_INTERFACE_NAME}:off\" >> /target/etc/initramfs-tools/initramfs.conf; \\"
        echo "cp /cdrom/root_${C_ROOT_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub /target/etc/dropbear-initramfs/authorized_keys; \\"
        echo "in-target update-initramfs -u;"
        # Installing some packages

      } >>"${path}"
    fi
  done
}

# This functions create ISO file, and upload into dropbox

# --dropbox-api upload --source /mnt/file.txt --destination /files
# --dropbox-api get-link --destination /files --filename /test/test.txt
# Note filename will only get the basename as dropbox only require this name /test/test2/test.txt = test.txt
# Use --scripting option to suppress message (useful for scripting)
dropbox_api() {

  local action options retval argnum scripting source destination filename dbx_cli file_direct_link
  action="$1"
  # For remote use this (remote dont use yet)
  #dbx_cli="${LATEST_OS_CODE_PATH}/usr/local/maxicode/maxicloud/dropbox/dbx"
  # For local use this
  # TODO remember to configure dbxcli to have chunk at least 150 dynamically because large ISO file with less chunk size will make upload slower
  if ! command -v dbxcli &>/dev/null; then
    _echo "$(msg yellow)Warning, the dropbox-cli dbxcli does not exist. Installing dropbox-cli ...$(msg end)" --name
    configure_dropbox_cli --run-force
  fi

  argnum="$#"
  if [ ${argnum} -eq 0 ]; then
    echo "Error, no argument is supplied. Use [ ${SCRIPT_NAME} --upload-to-dropbox --help ] to see the valid options"
    exit 1
  fi
  short_opts=""
  long_opts="help,scripting,source:,destination:,filename:"
  options=$(getopt -o "${short_opts}" --long "${long_opts}" -n "${FUNCNAME[0]} in ${SCRIPT_NAME}" -- "$@")
  retval=$?
  if [ ${retval} != 0 ]; then
    echo "Error, invalid parse data. Terminating..." >&2
    exit 1
  fi

  # Must quote this option variable
  eval set -- "${options}"

  scripting=false
  source=""
  destination=""
  filename=""
  while true; do
    case "$1" in
    --help)
      manual "${FUNCNAME[0]}"
      shift
      exit 0
      ;;
    --scripting)
      scripting=true
      shift
      ;;
    --source)
      source="$2"
      shift 2
      ;;
    --destination)
      destination="$2"
      shift 2
      ;;
    --filename)
      filename="$(basename -- "$2")"
      shift 2
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
    esac
  done
  if [[ "${action}" == "upload" ]]; then
    [[ ${scripting} == "false" ]] && _echo "$(msg cyan)Uploading file ${source} into ${destination} ...$(msg end)" --name
    if [[ ${scripting} == "false" ]]; then
      # The reason to delete the remote file first before uploading:
      # 1) When you upload the same file name, dropbox will not change the unique URL
      #    so, you will always get the same link even the file size or content has changed.
      #    this lead to problem because dropbox might cap the download speed for the same link
      #    So, best is to remove the remote file first to generate the new link
      dbxcli delete ${destination}
      dbxcli upload "${source}" "${destination}"
    else
      dbxcli -q delete ${destination}
      dbxcli -q upload "${source}" "${destination}"
    fi
  elif [[ "${action}" == "share" ]]; then
    if [[ ${scripting} == "false" ]]; then
      dbxcli share "${source}"
    else
      dbxcli -q upload "${source}"
    fi
  elif [[ "${action}" == "get-link" ]]; then
    [[ ${scripting} == "false" ]] && _echo "$(msg cyan)Generating download link ...$(msg end)" --name
    file_direct_link=$(dbxcli share "/${destination}/${filename}" | awk '{ print $4}' | sed 's/0$/1/g')
    [[ ${scripting} == "false" ]] && _echo "$(msg green)File direct link is: $(msg end)"
    echo "${file_direct_link}"
  else
    echo "Unknown action"
  fi

}
# iso_api <action> <required --iso-type> <required --iso-base> <optional --upload-to-dropbox> <optional --write-script> <optional --backup>
# iso_api create-os-iso --iso-type hdd-boot --iso-base local --upload-to-dropbox --write-script --backup
# Trigger --help for more information
iso_api() {

  local action argnum options retval iso_type iso_base upload_to_dropbox write_script backup
  action="$1"
  argnum="$#"
  if [ ${argnum} -eq 0 ]; then
    echo "Error, no argument is supplied. Use [ ${SCRIPT_NAME} --iso --help ] to see the valid options"
    exit 1
  fi
  short_opts=""
  long_opts="help,iso-type:,iso-base:,upload-to-dropbox,write-script,backup"
  options=$(getopt -o "${short_opts}" --long "${long_opts}" -n "${FUNCNAME[0]} in ${SCRIPT_NAME}" -- "$@")
  retval=$?
  if [ ${retval} != 0 ]; then
    echo "Error, invalid parse data. Terminating..." >&2
    exit 1
  fi

  # Must quote this option variable
  eval set -- "${options}"

  iso_type=""
  iso_base=""
  upload_to_dropbox=false
  write_script=false
  backup=false
  while true; do
    case "$1" in
    --help)
      manual "${FUNCNAME[0]}"
      shift
      exit 0
      ;;
    --iso-type)
      iso_type="$2"
      shift 2
      ;;
    --iso-base)
      iso_base="$2"
      shift 2
      ;;
    --upload-to-dropbox)
      upload_to_dropbox=true
      shift
      ;;
    --write-script)
      write_script=true
      shift
      ;;
    --backup)
      backup=true
      shift
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
    esac
  done

  if [[ "${action}" == "create-os-iso" ]]; then

    local iso_os date_time_random root_temp_path isomount_location isodir_write isodir_write_tmp preseed_file source_file \
      rsa_private_key rsa_private_key_ppk

    iso_os="${C_BOX_ISO_OS_NAME}"
    date_time_random="$(${DATE_BIN} '+%d_%m_%Y_%H_%M_%S').${RANDOM}"
    root_temp_path="/root/tmp_iso/${iso_os}"
    isomount_location="/mnt/mount_iso"
    isodir_write="${root_temp_path}/iso-rw"
    isodir_write_tmp="${root_temp_path}/iso-rw-tmp"
    preseed_file="${root_temp_path}/preseed.txt"
    source_file="${root_temp_path}/sources.list"

    if [ "${iso_os}" == "debian" ]; then
      local debian_name debian_release debian_select_version debian_latest_version debian_select_platform debian_image_type \
        debian_iso_installation_type debian_iso_url debian_initrd_gz_url debian_vmlinuz_url debian_isofile debian_isofile_final \
        debian_isofile_final_base_name

      debian_name="debian"
      debian_release="${C_OS_SET_CODE_NAME}" #use stable for latest version
      debian_select_version="${C_OS_SELECT_VERSION}"
      required "debian@@apt:curl" "ubuntu@@apt:curl"
      debian_latest_version="$(curl -s "http://cdimage.debian.org/cdimage/release/current/amd64/iso-cd/" | grep -oP "href=\"debian-\K[0-9]+\.[0-9]+\.[0-9]+" | sort -t. -rn -k1,1 -k2,2 -k3,3 | head -1)"
      debian_select_platform="amd64"
      debian_image_type="iso-cd"
      debian_iso_installation_type="netinst"
      #checksum_selection="debian-${debian_select_version}-${debian_select_platform}-${debian_iso_installation_type}.iso"
      if [ "${C_USE_LATEST_ISO}" == "true" ]; then
        debian_select_version="${debian_latest_version}"
        # The stable is the latest
        debian_release="stable" #use stable for latest version
      else
        if [ "${debian_select_version}" == "${debian_latest_version}" ]; then
          _echo "$(msg green)The Latest version of Debian is up-to-date with the selected version of Debian: v${debian_select_version}! $(msg end)" --name
        else
          _echo "$(msg yellow)Warning, the Latest version of Debian detected as ${debian_latest_version} but the selected version from config file is ${debian_select_version}!$(msg end)" --name
          _confirm
        fi
      fi

      debian_iso_url="http://cdimage.debian.org/cdimage/release/current/${debian_select_platform}/${debian_image_type}/${debian_name}-${debian_select_version}-${debian_select_platform}-${debian_iso_installation_type}.iso"
      debian_initrd_gz_url="http://ftp.debian.org/debian/dists/${debian_release}/main/installer-amd64/current/images/hd-media/initrd.gz"
      debian_vmlinuz_url="http://ftp.debian.org/debian/dists/${debian_release}/main/installer-amd64/current/images/hd-media/vmlinuz"

      debian_base_iso_256sum_online_value=$(curl -s "https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/SHA256SUMS" | grep "debian-${debian_select_version}-${debian_select_platform}-${debian_iso_installation_type}.iso" | awk '{ print $1 }')

      debian_isofile="${root_temp_path}/${iso_os}_${debian_select_version}.iso"
      debian_isofile_final="${root_temp_path}/${iso_os}_${debian_select_version}_final.iso"
      debian_isofile_final_base_name="$(basename -- "${debian_isofile_final}")"
      # Modify this to have the output name as different name (This file is just a backup file of debian_isofile_final)

      debian_iso_complete_file="${ISO_PATH}/os/debian/${debian_name}_${debian_select_version}_complete.iso"

      rm -rf "${debian_isofile_final}"
      rm -rf "${isodir_write}"
      rm -rf "${isodir_write_tmp}"
      rm -rf "${preseed_file}"
      rm -rf "${source_file}"

      mkdir -p "${root_temp_path}"
      mkdir -p "${isomount_location}"
      mkdir -p "${isodir_write}"
      mkdir -p "${isodir_write_tmp}"
      mkdir -p "$(dirname "${debian_iso_complete_file}")"
      echo ""

      if [ "${backup}" == "true" ]; then
        if [ -f "${debian_iso_complete_file}" ]; then
          _echo "$(msg green)OK, previous ISO file ${debian_iso_complete_file} exist$(msg end)" --name
          echo ""
          _echo "$(msg cyan)Checking if the ISO file ${debian_iso_complete_file} is valid (bootable) ..." --name
          required "ubuntu@@apt:genisoimage" "debian@@apt:genisoimage"
          isoinfo -d -i "${debian_iso_complete_file}" 2>/dev/null | grep -q "bootable"
          retval=$?
          if [ ${retval} -eq 0 ]; then
            local backup_dir iso_backup_dir ssh_backup_dir
            _echo "$(msg green)OK, previous ISO file ${debian_iso_complete_file} is valid (bootable). Backing up ISO files and SSH keys ...$(msg end)" --name
            backup_dir="${ISO_PATH}/backup/iso_backup_${date_time_random}"
            iso_backup_dir="${backup_dir}/iso"
            ssh_backup_dir="${backup_dir}/ssh"

            mkdir -p "${iso_backup_dir}"
            mkdir -p "${ssh_backup_dir}"
            cp -p "${debian_iso_complete_file}" "${iso_backup_dir}"
            cp -Rp "${SECURE_PATH}/ssh/" "${ssh_backup_dir}"
            echo "Backup location is at: ${iso_backup_dir}"
            echo ""
          else
            _echo "$(msg red)Error, the previous ISO file might be corrupted because it does not contain bootable record.$(msg end)" --name --verbose 3
            _exit 147
          fi
        else
          _echo "$(msg red)Error, backup failed because previous ISO file ${debian_iso_complete_file} was not found. Please inspect the location of the file$(msg end)" --name --verbose 3
          _echo "$(msg red)If you want to continue without backup, omit the option --backup$(msg end)" --name --verbose 3
          _exit 147
        fi
      fi

      if [ "${iso_base}" == "web" ]; then
        if [ "${C_USE_LATEST_ISO}" == "true" ]; then
          _echo "The Latest version of Debian detected is ${debian_latest_version} (auto selected version is ${debian_select_version})" --name
          _echo "Setup will download the most recent version of Debian regardless of the selected version because C_USE_LATEST_ISO is set to yes from the config file!" --name
          _pause 5
        else
          if [ "${debian_latest_version}" != "${C_OS_SELECT_VERSION}" ]; then
            _echo "$(msg yellow)Warning, OS version mismatch. The Latest version of Debian detected is ${debian_latest_version} but the selected version is ${debian_select_version}$(msg end)" --name
            _echo "The installation might fail due to the new changes in latest version of Debian. Please inspect the current OS by assigning the C_OS_SELECT_VERSION to the latest version" --name
            _echo "You can re-run this script without --rebuild-all once you did that"
            _exit 147
          fi
        fi
        _echo "$(msg cyan)Downloading ISO file from ${debian_iso_url} ...$(msg end)" --name
        rm -rf "${debian_isofile}"
        wget -nc --no-verbose -O "${debian_isofile}" "${debian_iso_url}" || true
      elif [ "${iso_base}" == "local" ]; then
        _echo "$(msg cyan)Setup will use the local ISO file downloaded previously! Checking existing ISO file ${debian_isofile} ... $(msg end)" --name
        # use the local ISO
        if [ -f "${debian_isofile}" ]; then
          # echo "ISO file exist"
          # Check here if ISO is corrupt based on online checksum
          if is_valid sha256sum "${debian_base_iso_256sum_online_value}" "${debian_isofile}"; then
            _echo "$(msg green)OK, the base ISO file content is valid sha256sum. Setup will create ISO file using existing ISO file$(msg end)" --name
          else
            _echo "$(msg red)Error, the base ISO file content is corrupted (not valid sha256sum). Please download a new one with an option [ --iso-base web ]$(msg end)" --name
            _exit 147
          fi

        else
          _echo "$(msg red) Error, the base ISO file ${debian_isofile} does not exist. You may need to use the option [ --iso-base web ] to automatically download new ISO file from web$(msg end)" --name
          _exit 147
        fi
      else
        _echo "$(msg red)Error, unknown ISO base type$(msg end)" --name
        _exit 147
      fi

      # For hard disk booting
      if [[ "${iso_type}" == "hdd-iso" || "${iso_type}" == "hdd-boot" || "${iso_type}" == "hdd" || "${iso_type}" == "isolinux" ]]; then

        required "ubuntu@@apt:debconf,isolinux,syslinux-utils,xorriso,wget" \
          "debian@@apt:debconf,isolinux,syslinux-utils,xorriso,wget"

        _echo "$(msg cyan)Creating new RSA Key for root ...$(msg end)" --name
        # This will create 2 files one is private and another one with the extension .pub
        # For root
        ssh_api create-key-with-putty --group root --user "${C_ROOT_USERNAME}" --comment "${C_BOX_HOSTNAME_FQHN}_secure_auth"
        echo ""

        _echo "$(msg cyan)Creating new RSA Key for sudo [user] ...$(msg end)" --name
        ssh_api create-key-with-putty --group user --user "${C_SSH_USERNAME}" --comment "${C_BOX_HOSTNAME_FQHN}_secure_auth"

        # Must copy the new keys to /root/.ssh with this command
        _echo "$(msg cyan)Updating the keys from ${SECURE_PATH}/ssh into /root/.ssh ...$(msg end)" --name
        ssh_api copy-public-keys --without-prompt
        echo ""
        _echo "$(msg cyan)Building a custom ${iso_os} image file for server using HDD Booting method ...$(msg end)" --name
        echo ""
        # Fixing
        navigate_path "${SCRIPT_PATH}"

        _echo "$(msg cyan)Writing new preseed file config ...$(msg end)" --name
        # Writing new preseed.cfg
        create_file "debian-preseed" "${preseed_file}"
        echo ""
        _echo "$(msg cyan)Checking preseed syntax file ${preseed_file} ...$(msg end)" --name
        if ! debconf-set-selections -c "${preseed_file}"; then
          _echo "$(msg red)Error, there there was a syntax error in the preseed.cfg. Check the syntax of the preconfiguration file.$(msg end)" --name
          _exit 1
        else
          _echo "$(msg green)OK, the preseed file ${preseed_file} syntax is ok$(msg end)" --name
        fi
        # exit 1
        echo ""
        _echo "$(msg cyan)Extracting the ISO file ${debian_isofile}'s contents into a temporary writeable directory at ${isodir_write_tmp} ...$(msg end)" --name
        xorriso -osirrox on -indev "${debian_isofile}" -extract / "${isodir_write_tmp}/"
        echo ""

        # Do not remove existing ISO file because we want to reuse this without downloading new ISO using the option --iso-base=local
        #_echo "$(msg cyan)Removing existing ISO file ...$(msg end)" --name
        #rm -rf "${debian_isofile}"

        #echo "Editing isolinux/isolinux.cfg to disable setup menu (straight to the first menu on startup) ..."
        #sed -i "s/timeout 0/timeout 1/" ${ISODIR_WRITE_TMP}/isolinux/isolinux.cfg
        echo ""
        _echo "$(msg cyan)Copying raw preseed file from ${preseed_file} into ${isodir_write_tmp}/preseed.cfg ...$(msg end)" --name
        cp "${preseed_file}" "${isodir_write_tmp}/preseed.cfg"
        #chmod 555 ${ISODIR_WRITE}/preseed.cfg
        echo ""

        _echo "$(msg cyan)Writing rsa public key (root) file into ${isodir_write_tmp}/root_${LABEL_C_ROOT_USERNAME}_${LABEL_C_BOX_HOSTNAME_FQHN}.id_rsa.pub ...$(msg end)" --name

        ssh_api get-public-key --group root --user "${C_ROOT_USERNAME}" --server "${C_BOX_HOSTNAME_FQHN}" >"${isodir_write_tmp}/root_${C_ROOT_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub"
        echo ""
        _echo "$(msg cyan)Writing rsa public key (user) file into ${isodir_write_tmp}/user_${LABEL_C_SSH_USERNAME}_${LABEL_C_BOX_HOSTNAME_FQHN}.id_rsa.pub ...$(msg end)" --name
        ssh_api get-public-key --group user --user "${C_SSH_USERNAME}" --server "${C_BOX_HOSTNAME_FQHN}" >"${isodir_write_tmp}/user_${C_SSH_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub"
        echo ""

        _echo "$(msg cyan)Creating os_initialize.sh script file into ${isodir_write_tmp}/os_initialize.sh ...$(msg end)" --name
        create_file os_initialize "${isodir_write_tmp}/os_initialize.sh"
        echo ""
        _echo "$(msg cyan)Changing permission of ${isodir_write_tmp}/preseed.cfg to own by root:root ...$(msg end)" --name
        chown root:root "${isodir_write_tmp}/preseed.cfg"
        echo ""
        _echo "$(msg cyan)Lowering the files permission from ${isodir_write_tmp}/install.amd to +w ...$(msg end)" --name
        chmod +w -R "${isodir_write_tmp}/install.amd"
        retval=$?
        if [ ${retval} -ne 0 ]; then
          _echo warning "Something is wrong when trying to lower the file permission for ${isodir_write_tmp}/install.amd to +w"
          _exit 1
        fi
        echo ""
        _echo "$(msg cyan)Extracting initrd.gz ...$(msg end)" --name
        gunzip "${isodir_write_tmp}/install.amd/initrd.gz"
        echo ""
        _echo "$(msg cyan)Writing preseed.cfg file into initrd ...$(msg end)" --name
        echo "${isodir_write_tmp}/preseed.cfg" | cpio -H newc -o -A -F "${isodir_write_tmp}/install.amd/initrd"
        echo ""
        ##exit 1
        _echo "$(msg cyan)Compressing initrd as initrd.gz ...$(msg end)" --name
        gzip "${isodir_write_tmp}/install.amd/initrd"
        echo ""
        _echo "$(msg cyan)Changing the folder permission of ${isodir_write_tmp}/install.amd/ to -w ...$(msg end)" --name
        chmod -w -R "${isodir_write_tmp}/install.amd/"
        echo ""

        _echo "$(msg cyan)Writing and fixing md5sum checksum in ${isodir_write} ...$(msg end)" --name
        navigate_path "${isodir_write_tmp}"

        # Alternative method:
        #pushd ${ISODIR_WRITE}
        #  md5sum $(find -type f) > md5sum.txt
        #popd

        # A warning will be issued because ./debian is a symlink to . :
        # find: File system loop detected; ./debian is part of the same file system loop as . :
        chmod +w md5sum.txt
        #find -follow -type f ! -name md5sum.txt -print0 | xargs -0 md5sum >md5sum.txt
        find . -follow -type f ! -name md5sum.txt -print0 | xargs -0 md5sum >tmpfile && mv tmpfile md5sum.txt
        chmod -w md5sum.txt
        echo ""

        _echo "$(msg cyan)Creating standalone ISO installation inside ${isodir_write}/${debian_isofile_final} ...$(msg end)" --name
        xorriso -as mkisofs \
          -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin \
          -c isolinux/boot.cat \
          -b isolinux/isolinux.bin \
          -no-emul-boot \
          -boot-load-size 4 \
          -boot-info-table \
          -eltorito-alt-boot \
          -e boot/grub/efi.img \
          -no-emul-boot \
          -isohybrid-gpt-basdat \
          -o "${isodir_write}/${debian_name}-${debian_release}-${debian_iso_installation_type}.iso" \
          "${isodir_write_tmp}"
        echo ""

        _echo "$(msg cyan)Copying ${isodir_write_tmp}/boot into ${isodir_write} ...$(msg end)" --name
        cp -rp "${isodir_write_tmp}/boot" "${isodir_write}"
        echo ""
        _echo "$(msg cyan)Creating new boot installation directory at ${isodir_write}/boot/os ...$(msg end)" --name
        mkdir -p "${isodir_write}/boot/os"
        echo ""
        navigate_path "${isodir_write}/boot/os"
        echo ""
        _echo "$(msg cyan)Downloading initrd.gz file into ${isodir_write}/boot/os ...$(msg end)" --name
        wget --no-verbose -O initrd.gz ${debian_initrd_gz_url}
        echo ""
        _echo "$(msg cyan)Downloading vmlinuz file into ${isodir_write}/boot/os ...$(msg end)" --name
        wget --no-verbose -O vmlinuz ${debian_vmlinuz_url}
        echo ""
        _echo "$(msg cyan)Copying ${isodir_write_tmp}/isolinux into ${isodir_write} ...$(msg end)" --name
        cp -rp "${isodir_write_tmp}/isolinux" "${isodir_write}"
        echo ""

        _echo "$(msg cyan)Backing up isolinux.cfg file at ${isodir_write}/isolinux/isolinux.cfg as ${isodir_write}/isolinux/original_isolinux.cfg ...$(msg end)" --name
        mv "${isodir_write}/isolinux/isolinux.cfg" "${isodir_write}/isolinux/original_isolinux.cfg"
        echo ""

        _echo "$(msg cyan)Modifying isolinux.cfg to create new operating system boot menu ...$(msg end)" --name
        {

          ## Config reference: https://www.alteeve.com/an-repo/files/isolinux.cfg
          # Use high-color menu
          echo "UI vesamenu.c32"
          # Timeout unit is 1/10s, 100 means 10 seconds
          echo "TIMEOUT 100"
          echo "PROMPT 0"

          echo "DEFAULT Debian - Auto Installation"
          echo "# Console Prompt"
          echo "say **********************************************************************"
          echo "say Sofibox Cloud Sdn Bhd."
          echo "say TOSP, Cyberjaya Malaysia."
          echo "say sofibox.com, tosp.sofibox.com"
          echo "say OPERATING SYSTEM INSTALLER"
          echo "Copyright (C) Arafat Ali"
          echo "say Automatically booting: Debian - Auto Installation in 10 seconds ..."
          echo "say **********************************************************************"

          echo "# Allow client to edit the boot parameters"
          echo "ALLOWOPTIONS 1"

          # If don't set default would be 640x480
          #MENU RESOLUTION 1024 768

          # The background image
          #MENU BACKGROUND pxe_splash_1024_768.jpg

          echo "# Menu Title"
          echo "MENU TITLE Sofibox - Maxinet Rescue Mode"

          echo "MENU AUTOBOOT Will boot the next device as configured in your BIOS in # second{,s}."
          echo "MENU TABMSG   Press the <tab> key to edit the boot parameters of the highlighted option."
          echo "MENU NOTABMSG Editing of this option is disabled."

          #The color
          echo "# Format is: MENU COLOR <Item> <ANSI Seq.> <foreground> <background> <shadow type>"
          echo "MENU COLOR screen      0  #80ffffff #00000000 std      # background colour not covered by the splash image"
          echo "MENU COLOR border      0  #ffffffff #ee000000 std      # The wire-frame border"
          echo "MENU COLOR title       0  #ffff3f7f #ee000000 std      # Menu title text"
          echo "MENU COLOR sel         0  #ff00dfdf #ee000000 std      # Selected menu option"
          echo "MENU COLOR hotsel      0  #ff7f7fff #ee000000 std      # The selected hotkey (set with ^ in MENU LABEL)"
          echo "MENU COLOR unsel       0  #ffffffff #ee000000 std      # Unselected menu options"
          echo "MENU COLOR hotkey      0  #ff7f7fff #ee000000 std      # Unselected hotkeys (set with ^ in MENU LABEL)"
          echo "MENU COLOR tabmsg      0  #c07f7fff #00000000 std      # Tab text"
          echo "MENU COLOR timeout_msg 0  #8000dfdf #00000000 std      # Timout text"
          echo "MENU COLOR timeout     0  #c0ff3f7f #00000000 std      # Timout counter"
          echo "MENU COLOR disabled    0  #807f7f7f #ee000000 std      # Disabled menu options, including SEPARATORs"
          echo "MENU COLOR cmdmark     0  #c000ffff #ee000000 std      # Command line marker - The '> ' on the left when editing an option"
          echo "MENU COLOR cmdline     0  #c0ffffff #ee000000 std      # Command line - The text being edited"
          echo "# Options below haven't been tested, descriptions may be lacking."
          echo "MENU COLOR scrollbar   0  #40000000 #00000000 std      # Scroll bar"
          echo "MENU COLOR pwdborder   0  #80ffffff #20ffffff std      # Password box wire-frame border"
          echo "MENU COLOR pwdheader   0  #80ff8080 #20ffffff std      # Password box header"
          echo "MENU COLOR pwdentry    0  #80ffffff #20ffffff std      # Password entry field"
          echo "MENU COLOR help        0  #c0ffffff #00000000 std      # Help text, if set via 'TEXT HELP ... ENDTEXT'"

          echo "LABEL Debian - Auto Installation"
          echo "    MENU LABEL ^1) Auto install Debian"
          echo "    MENU DEFAULT"
          echo "    KERNEL /boot/os/vmlinuz"
          #important, preseed file location need to be cdrom/preseed.cfg"
          echo "    APPEND initrd=/boot/os/initrd.gz preseed/file=/cdrom/preseed.cfg locale=${C_BOX_LOCALE} keymap=${C_BOX_KEYBOARD} language=${C_BOX_LANGUAGE_CODE} country=${C_BOX_COUNTRY_CODE} --"
          echo "    TEXT HELP"
          echo "    * This is an auto installation"
          echo "    * WARNING: ALL DATA ON DISKS WILL BE OVERWRITTEN WITHOUT ANY QUESTIONS"
          echo "    ENDTEXT"
          echo "LABEL Debian - Manual installation"
          echo "   MENU LABEL ^2) Manual Debian Installation"
          echo "   KERNEL  /boot/os/vmlinuz"
          echo "   APPEND initrd=/boot/os/initrd.gz --"
          echo "    TEXT HELP"
          echo "    * This is a manual installation"
          echo "    * NOTE: USE THIS MENU IF YOU WANT TO INSTALL DEBIAN INTERACTIVELY"
          echo "    ENDTEXT"
          # Warning this System Backup menu is beta and will not do anything. Will update in the future for backup function
          echo "LABEL Debian - System Backup"
          echo "MENU LABEL ^3) Debian Full System Backup"
          echo "   KERNEL  /boot/os/vmlinuz"
          echo "   APPEND initrd=/boot/os/initrd.gz --"
          echo "    TEXT HELP"
          echo "    * This is an operating system full backup mode"
          echo "    * NOTE: USE THIS MENU IF YOU WANT TO MAKE FULL BACKUP (TESTING)"
          echo "    ENDTEXT"

        } >"${isodir_write}/isolinux/isolinux.cfg"

        _echo "$(msg cyan)Writing and fixing md5sum checksum in ${isodir_write} ...$(msg end)" --name
        cp -p "${isodir_write_tmp}/md5sum.txt" "${isodir_write}"
        rm -rf "${isodir_write_tmp}"
        navigate_path "${isodir_write}"

        chmod +w md5sum.txt
        find . -follow -type f ! -name md5sum.txt -print0 | xargs -0 md5sum >tmpfile && mv tmpfile md5sum.txt
        chmod -w md5sum.txt
        echo ""

        _echo "$(msg cyan)Creating the final ISO file ...$(msg end)" --name
        xorriso -as mkisofs \
          -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin \
          -c isolinux/boot.cat \
          -b isolinux/isolinux.bin \
          -no-emul-boot \
          -boot-load-size 4 \
          -boot-info-table \
          -eltorito-alt-boot \
          -e boot/grub/efi.img \
          -no-emul-boot \
          -isohybrid-gpt-basdat \
          -o "${debian_isofile_final}" \
          "${isodir_write}"
        echo ""

        # Copying to shared folder
        _echo "$(msg cyan)Creating a copy of ISO file from ${debian_isofile_final} as ${debian_iso_complete_file} ...$(msg end)" --name
        cp "${debian_isofile_final}" "${debian_iso_complete_file}"
        echo ""
        if [[ "${upload_to_dropbox}" == "true" ]]; then
          # First check if the ISO file is bootable
          _echo "$(msg cyan)Checking whether ISO file ${debian_isofile_final} is valid (bootable) ...$(msg end)" --name
          isoinfo -d -i "${debian_isofile_final}" 2>/dev/null | grep -q "bootable"
          retval=$?
          if [ ${retval} -eq 0 ]; then
            _echo "$(msg green)OK, ISO file ${debian_isofile_final} is valid (bootable)$(msg end)" --name
          else
            _echo "$(msg red)Error, the ISO file ${debian_isofile_final} might be corrupted because it does not contain bootable record.$(msg end)" --name --verbose 3
            _exit 147
          fi
          echo ""
          _echo "$(msg cyan)Uploading local file ${debian_isofile_final} into dropbox remote location /files/${debian_isofile_final_base_name} ...$(msg end)" --name
          # Uploading to dropbox and generating link
          dropbox_api upload --source "${debian_isofile_final}" --destination "/files/$(basename -- "${debian_isofile_final}")"
          echo ""
          _echo "$(msg cyan)Generating uploaded file link of ${debian_isofile_final} ...$(msg end)" --name
          file_direct_link=$(dropbox_api get-link --destination "/files" --filename "${debian_isofile_final}" --scripting)
          if [ -z "${file_direct_link}" ]; then
            _echo "$(msg red)Error, uploaded file direct link is empty. Please inspect why! $(msg end)" --name
            _exit 147
          fi
          echo ""

          _echo "$(msg cyan)Creating automation script for installing operating system remotely into ${CODE_PATH}/ssh_scripts/os_write_ag.sh ...$(msg end)" --name
          {
            echo "#!/bin/bash"
            echo "# ==============================================="
            echo "# This script file was generated by ${SCRIPT_NAME}"
            echo "# This script is used to write OS into /dev/sda"
            echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
            echo "# ==============================================="
            echo "wget -O mini.iso ${file_direct_link}"
            echo "dd if=mini.iso of=/dev/sda"
            # This is needed to force reboot especially for rescue mode.
            echo "reboot --poweroff --force"
            echo "# Put 2 times exit below to safely exit the script if the first exit is not executed"
            echo "exit"
            echo "exit"
          } >"${CODE_PATH}/ssh_scripts/os_write_ag.sh"
          echo ""
          _echo "$(msg cyan)Generating rescue disk command for manual installation ...$(msg end)" --name
          {
            echo "# ==============================================="
            echo "# This manual file was generated by ${SCRIPT_NAME}"
            echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
            echo "# ==============================================="
            echo "# Download link available at:"
            echo "wget -O mini.iso \"${file_direct_link}\""
            echo "# Operating system installation script available at:"
            echo "${CODE_PATH}/ssh_scripts/os_write_ag.sh"
            echo "dd if=mini.iso of=/dev/sda"
          } >"$(dirname "${debian_iso_complete_file}")/install.txt"
          echo ""
          if [ "${C_HIDE_SENSITIVE_TEXT}" == "true" ]; then
            _echo "$(msg cyan)ISO direct link is: *hidden_link*$(msg end)" --name
          else
            _echo "$(msg cyan)ISO direct link is: $(msg red)${file_direct_link}$(msg end)" --name
          fi

          if [ ${write_script} == "true" ]; then
            _echo "$(msg red)==================================$(msg end)" --plain
            _echo "$(msg newline)" --plain
            if [ "${C_HIDE_SENSITIVE_TEXT}" == "true" ]; then
              _echo "$(msg green)wget -O mini.iso *hidden_link*$(msg end)" --plain
            else
              _echo "$(msg green)wget -O mini.iso \"${file_direct_link}\"$(msg end)" --plain
            fi
            _echo "$(msg green)dd if=mini.iso of=/dev/sda$(msg end)" --plain
            _echo "$(msg green)mkdir /mnt/iso$(msg end)" --plain
            _echo "$(msg green)mount mini.iso /mnt/iso$(msg end)" --plain
            _echo "$(msg green)echo \"\"$(msg end)" --plain
            _echo "$(msg newline)" --plain
            _echo "$(msg red)==================================$(msg end)" --plain
            _echo "$(msg newline)" --plain
          fi
          echo ""
        fi

        _echo "$(msg cyan)Removing current working directories ...$(msg end)" --name
        rm -rf "${isodir_write}"
        echo ""
        _echo "$(msg cyan)Removing current preseed configuration file ...$(msg end)" --name
        rm -rf "${preseed_file}"

      # My custom method
      else
        _echo "$(msg red)Error, unknown type or method for creating ISO file ${iso_type}!$(msg end)" --name --verbose 3
        _exit 147
      fi
    fi

    # This action is deprecated (this is used to create custom rescue disk for finnix before but we dont need it anymore, just use the improve version of linode finnix rescue disk)
  elif [[ "${action}" == "create-rescue-iso" ]]; then

    required "apt:genisoimage" "apt:wget" "apt:pwgen" "apt:whois" "apt:xorriso" "apt:debconf" "apt:isolinux" "apt:syslinux-utils" "apt:squashfs-tools" "apt:putty-tools"

    dbx_cli="${SCRIPT_PATH}/storage/os/debian/usr/local/maxicode/maxicloud/dropbox/dbx"
    if [[ "${C_HOST_MAX_PROCESSOR}" -lt 2 ]]; then
      _echo 'red' "Warning, this process will run slower when using compression tool because C_HOST_MAX_PROCESSOR is set less than 2"
      echo ""
    fi
    echo "Creating a new RSA Key for rescue root login ..."
    ssh_api "create-key-with-putty" "rescue" "root" "${C_BOX_HOSTNAME_FQHN}_secure_auth"

    # Good guide : https://www.dotpointer.ga/?section=notes&view=note&id_notes=164
    # Good guide 2: https://rmprepusb.com/tutorials/011-make-an-image-recovery-usb-drive-using-finnix/
    local action="$1"
    local retval=0
    local method="$1"
    local option="$2"
    local root_temp_path isofile isofile_final isomount_location finnix_select_version isodir_write iso_url isofile_final_base_name file_direct_link

    if [ $# -gt 3 ]; then
      echo "Argument shouldn't be more than 3 for now. See --help for more information"
      _exit 1
    fi
    root_temp_path="/root/tmp_iso/debian"
    isofile="${root_temp_path}/finnix-122.iso"
    isofile_final="${root_temp_path}/finnix_mod.iso"
    isofile_final_base_name="$(basename -- ${isofile_final})"
    iso_output_path="/mnt/c/Users/Maxibi/IdeaProjects/maxinet/storage/os/debian/finnixmod.iso"
    isomount_location="/mnt/mount_riso"
    isodir_write="${root_temp_path}/riso-rw"

    #https://www.finnix.org/releases/122/finnix-122.iso
    finnix_select_version="122"

    iso_url="https://www.finnix.org/releases/${finnix_select_version}/finnix-${finnix_select_version}.iso"

    _echo "$(msg cyan)Removing previous file ${isofile_final} ...$(msg end)" --name
    rm -rf "${isofile_final}"

    echo ""
    echo "$(msg cyan)Removing previous file ${isodir_write} ...$(msg end)" --name
    rm -rf "${isodir_write}"

    mkdir -p "${root_temp_path}"
    mkdir -p "${isomount_location}"
    mkdir -p "${isodir_write}"
    echo ""

    echo "Creating a custom Finnix rescue disk for hard disk booting ..."
    echo ""
    if [[ "${option}" == "--update-iso" || -z "${option}" ]]; then
      if [ -f "${isofile}" ]; then
        rm -rf "${isofile}"
        echo "Re-downloading system image ..."
      else
        echo "Downloading new system image ..."
      fi

      wget --no-verbose -nc -O "${isofile}" "${iso_url}" || true
    elif [[ "${option}" == "--no-update-iso" ]]; then
      if [ -f "${isofile}" ]; then
        echo "Using the existing ISO file ..."
      else
        echo "Warning, existing ISO file is missing! Use --update-iso option to download new file"
        _exit 1
      fi
      # Do nothing
    else
      echo "Invalid option supplied: ${option} on ${FUNCNAME[0]}"
      echo "${SCRIPT_NAME} ${action} --update-iso , to download the new ISO file where --update-iso is a default command if not specified"
      echo "${SCRIPT_NAME} ${action} --no-update-iso , to use existing ISO file"
      _exit 1
    fi
    echo ""
    echo "Copying ISO file content into writeable directory ${isodir_write} ..."
    xorriso -osirrox on -indev ${isofile} -extract / ${isodir_write}/
    echo ""
    echo "Removing initial ISO file ..."
    rm -rf "${isofile}"
    echo ""
    echo "Disabling startup timer menu (straight boot to the default menu) ..."
    sed -i "s/timeout .*/timeout 1/" ${isodir_write}/isolinux/isolinux.cfg
    echo ""
    #echo "Adding noeject and noprompt boot parameter at grub.cfg ..."
    #{
    #  echo "source /boot/grub/config.cfg"
    #  echo "# Live boot"
    #  echo "menuentry \"Live system\" --hotkey=l {"
    #  echo "    linux	/live/vmlinuz-5.10.0-3-amd64 quiet"
    #  echo "    initrd	/live/initrd.img-5.10.0-3-amd64"
    #  echo "}"
    #} >${isodir_write}/boot/grub/grub.cfg
    echo ""
    echo "Creating startup script on startup ..."
    #Guide here: https://www.finnix.org/Overlays (Startup shell scripts)
    mkdir -p "${isodir_write}/finnix/arch/indep/rc"
    echo "#!/bin/bash" >"${isodir_write}/finnix/arch/indep/rc/initial.sh"
    echo "#any startup script here" >>"${isodir_write}/finnix/arch/indep/rc/initial.sh"
    chmod +x "${isodir_write}/finnix/arch/indep/rc/initial.sh"
    echo ""
    echo "Creating working directory ${isodir_write}/live/workdir"
    mkdir -p "${isodir_write}/live/workdir"
    echo ""
    echo "Moving ${isodir_write}/live/filesystem.squashfs into ${isodir_write}/live/workdir ..."
    mv "${isodir_write}/live/filesystem.squashfs" "${isodir_write}/live/workdir"
    echo ""
    navigate_path "${isodir_write}/live/workdir"
    echo "Extracting squashfs file filesystem.squashfs ..."
    unsquashfs -processors "${C_HOST_MAX_PROCESSOR}" filesystem.squashfs
    echo ""
    echo "Removing the old filesystem.squashfs file ..."
    rm -rf filesystem.squashfs
    echo ""
    #exit 1
    # Now we have all file in here: isodir_write/live/workdir/squashfs-root/*
    echo "Creating .ssh directory in ${isodir_write}/live/workdir/squashfs-root/root/.ssh ..."
    mkdir -p "${isodir_write}/live/workdir/squashfs-root/root/.ssh"
    echo ""
    echo "Copying RSA certificate in ${isodir_write}/live/workdir/squashfs-root/root/.ssh/authorized_keys ..."

    #cp "${SCRIPT_PATH}/secure/rescue_root_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub" "${isodir_write}/live/workdir/squashfs-root/root/.ssh/authorized_keys"
    ssh_api "get-pubkey" "rescue" "root" >"${isodir_write}/live/workdir/squashfs-root/root/.ssh/authorized_keys"

    echo ""
    echo "Raising permission of .ssh folder ..."
    chmod -R go-rwx "${isodir_write}/live/workdir/squashfs-root/root/.ssh"
    echo ""
    echo "Disabling SSH root login in sshd_config ..."
    sed -i 's/^.*PermitRootLogin.*/PermitRootLogin no/g' "${isodir_write}/live/workdir/squashfs-root/etc/ssh/sshd_config"
    echo ""

    echo "Changing SSH login port to ${LABEL_C_RESCUE_SSH_PORT} ..."
    sed -i "s/#Port 22/Port ${C_RESCUE_SSH_PORT}/" "${isodir_write}/live/workdir/squashfs-root/etc/ssh/sshd_config"
    echo ""

    echo "Creating startup script at .profile to restart ssh on startup ..."
    echo "systemctl restart ssh" >>"${isodir_write}/live/workdir/squashfs-root/root/.profile"
    #chmod +x "${isodir_write}/live/workdir/squashfs-root/etc/rc.local"
    echo ""

    echo "Recreating the squashfs	filesystem from filesystem.squashfs ..."
    mksquashfs squashfs-root filesystem.squashfs -b 1024k -comp xz -Xbcj x86 -e boot -processors "${C_HOST_MAX_PROCESSOR}"
    echo ""

    echo "Moving filesystem.squashfs into ${isodir_write}/live/filesystem.squashfs ..."
    mv filesystem.squashfs ${isodir_write}/live/filesystem.squashfs
    echo ""
    echo "Removing working directory ..."
    rm -rf ${isodir_write}/live/workdir
    echo ""
    navigate_path "${isodir_write}"
    echo "Creating new sha256sum checksum for sha256sum.txt ..."
    chmod +w sha256sum.txt
    find "${isodir_write}" -follow -type f ! -name sha256sum.txt -print0 | xargs -0 sha256sum >sha256sum_tmp.txt
    mv -f sha256sum_tmp.txt sha256sum.txt
    chmod -w sha256sum.txt
    echo ""
    echo "Creating standalone ISO installation inside ${isofile_final} ..."
    xorriso -as mkisofs \
      -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin \
      -c isolinux/boot.cat \
      -b isolinux/isolinux.bin \
      -no-emul-boot \
      -boot-load-size 4 \
      -boot-info-table \
      -eltorito-alt-boot \
      -isohybrid-gpt-basdat \
      -o ${isofile_final} \
      ${isodir_write}

    # Do not quote the path. If quote it will become redundant path: '/root/tmp_iso/debian/riso-rw/~/tmp_iso/debian/riso-rw'
    echo ""

    # Copying to shared folder
    echo "Creating installation disk at ${iso_output_path} ..."
    cp "${isofile_final}" "${iso_output_path}"
    echo ""
    echo "Copying RSA private (with putty) keys inside ISO output ..."
    cp "${rsa_private_key}" "$(dirname "${iso_output_path}")/"
    cp "${rsa_private_key_ppk}" "$(dirname "${iso_output_path}")/"
    # Uploading to dropbox
    echo ""
    echo "Uploading ${isofile_final} into dropbox /files/${isofile_final_base_name} ..."
    dbxcli upload "${isofile_final}" "/files"

    echo "Creating download link ..."
    file_direct_link=$(dbxcli share "/files/${isofile_final_base_name}" | awk '{ print $4}' | sed 's/0$/1/g')
    echo "File direct link is: ${file_direct_link}"
    echo ""
    echo "Creating rescue disk script ..."
    _echo 'red' "=================================="
    echo ""
    echo "wget -O mini.iso \"${file_direct_link}\"" >"$(dirname "${iso_output_path}")/install.txt"
    echo "dd if=mini.iso of=/dev/sda" >>"$(dirname "${iso_output_path}")/install.txt"
    _echo 'green' "wget -O mini.iso \"${file_direct_link}\""
    _echo 'green' "dd if=mini.iso of=/dev/sda"
    _echo 'green' "mkdir /mnt/iso"
    _echo 'green' "mount mini.iso /mnt/iso"
    _echo 'green' "echo \"\""
    echo ""
    _echo 'red' "=================================="
    echo ""

    echo "Copying script into linode script ${SCRIPT_PATH}/dns/linode... "
    {
      echo "#!/bin/bash"
      echo "wget -O mini.iso ${file_direct_link}"
      echo "dd if=mini.iso of=/dev/sda"
      # Need this option to reboot when reboot check
      echo "reboot -f"
      echo "exit 0"
    } >"${SCRIPT_PATH}/dns/linode/rescue_write.sh"

    echo "Removing working directory ..."
    rm -rf "${isodir_write}"

  else

    _echo "$(msg red)Error, unknown action passed for iso_api ${action}$(msg end)" --name --verbose 3
    _exit 147
  fi

}

copy_local_dns_to_external_dns() {
  local domain a_records aaaa_records cname_records txt_records ns_records mx_records
  domain="$1"

  if [ "${DNS_PROVIDER_NAME}" == "linode" ]; then
    _echo "$(msg cyan)Creating domain ${domain} in linode with --rebuild option ...$(msg end)" --name
    linode_api_admin create-domain --domain-type "master" --domain "${domain}" --domain-email "webmaster@${domain}" --domain-ttl 30 --rebuild
    echo ""

    # Here we can create DNS records (we should scan all the records exists in test.domain.com and add them one by one into external DNS)
    # Important notes, this NS record is special in directadmin it does not show up in directadmin DNS management as A or AAAA records,
    # but if you query using API, you will get NS record at A and AAAA records.
    # NS record also can be found in ns_records call below with NS record type
    a_records=$(da_api_admin get-dns-records --domain "${domain}" --special-type "a" --scripting)
    aaaa_records=$(da_api_admin get-dns-records --domain "${domain}" --special-type "aaaa" --scripting)
    cname_records=$(da_api_admin get-dns-records --domain "${domain}" --special-type "cname" --scripting)
    txt_records=$(da_api_admin get-dns-records --domain "${domain}" --special-type "txt" --scripting)
    ns_records=$(da_api_admin get-dns-records --domain "${domain}" --special-type "ns" --scripting)
    mx_records=$(da_api_admin get-dns-records --domain "${domain}" --special-type "mx" --scripting)
    # We are not interested with this record yet
    #  srv_records=$(da_api_admin get-dns-records --domain "${domain}" --special-type "srv" --scripting)
    #  caa_records=$(da_api_admin get-dns-records --domain "${domain}" --special-type "caa" --scripting)
    #  ptr_records=$(da_api_admin get-dns-records --domain "${domain}" --special-type "ptr" --scripting)

    echo ""
    # For A record
    if [ -n "${a_records}" ]; then
      _echo "$(msg cyan)Adding all A records in linode ...$(msg end)" --name

      #echo "A record not empty"
      #echo "a record: "
      #echo "${a_records}"
      #echo "record length: "
      # total_record=$(echo "${a_records}" | jq -r ".type" | wc -w)
      # For record name
      readarray -t record <<<$(echo "${a_records}" | jq -r ".name")
      # For record value
      readarray -t record2 <<<$(echo "${a_records}" | jq -r ".value")

      _echo "" --plain --verbose 7
      _echo "record name:" --plain --verbose 7
      _echo "${record[@]}" --plain --verbose 7
      _echo "" --plain --verbose 7
      _echo "record value:" --plain --verbose 7
      _echo "${record2[@]}" --plain --verbose 7
      _echo "" --plain --verbose 7

      for i in "${!record[@]}"; do
        local record_name record_value
        record_name="${record[i]}"
        # This one fixed the dot character of the ending domain
        if [[ "$(echo "${record_name: -1}")" == "." ]]; then
          echo "Fixing record[$i] that contains dot character: ${record[$i]} ..."
          record_name=$(echo "${record_name}" | sed 's/.$//')
          echo "Record record[$i] is now set as ${record_name}"
          echo ""
        fi
        record_value="${record2[i]}"

        echo "record_name is ${record_name}"
        echo "record_value is ${record_value}"
        echo ""
        linode_api_admin add-dns-record --domain "${domain}" --record-type "A" --record-name "${record_name}" --record-value "${record_value}" --record-ttl 30
        echo ""
      done
    else
      _echo "$(msg yellow)Notice, no A record is found$(msg end)" --name

    fi

    echo ""
    # For AAAA record
    if [ -n "${aaaa_records}" ]; then
      _echo "$(msg cyan)Adding all AAAA records in linode ...$(msg end)" --name
      # For record name
      readarray -t record <<<$(echo "${aaaa_records}" | jq -r ".name")
      # For record value
      readarray -t record2 <<<$(echo "${aaaa_records}" | jq -r ".value")

      _echo "" --plain --verbose 7
      _echo "record name:" --plain --verbose 7
      _echo "${record[@]}" --plain --verbose 7
      _echo "" --plain --verbose 7
      _echo "record value:" --plain --verbose 7
      _echo "${record2[@]}" --plain --verbose 7
      _echo "" --plain --verbose 7

      for i in "${!record[@]}"; do
        local record_name record_value
        record_name="${record[i]}"
        # This one fixed the dot character of the ending domain
        if [[ "$(echo "${record_name: -1}")" == "." ]]; then
          echo "Fixing record[$i] that contains dot character: ${record[$i]} ..."
          record_name=$(echo "${record_name}" | sed 's/.$//')
          echo "Record record[$i] is now set as ${record_name}"
          echo ""
        fi
        record_value="${record2[i]}"
        linode_api_admin add-dns-record --domain "${domain}" --record-type "AAAA" --record-name "${record_name}" --record-value "${record_value}" --record-ttl 30
        echo ""
      done
    else
      _echo "$(msg yellow)Notice, no AAAA record is found$(msg end)" --name

    fi

    echo ""

    # For CNAME record
    if [ -n "${cname_records}" ]; then
      _echo "$(msg cyan)Adding all CNAME records in linode ...$(msg end)" --name
      # For record name
      readarray -t record <<<$(echo "${cname_records}" | jq -r ".name")
      # For record value
      readarray -t record2 <<<$(echo "${cname_records}" | jq -r ".value")

      _echo "" --plain --verbose 7
      _echo "record name:" --plain --verbose 7
      _echo "${record[@]}" --plain --verbose 7
      _echo "" --plain --verbose 7
      _echo "record value:" --plain --verbose 7
      _echo "${record2[@]}" --plain --verbose 7
      _echo "" --plain --verbose 7

      for i in "${!record[@]}"; do
        local record_name record_value
        record_name="${record[i]}"
        # This one fixed the dot character of the ending domain
        if [[ "$(echo "${record_name: -1}")" == "." ]]; then
          echo "Fixing record[$i] that contains dot character: ${record[$i]} ..."
          record_name=$(echo "${record_name}" | sed 's/.$//')
          echo "Record record[$i] is now set as ${record_name}"
          echo ""
        fi
        record_value="${record2[i]}"
        linode_api_admin add-dns-record --domain "${domain}" --record-type "CNAME" --record-name "${record_name}" --record-value "${record_value}" --record-ttl 30
        echo ""
      done
    else
      _echo "$(msg cyan)Notice, no CNAME record is found$(msg end)" --name

    fi
    echo ""
    # For TXT record
    if [ -n "${txt_records}" ]; then
      _echo "$(msg cyan)Adding all TXT records in linode ...$(msg end)" --name
      # For record name
      readarray -t record <<<$(echo "${txt_records}" | jq -r ".name")
      # For record value
      readarray -t record2 <<<$(echo "${txt_records}" | jq -r ".value")

      _echo "" --plain --verbose 7
      _echo "record name:" --plain --verbose 7
      _echo "${record[@]}" --plain --verbose 7
      _echo "" --plain --verbose 7
      _echo "record value:" --plain --verbose 7
      _echo "${record2[@]}" --plain --verbose 7
      _echo "" --plain --verbose 7
      #exit 1
      for i in "${!record[@]}"; do
        local record_name record_value
        record_name="${record[i]}"
        # This one fixed the dot character of the ending domain
        if [[ "$(echo "${record_name: -1}")" == "." ]]; then
          echo "Fixing record[$i] that contains dot character: ${record[$i]} ..."
          record_name=$(echo "${record_name}" | sed 's/.$//')
          echo "Record record[$i] is now set as ${record_name}"
          echo ""
        fi
        # Important must remove double quote for TXT record value because linode does not accept double quote as valid record
        record_value=$(echo "${record2[i]}" | sed -e 's/^"//' -e 's/"$//')
        echo "record_name is ${record_name}"
        echo "record_value is ${record_value}"
        echo ""
        linode_api_admin add-dns-record --domain "${domain}" --record-type "TXT" --record-name "${record_name}" --record-value "${record_value}" --record-ttl 30
        echo ""
      done
    else
      _echo "$(msg yellow)Notice, no TXT record is found$(msg end)" --name

    fi

    echo ""

    # For NS record
    if [ -n "${ns_records}" ]; then

      _echo "$(msg cyan)Adding all NS records in linode ...$(msg end)" --name
      # For record name
      readarray -t record <<<$(echo "${ns_records}" | jq -r ".name")
      # For record value
      readarray -t record2 <<<$(echo "${ns_records}" | jq -r ".value")

      _echo "" --plain --verbose 7
      _echo "record name:" --plain --verbose 7
      _echo "${record[@]}" --plain --verbose 7
      _echo "" --plain --verbose 7
      _echo "record value:" --plain --verbose 7
      _echo "${record2[@]}" --plain --verbose 7
      _echo "" --plain --verbose 7

      for i in "${!record[@]}"; do
        local record_name record_value
        record_name="${record[i]}"
        record_value="${record2[i]}"
        # This one fixed the dot character of the ending domain
        if [[ "$(echo "${record_name: -1}")" == "." ]]; then
          echo "Fixing record[$i] that contains dot character: ${record[$i]} ..."
          record_name=$(echo "${record_name}" | sed 's/.$//')
          echo "Record record[$i] is now set as ${record_name}"
          echo ""

        fi
        if [[ "$(echo "${record_value: -1}")" == "." ]]; then
          echo "Fixing record2[$i] that contains dot character: ${record2[$i]} ..."
          record_value=$(echo "${record_value}" | sed 's/.$//')
          echo "Record record2[$i] is now set as ${record_value}"
          echo ""
        fi

        linode_api_admin add-dns-record --domain "${domain}" --record-type "NS" --record-name "${record_name}" --record-value "${record_value}" --record-ttl 30
        echo ""
      done
    else
      _echo "$(msg yellow)Notice, no NS record is found$(msg end)" --name

    fi

    echo ""
    echo "${mx_records}"
    if [ -n "${mx_records}" ]; then
      _echo "$(msg cyan)Adding all MX records in linode ...$(msg end)" --name
      # For record name
      readarray -t record <<<$(echo "${mx_records}" | jq -r ".name")
      # For record value
      readarray -t record2 <<<$(echo "${mx_records}" | jq -r ".value")

      _echo "" --plain --verbose 7
      _echo "record name:" --plain --verbose 7
      _echo "${record[@]}" --plain --verbose 7
      _echo "" --plain --verbose 7
      _echo "record value (priority):" --plain --verbose 7
      _echo "${record2[@]}" --plain --verbose 7
      _echo "" --plain --verbose 7

      for i in "${!record[@]}"; do
        local record_value record_name record_priority
        record_value="${record[i]}"
        # record_name="${record2[i]}"

        if [[ "$(echo "${record_value: -1}")" == "." ]]; then

          echo "Fixing record[$i] that contains dot character: ${record_value} ..."
          record_value=$(echo "${record_value}" | sed 's/.$//')
          echo "Record record[$i] is now set as ${record_value}"

        fi

        record_name="$(echo "${record2[i]}" | awk '{ print $2 }')"

        if [[ "$(echo "${record_name: -1}")" == "." ]]; then
          echo "Fixing record_name that contains dot character: ${record_name} ..."
          record_name=$(echo "${record_name}" | sed 's/.$//')
          echo "Record record_name is now set as ${record_name}"
        fi

        record_priority="$(echo "${record2[i]}" | awk '{ print $1 }')"

        echo "record_name ${record_name}"
        echo "record_value ${record_value}"
        echo "record priority ${record_priority}"

        linode_api_admin add-dns-record --domain "${domain}" --record-type "MX" --record-name "${record_name}" --record-value "${record_value}" --record-priority "${record_priority}" --record-ttl 30
      done
    else
      _echo "$(msg yellow)Notice, no MX record is found$(msg end)" --name
    fi
    echo ""

  elif
    [ "${DNS_PROVIDER_NAME}" == "digitalocean" ]
  then
    echo "[${SCRIPT_NAME}]: External DNS provider for domain ${domain} is set to digitalocean [Using digitalocean API ...]"
    #Call digitalocean_api_admin
  #elif other provider
  elif [ "${DNS_PROVIDER_NAME}" == "local" ]; then
    echo "[${SCRIPT_NAME}]: External DNS provider for domain ${domain} is set to local"
  # Do nothing because it's local DNS managed by Directadmin
  fi
}

# This is a linode API admin function used to manage linode server
# Use <script_name> --linode-api --help for more information
linode_api_admin() {
  # local variables
  local action retval argnum
  local temp verbose log_level scripting default allow_duplicate_entry \
    linode_label domain domain_type domain_email domain_ttl ip_address \
    record_type record_name record_value record_ttl record_priority \
    label_devsda label_devsdb label_devsdc label_devsdd label_devsde label_devsdf label_devsdg label_devsdh \
    until_status linode_config_label linode_disk_label linode_disk_filetype linode_disk_size linode_config_comments \
    linode_config_virtual_mode linode_config_kernel linode_config_runlevel linode_config_memory_limit linode_config_rootdev \
    linode_config_enable_distro_helper linode_config_disable_update_db linode_config_enable_dep_helper linode_config_automount_devtmpfs \
    linode_config_autoconf_network recovery_mode_shutdown rebuild get_value new_linode_label
  action="$1"
  argnum="$#"
  # This variable linode_max_page is important, when using linode-cli to obtain data, we need to assign limit (required by linode).
  # If we don't, we might not be able to get the correct output. Depends on the record, mine maximum page for record would be 2,
  # if you have long record increase this value (increasing this value affects performance when query but it is recommend to increase this if your DNS records are huge)
  linode_max_page=3

  # This one is not needed, we can allow empty argument for shortcut purpose. Example --linode-api restart
  #if [ ${argnum} -eq 0 ]; then
  #  echo "Error, no argument is supplied. Use [ ${SCRIPT_NAME} --linode-api --help ] to see the valid options"
  #  exit 1
  #fi
  # do not use --type, it is a reserved keyword
  short_opts="hvlqsd"
  long_opts="help,verbose:,log-level:,quiet,scripting,default,allow-duplicate-entry,linode-label:,domain:,domain-type:,domain-email:, \
  domain-ttl:,ip-address:,record-type:,record-name:,record-value:,record-ttl:,record-priority:,label-devsda:,label-devsdb:,label-devsdc:,label-devsdd:,label-devsde:, \
  label-devsdf:,label-devsdg:,label-devsdh:,until-status:,linode-config-label:,linode-disk-label:,linode-disk-filetype:,linode-disk-size:,linode-config-comments:, \
  linode-config-virtual-mode:,linode-config-kernel:,linode-config-runlevel:,linode-config-memory-limit:,linode-config-rootdev:,linode-config-enable-distro-helper, \
  linode-config-disable-update-db, linode-config-enable-dep-helper, linode-config-automount-devtmpfs,linode-config-autoconf-network,recovery-mode-shutdown,rebuild,get-value: \
  new-linode-label:"

  options=$(getopt -o "${short_opts}" --long "${long_opts}" -n "${FUNCNAME[0]}@${action} in ${SCRIPT_NAME}" -- "$@")
  retval=$?
  if [ ${retval} != 0 ]; then
    _echo "$(msg red)Error, invalid parsed data. Terminating...$(msg end)" >&2
    _exit 147
  fi

  # Must quote this option variable
  eval set -- "${options}"
  verbose=6 # default value=6
  log_level="${C_LOG_VERBOSITY_LEVEL}}"
  scripting=false
  default=false
  allow_duplicate_entry=false
  linode_label=""                            # server.test.com, myserver, mybigserver (recommend to use server domain in fqdn format eg: server.test.com).
  domain=""                                  # test.com
  domain_type=""                             # master, slave
  domain_email=""                            # user@test.com
  domain_ttl=""                              # 30s 120(2m), 300(5m), 3600(1h), 7200(2h), 14400(4h), 28800(8h), 57600(16h), 0/86400(1d)-Default, 172800(2d), 345600(4d), 691200(8d), 604800(1w), 1209600(2w), 2419200(4w).
  record_type=""                             # a, aaaa, txt, ns, mx, cname, srv, caa
  record_name=""                             # _key.test.com
  record_value=""                            # 2(,@s*passWok
  record_ttl=""                              # 30s 120(2m), 300(5m), 3600(1h), 7200(2h), 14400(4h), 28800(8h), 57600(16h), 0/86400(1d)-Default, 172800(2d), 345600(4d), 691200(8d), 604800(1w), 1209600(2w), 2419200(4w).
  record_priority=""                         # 0-255 - 10 is mostly default value
  label_devsda=""                            # OS_Disk, Backup_Volume, Anything
  label_devsdb=""                            # OS_Disk, Backup_Volume, Anything
  label_devsdc=""                            # OS_Disk, Backup_Volume, Anything
  label_devsdd=""                            # OS_Disk, Backup_Volume, Anything
  label_devsde=""                            # OS_Disk, Backup_Volume, Anything
  label_devsdf=""                            # OS_Disk, Backup_Volume, Anything
  label_devsdg=""                            # OS_Disk, Backup_Volume, Anything
  label_devsdh=""                            # OS_Disk, Backup_Volume, Anything
  until_status=""                            # OS_Disk, Backup_Volume, Anything
  linode_config_label=""                     # Boot_Config, OS_Config, Anything
  linode_disk_label=""                       # OS_Disk, My_Disk, Anything
  linode_disk_filetype=""                    # raw, swap, ext3, ext4, initrd
  linode_disk_size=""                        # 1MB 2GB 3TB (Minimum supporting unit is MB - same as linode, Max supporting unit is TB), if no unit specified by default is MB
  linode_config_comments=""                  # This is a config profile ABC
  linode_config_virtual_mode="paravirt"      # paravirt, fullvirt. The default value is paravirt if not set
  linode_config_kernel="linode/latest-64bit" # linode/direct-disk (this is and example of the ID for direct disk kernel). Default if not specified is linode/latest-64bit. To get more kernel ID, run linode-cli kernels list
  linode_config_runlevel="default"           # default, single, binbash. The default value if not specified is default
  linode_config_memory_limit=""              # maximum RAM is default to RAM SIZE of the system from Config File
  linode_config_rootdev="/dev/sda"           # /dev/sda, /dev/sdb, /custom_path. If not specified default value is /dev/sda
  linode_config_enable_distro_helper=false   # default value in linode is true but here i should make it false
  linode_config_disable_update_db=false      # default value in linode is true but here i should make it false
  linode_config_enable_dep_helper=false      # default value in linode is true but here i should make it false
  linode_config_automount_devtmpfs=false     # default value in linode is true but here i should make it false
  linode_config_autoconf_network=false       # default value in linode is true but here i should make it false
  recovery_mode_shutdown=false
  rebuild=false
  ip_address=""       # 1.2.3.4
  get_value=""        # rdns, type
  new_linode_label="" # test.server.com
  while true; do
    case "$1" in
    -h | --help)
      manual "${FUNCNAME[0]}"
      shift
      exit 0
      ;;
    -v | --verbose)
      verbose="$2"
      shift 2
      ;;
    -l | --log-level)
      log_level="$2"
      C_LOG_VERBOSITY_LEVEL="${log_level}"
      [[ ${C_LOG_VERBOSITY_LEVEL} == "8" ]] && set -x
      shift 2
      ;;
    -q | --quiet)
      verbose=-1
      set +x
      shift
      ;;
    -s | --scripting)
      verbose=-1
      set +x
      scripting=true
      shift
      ;;
    -d | --default)
      default=true
      shift
      ;;
    --allow-duplicate-entry)
      allow_duplicate_entry=true
      shift
      ;;
    --domain)
      domain="$2"
      shift 2
      ;;
    --domain-type)
      domain_type="$2"
      shift 2
      ;;
    --domain-email)
      domain_email="$2"
      shift 2
      ;;
    --domain-ttl)
      domain_ttl="$2"
      shift 2
      ;;
    --record-type)
      record_type="$2"
      record_type="${record_type^^}"
      shift 2
      ;;
    --record-name)
      record_name="$2"
      shift 2
      ;;
    --record-value)
      record_value="$2"
      shift 2
      ;;
    --record-ttl)
      record_ttl="$2"
      shift 2
      ;;
    --record-priority)
      record_priority="$2"
      shift 2
      ;;
    --linode-label)
      linode_label="$2"
      shift 2
      ;;
    --label-devsda)
      label_devsda="$2"
      echo "label_devsda: ${label_devsda}"
      shift 2
      ;;
    --label-devsdb)
      label_devsdb="$2"
      echo "label_devsdb: ${label_devsdb}"
      shift 2
      ;;
    --label-devsdc)
      label_devsdc="$2"
      echo "label_devsdc: ${label_devsdc}"
      shift 2
      ;;
    --label-devsdd)
      label_devsdd="$2"
      echo "label_devsdd: ${label_devsdd}"
      shift 2
      ;;
    --label_devsde)
      label_devsde="$2"
      echo "label_devsde: ${label_devsde}"
      shift 2
      ;;
    --label-devsdf)
      label_devsdf="$2"
      echo "label_devsdf: ${label_devsdf}"
      shift 2
      ;;
    --label-devsdg)
      label_devsdg="$2"
      echo "label_devsdg: ${label_devsdg}"
      shift 2
      ;;
    --label-devsdh)
      label_devsdh="$2"
      echo "label_devsdh: ${label_devsdh}"
      shift 2
      ;;
    --until-status)
      until_status="$2"
      shift 2
      ;;
    --linode-config-label)
      linode_config_label="$2"
      shift 2
      ;;
    --linode-disk-label)
      linode_disk_label="$2"
      shift 2
      ;;
    --linode-disk-filetype)
      linode_disk_filetype="$2"
      shift 2
      ;;
    --linode-disk-size)
      linode_disk_size="$2"
      temp="${linode_disk_size}"
      # can be 10MB 10 MB or MB10 or MB 10
      # If mistaken input this 10 MB s = 10 s (invalid)
      # If mistaken input this 10 MB GB = 10 GB (valid), it will ignore the first unit
      linode_disk_size=$(echo "${temp}" | grep -Eo '[0-9]+' | tail -n1)
      linode_disk_unit=$(echo "${temp}" | grep -Eo '[[:alpha:]]+' | tail -n1)

      if [ -z "${linode_disk_unit}" ]; then
        linode_disk_unit="MB"
      fi
      if [[ "${linode_disk_unit^^}" == +(MB) ]]; then
        :
      elif [[ "${linode_disk_unit^^}" == +(GB) ]]; then
        ((linode_disk_size = linode_disk_size * 1000))
      elif [[ "${linode_disk_unit^^}" == +(TB) ]]; then
        ((linode_disk_size = linode_disk_size * 1000000))
      fi
      shift 2
      ;;
    --linode-config-comments)
      linode_config_comments="$2"
      shift 2
      ;;
    --linode-config-virtual-mode)
      linode_config_virtual_mode="$2"
      # TODO Validate this in ifelse only 2 values can be used
      shift 2
      ;;
    --linode-config-kernel)
      linode_config_kernel="$2"
      shift 2
      ;;
    --linode-config-runlevel)
      linode_config_runlevel="$2"
      shift 2
      ;;
    --linode-config-memory-limit)
      linode_config_memory_limit="$2"
      shift 2
      ;;
    --linode-config-rootdev)
      linode_config_rootdev="$2"
      shift 2
      ;;
    --linode-config-enable-distro-helper)
      linode_config_enable_distro_helper=true
      shift
      ;;
    --linode-config-disable-update-db)
      linode_config_disable_update_db=true
      shift
      ;;
    --linode-config-enable-dep-helper)
      linode_config_enable_dep_helper=true
      shift
      ;;
    --linode-config-automount-devtmpfs)
      linode_config_automount_devtmpfs=true
      shift
      ;;
    --linode-config-autoconf-network)
      linode_config_autoconf_network=true
      shift
      ;;
    --recovery-mode-shutdown)
      recovery_mode_shutdown=true
      shift
      ;;
    --rebuild)
      rebuild=true
      shift
      ;;
    --ip-address)
      ip_address="$2"
      shift 2
      ;;
    --get-value)
      get_value="$2"
      shift 2
      ;;
    --new-linode-label)
      new_linode_label="$2"
      shift 2
      ;;
    --)
      shift
      break
      ;;
    -*)
      opt="$1"
      echo "Invalid option ${opt}. Use --help to see the valid options"
      exit 147
      ;;
    *)
      break
      ;;
    esac
  done
  [[ ${scripting} == "false" ]] && exec_time start "linode_api_admin"
  # Package requirement installation for using linode:
  # python3-pip is for running pip3 command
  # autoconf is used to install make package (we want to install this https://github.com/vyos/ipaddrcheck)
  required "ubuntu@@apt:bind9-host,python3-pip,jq,autoconf" "debian@@apt:bind9-host,python3-pip,jq,autoconf"
  if ! command -v linode-cli &>/dev/null; then
    [[ ${scripting} == "false" ]] && _echo "Warning, missing linode-cli component. Installing linode-cli ..." --name --verbose 4
    [[ ${scripting} == "false" ]] && _echo "$(pip3 install linode-cli --upgrade)" --name --verbose 5
    C_PIP_ALWAYS_UPDATE=false
  else
    if [ "${C_PIP_ALWAYS_UPDATE}" == "true" ]; then
      # We do this on silent mode
      [[ ${scripting} == "false" ]] && _echo "Updating linode-cli to use new API version ..." --name --verbose 7
      # This will resolve this common issue: https://www.linode.com/community/questions/18361/linode-cli-version-mismatch
      [[ ${scripting} == "false" ]] && _echo "$(pip3 install linode-cli --upgrade)" --name --verbose 7 #--quiet
      C_PIP_ALWAYS_UPDATE=false
      [[ ${scripting} == "false" ]] && _echo "" --plain

    fi
  fi
  if [ ! -s /root/.config/linode-cli ]; then
    [[ ${scripting} == "false" ]] && _echo "$(msg yellow)Warning, linode-cli API config is missing. Writing linode-cli API config at /root/.config/linode-cli ...$(msg end)" --name --verbose 4
    mkdir -p /root/.config
    touch /root/.config/linode-cli
    {
      echo "[DEFAULT]"
      echo "default-user = ${DNS_PROVIDER_USER}"
      echo "[${DNS_PROVIDER_USER}]"
      echo "token = ${DNS_PROVIDER_API_KEY}"
    } >/root/.config/linode-cli
  fi
  # Important: The command linode-cli -v needs linode-cli config completely configured. That means, /root/.config/linode-cli must exist:
  # linode-cli -v
  # Do another check for linode-cli and assign a variable for it. We will use this variable to run linode-cli
  if command -v linode-cli &>/dev/null; then
    LINODE_CLI_BIN=$(command -v linode-cli)
  else
    _echo "$(msg yellow)Warning, unable to find [ linode-cli ] binary. Please manually inspect why$(msg end)" --name --verbose 4
    _exit 1
  fi
  # Do another check for jq for the second time and assign a variable for it. We will use this variable to run jq
  if command -v jq &>/dev/null; then
    JQ_BIN=$(command -v jq)
  else
    _echo "$(msg yellow)Warning, unable to find [ jq ] binary. Please manually inspect why$(msg end)" --name --verbose 4
    _exit 1
  fi
  # Example: maxinet --linode-api get-linode-id --linode-label server.test.com
  # For more info use maxinet --linode-api --help
  # return code 2 = empty result
  if [[ "${action}" == "get-linode-id" ]]; then
    # This scope is completed
    local return_label
    # ===== VALIDATION =====
    # Validate linode label (linode label should renamed as FQDN), it will just give warning as suggestion (not exit)

    if is_valid domain "${linode_label}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --linode-label $(msg red)${linode_label}$(msg green) is valid FQDN$(msg end)" --name --verbose 7
    else
      # This text is just a warning about the --linode-label that should be FQDN format (no return or exit). For warning use --verbose=4
      [[ ${scripting} == "false" ]] && _echo "$(msg yellow)Warning, the given --linode-label $(msg red)${linode_label}$(msg green) is not FQDN. It is recommend to name it as FQDN$(msg end)" --name --verbose 4
    fi
    if [ -z "${linode_label}" ]; then
      _echo "$(msg red)Error, --linode-label is empty. Please, provide --linode-label (eg: --linode-label test.domain.com)!$(msg end)" --name --verbose 3
      # Show total running time before exit this scope
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi
    [[ ${scripting} == "false" ]] && _echo "$(msg cyan)Getting linode ID for ${linode_label} ...$(msg end)" --name --verbose 7
    return_label=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings linodes list | ${JQ_BIN} ".[] | select(.label == \"${linode_label}\") | .id")
    if [ -n "${return_label}" ]; then
      echo "${return_label}"
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 0
    else
      _echo "$(msg red)Error, no linode label found for $(msg red)--linode-label ${linode_label}$(msg end)" --name --verbose 3
      # Show total running time before exit this scope
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi
    [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
    # maxinet --linode-api get-linode-status test.server.com
    # return status: 1=online, 2=rebooting, 3=offline
  elif [[ "${action}" == "get-linode-status" ]]; then
    # This scope is completed
    local linode_status
    # ===== VALIDATION =====
    # Validate linode label (linode label should renamed as FQDN), it will just give warning as suggestion (not exit)
    if is_valid domain "${linode_label}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --linode-label $(msg red)${linode_label}$(msg green) is valid FQDN$(msg end)" --name --verbose 7
    else
      # This text is just a warning about the --linode-label that should be FQDN format (no return or exit). For warning use --verbose=4
      [[ ${scripting} == "false" ]] && _echo "$(msg yellow)Warning, the given --linode-label $(msg red)${linode_label}$(msg green) is not FQDN. It is recommend to name it as FQDN$(msg end)" --name --verbose 4
    fi
    if [ -z "${linode_label}" ]; then
      _echo "$(msg red)Error, --linode-label is empty. Please, provide --linode-label (eg: --linode-label test.domain.com)!$(msg end)" --name --verbose 3
      # Show total running time before exit this scope
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi
    [[ ${scripting} == "false" ]] && _echo "$(msg cyan)Getting linode status for ${linode_label} ...$(msg end)" --name --verbose 7
    linode_status=$(${LINODE_CLI_BIN} --pretty --json linodes list | ${JQ_BIN} -r ".[] | select(.label == \"${linode_label}\") | .status")
    if [ -n "${linode_status}" ]; then
      # Here is the result for linode status:
      echo "${linode_status}"
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      # Special return code
      if [ "${linode_status}" == "running" ]; then
        return 1
      elif [ "${linode_status}" == "rebooting" ]; then
        return 2
      elif [ "${linode_status}" == "offline" ]; then
        return 3
      else
        # Unknown code
        return 129
      fi
    else
      _echo "$(msg red)Error, no linode status found for --linode-label $(msg yellow)${linode_label}$(msg end)" --name --verbose 3
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi
    # maxinet --linode-api get-domain-id server.com
    # return code 147 = error, return code 0 = success
  elif [[ "${action}" == "get-domain-id" ]]; then
    # This scope is completed and has perfect conditional for returning values
    local domain_id
    # Data validation
    # 1) Domain validation
    if is_valid domain "${domain}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --domain $(msg red)${domain}$(msg green) is valid FQDN$(msg end)" --name --verbose 7
    else
      _echo "$(msg yellow)Warning, the given --domain $(msg red)${domain}$(msg green) is not FQDN$(msg end)" --name --verbose 4
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi
    domain_id=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains list | ${JQ_BIN} ".[] | select(.domain == \"${domain}\") | .id")
    if [ -n "${domain_id}" ]; then
      # Here is the result for domain ID:
      echo "${domain_id}"
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 0
    else
      _echo "$(msg red)Error, no domain ID is found for --domain $(msg red)${domain}$(msg end)" --name --verbose 3
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi
  # linode_api_admin create-domain --domain test.com --domain-type master --domain-email webmaster@test.com --domain-ttl 30 --rebuild
  elif [[ ${action} == "create-domain" || ${action} == "add-domain" ]]; then
    local retval=1
    # Default values (if --default options is enabled)
    if [[ ${default} == true ]]; then
      [[ ${scripting} == "false" ]] && _echo "$(msg yellow)The option --default is set. The following options will have default values as follow: $(msg end)" --name
      if [ -z "${domain_type}" ]; then
        [[ ${scripting} == "false" ]] && _echo "$(msg cyan)--domain-type=master$(msg end)" --name
        domain_type="master"
      fi
      if [ -z "${domain_email}" ]; then
        [[ ${scripting} == "false" ]] && _echo "$(msg cyan)--domain-email=webmaster@${domain}$(msg end)" --name
        domain_email="webmaster@${domain}"
      fi

      if [ -z "${domain_ttl}" ]; then
        [[ ${scripting} == "false" ]] && _echo "$(msg cyan)--domain-ttl=30$(msg end)" --name
        domain_ttl="30"
      fi
    fi

    # Data validation
    # 1) Validate domain name

    if is_valid domain "${domain}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --domain $(msg red)${domain}$(msg green) is FQDN$(msg end)" --name --verbose 7
    else
      _echo "$(msg yellow)Warning, the given --domain $(msg red)${domain}$(msg green) is not FQDN$(msg end)" --name --verbose 4
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi

    #2) Validate domain type
    if is_valid "domain_type" "${domain_type}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --domain-type $(msg red)${domain_type}$(msg green) is valid$(msg end)" --name --verbose 7
    else
      _echo "$(msg yellow)Warning, the given --domain-type $(msg red)${domain_type}$(msg green) is not valid$(msg end)" --name
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi

    #3 ) Validate domain email
    if is_valid "email" "${domain_email}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --domain-email $(msg red)${domain_email}$(msg green) is valid$(msg end)" --name --verbose 7
    else
      _echo "$(msg yellow)Warning, the given --domain-email $(msg red)${domain_email}$(msg green) is not valid$(msg end)" --name
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi

    #4) Validate domain ttl
    if is_valid "domain_ttl" "${domain_ttl}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --domain-ttl $(msg red)${domain_ttl}$(msg green) is valid$(msg end)" --name --verbose 7
    else
      _echo "$(msg yellow)Warning, the given --domain-ttl $(msg red)${domain_ttl}$(msg green) is not valid$(msg end)" --name
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi

    # If using --rebuild option we must delete this domain first if exist
    if [ "${rebuild}" == "true" ]; then
      _echo "$(msg yellow)The option --rebuild is enabled. The existing domain ${domain} will be deleted (if found) before creating a new one$(msg end)" --name

      [[ ${scripting} == "false" ]] && _echo "Getting required domain ID for --domain ${domain} ..." --name --verbose 7
      domain_id=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains list | ${JQ_BIN} ".[] | select(.domain == \"${domain}\") | .id")

      if [ -z "${domain_id}" ]; then
        _echo "$(msg green)OK, no domain ID found for --domain ${domain}$(msg end)"
      else

        [[ ${scripting} == "false" ]] && _echo "$(msg cyan)Found existing domain ${domain}. Deleting domain $(msg red)${domain}$(msg end) $(msg cyan)...$(msg end)" --name
        if [[ ${scripting} == "false" ]]; then
          ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains delete "${domain_id}"
        else
          ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains delete "${domain_id}" &>/dev/null
        fi
      fi
    fi

    [[ ${scripting} == "false" ]] && _echo "$(msg cyan)Creating domain $(msg red)${domain}$(msg end) $(msg cyan)...$(msg end)" --name
    if [[ ${scripting} == "false" ]]; then
      ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains create --domain "${domain}" --type "${domain_type}" --soa_email "${domain_email}" --ttl_sec "${domain_ttl}"
      retval=$?
    else
      ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains create --domain "${domain}" --type "${domain_type}" --soa_email "${domain_email}" --ttl_sec "${domain_ttl}" &>/dev/null
      retval=$?
    fi

    if [ "${retval}" -eq 0 ]; then
      echo "success"
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 0
    else
      _echo "$(msg red)[${retval}] Error, something wrong when creating domain $(msg red)${domain}!$(msg end)" --name --verbose 3
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return ${retval}
    fi
    # da_api_admin delete-domain --domain sofibox.com
  elif [[ "${action}" == "delete-domain" || "${action}" == "remove-domain" ]]; then
    local domain_id retval=1
    # Data validation
    # 1) Validate domain name

    [[ ${scripting} == "false" ]] && _echo "Getting required domain ID for --domain ${domain} ..." --name --verbose 7
    domain_id=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains list | ${JQ_BIN} ".[] | select(.domain == \"${domain}\") | .id")

    if [ -z "${domain_id}" ]; then
      _echo "$(msg red)Error, no domain ID found for --domain ${domain}$(msg end)"
      return 147
    fi

    [[ ${scripting} == "false" ]] && _echo "$(msg cyan)Deleting domain $(msg red)${domain}$(msg end) $(msg cyan)...$(msg end)" --name
    if [[ ${scripting} == "false" ]]; then
      ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains delete "${domain_id}"
      retval=$?
    else
      ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains delete "${domain_id}" &>/dev/null
      retval=$?
    fi

    if [ "${retval}" -eq 0 ]; then
      echo "success"
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 0
    else
      _echo "$(msg red)[${retval}] Error, something wrong when deleting domain $(msg red)${domain}!$(msg end)" --name --verbose 3
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return ${retval}
    fi
  elif [[ "${action}" == "create-domain-record" || "${action}" == "add-domain-record" || "${action}" == "create-dns-record" || "${action}" == "add-dns-record" ]]; then
    local domain_id retval=1
    # Data validation
    # 1) Validate domain name

    [[ ${scripting} == "false" ]] && _echo "Getting required domain ID for --domain ${domain} ..." --name --verbose 7
    domain_id=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains list | ${JQ_BIN} ".[] | select(.domain == \"${domain}\") | .id")

    if [ -z "${domain_id}" ]; then
      _echo "$(msg red)Error, no domain ID found for --domain ${domain}$(msg end)"
      return 147
    fi
    # This validation argument required for all (put here to not redundant the codes)
    if is_valid domain "${domain}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --domain $(msg red)${domain}$(msg green) is FQDN$(msg end)" --name --verbose 7
    else
      _echo "$(msg yellow)Warning, the given --domain $(msg red)${domain}$(msg green) is not FQDN$(msg end)" --name --verbose 4
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi

    if is_valid record_type "${record_type}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --record-type $(msg red)${record_type}$(msg green) is valid$(msg end)" --name --verbose 7
    else
      _echo "$(msg yellow)Warning, the given --record-type $(msg red)${record_type}$(msg green) is not valid$(msg end)" --name --verbose 4
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi

    if is_valid "record_ttl" "${record_ttl}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --record-ttl $(msg red)${record_ttl}$(msg green) is valid$(msg end)" --name --verbose 7
    else
      _echo "$(msg yellow)Warning, the given --record-ttl $(msg red)${record_ttl}$(msg green) is not valid$(msg end)" --name
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi

    # For adding linode TXT record, record name is considered as hostname whereas record value is considered as record value
    # record name and record value can be empty
    # If we specify the value for record name, it must not contains invalid character

    if [ "${record_type}" == "TXT" ]; then
      # Scope completed v1
      if is_valid server_record_valid_character "${record_name}"; then
        [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --record-name $(msg red)${record_name}$(msg green) is valid character$(msg end)" --name --verbose 7
      else
        _echo "$(msg yellow)Warning, the given --record-name $(msg red)${record_name}$(msg green) is not valid character$(msg end)" --name --verbose 4
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      fi
      [[ ${scripting} == "false" ]] && _echo "$(msg cyan)Creating TXT record name $(msg red)[${record_name}]$(msg end) $(msg cyan)...$(msg end)" --name

      if [[ ${scripting} == "false" ]]; then
        ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains records-create "${domain_id}" --type "${record_type}" --name "${record_name}" \
          --target "${record_value}" --ttl_sec "${record_ttl}"
        retval=$?
      else
        ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains records-create "${domain_id}" --type "${record_type}" --name "${record_name}" \
          --target "${record_value}" --ttl_sec "${record_ttl}" &>/dev/null
        retval=$?
      fi
    # linode_api_admin add-dns-record --domain test.com --record-name mail --record-value sofibox.com. --record-priority 10 --record-ttl 30
    elif [ "${record_type}" == "MX" ]; then
      # Scope completed v1
      if is_valid server_record_valid_character "${record_name}"; then
        [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --record-name $(msg red)${record_name}$(msg green) (for name server) is valid character$(msg end)" --name --verbose 7
      else
        _echo "$(msg yellow)Warning, the given --record-name $(msg red)${record_name}$(msg green) (for name server) is not valid character$(msg end)" --name --verbose 4
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      fi

      if is_valid server_record_valid_character "${record_value}"; then
        [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --record-value $(msg red)${record_value}$(msg green) (for subdomain) is FQDN and valid character$(msg end)" --name --verbose 7
      else
        _echo "$(msg yellow)Warning, the given --record-value $(msg red)${record_value}$(msg green) (for subdomain) is not FQDN or valid character$(msg end)" --name --verbose 4
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      fi

      if is_valid "record_priority" "${record_priority}"; then
        [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --record-priority $(msg red)${record_priority}$(msg green) is valid$(msg end)" --name --verbose 7
      else
        _echo "$(msg yellow)Warning, the given --record-priority $(msg red)${record_priority}$(msg green) is not valid$(msg end)" --name
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      fi

      #linode-cli domains records-create ${sofibox_id} --type MX --name mail --target sofibox.com. --priority 10 --ttl_sec 1
      [[ ${scripting} == "false" ]] && _echo "$(msg cyan)Creating MX record name $(msg red)[${record_name}]$(msg end) $(msg cyan)...$(msg end)" --name

      if [[ ${scripting} == "false" ]]; then
        ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains records-create "${domain_id}" --type "${record_type}" --name "${record_name}" \
          --target "${record_value}" --priority "${record_priority}" --ttl_sec "${record_ttl}"
        retval=$?
      else
        ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains records-create "${domain_id}" --type "${record_type}" --name "${record_name}" \
          --target "${record_value}" --priority "${record_priority}" --ttl_sec "${record_ttl}" &>/dev/null
        retval=$?
      fi
    # In linode, record name is considered as subdomain where as record value is considered as name server
    # the record name (subdomain) is optional but if specified must be valid character for the record.
    # the record value (name server) is required and must be valid FQDN and valid character
    elif [ "${record_type}" == "NS" ]; then
      #Scope completed v1
      # subdomain can be anything except weird character.
      if is_valid server_record_valid_character "${record_name}"; then
        [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --record-name $(msg red)${record_name}$(msg green) (for subdomain) is valid character$(msg end)" --name --verbose 7
      else
        _echo "$(msg yellow)Warning, the given --record-name $(msg red)${record_name}$(msg green) (for subdomain) is not valid character$(msg end)" --name --verbose 4
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      fi
      # This is special we for NS record we check that the record name is FQDN
      if is_valid domain "${record_value}" && is_valid server_record_valid_character "${record_value}"; then
        [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --record-value $(msg red)${record_value}$(msg green) (for name server) is FQDN and valid character$(msg end)" --name --verbose 7
      else
        _echo "$(msg yellow)Warning, the given --record-value $(msg red)${record_value}$(msg green) (for name server) is not FQDN or valid character$(msg end)" --name --verbose 4
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      fi

      [[ ${scripting} == "false" ]] && _echo "$(msg cyan)Creating NS record name $(msg red)[${record_name}]$(msg end) $(msg cyan)...$(msg end)" --name

      if [[ ${scripting} == "false" ]]; then
        ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains records-create "${domain_id}" --type "${record_type}" --name "${record_name}" \
          --target "${record_value}" --ttl_sec "${record_ttl}"
        retval=$?
      else
        ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains records-create "${domain_id}" --type "${record_type}" --name "${record_name}" \
          --target "${record_value}" --ttl_sec "${record_ttl}" &>/dev/null
        retval=$?
      fi
      # Linode use the same entry for A and AAAA
      # linode_api_admin create-dns-record --domain test.com --record-type A --record-name name --record-value value --record-ttl 30
    elif [[ "${record_type}" == "A" ]]; then
      # Extra validation to include wildcard character in DNS record * and @ for root domain
      if [[ $(is_valid server_record_valid_character "${record_name}") -eq 0 || "${record_name}" == "*" ]]; then
        [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --record-name $(msg red)${record_name}$(msg green) (for hostname) is valid character$(msg end)" --name --verbose 7
      else
        _echo "$(msg yellow)Warning, the given --record-name $(msg red)${record_name}$(msg green) (for hostname) is not valid character$(msg end)" --name --verbose 4
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      fi

      if is_valid ipv4 "${record_value}"; then
        [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --record-value $(msg red)${record_value}$(msg green) (for IPv4 address) is valid$(msg end)" --name --verbose 7
      else
        _echo "$(msg yellow)Warning, the given --record-value $(msg red)${record_value}$(msg green) (for IPv4 address) is not valid$(msg end)" --name --verbose 4
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      fi

      [[ ${scripting} == "false" ]] && _echo "$(msg cyan)Creating A record name $(msg red)[${record_name}]$(msg end) $(msg cyan)...$(msg end)" --name

      if [[ ${scripting} == "false" ]]; then
        ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains records-create "${domain_id}" --type "${record_type}" --name "${record_name}" \
          --target "${record_value}" --ttl_sec "${record_ttl}"
        retval=$?
      else
        ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains records-create "${domain_id}" --type "${record_type}" --name "${record_name}" \
          --target "${record_value}" --ttl_sec "${record_ttl}" &>/dev/null
        retval=$?
      fi
      # linode_api_admin create-dns-record --domain test.com --record-type AAAA --record-name name --record-value value --record-ttl 30

    elif [[ "${record_type}" == "AAAA" ]]; then
      # Extra validation to include wildcard character in DNS record * and @ for root domain
      if [[ $(is_valid server_record_valid_character "${record_name}") -eq 0 || "${record_name}" == "*" ]]; then
        [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --record-name $(msg red)${record_name}$(msg green) (for hostname) is valid character$(msg end)" --name --verbose 7
      else
        _echo "$(msg yellow)Warning, the given --record-name $(msg red)${record_name}$(msg green) (for hostname) is not valid character$(msg end)" --name --verbose 4
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      fi

      if is_valid ipv6 "${record_value}"; then
        [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --record-value $(msg red)${record_value}$(msg green) (for IPv6 address) is valid$(msg end)" --name --verbose 7
      else
        _echo "$(msg yellow)Warning, the given --record-value $(msg red)${record_value}$(msg green) (for IPv6 address) is not valid$(msg end)" --name --verbose 4
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      fi

      [[ ${scripting} == "false" ]] && _echo "$(msg cyan)Creating AAAA record name $(msg red)[${record_name}]$(msg end) $(msg cyan)...$(msg end)" --name

      if [[ ${scripting} == "false" ]]; then
        ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains records-create "${domain_id}" --type "${record_type}" --name "${record_name}" \
          --target "${record_value}" --ttl_sec "${record_ttl}"
        retval=$?
      else
        ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains records-create "${domain_id}" --type "${record_type}" --name "${record_name}" \
          --target "${record_value}" --ttl_sec "${record_ttl}" &>/dev/null
        retval=$?
      fi

    elif [ "${record_type}" == "CNAME" ]; then
      # Extra validation to include wildcard character in DNS record * and @ for root domain
      if [[ $(is_valid server_record_valid_character "${record_name}") -eq 0 ]]; then
        [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --record-name $(msg red)${record_name}$(msg green) (for hostname) is valid character$(msg end)" --name --verbose 7
      else
        _echo "$(msg yellow)Warning, the given --record-name $(msg red)${record_name}$(msg green) (for hostname) is not valid character$(msg end)" --name --verbose 4
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      fi

      if [[ $(is_valid server_record_valid_character "${record_value}") -eq 0 ]]; then
        [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --record-value $(msg red)${record_value}$(msg green) (for hostname) is valid character$(msg end)" --name --verbose 7
      else
        _echo "$(msg yellow)Warning, the given --record-value $(msg red)${record_value}$(msg green) (for hostname) is not valid character$(msg end)" --name --verbose 4

        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      fi

      [[ ${scripting} == "false" ]] && _echo "$(msg cyan)Creating CNAME record name $(msg red)[${record_name}]$(msg end) $(msg cyan)...$(msg end)" --name
      if [[ ${scripting} == "false" ]]; then
        ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains records-create "${domain_id}" --type "${record_type}" --name "${record_name}" \
          --target "${record_value}" --ttl_sec "${record_ttl}"
        retval=$?
      else
        ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains records-create "${domain_id}" --type "${record_type}" --name "${record_name}" \
          --target "${record_value}" --ttl_sec "${record_ttl}" &>/dev/null
        retval=$?
      fi

    elif [ "${record_type}" == "SRV" ]; then
      :
    elif [ "${record_type}" == "CAA" ]; then
      :
    elif [ "${record_type}" == "PTR" ]; then
      :
    fi

    if [ ${retval} = 0 ]; then
      echo "success"
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 0
    else
      _echo "$(msg red)[${retval}], something is wrong when executing DNS record into linode DNS management$(msg end)" --name --verbose 3
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return ${retval}
    fi

  # linode_api_admin delete-dns-record --domain test.com --record-type "TXT" --record-name "_domainkey"
  # Note, currently only delete record based on name, type. Might put based on value next time
  elif [[ "${action}" == "delete-dns-record" || "${action}" == "delete-domain-record" ]]; then

    local domain_id retval=1 record_count
    # Data validation
    # 1) Validate domain name

    [[ ${scripting} == "false" ]] && _echo "Getting required domain ID for --domain ${domain} ..." --name --verbose 7
    domain_id=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains list | ${JQ_BIN} ".[] | select(.domain == \"${domain}\") | .id")

    if [ -z "${domain_id}" ]; then
      _echo "$(msg red)Error, no domain ID found for --domain ${domain}$(msg end)"
      return 147
    fi
    # This validation argument required for all (put here to not redundant the codes)
    if is_valid domain "${domain}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --domain $(msg red)${domain}$(msg green) is FQDN$(msg end)" --name --verbose 7
    else
      _echo "$(msg yellow)Warning, the given --domain $(msg red)${domain}$(msg green) is not FQDN$(msg end)" --name --verbose 4
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi

    record_count=1
    while [[ ${record_count} -le ${linode_max_page} ]]; do
      record_ids=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains records-list --page "${record_count}" "${domain_id}" |
        ${JQ_BIN} ".[] | select((.name == \"${record_name}\") and (.type==\"${record_type}\")) \
      | .id")
      # Break if found result for that page
      if [[ -n ${record_ids} ]]; then
        break
      fi
      ((record_count++))
    done

    # Important, dont use -z to check empty record, use -n condition
    # Because if we use -z the record will be counted as 1 even it's an empty line (this record can return an empty line)
    if [[ -n "${record_ids}" ]]; then
      local record_ids_count success_deleted
      record_ids_count=$(echo "${record_ids}" | wc -l)
      echo ""
      _echo "Record deletion details:" --name
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name
      _echo "Record name: ${record_name}" --name
      _echo "Record type: ${record_type}" --name
      _echo "Total record ID found: ${record_ids_count}" --name
      _echo "Record ID found (below):" --name
      echo ""
      _echo "${record_ids}" --plain
      echo ""
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name
      echo ""
      success_deleted=0
      for record_id in ${record_ids}; do
        _echo "$(msg cyan)Deleting record name ${record_name} ( ${record_id} ) ...$(msg end)" --name
        ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains records-delete "${domain_id}" "${record_id}"
        retval=$?
        if [ "${retval}" = 0 ]; then
          _echo "$(msg green)OK, record ${record_name} ( ${record_id} ) has been deleted successfully.$(msg end)" --name
          ((success_deleted++))
        else
          _echo "$(msg red)Error, [${retval}], delete failed for record ${record_name} ( ${record_id} )$(msg end)" --name
        fi
        echo ""
      done

      if [ "${success_deleted}" == "${record_ids_count}" ]; then
        _echo "$(msg green)OK, ${success_deleted} out of ${record_ids_count} record(s) have been successfully deleted$(msg end)" --name

      elif [[ "${success_deleted}" -eq 1 && "${success_deleted}" -lt "${record_ids_count}" ]]; then
        _echo "$(msg yellow)Warning, only ${success_deleted} out of ${record_ids_count} record(s) have been successfully deleted$(msg end)" --name
      else
        _echo "$(msg yellow)Warning, no record has been deleted due to deletion error$(msg end)" --name
      fi
      echo ""
    else
      _echo "$(msg yellow)Warning, record name ${record_name} and type ${record_type} does not exist in domain ${domain}$(msg end)" --name
      return 147
    fi
    # This action is used to check linode status until a specified condition and then it will break
    # Current accepted condition is running or offline passed via --until-status option
    # Usage:
    #linode_api_admin wait-linode-status --linode-label test.server.com --until-status running
  elif [[ "${action}" == "wait-linode-status" ]]; then
    local linode_id linode_status loop_count timeout
    # Wait 2 seconds for the status to be new
    timeout=420
    linode_id=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings linodes list | ${JQ_BIN} ".[] | select(.label == \"${linode_label}\") | .id")
    if [ -z "${linode_id}" ]; then
      echo "Linode ID not found!"
      return 147
    fi
    sleep 2
    if [[ "${until_status^^}" == "RUNNING" || "${until_status^^}" == "ONLINE" ]]; then
      _echo "$(msg cyan)Waiting for linode ${linode_label} to have running status ...$(msg end)" --name
      linode_status=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings linodes view "${linode_id}" | ${JQ_BIN} -r ".[] | .status")
      if [[ "${linode_status}" == "running" ]]; then
        # test uncomment below later if not working
        _echo "$(msg yellow)Warning linode ${linode_label} is already in running mode$(msg end)" --name --verbose 3
        return 0
      else
        while :; do
          sleep 1
          linode_status=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings linodes view "${linode_id}" | ${JQ_BIN} -r ".[] | .status")
          if [[ "${linode_status}" == "running" ]]; then
            _echo "$(msg green)Success, linode ${linode_label} is running.$(msg end)" --stop-spin
            break
          elif [[ "${linode_status}" == "offline" ]]; then
            # Force shutdown using lish_console command
            # Don't do this, this function does not execute command, just checking status
            #lish_console shutdown
            _echo "$(msg yellow)Warning, linode is offline. Waiting for running status ...$(msg end)" --start-spin --name
          else
            _echo "$(msg yellow)Linode status is ${linode_status}. Waiting for running status ...$(msg end)" --start-spin --name
          fi
        done
      fi
    elif [[ "${until_status^^}" == "OFFLINE" ]]; then
      _echo "$(msg cyan)Waiting for linode ${linode_label} to have offline status ...$(msg end)" --name
      linode_status=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings linodes view "${linode_id}" | ${JQ_BIN} -r ".[] | .status")
      if [[ "${linode_status}" == "offline" ]]; then
        _echo "$(msg yellow)Warning linode ${linode_label} is already in offline mode$(msg end)" --name --verbose 3
        return 0
      else
        loop_count=0
        while :; do
          sleep 1
          ((loop_count++))
          linode_status=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings linodes view "${linode_id}" | ${JQ_BIN} -r ".[] | .status")
          if [[ "${linode_status}" == "offline" ]]; then
            _echo "$(msg green)Success, linode ${linode_label} is offline.$(msg end)" --stop-spin --name
            break
          elif [[ "${linode_status}" == "running" ]]; then
            _echo "$(msg yellow)Warning, linode is running. Waiting for offline status ...$(msg end)" --name --start-spin
            if [ "${loop_count}" -eq ${timeout} ]; then
              echo ""
              _echo "$(msg yellow)Warning, linode has not entered into offline mode for more than ${timeout} seconds ...$(msg end)" --name
              # Increase this value if process requires more than 7 minutes or 420 seconds or more
              _echo "$(msg yellow)This is the maximum waiting time that linode should not wait more than this duration. Please inspect why linode still running!$(msg end)" --name
              _echo "$(msg yellow)You may want to visit the lish console here: https://cloud.linode.com/linodes/${linode_id}/lish/glish$(msg end)" --name
              _exit 147
            fi
          else
            _echo "$(msg yellow)Linode status is ${linode_status}. Waiting for offline status ...$(msg end)" --start-spin --name
          fi
        done
      fi

    fi

  #linode_api_admin reboot-to-rescue --linode-label test.server.com --dev-sda "disk:Boot_Disk" --dev-sdb "disk:OS_Disk" --dev-sdc "volume:Volume_Disk"
  elif [[ "${action^^}" == +(REBOOT-TO-RESCUE|RESCUE-REBOOT|REBOOT-RESCUE|BOOT-TO-RESCUE|RESCUE-MODE) ]]; then
    # scope finish 0.1 --- see validation ...
    local linode_id retval=1 config_disk_vol loop_count

    if is_valid domain "${linode_label}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --linode-label $(msg red)${linode_label}$(msg green) is valid FQDN$(msg end)" --name --verbose 7
    else
      # This text is just a warning about the --linode-label that should be FQDN format (no return or exit). For warning use --verbose=4
      [[ ${scripting} == "false" ]] && _echo "$(msg yellow)Warning, the given --linode-label $(msg red)${linode_label}$(msg green) is not FQDN. It is recommend to name it as FQDN$(msg end)" --name --verbose 4
    fi

    [[ ${scripting} == "false" ]] && _echo "Getting required linode ID for --linode-label ${linode_label} ..." --name --verbose 7
    linode_id=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings linodes list | ${JQ_BIN} ".[] | select(.label == \"${linode_label}\") | .id")
    #echo "Linode ID : ${linode_id}"
    if [ -z "${linode_id}" ]; then
      _echo "$(msg red)Error, no linode label found for $(msg red)--linode-label ${linode_label}$(msg end)" --name --verbose 3
      return 147
    else
      # maximum letter is g because h is assigned for default Finnix Rescue Disk
      local disk_letters="a b c d e f g" label_type label_name label_disk_vol config_disk_vol disk_vol_id
      for letter in ${disk_letters}; do
        typeset -n "label_disk_vol"="label_devsd${letter}"

        label_type=$(echo "${label_disk_vol}" | awk -F: '{ print $1 }')
        label_name=$(echo "${label_disk_vol}" | awk -F: '{ print $2 }')
        #echo "label_type: ${label_type}"
        #echo "label name: ${label_name}"
        if [ "${label_type}" == "disk" ]; then
          disk_vol_id=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings linodes disks-list "${linode_id}" | ${JQ_BIN} ".[] | select(.label == \"${label_name}\") | .id")
        elif [ "${label_type}" == "volume" ]; then
          disk_vol_id=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings volumes list | ${JQ_BIN} ".[] | select(.label == \"${label_name}\") | .id")
        else
          continue
        fi
        if [ -z "${disk_vol_id}" ]; then
          _echo "$(msg red)Error, the ${label_type} label [${label_name}] does not exist. Please, make sure that the ${label_type} was created in linode$(msg end)" --name --verbose 3
          _exit 1
        fi
        config_disk_vol="${config_disk_vol} --devices.sd${letter}.${label_type}_id ${disk_vol_id}"
      done
      #echo "OPTIONS: ${config_disk_vol}"
      if [[ -z "${config_disk_vol}" ]]; then
        _echo "Config disk option is blank. Linode will boot into rescue mode without mounting any disks or volumes" --name --verbose 4
      else
        _echo "Notice, Linode will boot into rescue mode and mount the following options"
        echo ""
        _echo "OPTIONS: ${config_disk_vol}" --plain
        echo ""
      fi

      _echo "$(msg cyan)Putting linode ${linode_label} into rescue mode ...$(msg end)" --name
      ${LINODE_CLI_BIN} linodes rescue --suppress-warnings "${linode_id}" ${config_disk_vol}
      #wait_until_linode_status_is running

      loop_count=0
      while :; do
        sleep 1
        linode_status=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings linodes view "${linode_id}" | ${JQ_BIN} -r ".[] | .status")
        if [[ "${linode_status}" == "running" ]]; then
          _echo "$(msg green)Success, linode ${linode_label} has been successfully booted into rescue mode.$(msg end)" --stop-spin --name
          break
        else
          _echo "$(msg cyan)Linode status is ${linode_status}. Waiting for running status on rescue mode ...$(msg end)" --start-spin --name
          ((loop_count++))
          if [ "${loop_count}" -eq 60 ]; then
            #loop_count=0
            _echo "$(msg yellow)Warning it has been more than 60 seconds linode ${linode_label} has not entered into rescue mode!$(msg end)" --name
            _echo "$(msg cyan)Putting linode ${linode_label} into rescue mode (for the second time) ...$(msg end)" --name
            ${LINODE_CLI_BIN} linodes rescue --suppress-warnings "${linode_id}" ${config_disk_vol}
          fi

          if [ "${loop_count}" -gt 120 ]; then
            _echo "$(msg red)Warning it has been more than 120 seconds linode ${linode_label} has not entered into rescue mode. Something is wrong, please inspect why!$(msg end)" --name
            _exit 147
          fi
        fi
      done

    fi
  # linode_api_admin restart-linode --linode-label test.server.com --linode-config-label OS_Config
  elif [[ "${action^^}" == +(RESTART-LINODE|REBOOT-LINODE) ]]; then
    local linode_id linode_config_id linode_api_exec option loop_count
    option="$2"
    # Required linode_id and linode_config_id

    # This is for faster server reboot syntax. For example to reboot, we do not need to specify many arguments.
    # maxinet --linode-api reboot-linode os (this will reboot using OS_Config), also works the same without 'os' argument
    # maxinet --linode-api reboot-linode boot (this will reboot using Boot_Config)
    if [[ "${argnum}" -le 1 || "${option}" == "os" ]]; then
      linode_label="${C_BOX_HOSTNAME_FQHN}"
      linode_config_label="${C_LINODE_OS_CONFIG_LABEL}"
    elif [[ "${option}" == "boot" ]]; then
      linode_label="${C_BOX_HOSTNAME_FQHN}"
      linode_config_label="${C_LINODE_BOOT_CONFIG_LABEL}"
    elif [[ "${option}" == "rescue" ]]; then
      linode_label="${C_BOX_HOSTNAME_FQHN}"
      linode_config_label="${C_LINODE_RESCUE_CONFIG_LABEL}"
    fi
    echo "linode_label: ${linode_label}"
    echo "linode_config_label: ${linode_config_label}"

    if is_valid domain "${linode_label}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --linode-label $(msg red)${linode_label}$(msg green) is valid FQDN$(msg end)" --name --verbose 7
    else
      # This text is just a warning about the --linode-label that should be FQDN format (no return or exit). For warning use --verbose=4
      [[ ${scripting} == "false" ]] && _echo "$(msg yellow)Warning, the given --linode-label $(msg red)${linode_label}$(msg green) is not FQDN. It is recommend to name it as FQDN$(msg end)" --name --verbose 4
    fi

    [[ ${scripting} == "false" ]] && _echo "Getting required linode ID for --linode-label ${linode_label} ..." --name --verbose 7
    linode_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes list | ${JQ_BIN} ".[] | select(.label == \"${linode_label}\") | .id")
    if [ -z "${linode_id}" ]; then
      _echo "$(msg red)Error, no linode label ID found for $(msg red)--linode-label ${linode_label}$(msg end)" --name --verbose 3
      return 147
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
    fi
    [[ ${scripting} == "false" ]] && _echo "Getting required linode config ID for --linode-config-label ${linode_config_label} ..." --name --verbose 7
    linode_config_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes configs-list "${linode_id}" | ${JQ_BIN} ".[] | select(.label == \"${linode_config_label}\") | .id")
    if [ -z "${linode_config_id}" ]; then
      _echo "$(msg red)Error, no linode label config ID found for $(msg red)--linode-config-label ${linode_config_label}$(msg end)" --name --verbose 3
      return 147
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
    fi
    [[ ${scripting} == "false" ]] && _echo "$(msg cyan)Rebooting linode ${linode_label} using config ${linode_config_label} ...$(msg end)" --name
    linode_api_exec=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes reboot "${linode_id}" --config_id "${linode_config_id}" 2> >(grep 'Linode busy'))
    if [ -n "${linode_api_exec}" ]; then
      _echo "$(msg yellow)Warning, Linode is busy. Re-executing linodes reboot in 10 seconds ...$(msg end)" --name --verbose 4
      sleep 10
      linode_api_exec=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes reboot "${linode_id}" --config_id "${linode_config_id}" 2> >(grep 'Linode busy'))
      if [ -n "${linode_api_exec}" ]; then
        _echo "$(msg yellow)Warning, Linode is busy. Re-executing linodes reboot in 10 seconds ...$(msg end)" --name --verbose 4
        sleep 10
        linode_api_exec=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes reboot "${linode_id}" --config_id "${linode_config_id}" 2> >(grep 'Linode busy'))
        if [ -n "${linode_api_exec}" ]; then
          _echo "$(msg red)Error, Linode is stuck with busy status for more than 20 seconds. Please inspect why.$(msg end)" --name --verbose 4
          exit 147
          [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        fi
      fi

    fi

    loop_count=0
    while :; do
      ((loop_count++))
      linode_status=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes view "${linode_id}" | ${JQ_BIN} -r ".[] | .status")
      if [[ "${linode_status}" == "running" ]]; then
        _echo "$(msg green)Success, linode ${linode_label} has been successfully rebooted.$(msg end)" --stop-spin --name
        return 0
        #break
      elif [[ "${linode_status}" == "offline" ]]; then
        if [ "${loop_count}" -eq 60 ]; then
          _echo "$(msg yellow)Warning it has been more than 60 seconds linode ${linode_label} has not entered into running mode!$(msg end)" --name
          _echo "$(msg cyan)Rebooting linode ${linode_label} (for the second time) ...$(msg end)" --name
          ${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes reboot "${linode_id}" --config_id "${linode_config_id}"
        fi

        if [ "${loop_count}" -gt 120 ]; then
          _echo "$(msg red)Warning it has been more than 120 seconds linode ${linode_label} linode is still in offline mode! Please inspect why$(msg end)" --name
          _exit 147
        fi
      else
        _echo "$(msg cyan)Linode ${linode_label}'s status is ${linode_status}. Waiting for running status after rebooting ...$(msg end)" --start-spin --name
      fi

    done

  elif
    [[ "${action^^}" == +(SHUTDOWN-LINODE|POWEROFF-LINODE|TURNOFF-LINODE) ]]
  then
    # This scope is completed v1
    local linode_id linode_api_exec ssh_pid
    # Required only linode_id
    if is_valid domain "${linode_label}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --linode-label $(msg red)${linode_label}$(msg green) is valid FQDN$(msg end)" --name --verbose 7
    else
      # This text is just a warning about the --linode-label that should be FQDN format (no return or exit). For warning use --verbose=4
      [[ ${scripting} == "false" ]] && _echo "$(msg yellow)Warning, the given --linode-label $(msg red)${linode_label}$(msg green) is not FQDN. It is recommend to name it as FQDN$(msg end)" --name --verbose 4
    fi

    [[ ${scripting} == "false" ]] && _echo "Getting required linode ID for --linode-label ${linode_label} ..." --name --verbose 7
    linode_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes list | ${JQ_BIN} ".[] | select(.label == \"${linode_label}\") | .id")
    if [ -z "${linode_id}" ]; then
      _echo "$(msg red)Error, no linode label ID found for $(msg red)--linode-label ${linode_label}$(msg end)" --name --verbose 3
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi

    linode_status=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes view "${linode_id}" | ${JQ_BIN} -r ".[] | .status")

    if [[ "${linode_status}" == "offline" ]]; then
      _echo "$(msg yellow)Notice, linode ${linode_label} status is already offline!$(msg end)" --name
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 0
    else
      [[ ${scripting} == "false" ]] && _echo "Notice, linode ${linode_label} status is ${linode_status}" --name
      if [ "${recovery_mode_shutdown}" == "true" ]; then
        # This solved the workaround here: https://www.linode.com/community/questions/21319/please-remove-the-disk-eject-question-on-finnix-rescue-disk
        # Force shutting down linode using script (fix delay reboot due to Finnix recovery need to press enter to eject CDROM even no CDROM is present.)
        # Note when using this method, it will not show the status "shutting_down", only offline or running.
        [[ ${scripting} == "false" ]] && _echo "$(msg cyan)Shutting down linode ${linode_label} using SSH push script (if server is in recovery mode) ...$(msg end)" --name
        ssh -o "StrictHostKeyChecking no" -i /root/.ssh/linode_lish.id_rsa -tt "${DNS_PROVIDER_USER}@${C_DNS_PROVIDER_TERMINAL_SERVER}" "${C_BOX_HOSTNAME_FQHN}" <"${SCRIPT_PATH}/dns/linode/shutdown_command.sh" >/dev/null 2>&1 &
        ssh_pid=$!
        sleep 10
      else
        [[ ${scripting} == "false" ]] && _echo "$(msg cyan)Shutting down linode using linode API ${linode_label} ...$(msg end)" --name
        linode_api_exec=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes shutdown "${linode_id}" 2> >(grep 'Linode busy'))
      fi
      if [ -n "${linode_api_exec}" ]; then
        _echo "$(msg yellow)Warning, Linode is busy. Re-executing linodes shutdown in 10 seconds ...$(msg end)" --name --verbose 4
        sleep 10
        linode_api_exec=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes shutdown "${linode_id}" 2> >(grep 'Linode busy'))
        if [ -n "${linode_api_exec}" ]; then
          _echo "$(msg yellow)Warning, Linode is busy. Re-executing linodes shutdown in 10 seconds ...$(msg end)" --name --verbose 4
          sleep 10
          linode_api_exec=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes shutdown "${linode_id}" 2> >(grep 'Linode busy'))
          if [ -n "${linode_api_exec}" ]; then
            _echo "$(msg red)Error, Linode is stuck with busy status for more than 20 seconds. Please inspect why.$(msg end)" --name --verbose 4
            [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
            return 147
          fi
        fi

      fi

      [[ ${scripting} == "false" ]] && _echo "$(msg cyan)Shutting down linode ${linode_label} ...$(msg end)" --name
      while :; do
        linode_status=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes view "${linode_id}" | ${JQ_BIN} -r ".[] | .status")
        if [ "${linode_status}" == "running" ]; then
          _echo "$(msg yellow)Notice, linode ${linode_label} is running. Waiting for offline status ...$(msg end)" --start-spin --name
        elif [[ "${linode_status}" == "offline" ]]; then
          _echo "$(msg green)Success, linode ${linode_label} is offline.$(msg end)" --stop-spin --name
          # Linode status is shutting down, so the push script shutdown_command is triggered successfully, we can kill running ssh for safety.
          { kill -9 ${ssh_pid} && wait ${ssh_pid}; } 2>/dev/null
          [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
          return 0
          #break
        elif [[ "${linode_status}" == "shutting_down" ]]; then
          _echo "$(msg yellow)Notice, linode ${linode_label} is shutting down. Waiting for offline status$(msg end)" --start-spin --name

        else
          _echo "$(msg cyan)Linode ${linode_label}'s status is ${linode_status}. Waiting for offline status ...$(msg end)" --start-spin --name
        fi
      done

    fi
    # linode_api_admin create-disk sun.sofibox.com <disk_label> <disk_filetype> <disk_size_in_MB>
    # linode_api_admin create-disk --linode-label test.server.com --linode-disk-label Boot_Disk --linode-disk-filetype raw --linode-disk-size 10
  elif [[ "${action}" == "create-disk" || "${action}" == "add-disk" ]]; then
    # Required linode_id, disk_id, disk_type, disk_size

    local linode_id disk_label_created disk_status linode_status linode_api_exec
    if is_valid domain "${linode_label}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --linode-label $(msg red)${linode_label}$(msg green) is valid FQDN$(msg end)" --name --verbose 7
    else
      # This text is just a warning about the --linode-label that should be FQDN format (no return or exit). For warning use --verbose=4
      [[ ${scripting} == "false" ]] && _echo "$(msg yellow)Warning, the given --linode-label $(msg red)${linode_label}$(msg green) is not FQDN. It is recommend to name it as FQDN$(msg end)" --name --verbose 4
    fi

    if is_valid not-empty-string "${linode_disk_label}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --linode-disk-label $(msg red)${linode_disk_label}$(msg green) is valid (not empty string)$(msg end)" --name --verbose 7
    else
      [[ ${scripting} == "false" ]] && _echo "$(msg red)Error, the given --linode-disk-label $(msg red)${linode_disk_label}$(msg green) is not valid (empty string)$(msg end)" --name --verbose 4
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi

    if is_valid valid-linode-disk-filetype "${linode_disk_filetype}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --linode-disk-filetype $(msg red)${linode_disk_label}$(msg green) is valid linode filetype$(msg end)" --name --verbose 7
    else
      [[ ${scripting} == "false" ]] && _echo "$(msg red)Error, the given --linode-disk-filetype $(msg red)${linode_disk_label}$(msg green) is not valid linode filetype$(msg end)" --name --verbose 4
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi

    if is_valid not-empty-string "${linode_disk_size}" && is_valid integer "${linode_disk_size}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --linode-disk-size $(msg red)${linode_disk_size}$(msg green) is valid (not empty string and input is an integer)$(msg end)" --name --verbose 7
    else
      [[ ${scripting} == "false" ]] && _echo "$(msg red)Error, the given --linode-disk-size $(msg red)${linode_disk_size}$(msg green) is not valid (empty string or not input is not integer)$(msg end)" --name --verbose 4
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi

    [[ ${scripting} == "false" ]] && _echo "Getting required linode ID for --linode-label ${linode_label} ..." --name --verbose 7
    linode_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes list | ${JQ_BIN} -r ".[] | select(.label == \"${linode_label}\") | .id")
    if [ -z "${linode_id}" ]; then
      _echo "$(msg red)Error, no linode label ID found for $(msg red)--linode-label ${linode_label}$(msg end)" --name --verbose 3
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147

    fi

    if [[ ${allow_duplicate_entry} == false ]]; then
      [[ ${scripting} == "false" ]] && _echo "Checking existing --linode-disk-label ${linode_disk_label} ..." --name --verbose 7
      disk_label_created=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes disks-list "${linode_id}" | ${JQ_BIN} -r ".[] | select(.label == \"${linode_disk_label}\") | .label" | tail -n 1)
      if [[ "${disk_label_created}" == "${linode_disk_label}" ]]; then
        _echo "$(msg yellow)Warning, there is already a linode-disk-label ${linode_disk_label} entry for in linode disk. If you want to create duplicate entry then, use option --allow-duplicate-entry$(msg end)" --name --verbose 4
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      fi
    else
      [[ ${scripting} == "false" ]] && _echo "$(msg yellow)Warning, --allow-duplicate-entry is set. Duplicate disk label is allowed to be created$(msg end)" --name --verbose 4
    fi

    # Need to make sure that the linode status is offline before we can delete the disk.
    linode_status=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes view "${linode_id}" | ${JQ_BIN} -r ".[] | .status")

    if [[ "${linode_status}" == "offline" ]]; then
      [[ ${scripting} == "false" ]] && _echo "$(msg cyan)Creating a new linode disk from --linode-disk-label ${linode_disk_label} ...$(msg end)" --name
      # For disk space
      ${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes disk-create "${linode_id}" --label "${linode_disk_label}" --filesystem "${linode_disk_filetype}" --size "${linode_disk_size}"
      # Placeholder to check if linode is busy or other conditions that prevented from disk creation such as not enough disk space
      #linode_api_exec=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes disk-create "${linode_id}" --label "${linode_disk_label}" --filesystem "${linode_disk_filetype}" --size "${linode_disk_size}" 2> >(grep 'You do not have enough unallocated storage to create this Disk'))
      #echo "${linode_api_exec}"
      #exit 1
      #  if [ -n "${linode_api_exec}" ]; then
      #    _echo "$(msg red)Warning, no disk space left on linode with --linode-label ${linode_label}. Please delete unused partition$(msg end)" --name --verbose 4
      #    exit 147
      #    [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      #  else
      #    echo "${linode_api_exec}"
      #  fi

      _echo "$(msg cyan)Checking disk status --linode-disk-label ${linode_disk_label} for ready state ... $(msg end)" --name
      while :; do
        disk_status=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes disks-list "${linode_id}" | ${JQ_BIN} -r ".[] | select(.label == \"${linode_disk_label}\") | .status" | tail -n 1)
        if [ "${disk_status}" == "ready" ]; then
          _echo "$(msg green)Success, linode disk status for --linode-disk-label ${linode_disk_label} is now ready$(msg end)" --name --stop-spin
          break
          [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        elif [ "${disk_status}" == "not ready" ]; then
          _echo "$(msg yellow)Disk status is not ready. Waiting for disk status to be ready ...$(msg end)" --name --start-spin
        elif [ -z "${disk_status}" ]; then
          _echo "$(msg yellow)Warning, empty disk status. Waiting for disk status to be ready ... $(msg end)" --name --start-spin
        else
          _echo "$(msg yellow)Warning, unknown disk status (not in condition): [${disk_status}]. Waiting for disk status to be ready ... $(msg end)" --name --start-spin

        fi

      done

    else
      _echo "Error, linode ${linode_label} must be offline first to delete disk but its current status is ${linode_status}" --name --verbose 3
      return 147
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
    fi
  # To remove specific disk: linode_api_admin delete-disk --linode-label test.server.com --linode-disk-label "OS_Disk"
  # To remove all disks: linode_api_admin "delete-disks" --linode-label test.server.com
  elif [[ "${action}" == "delete-disk" || "${action}" == "remove-disk" || "${action}" == "delete-disks" || "${action}" == "remove-disks" ]]; then
    local linode_id disk_status disk_count disk_id success_deleted disk_labels disk_labels_count disk_label

    if [[ "${action}" == "delete-disks" || "${action}" == "remove-disks" ]]; then
      if [ -n "${linode_disk_label}" ]; then
        _echo "$(msg red)Error, the action ${action} (with plurals) does not require --linode-disk-label option! It is used to delete all linode disks!$(msg end)" --name --verbose 3
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      fi
    else
      if is_valid not-empty-string "${linode_disk_label}"; then
        [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --linode-disk-label $(msg red)${linode_disk_label}$(msg green) is valid (not empty string)$(msg end)" --name --verbose 7
      else
        [[ ${scripting} == "false" ]] && _echo "$(msg red)Error, the given --linode-disk-label $(msg red)${linode_disk_label}$(msg green) is not valid (empty string)$(msg end)" --name --verbose 4
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      fi
    fi
    if is_valid domain "${linode_label}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --linode-label $(msg red)${linode_label}$(msg green) is valid FQDN$(msg end)" --name --verbose 7
    else
      # This text is just a warning about the --linode-label that should be FQDN format (no return or exit). For warning use --verbose=4
      [[ ${scripting} == "false" ]] && _echo "$(msg yellow)Warning, the given --linode-label $(msg red)${linode_label}$(msg green) is not FQDN. It is recommend to name it as FQDN$(msg end)" --name --verbose 4
    fi
    [[ ${scripting} == "false" ]] && _echo "Getting required linode ID for --linode-label ${linode_label} ..." --name --verbose 7
    linode_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes list | ${JQ_BIN} -r ".[] | select(.label == \"${linode_label}\") | .id")
    if [ -z "${linode_id}" ]; then
      _echo "$(msg red)Error, no linode label ID found for $(msg red)--linode-label ${linode_label}$(msg end)" --name --verbose 3
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147

    fi

    # If plurals delete-disks or remove-disks (we delete all)
    if [[ "${action}" == "delete-disks" || "${action}" == "remove-disks" ]]; then
      _echo "$(msg cyan)Deleting all the linode disks from --linode-label ${linode_label} ...$(msg end)" --name
      disk_labels=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes disks-list "${linode_id}" | ${JQ_BIN} -r ".[] | .label")
      if [ -z "${disk_labels}" ]; then
        _echo "$(msg red)Error, no linode disk label found from $(msg red)--linode-label ${linode_label}$(msg end)" --name --verbose 3
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      else
        disk_labels_count=$(echo "${disk_labels}" | wc -w)
        _echo "Notice, total linode disk(s) found is ${disk_labels_count}" --name
      fi

    else

      _echo "$(msg cyan)Deleting linode disk from --linode-disk-label ${linode_disk_label} ...$(msg end)" --name
      disk_labels=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes disks-list "${linode_id}" | ${JQ_BIN} -r ".[] | select(.label == \"${linode_disk_label}\") | .label")
      if [ -z "${disk_labels}" ]; then
        _echo "$(msg red)Error, no linode disk label found for $(msg red)--linode-disk-label ${linode_disk_label}$(msg end)" --name --verbose 3
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      else
        disk_labels_count=$(echo "${disk_labels}" | wc -w)
        _echo "Notice, total linode disk(s) found is ${disk_labels_count}." --name
      fi
    fi

    disk_count=0
    success_deleted=0
    # Need to make sure that the linode status is offline before we can delete the disk.
    linode_status=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes view "${linode_id}" | ${JQ_BIN} -r ".[] | .status")
    #echo "LINODE STATUS: ${linode_status}"
    if [[ "${linode_status}" == "offline" ]]; then

      for disk_label in ${disk_labels}; do
        ((disk_count++))

        # Delete the first result that appear with tail -n 1
        disk_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes disks-list "${linode_id}" | ${JQ_BIN} -r ".[] | select(.label == \"${disk_label}\") | .id" | tail -n 1)
        _echo "$(msg cyan)Deleting linode disk ${disk_count} / ${disk_labels_count} with disk label ${disk_label} and disk ID ${disk_id} ...$(msg end)" --name
        ${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes disk-delete "${linode_id}" "${disk_id}"

        while :; do
          # do not quote $disk_id variable
          disk_status=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes disks-list "${linode_id}" | ${JQ_BIN} -r ".[] | select(.id == ${disk_id}) | .status")
          if [[ -z "${disk_status}" ]]; then
            # If disk_status is empty meaning that it has been deleted!
            _echo "$(msg green)Success, the linode disk label ${disk_label} (${disk_id}) has been deleted!$(msg end)" --name --stop-spin
            [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
            ((sucess_deleted++))
            break
          elif [[ ${disk_status} == "deleting" ]]; then
            _echo "$(msg cyan)Deleting linode --disk-label ${disk_label} ...$(msg end)" --name --start-spin
          else
            _echo "$(msg yellow)Warning, unknown linode disk status for --disk-label ${disk_label}: ${disk_status}$(msg end)" --name --start-spin
            [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
            return 147
          fi
        done
      done
    else
      _echo "Error, linode ${linode_label} must be offline first to delete disk but its current status is ${linode_status}" --name --verbose 3
      return 147
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
    fi

    if [ ${success_deleted} -ne 0 ]; then
      return 0
    else
      return 1
    fi
    [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
    # linode_api_admin delete-configs --linode-label test.server.com
    # linode_api_admin delete-config --linode-label test.server.com --linode-config-label Boot_Config
  elif [[ "${action}" == "delete-configs" || "${action}" == "remove-configs" || "${action}" == "delete-config" || "${action}" == "remove-config" ]]; then

    local linode_id config_status config_count config_id success_deleted config_labels config_labels_count config_label retval

    if [[ "${action}" == "delete-configs" || "${action}" == "remove-configs" ]]; then
      if [ -n "${linode_config_label}" ]; then
        _echo "$(msg red)Error, the action ${action} (with plurals) does not require --linode-config-label option! It is used to delete all linode configs!$(msg end)" --name --verbose 3
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      fi
    else
      if is_valid not-empty-string "${linode_config_label}"; then
        [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --linode-config-label $(msg red)${linode_config_label}$(msg green) is valid (not empty string)$(msg end)" --name --verbose 7
      else
        [[ ${scripting} == "false" ]] && _echo "$(msg red)Error, the given --linode-config-label $(msg red)${linode_config_label}$(msg green) is not valid (empty string)$(msg end)" --name --verbose 4
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      fi
    fi
    if is_valid domain "${linode_label}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --linode-label $(msg red)${linode_label}$(msg green) is valid FQDN$(msg end)" --name --verbose 7
    else
      # This text is just a warning about the --linode-label that should be FQDN format (no return or exit). For warning use --verbose=4
      [[ ${scripting} == "false" ]] && _echo "$(msg yellow)Warning, the given --linode-label $(msg red)${linode_label}$(msg green) is not FQDN. It is recommend to name it as FQDN$(msg end)" --name --verbose 4
    fi
    [[ ${scripting} == "false" ]] && _echo "Getting required linode ID for --linode-label ${linode_label} ..." --name --verbose 7
    linode_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes list | ${JQ_BIN} -r ".[] | select(.label == \"${linode_label}\") | .id")
    if [ -z "${linode_id}" ]; then
      _echo "$(msg red)Error, no linode label ID found for $(msg red)--linode-label ${linode_label}$(msg end)" --name --verbose 3
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147

    fi

    # If plurals delete-configs or remove-configs (we delete all)
    if [[ "${action}" == "delete-configs" || "${action}" == "remove-configs" ]]; then
      _echo "$(msg cyan)Deleting all the linode configs from --linode-label ${linode_label} ...$(msg end)" --name
      config_labels=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes configs-list "${linode_id}" | ${JQ_BIN} -r ".[] | .label")

      if [ -z "${config_labels}" ]; then
        _echo "$(msg red)Error, no linode config label found from $(msg red)--linode-label ${linode_label}$(msg end)" --name --verbose 3
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      else
        config_labels_count=$(echo "${config_labels}" | wc -w)
        _echo "Notice, total linode config(s) found is ${config_labels_count}." --name
      fi

    else

      _echo "$(msg cyan)Deleting linode config from --linode-config-label ${linode_config_label} ...$(msg end)" --name
      config_labels=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes configs-list "${linode_id}" | ${JQ_BIN} -r ".[] | select(.label == \"${linode_config_label}\") | .label")
      #config_labels=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes configs-list "${linode_id}" | ${JQ_BIN} ".[] | select(.label == ${linode_config_label}) | .label")
      #echo "CONFIG_LABELS: ${config_labels}"
      #exit 1
      if [ -z "${config_labels}" ]; then
        _echo "$(msg red)Error, no linode config label found for $(msg red)--linode-config-label ${linode_config_label}$(msg end)" --name --verbose 3
        [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
        return 147
      else
        config_labels_count=$(echo "${config_labels}" | wc -w)
        _echo "Notice, total linode config(s) found is ${config_labels_count}." --name
      fi
    fi

    config_count=0
    success_deleted=0

    for config_label in ${config_labels}; do
      ((config_count++))

      # Delete the first result that appear with tail -n 1
      config_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes configs-list "${linode_id}" | ${JQ_BIN} -r ".[] | select(.label == \"${config_label}\") | .id" | tail -n 1)
      _echo "$(msg cyan)Deleting linode config ${config_count} / ${config_labels_count} with config label ${config_label} and config ID ${config_id} ...$(msg end)" --name
      ${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes config-delete "${linode_id}" "${config_id}"
      retval=$?
      while :; do
        if [[ "${retval}" -eq 0 ]]; then
          _echo "$(msg green)Success, the linode config label ${config_label} (${config_id}) has been deleted!$(msg end)" --name --stop-spin
          [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
          ((sucess_deleted++))
          break
        else
          _echo "$(msg yellow)Warning, unknown deletion status when deleting --config-label ${linode_config_label}: ${config_status}$(msg end)" --name --start-spin
          [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
          return 147
        fi
      done
    done

    if [ ${success_deleted} -ne 0 ]; then
      return 0
    else
      return 1
    fi
    [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"

    # new:
    #linode_api_admin "create-config" --linode-label "${C_BOX_HOSTNAME_FQHN}" \
    #--linode-config-label "Boot_Config" --linode-config-comment "The installer boot configuration" --linode-config-virtual-mode "paravirt" \
    #--linode-config-kernel "linode/direct-disk" --linode-config-runlevel "default" --linode-config-memory-limit "4096" --linode-config-rootdev "/dev/sda" \
    #--linode-config-enable-distro-helper --linode-config-disable-update_db --linode-config-dep-helper --linode-config-automount-devtmpfs --linode-config-autoconf-network
    #--dev-sda "disk:Boot_Disk" --dev-sdb "disk:OS_Disk" ${config_disk_vol} # Do not double quote this, because we want to split the string for disk/volume options
  # The linode memory limit is not important.
  elif [[ "${action}" == "create-config" || "${action}" == "add-config" ]]; then
    local linode_id disk_letters label_type label_name label_disk_vol config_disk_vol disk_vol_id

    if is_valid domain "${linode_label}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --linode-label $(msg red)${linode_label}$(msg green) is valid FQDN$(msg end)" --name --verbose 7
    else
      # This text is just a warning about the --linode-label that should be FQDN format (no return or exit). For warning use --verbose=4
      [[ ${scripting} == "false" ]] && _echo "$(msg yellow)Warning, the given --linode-label $(msg red)${linode_label}$(msg green) is not FQDN. It is recommend to name it as FQDN$(msg end)" --name --verbose 4
    fi
    [[ ${scripting} == "false" ]] && _echo "Getting required linode ID for --linode-label ${linode_label} ..." --name --verbose 7
    linode_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes list | ${JQ_BIN} -r ".[] | select(.label == \"${linode_label}\") | .id")
    if [ -z "${linode_id}" ]; then
      _echo "$(msg red)Error, no linode label ID found for $(msg red)--linode-label ${linode_label}$(msg end)" --name --verbose 3
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147

    fi

    # Validate linode_config_label (this is the only required field for linode config profile)
    if is_valid not-empty-string "${linode_config_label}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --linode-config-label $(msg red)${linode_config_label}$(msg green) is valid (not empty string)$(msg end)" --name --verbose 7
    else
      [[ ${scripting} == "false" ]] && _echo "$(msg red)Error, the given --linode-config-label $(msg red)${linode_config_label}$(msg green) is not valid (empty string)$(msg end)" --name --verbose 4
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi

    disk_letters="a b c d e f g h"
    for letter in ${disk_letters}; do
      typeset -n "label_disk_vol"="label_devsd${letter}"

      label_type=$(echo "${label_disk_vol}" | awk -F: '{ print $1 }')
      label_name=$(echo "${label_disk_vol}" | awk -F: '{ print $2 }')
      #echo "label_type: ${label_type}"
      #echo "label name: ${label_name}"
      if [ "${label_type}" == "disk" ]; then
        disk_vol_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes disks-list "${linode_id}" | ${JQ_BIN} ".[] | select(.label == \"${label_name}\") | .id")
      elif [ "${label_type}" == "volume" ]; then
        disk_vol_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings volumes list | ${JQ_BIN} ".[] | select(.label == \"${label_name}\") | .id")
      else
        continue
      fi
      if [ -z "${disk_vol_id}" ]; then
        _echo "$(msg red)Error, the ${label_type} label [${label_name}] does not exist. Please, make sure that the ${label_type} was created in linode$(msg end)" --name --verbose 3
        _exit 1
      fi
      config_disk_vol="${config_disk_vol} --devices.sd${letter}.${label_type}_id ${disk_vol_id}"
    done
    #echo "OPTIONS: ${config_disk_vol}"
    if [[ -z "${config_disk_vol}" ]]; then
      _echo "Error, device option is blank. Linode config required at least one device to be mounted" --name --verbose 3
      return 147
    else
      _echo "Notice, linode config will be created and mounted with the following devices: "
      echo ""
      _echo "OPTIONS: ${config_disk_vol}" --plain
      echo ""
    fi
    if [ ${linode_config_enable_distro_helper} == "true" ]; then
      linode_config_enable_distro_helper="--helpers.distro true"
    else
      linode_config_enable_distro_helper="--helpers.distro false"
    fi

    if [ ${linode_config_disable_update_db} == "true" ]; then
      linode_config_disable_update_db="--helpers.updatedb_disabled true"
    else
      linode_config_disable_update_db="--helpers.updatedb_disabled false"
    fi

    if [ ${linode_config_enable_dep_helper} == "true" ]; then
      linode_config_enable_dep_helper="--helpers.modules_dep true"
    else
      linode_config_enable_dep_helper="--helpers.modules_dep false"
    fi

    if [ ${linode_config_automount_devtmpfs} == "true" ]; then
      linode_config_automount_devtmpfs="--helpers.devtmpfs_automount true"
    else
      linode_config_automount_devtmpfs="--helpers.devtmpfs_automount false"
    fi

    if [ ${linode_config_autoconf_network} == "true" ]; then
      linode_config_autoconf_network="--helpers.network true"
    else
      linode_config_autoconf_network="--helpers.network false"
    fi

    if [[ -n "${linode_config_memory_limit}" ]]; then
      linode_config_memory_limit="--memory_limit ${linode_config_memory_limit}"
    fi

    #linode_config_comments="--comments ${linode_config_comments}"

    #${LINODE_CLI_BIN} linodes config-create "${linode_id}" --label "${linode_config_label}" "${linode_config_comments}" "${linode_config_virtual_mode}" \
    # "${linode_config_kernel}" "${linode_config_runlevel}" "${linode_config_memory_limit}" "${linode_config_rootdev}" \
    #  --helpers.distro "${linode_config_enable_distro_helper}" \
    #  --helpers.updatedb_disabled "${linode_config_disable_update_db}" \
    #  --helpers.modules_dep "${linode_config_enable_dep_helper}" \
    #  --helpers.devtmpfs_automount "${linode_config_automount_devtmpfs}" \
    #  --helpers.network "${linode_config_autoconf_network}" ${config_disk_vol} # Do not double quote this, because we want to split the string for options
    #  retval=$?
    # It is important some variables are not quoted
    ${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes config-create "${linode_id}" --label "${linode_config_label}" --comments "${linode_config_comments}" --virt_mode "${linode_config_virtual_mode}" \
      --kernel "${linode_config_kernel}" --run_level "${linode_config_runlevel}" ${linode_config_memory_limit} --root_device "${linode_config_rootdev}" \
      ${linode_config_enable_distro_helper} ${linode_config_disable_update_db} ${linode_config_enable_dep_helper} ${linode_config_automount_devtmpfs} ${linode_config_autoconf_network} ${config_disk_vol}
    retval=$?
    echo "CONFIG_CREATE RETURN STATUS: ${retval}"
    echo ""

    if [ ${retval} -eq 0 ]; then
      _echo "Success, linode config profile for --linode-config-label ${linode_config_label} was successfully created!" --name
      return 0
    else
      _echo "Error, something was wrong when creating linode config profile for  --linode-config-label ${linode_config_label}" --verbose 4
      return 147
    fi
  #Using reboot-linode is similar to this except boot-linode cannot be used if it's not offline mode.
  elif [[ "${action^^}" == +(BOOT-LINODE|START-LINODE|BOOT|START|TURN-ON|TURNON|POWER-ON|POWERON) ]]; then
    local linode_id linode_api_exec ssh_pid linode_config_id linode_api_exec option
    option="$2"
    # Boot shortcut. eg: linode_api_admin boot os
    if [[ "${argnum}" -le 1 || "${option}" == "os" ]]; then
      linode_label="${C_BOX_HOSTNAME_FQHN}"
      linode_config_label="${C_LINODE_OS_CONFIG_LABEL}"
    elif [[ "${option}" == "boot" ]]; then
      linode_label="${C_BOX_HOSTNAME_FQHN}"
      linode_config_label="${C_LINODE_BOOT_CONFIG_LABEL}"
    elif [[ "${option}" == "rescue" ]]; then
      linode_label="${C_BOX_HOSTNAME_FQHN}"
      linode_config_label="${C_LINODE_RESCUE_CONFIG_LABEL}"
    fi

    # Required only linode_id and config_id
    if is_valid domain "${linode_label}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --linode-label $(msg red)${linode_label}$(msg green) is valid FQDN$(msg end)" --name --verbose 7
    else
      # This text is just a warning about the --linode-label that should be FQDN format (no return or exit). For warning use --verbose=4
      [[ ${scripting} == "false" ]] && _echo "$(msg yellow)Warning, the given --linode-label $(msg red)${linode_label}$(msg green) is not FQDN. It is recommend to name it as FQDN$(msg end)" --name --verbose 4
    fi

    # Validate linode_config_label (this is the only required field for linode config profile)
    if is_valid not-empty-string "${linode_config_label}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --linode-config-label $(msg red)${linode_config_label}$(msg green) is valid (not empty string)$(msg end)" --name --verbose 7
    else
      [[ ${scripting} == "false" ]] && _echo "$(msg red)Error, the given --linode-config-label $(msg red)${linode_config_label}$(msg green) is not valid (empty string)$(msg end)" --name --verbose 4
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi

    [[ ${scripting} == "false" ]] && _echo "Getting required linode ID for --linode-label ${linode_label} ..." --name --verbose 7
    linode_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes list | ${JQ_BIN} ".[] | select(.label == \"${linode_label}\") | .id")
    if [ -z "${linode_id}" ]; then
      _echo "$(msg red)Error, no linode label ID found for $(msg red)--linode-label ${linode_label}$(msg end)" --name --verbose 3
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
      return 147
    fi

    [[ ${scripting} == "false" ]] && _echo "Getting required linode config ID for --linode-config-label ${linode_config_label} ..." --name --verbose 7
    linode_config_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes configs-list "${linode_id}" | ${JQ_BIN} ".[] | select(.label == \"${linode_config_label}\") | .id")
    if [ -z "${linode_config_id}" ]; then
      _echo "$(msg red)Error, no linode label config ID found for $(msg red)--linode-config-label ${linode_config_label}$(msg end)" --name --verbose 3
      return 147
      [[ ${scripting} == "false" ]] && exec_time total "linode_api_admin"
    fi

    _echo "$(msg cyan)Booting linode ${linode_label} using --linode-config-label ${linode_config_label} ...$(msg end)" --name
    # TODO use this method for other error handling in linode API (this is the best way)
    linode_api_exec=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes boot "${linode_id}" --config_id "${linode_config_id}" 2>&1)
    request_failed=$(echo "${linode_api_exec}" | grep 'Request failed: 400')
    # can use this variable for other purpose
    #reason_failed=$(echo "${linode_api_exec}" | grep 'already booted')
    if [ -n "${request_failed}" ]; then
      _echo "$(msg red)Error, request failed. Reason:$(msg end)" --name --verbose 3
      echo "${linode_api_exec}"
      _exit 147
    fi

    # Give a little bit time 2 seconds for the status to change:
    sleep 2
    while :; do
      linode_status=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes view "${linode_id}" | ${JQ_BIN} -r ".[] | .status")
      if [[ "${linode_status}" == "running" ]]; then
        _echo "$(msg green)Success, linode ${linode_label} has been successfully booted using config ${linode_config_label}$(msg end)" --stop-spin --name
        break
      else
        _echo "$(msg cyan)Linode status is ${linode_status}. Waiting for running status ...$(msg end)" --start-spin --name
      fi
    done
    # linode_api_admin update-reverse-dns --ip --domain
  elif [[ "${action}" == "update-reverse-dns" || "${action}" == "update-rdns" ]]; then
    local linode_api_exec request_failed
    if is_valid ipv4 "${ip_address}" || is_valid ipv6 "${ip_address}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --ip-address $(msg red)${ip_address}$(msg green) is valid$(msg end)" --name --verbose 7
    else
      [[ ${scripting} == "false" ]] && _echo "$(msg yellow)Warning, the given --ip-address $(msg red)${ip_address}$(msg green) is not valid$(msg end)" --name --verbose 4
      _exit 147
    fi

    if is_valid domain "${domain}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --domain $(msg red)${domain}$(msg green) is valid FQDN$(msg end)" --name --verbose 7
    else
      [[ ${scripting} == "false" ]] && _echo "$(msg yellow)Warning, the given --domain $(msg red)${domain}$(msg green) is not FQDN$(msg end)" --name --verbose 4
      _exit 147
    fi

    linode_api_exec=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings networking ip-update "${ip_address}" --rdns "${domain}" 2>&1)
    request_failed=$(echo "${linode_api_exec}" | grep 'Request failed: 400')
    # can use this variable for other purpose
    #reason_failed=$(echo "${linode_api_exec}" | grep 'already booted')
    if [ -n "${request_failed}" ]; then
      _echo "$(msg red)Error, request failed. Reason:$(msg end)" --name --verbose 3
      echo "${linode_api_exec}"
      _exit 147
    else
      _echo "$(msg green)${linode_api_exec}$(msg end)" --name --verbose 3
    fi
    # linode_api_admin ip-address-view --ip-address <ip> --get-value rdns
  elif [[ "${action}" == "ip-address-view" ]]; then
    local linode_api_exec request_failed
    if is_valid ipv4 "${ip_address}" || is_valid ipv6 "${ip_address}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --ip-address $(msg red)${ip_address}$(msg green) is valid$(msg end)" --name --verbose 7
    else
      [[ ${scripting} == "false" ]] && _echo "$(msg yellow)Warning, the given --ip-address $(msg red)${ip_address}$(msg green) is not valid$(msg end)" --name --verbose 4
      _exit 147
    fi

    linode_api_exec=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings networking ip-view "${ip_address}")
    request_failed=$(echo "${linode_api_exec}" | grep 'Request failed: 400')
    # can use this variable for other purpose
    #reason_failed=$(echo "${linode_api_exec}" | grep 'already booted')
    if [ -n "${request_failed}" ]; then
      _echo "$(msg red)Error, request failed. Reason:$(msg end)" --name --verbose 3
      echo "${linode_api_exec}"
      _exit 147
    else
      if [ -n "${get_value}" ]; then
        echo "${linode_api_exec}" | jq -r ".[] | .${get_value}"
      else
        _echo "$(msg green)${linode_api_exec}$(msg end)" --name --verbose 3
      fi
    fi
    # linode_api_admin get-linode-ipv4 --scripting
  elif [[ "${action}" == "get-linode-ipv4" ]]; then
    local linode_api_exec request_failed

    linode_api_exec=$(${LINODE_CLI_BIN} --pretty --json linodes list | jq -r ".[].ipv4 | .[]")

    request_failed=$(echo "${linode_api_exec}" | grep 'Request failed: 400')
    if [ -n "${request_failed}" ]; then
      _echo "$(msg red)Error, request failed. Reason:$(msg end)" --name --verbose 3
      echo "${linode_api_exec}"
      _exit 147
    else
      echo "${linode_api_exec}"
    fi

    # linode_api_admin get-linode-label --ip-address <ipv4> --scripting
  elif [[ "${action}" == "get-linode-label" ]]; then
    local linode_api_exec request_failed
    linode_api_exec=$(${LINODE_CLI_BIN} --pretty --json linodes list | jq -r ".[] | select(.ipv4 | .[] == \"${ip_address}\") | .label")

    request_failed=$(echo "${linode_api_exec}" | grep 'Request failed: 400')
    if [ -n "${request_failed}" ]; then
      _echo "$(msg red)Error, request failed. Reason:$(msg end)" --name --verbose 3
      echo "${linode_api_exec}"
      _exit 147
    else
      echo "${linode_api_exec}"
    fi
    # linode_api_admin update-linode --linode-label <current_label> --new-linode-label <new_linode_label>
  elif [[ "${action}" == "update-linode" || "${action}" == "linode-update" ]]; then
    local linode_id linode_api_exec request_failed

    if is_valid domain "${new_linode_label}"; then
      [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --new-linode-label $(msg red)${linode_label}$(msg green) is valid FQDN$(msg end)" --name --verbose 7
    else
      # This text is just a warning about the --linode-label that should be FQDN format (no return or exit). For warning use --verbose=4
      [[ ${scripting} == "false" ]] && _echo "$(msg yellow)Warning, the given hostname $(msg red)${new_linode_label}$(msg green) is not FQDN. It is recommend to name it as FQDN$(msg end)" --name --verbose 4
      _exit 147
    fi

    [[ ${scripting} == "false" ]] && _echo "Getting required linode ID for --linode-label ${linode_label} ..." --name --verbose 7
    linode_id=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings linodes list | ${JQ_BIN} ".[] | select(.label == \"${linode_label}\") | .id")
    #echo "Linode ID : ${linode_id}"
    if [ -z "${linode_id}" ]; then
      _echo "$(msg red)Error, no linode label found for $(msg red)--linode-label ${linode_label}$(msg end)" --name --verbose 3
      return 147
    fi

    linode_api_exec=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings linodes update "${linode_id}" --label "${new_linode_label}")
    request_failed=$(echo "${linode_api_exec}" | grep 'Request failed: 400')
    # can use this variable for other purpose
    #reason_failed=$(echo "${linode_api_exec}" | grep 'already booted')
    if [ -n "${request_failed}" ]; then
      _echo "$(msg red)Error, request failed. Reason:$(msg end)" --name --verbose 3
      echo "${linode_api_exec}"
      _exit 147
    else
      echo "${linode_api_exec}"
    fi

  elif
    [[ "${action}" == "view-linode" || "${action}" == "lookup-linode" ]]
  then
    shift
    local linode_id hostname_fqdn
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${C_BOX_HOSTNAME_FQHN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    echo "[${SCRIPT_NAME}]: Viewing linode ${hostname_fqdn} ..."
    linode_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes list | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    ${LINODE_CLI_BIN} linodes view "${linode_id}" --suppress-warnings
    echo "Status: $?"
    # --linode-api get-disk-id "sun.sofibox.com" "Boot_Disk"
  elif [[ "${action}" == "get-disk-id" ]]; then
    shift
    local linode_id hostname_fqdn disk_label disk_id
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${C_BOX_HOSTNAME_FQHN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    disk_label="$1"
    echo "[${SCRIPT_NAME}]: listing config ${hostname_fqdn} ..."
    linode_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes list | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    disk_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes disks-list "${linode_id}" | ${JQ_BIN} ".[] | select(.label == \"${disk_label}\") | .id")
    echo "${disk_id}"
  elif [[ "${action}" == "list-disks" || "${action}" == "lookup-disks" ]]; then
    shift
    local linode_id hostname_fqdn
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${C_BOX_HOSTNAME_FQHN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    echo "[${SCRIPT_NAME}]: listing config ${hostname_fqdn} ..."
    linode_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes list | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    ${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes disks-list "${linode_id}"
    echo $?
    # --linode-api check-disk-status sun.sofibox.com <disk_label>
  elif [[ "${action}" == "check-disk-status" || "${action}" == "disk-status" ]]; then
    shift
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${C_BOX_HOSTNAME_FQHN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    disk_label="$1"
    linode_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes list | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    echo "[${SCRIPT_NAME}]: Checking disk status ${disk_label} from ${hostname_fqdn} ..."
    rescue_disk_status=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes disks-list "${linode_id}" | ${JQ_BIN} -r ".[] | select(.label == \"${disk_label}\") | .status" | tail -n 1)
    if [ "${rescue_disk_status}" == "ready" ]; then
      #echo "[${SCRIPT_NAME}]: Rescue Disk status is now ready"
      return 0
    else
      #echo "[${SCRIPT_NAME}]: Disk status is not ready"
      return 147
    fi
    # --linode-api "list-configs" <hostname_fqdn>
  elif [[ "${action}" == "list-configs" || "${action}" == "lookup-configs" ]]; then
    shift
    local linode_id hostname_fqdn
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${C_BOX_HOSTNAME_FQHN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    echo "[${SCRIPT_NAME}]: listing config ${hostname_fqdn} ..."
    linode_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes list | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    ${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes configs-list "${linode_id}"
    # --linode-api config-view <hostname_fqdn> <config_label>
  elif [[ "${action}" == "config-view" ]]; then
    shift
    local linode_id hostname_fqdn config_id config_label
    hostname_fqdn="$1"
    local retval
    host "${hostname_fqdn}" >/dev/null 2>&1
    retval=$?
    if [ ${retval} -eq 0 ]; then
      #echo "[${SCRIPT_NAME}]: Ok, ${hostname_fqdn} is a FQDN"
      :
    else
      echo "[${SCRIPT_NAME}]: Warning, hostname is not a FQDN: ${hostname_fqdn}"
      hostname_fqdn=${C_BOX_HOSTNAME_FQHN}
      echo "[${SCRIPT_NAME}]: Hostname is now set as: ${hostname_fqdn} from config file"
    fi
    shift
    config_label="$1"
    echo "[${SCRIPT_NAME}]: listing config ${hostname_fqdn} ..."
    linode_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes list | ${JQ_BIN} ".[] | select(.label == \"${hostname_fqdn}\") | .id")
    config_id=$(${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes configs-list "${linode_id}" | ${JQ_BIN} ".[] | select(.label == \"${config_label}\") | .id")
    echo "Viewing config ID ${config_id} from ${hostname_fqdn} ..."
    ${LINODE_CLI_BIN} --json --pretty --suppress-warnings linodes config-view "${linode_id}" "${config_id}"

  elif [[ "${action}" == "help" ]]; then

    echo "=== Linode API Syntax and example (Help Section) ==="
    echo ""
    echo "Get linode ID: "
    echo "  linode_api_admin get-linode-id <hostname_fqdn>"
    echo ""
    echo "Shutdown/turn off linode:"
    echo "  linode_api_admin shutdown-linode <hostname_fqdn>"
    echo ""
    echo "Boot/start linode: "
    echo "  linode_api_admin boot-linode <hostname_fqdn>"
    echo ""
    echo "Reboot/Restart linode: "
    echo "   linode_api_admin reboot-linode <hostname_fqdn>"
    echo ""
    echo "View linode information: "
    echo "   linode_api_admin view-linode <hostname_fqdn>"
    echo ""
    echo "View all linode configs information: "
    echo "   linode_api_admin list-configs <hostname_fqdn>"
    echo ""

  # In linode for record, only 3 things can be updated: name, value and TTL.
  # maxidns --linode "update-dns-record" <domain_name> <record_type> <record_name> <record_value> <record_ttl>
  elif [[ "${action}" == "update-dns-record" ]]; then
    shift
    #echo "add-dns-record"
    local domain type name value dis_args record_id record_ids record_ids_count
    domain="$1"
    # Record name
    type="$2"
    name="$3"
    value="$4"
    ttl="$5"
    dis_args="${*:6}"

    if [[ -n "${dis_args}" ]]; then
      echo "[${SCRIPT_NAME}]: Warning, extra arguments discarded: ${dis_args}"
    fi

    if [ $# -ge 5 ]; then
      echo "[${SCRIPT_NAME}]: Checking record for domain ${domain} with record name ${name} and type ${type} ..."
      #domain_id=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains list --domain "${domain}" | grep -F '"id":' | sed -r 's/[^0-9]//g')
      domain_id=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains list | ${JQ_BIN} ".[] | select(.domain == \"${domain}\") | .id")
      if [ -n "${domain_id}" ]; then
        count=1
        while [[ ${count} -le ${linode_max_page} ]]; do
          record_ids=$(${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains records-list --page ${count} "${domain_id}" | ${JQ_BIN} ".[] | select((.name == \"${name}\") and (.type==\"${type}\")) | .id")
          # Break if found result for that page
          if [[ -n ${record_ids} ]]; then
            break
          fi
          ((count++))
        done
        # Without -n condition, the record will be counted as 1 even it's empty line
        if [[ -n "${record_ids}" ]]; then
          record_ids_count=$(echo "${record_ids}" | wc -l)
          #echo "${record_ids}"
          echo "[${SCRIPT_NAME}]: Total record ID found for the record name ${name} is ${record_ids_count}"
          echo "[${SCRIPT_NAME}]: Updating ${record_ids_count} record(s):"
          success=0
          for record_id in ${record_ids}; do
            #Debug:
            echo "[${SCRIPT_NAME}]: Updating record ID ${record_id} ..."
            ${LINODE_CLI_BIN} --pretty --json --suppress-warnings domains records-update "${domain_id}" "${record_id}" --name "${name}" --target "${value}" --ttl_sec "${ttl}"
            retval=$?
            if [ "${retval}" = 0 ]; then
              echo "=~=~=~=~=~=~=~=~=~=~="
              echo "OK, record ID ${record_id} has been updated successfully updated."
              # Do next update
              ((success++))
            else
              echo "Error [${retval}], update failed for record ID ${record_id}"
              # Do next update
            fi
          done
          echo ""
          if [ "${success}" == "${record_ids_count}" ]; then
            echo "OK, ${success} out of ${record_ids_count} record(s) has been successfully updated"

          elif [[ "${success}" -eq 1 && "${success}" -lt "${record_ids_count}" ]]; then
            echo "Warning, only ${success} out of ${record_ids_count} record(s) has been successfully updated"
          else
            echo "Warning, no record has been updated"
          fi
          echo "=~=~=~=~=~=~=~=~=~=~="
        else
          # Useful variable for future reference
          record_ids_count=0
          echo "[${SCRIPT_NAME}]: Error, no record ID with record name ${name} and type ${type} is found for domain ${domain}"
          return 147
        fi
      else
        echo "[${SCRIPT_NAME}]: Error, no domain ID found for domain ${domain}"
        return 147
      fi
      return 0
    else
      echo "[${SCRIPT_NAME}]: Error, usage: linode_api_admin ${action} <domain_name> <record_type> <record_name> <record_value> <record_ttl>"
      _exit 2
    fi

  else

    _echo "$(msg red)Error, the given action argument '${action}' does not exist$(msg end)" --name
    _exit 1
  fi

}

digitalocean_api_admin() {
  :
}

amazonaws_api_admin() {
  :
}
# maxinet manage-maxicode update --app-name maxigpg --distro-name "debian"
maxicode_admin() {

  local app_name distro_name

  action="$1"
  argnum="$#"

  #echo "action ${action}"
  #echo "argnum ${argnum}"

  short_opts="h"
  long_opts="help,app-name:,distro-name:"
  options=$(getopt -o "${short_opts}" --long "${long_opts}" -n "${FUNCNAME[0]}@${action} in ${SCRIPT_NAME}" -- "$@")
  retval=$?
  if [ ${retval} != 0 ]; then
    _echo "$(msg red)Error, invalid parsed data. Terminating...$(msg end)" >&2
    _exit 147
  fi

  eval set -- "${options}"
  app_name=""    # maxigpg
  distro_name="" # debian

  while true; do
    case "$1" in
    -h | --help)
      manual "${FUNCNAME[0]}"
      shift
      exit 0
      ;;
    --app-name)
      app_name="$2"
      shift 2
      ;;
    --distro-name)
      distro_name="$2"
      shift 2
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
    esac
  done

  if [[ "${action}" == "update" ]]; then
    if [ -z "${app_name}" ]; then
      echo "${SCRIPT_NAME} ${action} --app-name <APP_NAME> --distro-name <DISTRO_NAME>"
      exit 1
    fi

    if [ -z "${distro_name}" ]; then
      #echo "${SCRIPT_NAME} ${action} --app-name <APP_NAME> --distro-name <DISTRO_NAME>"
      distro_name="${C_BOX_ISO_OS_NAME}"
    fi

    if [ "${app_name}" == "maxigpg" ]; then
      local code_path
      code_path="${STORAGE_PATH}/os/${distro_name}/usr/local/maxicode/maxigpg"
      #echo "code_path is: ${code_path}"
      ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" \
        --local-files "${code_path}/maxigpg ${code_path}/readme.txt ${code_path}/readme.md" --remote-path /usr/local/maxicode/maxigpg/

    elif [ "${app_name}" == "maxiaide" ]; then
      local code_path
      code_path="${STORAGE_PATH}/os/${distro_name}/usr/local/maxicode/maxiaide"
      ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" \
        --local-files "${code_path}/maxiaide ${code_path}/readme.txt ${code_path}/readme.md" --remote-path /usr/local/maxicode/maxiaide/
      echo ""
      ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" \
        --local-files "${code_path}/conf/custom_aide.conf ${code_path}/conf/default_custom_aide.conf ${code_path}/conf/custom_rules" --remote-path /usr/local/maxicode/maxiaide/conf
    elif [ "${app_name}" == "maxiperm" ]; then
      local code_path
      code_path="${STORAGE_PATH}/os/${distro_name}/usr/local/maxicode/maxiperm"
      ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" \
        --local-files "${code_path}/perm ${code_path}/readme.txt ${code_path}/readme.md" --remote-path /usr/local/maxicode/maxiperm/
    elif [ "${app_name}" == "maxinance" ]; then
      local code_path
      code_path="${STORAGE_PATH}/os/${distro_name}/usr/local/maxicode/maxinance"
      ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" \
        --local-files "${code_path}/maxinance ${code_path}/readme.txt ${code_path}/readme.md" --remote-path /usr/local/maxicode/maxinance/
    elif [ "${app_name}" == "maxida" ]; then
      local code_path
      code_path="${STORAGE_PATH}/os/${distro_name}/usr/local/maxicode/maxida"
      ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" \
        --local-files "${code_path}/maxida ${code_path}/dacli ${code_path}/readme.txt ${code_path}/readme.md" --remote-path /usr/local/maxicode/maxida/
    elif [ "${app_name}" == "maxicli" ]; then
      local code_path
      code_path="${STORAGE_PATH}/os/${distro_name}/usr/local/maxicode/maxicli"
      ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" \
        --local-files "${code_path}/maxicli ${code_path}/maxicli ${code_path}/readme.txt ${code_path}/readme.md" --remote-path /usr/local/maxicode/maxicli/
    elif [ "${app_name}" == "maxirbl" ]; then
      local code_path
      code_path="${STORAGE_PATH}/os/${distro_name}/usr/local/maxicode/maxirbl"
      ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" \
        --local-files "${code_path}/blcheck ${code_path}/search_field.awk" --remote-path /usr/local/maxicode/maxirbl/
    elif [ "${app_name}" == "maxiwall" ]; then
      local code_path
      code_path="${STORAGE_PATH}/os/${distro_name}/usr/local/maxicode/maxiwall"
      ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" \
        --local-files "${code_path}/maxiwall ${code_path}/maxiwall.conf ${code_path}/readme.txt ${code_path}/readme.md" --remote-path /usr/local/maxicode/maxiwall/
      # For code path
      ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" \
        --local-files "${code_path}/code/search_field.awk" --remote-path /usr/local/maxicode/maxiwall/code/
      # For all .lua report
      ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" \
        --local-files "${code_path}/code/etc/suricata/lua-output/maxiwall.lua ${code_path}/code/etc/suricata/lua-output/maxiwall-http.lua" --remote-path /etc/suricata/lua-output/
      # For suricata.yaml and suricata-test.yaml
      ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" \
        --local-files "${code_path}/code/etc/suricata/suricata.yaml ${code_path}/code/etc/suricata/suricata-test.yaml" --remote-path /etc/suricata/
      # For custom rules (maxiwall.rules and maxiwall-test.rules)
      ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" \
        --local-files "${code_path}/code/etc/suricata/rules/maxiwall.rules ${code_path}/code/etc/suricata/rules/maxiwall-test.rules" --remote-path /etc/suricata/rules/
      # For blcheck_service_file.lst (the custom blcheck blocklist file)
      ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" \
        --local-files "${code_path}/conf/blcheck_service_file.lst ${code_path}/conf/maxiwall_alert_log.lst" --remote-path /usr/local/maxicode/maxiwall/conf/

    else

      _echo "$(msg red)Error, unknown or invalid app_name ${app_name}$(msg end)" --name
      _exit 147
    fi
  fi

}
# da_api_admin <action> <action-option-arguments>
# For curl do not use --max-time or decrease time out because letsencrypt API will need more time to request cert
da_api_admin() {
  local action argnum short_opts long_opts options retval sign_as username password \
    ip_address netmask \
    email name nameserver1 nameserver2 where_username_is \
    package_name \
    domain subdomain ip_type \
    record_type record_name record_value record_domain record_priority record_subdomain record_ttl affect_pointers \
    special_type \
    skin_name logo_mode logo_file \
    answer question \
    text_output recommend_values \
    mail_domain mail_user mail_password mail_quota mail_limit \
    db_domain db_name db_user db_password db_existing_user \
    ssl_provider ssl_root_domain ssl_subdomains_query \
    backup_ip backup_path backup_file_name backup_password \
    api_username api_password \
    scripting
  action="$1"
  argnum="$#"

  #echo "${action}"
  short_opts="h"

  long_opts="help,sign-as:,username:,password:,ip-address:,netmask:,email:,name:,nameserver1:,nameserver2:,where-username-is:,text-output:,package-name:, \
  mail-domain:, mail-user:, mail-password:, mail-quota:, mail-limit:, db-domain:, db-name:, db-user:, db-password:, db-existing-user:,\
  recommend-values,domain:,subdomain:,ip-type:, record-type:, record-name:, record-value:, record-domain:, record-priority:, record-subdomain:, record-ttl:, affect-pointers:, special-type:, skin-name:, \
  backup-ip:,backup-path:,backup-file-name:,backup-password:,logo-mode:,logo-file:,question:,answer:,api-username:,api-password:,scripting"
  options=$(getopt -o "${short_opts}" --long "${long_opts}" -n "${FUNCNAME[0]}@${action} in ${SCRIPT_NAME}" -- "$@")
  retval=$?
  if [ ${retval} != 0 ]; then
    _echo "$(msg red)Error, invalid parsed data. Terminating...$(msg end)" >&2
    _exit 147
  fi

  eval set -- "${options}"
  sign_as="owner1"     # specify by role such as: owner1, admin1, reseller1, user1 OR specify by username such as: arafatx, maxi32. Default is owner1 (the first owner).
  username=""          # arafatx
  password=""          # 1234x
  ip_address=""        # Can be ipv4 or ipv6 address
  netmask=""           # eg: 255.255.255.0 or /24, /64
  email=""             # arafat@test.com
  name=""              # Arafat Ali
  nameserver1=""       # ns1.test.com
  nameserver2=""       # ns2.test.com
  where_username_is="" # admin
  text_output=""       # post
  mail_domain=""       # sofibox.com
  mail_user=""         # webmaster
  mail_password=""     # 12321
  mail_quota=""        # 0
  mail_limit=""        # 200
  db_domain=""         # abc.com
  db_name=""           # abc
  db_user=""           # dbuser123
  db_password=""       # 12321aa
  db_existing_user=""  # dbuser123
  package_name=""      # UNLIMITED_PACKAGE
  recommend_values=false
  domain=""               # sofibox.com
  subdomain=""            # abc (don not specify full domain)
  ip_type=""              # shared, server etc
  api_username=""         # arafatx
  api_password=""         # 1234x
  record_type=""          # txt,a,aaaa etc
  record_name=""          # _domainkey
  record_value=""         # value
  record_domain=""        # abc.com
  record_priority=""      # 10
  record_subdomain=""     # change
  record_ttl=""           # 36000
  affect_pointers=""      #yes or no
  special_type=""         # dkim, dmarc, spf, dkim-policy
  skin_name=""            # evolution, enhanced etc
  logo_mode=""            # default-logo, dark-logo, favicon
  logo_file=""            # /tmp/logo.png
  question=""             # Kau dah lama hidup?
  answer=""               # Belum
  ssl_provider=""         # letsencrypt, amazonaws, digitalocean
  ssl_root_domain=""      # test.com
  ssl_subdomains_query="" # the subdomain query in directadmin
  scripting=false
  backup_ip=""        # 1.2.3.4
  backup_path=""      # /root/backup_admin/
  backup_file_name="" # backup.tar.gz
  backup_password=""  # abc123

  while true; do
    case "$1" in
    -h | --help)
      manual "${FUNCNAME[0]}"
      shift
      exit 0
      ;;
    --sign-as)
      sign_as="$2"
      shift 2
      ;;
    --username)
      username="$2"
      shift 2
      ;;
    --password)
      password="$2"
      shift 2
      ;;
    --ip-address)
      ip_address="$2"
      shift 2
      ;;
    --netmask)
      netmask="$2"
      shift 2
      ;;
    --email)
      email="$2"
      shift 2
      ;;
    --name)
      name="$2"
      shift 2
      ;;
    --nameserver1)
      nameserver1="$2"
      shift 2
      ;;
    --nameserver2)
      nameserver2="$2"
      shift 2
      ;;
    --where-username-is)
      where_username_is="$2"
      shift 2
      ;;
    --text-output)
      text_output="$2"
      shift 2
      ;;
    --mail-domain)
      mail_domain="$2"
      shift 2
      ;;
    --mail-user)
      mail_user="$2"
      shift 2
      ;;
    --mail-password)
      mail_password="$2"
      shift 2
      ;;
    --mail-quota)
      mail_quota="$2"
      shift 2
      ;;
    --mail-limit)
      mail_limit="$2"
      shift 2
      ;;
    --db-domain)
      db_domain="$2"
      shift 2
      ;;
    --db-name)
      db_name="$2"
      shift 2
      ;;
    --db-user)
      db_user="$2"
      shift 2
      ;;
    --db-password)
      db_password="$2"
      shift 2
      ;;
    --db-existing-user)
      db_existing_user="$2"
      shift 2
      ;;
    --package-name)
      package_name="$2"
      shift 2
      ;;
    --recommend-values)
      recommend_values=true
      shift
      ;;
    --domain)
      domain="$2"
      shift 2
      ;;
    --subdomain)
      subdomain="$2"
      shift 2
      ;;
    --ip-type)
      ip_type="$2"
      shift 2
      ;;
    --record-type)
      record_type="$2"
      shift 2
      ;;
    --record-name)
      record_name="$2"
      shift 2
      ;;
    --record-value)
      record_value="$2"
      shift 2
      ;;
    --record-ttl)
      record_ttl="$2"
      shift 2
      ;;
    --record-domain)
      record_domain="$2"
      shift 2
      ;;
    --record-priority)
      record_priority="$2"
      shift 2
      ;;
    --record-subdomain)
      record_subdomain="$2"
      shift 2
      ;;
    --affect-pointers)
      affect_pointers="$2"
      shift 2
      ;;
    --special-type)
      special_type="$2"
      shift 2
      ;;
    --skin-name)
      skin_name="$2"
      shift 2
      ;;
    --logo-mode)
      logo_mode="$2"
      shift 2
      ;;
    --logo-file)
      logo_file="$2"
      shift 2
      ;;
    --question)
      question="$2"
      shift 2
      ;;
    --answer)
      answer="$2"
      shift 2
      ;;
    # This is not used but for reference, api_username will be automatically
    --api-username)
      # API use --sign-as, --signas
      api_username="$2"
      shift 2
      ;;
    --api-password)
      api_password="$2"
      shift 2
      ;;
    --scripting)
      scripting=true
      shift
      ;;
    --ssl-provider)
      ssl_provider="$2"
      shift 2
      ;;
    --ssl-root-domain)
      ssl_root_domain="$2"
      shift 2
      ;;
    --ssl-subdomains-query)
      ssl_subdomains_query="$2"
      shift 2
      ;;
    --backup-ip)
      backup_ip="$2"
      shift 2
      ;;
    --backup-path)
      backup_path="$2"
      shift 2
      ;;
    --backup-file-name)
      backup_file_name="$2"
      shift 2
      ;;
    --backup-password)
      backup_password="$2"
      shift 2
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
    esac
  done
  required "ubuntu@@apt:jq" "debian@@apt:jq"
  # da_api_admin debug --text-output "test"
  if [[ "${action}" == "debug" ]]; then
    local da_bin
    da_bin="/usr/local/directadmin/directadmin"
    if [[ -f "${da_bin}" ]]; then
      :
    else
      _echo "$(msg red)Error, directadmin binary does not exist!$(msg end)" --name
      _exit 147
    fi
    # This trap function is used to restore directadmin service back to normal once this debugging status is terminated
    traps da_debug_exit INT
    killall -9 directadmin
    if [ -n "${text_output}" ]; then
      echo ""
      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
      echo "                            **STARTING DIRECTADMIN DEBUG MODE**                       "
      echo ""
      echo "Running directadmin debug mode with filtered output ..."
      echo "FILTERED OUTPUT:"
      echo "${text_output}"
      echo ""
      echo "Press CTRL+C to exit debug mode"
      echo ""
      ${da_bin} b2000 | grep "${text_output}"
    else
      echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
      echo "                            **STARTING DIRECTADMIN DEBUG MODE**                       "
      echo ""
      echo "Running directadmin debug mode with full output ..."
      echo ""
      echo "Press CTRL+C to exit debug mode"
      echo ""
      ${da_bin} b2000
    fi

    _exit 0
  fi

  local da_api_username da_api_password admin_original_auth_file
  local user_list_path da_user

  #local owner_main_auth admin_main_auth reseller_main_auth user_main_auth user_extra_auth
  local ssl_protocol port

  # This folder contains list of directadmin users as folder name
  user_list_path="/usr/local/directadmin/data/users/"
  admin_original_auth_file="/usr/local/directadmin/scripts/setup.txt"

  port="$(cat /usr/local/directadmin/conf/directadmin.conf | grep '^port=' | cut -d= -f2)"

  if [ -z "${port}" ]; then
    [[ "${scripting}" == "false" ]] && _echo "$(msg red)Error, directadmin.conf should contain port option!$(msg end)" --name --verbose 7
    # or set default
    # port=2222
    _exit 147
  fi

  if [ "${C_DA_AUTO_SELECT_API_PROTOCOL}" == "true" ]; then
    if is_valid ssl_site "${C_BOX_HOSTNAME_FQHN}"; then
      [[ "${scripting}" == "false" ]] && _echo "OK, ${C_BOX_HOSTNAME_FQHN} is a valid SSL/https site"
      ssl_protocol="https"
    else
      [[ "${scripting}" == "false" ]] && _echo "$(msg yellow)Warning, using unsecured connection for directadmin API because ${C_BOX_HOSTNAME_FQHN} is currently not a valid SSL/https site$(msg end)" --name --verbose 7
      ssl_protocol="http"
    fi
  else
    [[ "${scripting}" == "false" ]] && _echo "$(msg yellow)Warning, using unsecured connection for directadmin API because ${C_BOX_HOSTNAME_FQHN} is currently not a valid SSL/https site$(msg end)" --name --verbose 7
    ssl_protocol="http"
  fi

  # TODO this one contains sensitive information, hide later or suggesting to use  --verbose less than 7
  if [[ "${scripting}" == "false" ]]; then
    _echo "$(msg newline)" --plain --verbose 7
    _echo "API_DETAILS:" --name --verbose 7
    _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7
    _echo "ALL ARGS: $*" --name --verbose 7
    _echo "ACTION: ${action}" --name --verbose 7
    _echo "SIGN_AS or EXECUTE_AS: ${sign_as}" --name --verbose 7
    _echo "$(msg newline)" --plain --verbose 7
  fi

  if [ "${C_DA_LOGIN_METHOD}" == "sign-as" ]; then

    if [ "${sign_as}" == "owner1" ]; then
      sign_as="${C_DA_OWNER_USERNAME1}"
    elif [ "${sign_as}" == "admin1" ]; then
      sign_as="${C_DA_ADMIN_USERNAME1}"
    elif [ "${sign_as}" == "reseller1" ]; then
      sign_as="${C_DA_RESELLER_USERNAME1}"
    elif [ "${sign_as}" == "user1" ]; then
      sign_as="${C_DA_USER_USERNAME1}"
    fi

    if [[ -n "${api_username}" && -z "${api_password}" ]]; then
      _echo "$(msg red)Error need option --api-password when supplying option --api-username or use --sign-as instead for automatic authentication!$(msg end)" --name
      _exit 147
    elif [[ -n "${api_password}" && -z "${api_username}" ]]; then
      _echo "$(msg red)Error need option --api-username when supplying option --api-password or use --sign-as instead for automatic authentication!$(msg end)" --name
      _exit 147
    fi

    da_user="$(basename "$(find ${user_list_path} -name "${sign_as}" -type d | tail -n 1)")"

    if [[ -n "${api_username}" && -n "${api_password}" ]]; then
      da_user="$(basename "$(find ${user_list_path} -name "${api_username}" -type d | tail -n 1)")"
      if [[ -n "${da_user}" ]]; then
        da_api_username="${api_username}"
        da_api_password="${api_password}"
        [[ "${scripting}" == "false" ]] && _echo "DA_API_USERNAME: ${da_api_username}" --name --verbose 7
      else
        _echo "$(msg red)Error, user ${api_username} does not exist in directadmin system!$(msg end)" --name
        _exit 147
      fi
    # if sign_as == the first owner username and it exist in system use that first owner
    elif [[ "${sign_as}" == "${C_DA_OWNER_USERNAME1}" && -n "${da_user}" ]]; then
      da_api_username="${C_DA_OWNER_USERNAME1}"
      da_api_password="${C_DA_OWNER_USERPASS1}"
      [[ "${scripting}" == "false" ]] && _echo "DA_API_USERNAME: ${da_api_username}" --name --verbose 7
    else # For other users other than owner but it must exist in the system
      if [[ -n "${da_user}" ]]; then
        da_api_username="${C_DA_OWNER_USERNAME1}|${da_user}"
        da_api_password="${C_DA_OWNER_USERPASS1}"
        [[ "${scripting}" == "false" ]] && _echo "DA_API_USERNAME: ${da_api_username} (Login-as)" --name --verbose 7
      else # If it does not exist in the system, we use default admin
        # If the above authentication does not exist, we try to use old admin from setup.txt (first check if old admin exist)
        da_user="$(basename "$(find ${user_list_path} -name "admin" -type d | tail -n 1)")"
        if [[ -n "${da_user}" ]]; then
          da_api_username=$(grep "^adminname" "${admin_original_auth_file}" | cut -d= -f2)
          da_api_password=$(grep "^adminpass" "${admin_original_auth_file}" | cut -d= -f2)
          [[ "${scripting}" == "false" ]] && _echo "DA_API_USERNAME: ${da_api_username} (from original admin setup.txt)" --name --verbose 7
        else
          _echo "$(msg red)Error, user ${sign_as} does not exist in directadmin system!$(msg end)" --name
          _exit 147
        fi
      fi
    fi
  else
    _echo "$(msg red)Error, directadmin login method [ ${C_DA_LOGIN_METHOD} ] is not recognized$(msg end)" --name
    _exit 147
  fi

  [[ "${scripting}" == "false" ]] && _echo "DA_API_PASSWORD: ${da_api_password}" --name --verbose 7
  [[ "${scripting}" == "false" ]] && _echo "API PROTOCOL SELECTED: ${ssl_protocol}" --name --verbose 7
  [[ "${scripting}" == "false" ]] && _echo "API PORT SELECTED: ${port}" --name --verbose 7
  [[ "${scripting}" == "false" ]] && _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7
  [[ "${scripting}" == "false" ]] && _echo "$(msg newline)" --plain --verbose 7

  if [[ "${action}" == "get-user-package" ]]; then
    local cmd_api data method da_api_exec has_success
    cmd_api="CMD_API_PACKAGES_USER"
    data="package=${package_name}"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
      _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    #_exit 147
    else
      _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
      _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    fi

  # da_api_admin test-login --username username_to_check
  # it will return exist=1 if found or exist=0 if not found
  elif [[ "${action}" == "test-login" || "${action}" == "login" ]]; then
    local cmd_api data method retval da_api_exec has_success
    cmd_api="CMD_API_USER_EXISTS"
    data="user=${username}"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

    if [ -z "${has_success}" ]; then
      _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
      _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    #_exit 147
    else
      _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
      _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    fi
    # eg: for ipv4 -> maxinet --da-api add-ip --sign-as owner1 --ip-address 1.1.1.1 --netmask 255.255.255.0
  # eg: for ipv6 -> maxinet --da-api add-ip --ip-address 2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b --netmask /64 for ipv4 -> maxinet --da-api add-ip --sign-as owner1 --ip-address 1.1.1.1 --netmask 255.255.255.0
  # eg: for ipv6 -> maxinet --da-api add-ip --ip-address 2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b --netmask /64
  elif [[ "${action}" == "add-ip" ]]; then
    local cmd_api data method retval da_api_exec has_success
    if is_valid ipv6 "${ip_address}"; then
      #echo "${netmask}" | grep -qE "(^(\/)((?:[0-9])|(?:[0-9][0-9][0-9])|(?:3[0-2])))$"
      # Remember for IPv6, netmask must be using subnet prefix notation. This will check that:
      #/1 - /64
      if ! is_valid ipv6_prefix "${netmask}"; then
        _echo "$(msg red)Error, IPv6 address requires netmask in subnet prefix notation. eg: /0 - /128$(msg end)" --name
        _exit 147
      fi
    fi

    #echo "Adding IP"
    #echo "Sign as: ${sign_as}"
    #echo "API username: ${da_api_username}"
    #echo "API password: ${da_api_password}"
    #echo "IP address is: ${ip_address}"
    #echo "Netmask is: ${netmask_ip}"
    # API configs
    cmd_api="CMD_API_IP_MANAGER"
    # the add_to_device_aware is needed if want to use device=yes or device=no (https://www.directadmin.com/features.php?id=2080)
    data="action=add&ip=${ip_address}&netmask=${netmask}&device=yes&add_to_device_aware=yes"
    method="POST"
    # API call
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

    if [ -z "${has_success}" ]; then
      _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
      _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    #_exit 147
    else
      _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
      _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    fi
    # This is deprecated (as the real API has not released yet for CMD_API_ADMIN_SETTINGS)
    #da_api_admin set-da-admin-settings --recommend-values
  elif [[ "${action}" == "set-da-admin-settings" ]]; then
    # Big NOTE! directadmin does not have CMD_API_ADMIN_SETTINGS
    local cmd_api data method retval da_api_exec has_success has_cmd_api
    has_cmd_api="false"
    _echo "$(msg yellow)Note, directadmin does not have CMD_API_ADMIN_SETTINGS for this call (https://forum.directadmin.com/threads/api-set-server-hostname.37872/post-188426). Using CMD_ADMIN_SETTINGS ...$(msg end)" --name
    #error=1&text=You%20cannot%20execute%20that%20command&details=The%20request%20you%27ve%20made%20cannot%20be%20executed%20because%20it%20does%20not%20exist%20in%20your%20authority%20level
    # Note this CMD_API_ADMIN_SETTINGS have not been released. So, we need to use json and ignore error checking
    # If the API is released, just put has_cmd_api=true, this will automatically use the new API
    method="POST"
    # This API includes security settings and email settings (DA combined this)
    if [ "${has_cmd_api}" == "false" ]; then
      cmd_api="CMD_ADMIN_SETTINGS"
      if [ "${recommend_values}" == "true" ]; then
        # TODO: Note the auto_update=yes here might be part of custombuild setting (check that)
        # Remember to use json=yes, if not no output or weird output because API has not released
        data="auto_update=yes&backup_threshold=90&demo_admin=no&demo_reseller=no&demo_user=no&oversell=yes&service_email_active=yes&suspend=yes&user_backup=yes&action=save&json=yes"
      else
        _echo "$(msg red)Error, please temporarily use the option --recommend-values for this action ${action} $(msg end)" --name
        # Add single values here
        _exit 147
      fi
      curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}"
    else # If API released true
      cmd_api="CMD_API_ADMIN_SETTINGS"
      if [ "${recommend_values}" == "true" ]; then
        data="auto_update=yes&backup_threshold=90&demo_admin=no&demo_reseller=no&demo_user=no&oversell=yes&service_email_active=yes&suspend=yes&user_backup=yes&action=save"
      else
        _echo "$(msg red)Error, please temporarily use the option --recommend-values for this action ${action} $(msg end)" --name
        # Add single values here
        _exit 147
      fi

      da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
      has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

      if [ -z "${has_success}" ]; then
        _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
        _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
      #_exit 147
      else
        _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
        _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
      fi
    fi
  elif [[ "${action}" == "set-da-server-settings" ]]; then
    local cmd_api data method retval da_api_exec has_success has_cmd_api
    has_cmd_api=false
    cmd_api="CMD_ADMIN_SETTINGS"
    _echo "$(msg yellow)Note, directadmin does not have CMD_API_ADMIN_SETTINGS for this call (https://forum.directadmin.com/threads/api-set-server-hostname.37872/post-188426). Using CMD_ADMIN_SETTINGS ...$(msg end)" --name

    if [ "${recommend_values}" == "true" ]; then
      # Recommend values
      # Remember to use json=yes, if not no output or weird output because API has not released
      #data="per_email_limit=200&rbl_enabled=yes&session_minutes=${C_DA_SESSION_MINUTES}&virtual_limit=1000&action=config&json=yes"
      # Important the parameter maxfilesize, servername, ns1, ns2, timeout are needed, without them this API will fail. The rest parameter are not included in directadmin.conf
      if [ "${C_DA_RBL_ENABLED}" == "1" ]; then
        C_DA_RBL_ENABLED="yes"
      else
        C_DA_RBL_ENABLED="no"
      fi
      data="maxfilesize=${C_DA_MAXFILESIZE}&servername=${C_BOX_HOSTNAME_FQHN}&ns1=${C_BOX_NS1}&ns2=${C_BOX_NS2} \
      &per_email_limit=${C_DA_PER_EMAIL_LIMIT}&rbl_enabled=${C_DA_RBL_ENABLED}&timeout=${C_DA_TIMEOUT}&virtual_limit=${C_DA_VIRTUAL_LIMIT}&json=yes&action=config"

    else
      _echo "$(msg red)Error, please temporarily use the option --recommend-values for this action ${action} $(msg end)" --name
      # Add single values here
      _exit 147
    fi
    method="POST"
    if [ "${has_cmd_api}" == "false" ]; then
      curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}"
    else
      da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
      has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
      if [ -z "${has_success}" ]; then
        _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
        _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
      #_exit 147
      else
        _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
        _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
      fi
    fi
    # da_api_admin modify-user --sign-as owner1 --where-username-is admin --email abc@dsaa.com --name Arafat Ali --nameserver1 ns1.test.com --nameserver2 ns2.test.com
  elif [[ "${action}" == "modify-user" || "${action}" == "change-user" || "${action}" == "update-user" ]]; then
    local cmd_api method retval da_api_exec has_success data data1 data2 data3 data4
    cmd_api="CMD_API_MODIFY_USER"
    method="POST"
    # If email option is provided, we check the email
    if [ -n "${email}" ]; then
      if is_valid "email" "${domain_email}"; then
        [[ ${scripting} == "false" ]] && _echo "$(msg green)OK, the given --email $(msg red)${email}$(msg green) is valid$(msg end)" --name --verbose 7
      else
        _echo "$(msg yellow)Warning, the given --email $(msg red)${email}$(msg green) is not valid$(msg end)" --name
        return 147
      fi
      data1="user=${where_username_is}&evalue=${email}&action=single&email=yes"
    fi

    if [ -n "${name}" ]; then
      data2="user=${where_username_is}&nvalue=${name}&action=single&name=yes"
    fi

    if [ -n "${nameserver1}" ]; then
      data3="user=${where_username_is}&ns1=${nameserver1}&action=single&ns=yes"
    fi

    if [ -n "${nameserver2}" ]; then
      data4="user=${where_username_is}&ns2=${nameserver2}&action=single&ns=yes"
    fi

    for data in "${data1}" "${data2}" "${data3}" "${data4}"; do

      #echo "data-------------------------: ${data}"
      if [ -n "${data}" ]; then
        da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
        has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

        if [ -z "${has_success}" ]; then
          _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
          _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
        #_exit 147
        else
          _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
          _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
        fi
      fi
    done
    # da_api_admin create-admin-account --username admin2 --email admin2@test.com --password abc12321
  elif [ "${action}" == "create-admin-account" ]; then
    local cmd_api data method retval da_api_exec has_success
    cmd_api="CMD_API_ACCOUNT_ADMIN"
    data="action=create&add=submit&username=${username}&email=${email}&passwd=${password}&passwd2=${password}&notify=no"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
      _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    #_exit 147
    else
      _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
      _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    fi

  # da_api_admin create-reseller-account --sign-as admin1 --username reseller2 --email reseller2@test.com --password abc1231aa --domain test.com --package-name "RESELLER_UNLIMITED" --ip-type "shared"
  elif [ "${action}" == "create-reseller-account" ]; then
    local cmd_api data method retval da_api_exec has_success
    cmd_api="CMD_API_ACCOUNT_RESELLER" # CMD_ACCOUNT_RESELLER is not working
    data="username=${username}&email=${email}&passwd=${password}&passwd2=${password}&domain=${domain}&package=${package_name}&notify=yes&ip=${ip_type}&action=create&add=yes"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
      _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    #_exit 147
    else
      _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
      _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    fi
  # da_api_admin create-reseller-package --package-name "RESELLER_UNLIMITED" --recommend-values
  elif [ "${action}" == "create-reseller-package" ]; then
    local cmd_api data method retval da_api_exec has_success
    cmd_api="CMD_API_MANAGE_RESELLER_PACKAGES"
    if [ "${recommend_values}" == "true" ]; then
      # This is unlimited RESELLER package recommend values:
      data="bandwidth=5000&ubandwidth=yes&quota=1000&uquota=yes&inode=&uinode=yes&vdomains=10&uvdomains=yes&nsubdomains=10 \
    &unsubdomains=yes&nemails=100&unemails=yes&nemailf=100&unemailf=yes&nemailml=10&unemailml=yes&nemailr=100&unemailr=yes \
    &mysql=0&umysql=yes&domainptr=0&udomainptr=yes&ftp=10&uftp=yes&cgi=ON&php=ON&spam=ON&catchall=ON&ssl=ON&oversell=ON&cron=ON \
    &sysinfo=ON&login_keys=ON&dnscontrol=ON&dns=OFF&serverip=ON&packagename=${package_name}&nusers=&unusers=yes&add=save&ips=0"
    else
      _echo "$(msg red)Error, please temporarily use the option --recommend-values for this action ${action} $(msg end)" --name
      # Add single values here
      _exit 147
    fi
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")

    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

    if [ -z "${has_success}" ]; then
      _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
      _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    #_exit 147
    else
      _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
      _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    fi
    # da_api_admin create-user-package --package-name "USER_UNLIMITED" --recommend-values
  elif [ "${action}" == "create-user-package" ]; then
    local cmd_api data method retval da_api_exec has_success
    cmd_api="CMD_API_MANAGE_USER_PACKAGES"
    if [ "${recommend_values}" == "true" ]; then
      # This is unlimited USER package recommend values: (this API has changed because of new feature)
      data="bandwidth=1000&ubandwidth=yes&quota=100&uquota=yes&inode=&uinode=yes&vdomains=1&uvdomains=yes&nsubdomains=10 \
    &unsubdomains=yes&nemails=10&unemails=yes&unemailf=yes&nemailml=0&unemailml=yes&nemailr=10&unemailr=yes \
    &mysql=5&umysql=yes&domainptr=0&udomainptr=yes&ftp=1&uftp=yes&php=ON&spam=ON&catchall=ON&ssl=ON&cron=ON \
    &sysinfo=ON&login_keys=ON&dnscontrol=ON&suspend_at_limit=ON&language=en&skin=evolution&packagename=${package_name}&add=save"
    else
      _echo "$(msg red)Error, please temporarily use the option --recommend-values for this action ${action} $(msg end)" --name
      # Add single values here
      _exit 147
    fi
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

    if [ -z "${has_success}" ]; then
      _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
      _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    #_exit 147
    else
      _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
      _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    fi

  elif [[ "${action}" == "enable-domain-dkim" || "${action}" == "enable-email-dkim" ]]; then
    local cmd_api data method retval da_api_exec has_success
    cmd_api="CMD_API_EMAIL_POP"
    data="action=set_dkim&domain=${domain}&enable=yes"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

    if [ -z "${has_success}" ]; then
      _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
      _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    #_exit 147
    else
      _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
      _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    fi
    # da_api_admin create-admin-dns-record--domain test.com --record-type TXT --record-name name11 --record-value value1 --record-ttl 30 --affect-pointers yes
  elif [[ "${action}" == "create-admin-dns-record" || "${action}" == "add-admin-dns-record" ]]; then
    local cmd_api data method retval da_api_exec has_success record_value
    cmd_api="CMD_API_DNS_ADMIN"
    affect_pointers=yes
    data="domain=${domain}&type=${record_type}&name=${record_name}&value=${record_value}&ttl=${record_ttl}&affect_pointers=${affect_pointers}&action=add"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

    if [ -z "${has_success}" ]; then
      _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
      _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    #_exit 147
    else
      _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
      _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    fi
    # Other DNS record:
    # da_api_admin create-dns-record --domain test.com --record-type TXT --record-name name11 --record-value value1 --record-ttl 30 --affect-pointers yes
    # MX RECORD:
  elif [[ "${action}" == "create-dns-record" || "${action}" == "add-dns-record" ]]; then
    local cmd_api data method retval da_api_exec has_success record_value
    cmd_api="CMD_API_DNS_CONTROL"
    affect_pointers=yes
    if [[ "${record_type^^}" == "MX" ]]; then
      # for mx record, record name is the domain, record value is priority, record subdomain is mx_value
      data="domain=${domain}&type=${record_type}&name=${record_domain}&value=${record_priority}&mx_value=${record_subdomain}&ttl=${record_ttl}&affect_pointers=${affect_pointers}&action=add"
    else
      data="domain=${domain}&type=${record_type}&name=${record_name}&value=${record_value}&ttl=${record_ttl}&affect_pointers=${affect_pointers}&action=add"
    fi
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

    if [ -z "${has_success}" ]; then
      _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
      _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    #_exit 147
    else
      _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
      _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    fi
    # da_api_admin get-dns-special-record-type-value --where-domain-name-is test.com --special-type 'dkim'
    # special-type dkim, dkim-policy, spf, dmarc
    # This can return many records, to return only one record use with this | tail -n 1
  elif [ "${action}" == "get-dns-special-record-type-value" ]; then
    local cmd_api data method has_record
    cmd_api="CMD_API_DNS_CONTROL"
    data="domain=${domain}&json=yes"
    method="POST"

    if [ "${special_type}" == "dkim" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select((.type==\"TXT\") and (.name==\"x._domainkey\") and (.value | contains(\"v=DKIM1\"))) \
        | .value" |
        sed -e 's/^"//' -e 's/"$//')
    elif [ "${special_type}" == "dkim-policy" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select((.type==\"TXT\") and (.name==\"_domainkey\") and (.value | contains(\"o=\"))) \
        | .value" |
        sed -e 's/^"//' -e 's/"$//')
    elif [ "${special_type}" == "spf" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select((.type==\"TXT\") and (.name==\"${domain}.\") and (.value | contains(\"v=spf1\"))) \
        | .value" |
        sed -e 's/^"//' -e 's/"$//')
    elif [ "${special_type}" == "dmarc" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select((.type==\"TXT\") and (.name==\"_dmarc\") and (.value | contains(\"v=DMARC1\"))) \
        | .value" |
        sed -e 's/^"//' -e 's/"$//')
    fi

    if [ -z "${has_record}" ]; then
      _echo "$(msg red)Warning, no record found for the dns special record ${special_type} $(msg end)" --name
      _echo "$(msg red)${has_record}$(msg end)" --plain | urldecode | awksep '&'
      _exit 147
    else
      echo "${has_record}"
      return 0
    fi

  elif [[ "${action}" == "get-dns-zone" || "${action}" == "get-dns-records" ]]; then
    local cmd_api data method da_api_exec has_success
    cmd_api="CMD_API_DNS_ADMIN"
    # Need to pass full_max_records to display full list of mx records
    data="domain=${domain}&json=yes&full_mx_records=yes"
    method="POST"

    if [ "${special_type^^}" == "A" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select(.type==\"A\")")
    elif [ "${special_type^^}" == "AAAA" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select(.type==\"AAAA\")")
    elif [ "${special_type^^}" == "CNAME" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select(.type==\"CNAME\")")
      # This wil list all TXT record
    elif [ "${special_type^^}" == "TXT" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select(.type==\"TXT\")")
    elif [ "${special_type^^}" == "NS" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select(.type==\"NS\")")
    elif [ "${special_type^^}" == "MX" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select(.type==\"MX\")")
    elif [ "${special_type^^}" == "SRV" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select(.type==\"SRV\")")
    elif [ "${special_type^^}" == "CAA" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select(.type==\"CAA\")")
    elif [ "${special_type^^}" == "PTR" ]; then
      has_record=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}" |
        jq -r ".records[] \
        | select(.type==\"PTR\")")
    fi

    if [ -z "${has_record}" ]; then
      [[ "${scripting}" == "false" ]] && _echo "$(msg red)Warning, no record found for the dns special record ${special_type} $(msg end)" --name
      return 147
    else
      echo "${has_record}"
      return 0
    fi

  # da_api_admin create-domain --domain test.com --recommend-values
  elif [ "${action}" == "create-domain" ]; then
    local cmd_api data method da_api_exec has_success
    cmd_api="CMD_API_DOMAIN"
    if [ "${recommend_values}" == "true" ]; then
      data="domain=${domain}&uquota=unlimited&ssl=ON&php=ON&action=create&ubandwidth=unlimited"
    else
      _echo "$(msg red)Error, please temporarily use the option --recommend-values for this action ${action} $(msg end)" --name
      # Add single values here
      _exit 147
    fi
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
      _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    #_exit 147
    else
      _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
      _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    fi
    # da_api_admin set-da-skin-settings --skin-name="evolution"
  elif [[ "${action}" == "set-da-skin-settings" || "${action}" == "set-da-skin-setting" ]]; then
    local cmd_api data method retval da_api_exec has_success
    cmd_api="CMD_API_SKINS"
    #config will be stored in: username/skin_customizations/evolution/config.json
    db_route_name=$(echo "${C_PHPMYADMIN_LOGIN_ROUTE}" | sed 's/^\///')
    rc_route_name=$(echo "${C_ROUNDCUBE_LOGIN_ROUTE}" | sed 's/^\///')
    # This value I got from da-debug, removed the json=yes inside that json, validate that json file online, then add extra json=yes&name=evolution&action=save_config_json&config.json=
    if [ "${recommend_values}" == "true" ]; then
      # TODO shorten this long json
      if [ "${skin_name}" == "evolution" ]; then
        data="name=${skin_name}&action=save_config_json&config.json=%7B%22menu%22%3A%7B%22user%22%3A%5B%7B%22name%22%3A%22Account%20Manager%22%2C%22icon%22%3A%22account-manager%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Fuser%2Fdomains%22%2C%22name%22%3A%22Domain%20Setup%22%2C%22icon%22%3A%22domain-setup%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fsubdomains%22%2C%22name%22%3A%22Subdomain%20Management%22%2C%22icon%22%3A%22subdomain-management%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fdns%22%2C%22name%22%3A%22DNS%20Management%22%2C%22icon%22%3A%22dns-management%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fssl%22%2C%22name%22%3A%22SSL%20Certificates%22%2C%22icon%22%3A%22ssl%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fftp-accounts%22%2C%22name%22%3A%22FTP%20Management%22%2C%22icon%22%3A%22ftp-management%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fdatabase%22%2C%22name%22%3A%22MySQL%20Management%22%2C%22icon%22%3A%22mysql-management%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fdomain-pointers%22%2C%22name%22%3A%22Domain%20Pointers%22%2C%22icon%22%3A%22domain-pointers%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fredirects%22%2C%22name%22%3A%22Site%20Redirection%22%2C%22icon%22%3A%22site-redirection%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fhotlinks%22%2C%22name%22%3A%22Hotlinks%20Protection%22%2C%22icon%22%3A%22hotlinks%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fphp-settings%22%2C%22name%22%3A%22PHP%20Settings%22%2C%22icon%22%3A%22php-configuration%22%2C%22enabled%22%3Atrue%7D%5D%7D%2C%7B%22name%22%3A%22E-mail%20Manager%22%2C%22icon%22%3A%22email-manager%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Fuser%2Femail%2Faccounts%22%2C%22name%22%3A%22E-mail%20Accounts%22%2C%22icon%22%3A%22email-accounts%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Fforwarders%22%2C%22name%22%3A%22Forwarders%22%2C%22icon%22%3A%22forwarders%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Fautoresponders%22%2C%22name%22%3A%22Autoresponders%22%2C%22icon%22%3A%22autoresponders%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Fvacations%22%2C%22name%22%3A%22Vacation%20Messages%22%2C%22icon%22%3A%22vacation-messages%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Fspamassassin%22%2C%22name%22%3A%22Spamassassin%20Setup%22%2C%22icon%22%3A%22spamassassin%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Ffilters%22%2C%22name%22%3A%22SPAM%20Filters%22%2C%22icon%22%3A%22spam-filters%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Flists%22%2C%22name%22%3A%22Mailing%20Lists%22%2C%22icon%22%3A%22mailing-lists%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fdns%2Fmx-records%22%2C%22name%22%3A%22MX%20Records%22%2C%22icon%22%3A%22mx-records%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Ftracking%22%2C%22name%22%3A%22E-mail%20Tracking%22%2C%22icon%22%3A%22email-tracking%22%2C%22enabled%22%3Atrue%7D%5D%7D%2C%7B%22icon%22%3A%22advanced-features%22%2C%22name%22%3A%22Advanced%20Features%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Fuser%2Fhandlers%22%2C%22name%22%3A%22Apache%20Handlers%22%2C%22icon%22%3A%22apache-handlers%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Femail%2Fcatch-all%22%2C%22name%22%3A%22Catch-All%20E-mail%22%2C%22icon%22%3A%22catch-all-email%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fbackup%22%2C%22name%22%3A%22Create%2FRestore%20Backups%22%2C%22icon%22%3A%22create-restore-backup%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fcronjobs%22%2C%22name%22%3A%22Cron%20Jobs%22%2C%22icon%22%3A%22cron-jobs%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Ferror-pages%22%2C%22name%22%3A%22Custom%20Error%20Pages%22%2C%22icon%22%3A%22custom-error-pages%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fmimetypes%22%2C%22name%22%3A%22Mime%20Types%22%2C%22icon%22%3A%22mime-types%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fsecurity-questions%22%2C%22name%22%3A%22Security%20Questions%22%2C%22icon%22%3A%22security-questions%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Ftwo-step-auth%22%2C%22name%22%3A%22Two-Step%20Authentication%22%2C%22icon%22%3A%22two-step-auth%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fprotected-directories%22%2C%22name%22%3A%22Password%20Protected%20Directories%22%2C%22icon%22%3A%22password-protected-directories%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fssh-keys%22%2C%22name%22%3A%22SSH%20Keys%22%2C%22icon%22%3A%22ssh-keys%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fmodsecurity%22%2C%22name%22%3A%22ModSecurity%22%2C%22icon%22%3A%22mod-security%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Funit%22%2C%22name%22%3A%22Nginx%20Unit%22%2C%22icon%22%3A%22nginx-unit%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fnginx-templates%22%2C%22name%22%3A%22Nginx%20URL%20Rewrites%22%2C%22icon%22%3A%22nginx-templates%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fredis%22%2C%22name%22%3A%22Redis%22%2C%22icon%22%3A%22redis%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fgit%22%2C%22name%22%3A%22Git%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22resource-limits%22%7D%5D%7D%2C%7B%22icon%22%3A%22system-information%22%2C%22name%22%3A%22System%20Info%20%26%20Files%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%2FCMD_FILE_MANAGER%22%2C%22newTab%22%3Atrue%2C%22name%22%3A%22File%20Manager%22%2C%22icon%22%3A%22file-manager%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fperl-modules%22%2C%22name%22%3A%22Installed%20Perl%20Modules%22%2C%22icon%22%3A%22installed-perl-modules%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fsystem-info%22%2C%22name%22%3A%22System%20Information%22%2C%22icon%22%3A%22server-information%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fstats%22%2C%22name%22%3A%22Site%20Summary%20%2F%20Statistics%20%2F%20Logs%22%2C%22icon%22%3A%22site-summary%22%2C%22enabled%22%3Atrue%7D%2C%7B%22route%22%3A%22%2Fuser%2Fresource-limits%22%2C%22name%22%3A%22Resource%20Limits%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22resource-limits%22%7D%5D%7D%2C%7B%22icon%22%3A%22extra-features%22%2C%22name%22%3A%22Extra%20Features%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2Fsquirrelmail%22%2C%22name%22%3A%22Webmail%3A%20Squirrelmail%22%2C%22enabled%22%3Afalse%2C%22newTab%22%3Atrue%2C%22slug%22%3A%22squirrelmail%22%2C%22icon%22%3A%22squirellmail%22%7D%2C%7B%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2F${rc_route_name}%22%2C%22name%22%3A%22Webmail%3A%20${C_ROUNDCUBE_CUSTOM_NAME}%22%2C%22enabled%22%3Atrue%2C%22newTab%22%3Atrue%2C%22slug%22%3A%22roundcube%22%2C%22icon%22%3A%22roundcube%22%7D%2C%7B%22route%22%3A%22phpmyadmin%22%2C%22name%22%3A%22phpMyAdmin%22%2C%22enabled%22%3Afalse%2C%22icon%22%3A%22phpmyadmin%22%7D%2C%7B%22route%22%3A%22plugins%22%2C%22name%22%3A%22Plugins%20will%20be%20inserted%20after%20this%20entry%22%2C%22enabled%22%3Afalse%7D%2C%7B%22name%22%3A%22Database%3A%20${C_PHPMYADMIN_CUSTOM_NAME}%22%2C%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2F${db_route_name}%22%2C%22newTab%22%3Atrue%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22phpmyadmin%22%7D%5D%7D%2C%7B%22icon%22%3A%22support-help%22%2C%22name%22%3A%22Support%20%26%20Help%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%7B%7Bhelp%7D%7D%22%2C%22name%22%3A%22Help%22%2C%22enabled%22%3Atrue%2C%22newTab%22%3Atrue%2C%22icon%22%3A%22help%22%7D%2C%7B%22route%22%3A%22%2Fuser%2Fcreate-ticket%22%2C%22name%22%3A%22Create%20Ticket%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22create-ticket%22%7D%2C%7B%22route%22%3A%22%2Fuser%2Fmessages%22%2C%22name%22%3A%22Support%20Center%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22support-center%22%7D%5D%7D%5D%2C%22reseller%22%3A%5B%7B%22name%22%3A%22Account%20Manager%22%2C%22icon%22%3A%22account-manager%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A3%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Freseller%2Fcreate-user%22%2C%22name%22%3A%22Add%20New%20User%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22add-new-user%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fusers%22%2C%22name%22%3A%22List%20Users%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22list-users%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fuser-packages%22%2C%22name%22%3A%22Manage%20User%20Packages%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22manage-user-packages%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fpasswords%22%2C%22name%22%3A%22Change%20Passwords%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22change-passwords%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fedit-user-message%22%2C%22name%22%3A%22Edit%20User%20Message%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22edit-user-message%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fsuspension-message%22%2C%22name%22%3A%22Suspension%20Message%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22edit-user-message%22%7D%5D%7D%2C%7B%22name%22%3A%22Server%20Manager%22%2C%22icon%22%3A%22server-manager%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Freseller%2Fip-config%22%2C%22name%22%3A%22IP%20Management%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22ip-management%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fnameservers%22%2C%22name%22%3A%22Name%20Servers%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22name-servers%22%7D%2C%7B%22route%22%3A%22%2Fuser%2Fssh-keys%22%2C%22name%22%3A%22SSH%20Keys%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22ssh-keys%22%7D%5D%7D%2C%7B%22name%22%3A%22Reseller%20Tools%22%2C%22icon%22%3A%22admin-tools%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Freseller%2Fbackups%22%2C%22name%22%3A%22Manage%20User%20Backups%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22manage-user-backups%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fmessage-users%22%2C%22name%22%3A%22Message%20All%20Users%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22message-all-users%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fskins%22%2C%22name%22%3A%22Skin%20Manager%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22skin-manager%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fcustomize-skin%22%2C%22name%22%3A%22Customize%20Evolution%20Skin%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22customize-evolution-skin%22%7D%5D%7D%2C%7B%22name%22%3A%22System%20Info%20%26%20Files%22%2C%22icon%22%3A%22system-information%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%2FCMD_FILE_MANAGER%22%2C%22newTab%22%3Atrue%2C%22name%22%3A%22File%20Manager%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22file-manager%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fsystem-info%22%2C%22name%22%3A%22System%20Information%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22system-info%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fstats%22%2C%22name%22%3A%22Reseller%20Statistics%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22reseller-statistics%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fresource-limits%22%2C%22name%22%3A%22Resource%20Limits%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22resource-limits%22%7D%5D%7D%2C%7B%22name%22%3A%22Extra%20Features%22%2C%22icon%22%3A%22extra-features%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2Fsquirrelmail%22%2C%22name%22%3A%22Webmail%3A%20Squirrelmail%22%2C%22enabled%22%3Afalse%2C%22newTab%22%3Atrue%2C%22slug%22%3A%22squirrelmail%22%2C%22icon%22%3A%22squirellmail%22%7D%2C%7B%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2Fwebmail%22%2C%22name%22%3A%22Webmail%3A%20UebiMiau%22%2C%22enabled%22%3Afalse%2C%22newTab%22%3Atrue%2C%22slug%22%3A%22uebimiau%22%2C%22icon%22%3A%22uebimiau%22%7D%2C%7B%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2F${rc_route_name}%22%2C%22name%22%3A%22Webmail%3A%20${C_ROUNDCUBE_CUSTOM_NAME}%22%2C%22enabled%22%3Atrue%2C%22newTab%22%3Atrue%2C%22slug%22%3A%22roundcube%22%2C%22icon%22%3A%22roundcube%22%7D%2C%7B%22route%22%3A%22phpmyadmin%22%2C%22name%22%3A%22phpMyAdmin%22%2C%22enabled%22%3Afalse%2C%22icon%22%3A%22phpmyadmin%22%7D%2C%7B%22route%22%3A%22plugins%22%2C%22name%22%3A%22Plugins%20will%20be%20inserted%20after%20this%20entry%22%2C%22enabled%22%3Afalse%7D%2C%7B%22name%22%3A%22Database%3A%20${C_PHPMYADMIN_CUSTOM_NAME}%22%2C%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2F${db_route_name}%22%2C%22newTab%22%3Atrue%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22phpmyadmin%22%7D%5D%7D%2C%7B%22name%22%3A%22Support%20%26%20Help%22%2C%22icon%22%3A%22support-help%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%7B%7Bhelp%7D%7D%22%2C%22name%22%3A%22Help%22%2C%22enabled%22%3Atrue%2C%22newTab%22%3Atrue%2C%22icon%22%3A%22help%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Ftickets%22%2C%22name%22%3A%22Manage%20Tickets%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22manage-tickets%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Ftickets%2Fcreate%22%2C%22name%22%3A%22Create%20Ticket%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22create-ticket%22%7D%5D%7D%5D%2C%22admin%22%3A%5B%7B%22name%22%3A%22Account%20Manager%22%2C%22icon%22%3A%22account-manager%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A4%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Freseller%2Fcreate-user%22%2C%22name%22%3A%22Add%20New%20User%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22add-new-user%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fusers%22%2C%22name%22%3A%22Show%20All%20Users%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22show-all-users%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fusers%22%2C%22name%22%3A%22My%20Users%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22list-users%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fuser-packages%22%2C%22name%22%3A%22Manage%20User%20Packages%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22manage-user-packages%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fusers%2Fmove%22%2C%22name%22%3A%22Move%20Users%20between%20Resellers%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22move-users-between-resellers%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fedit-user-message%22%2C%22name%22%3A%22Edit%20User%20Message%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22edit-user-message%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fpasswords%22%2C%22name%22%3A%22Change%20Passwords%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22change-passwords%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fusers%2Fresellers%2Fcreate%22%2C%22name%22%3A%22Create%20Reseller%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22create-reseller%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fusers%2Fresellers%22%2C%22name%22%3A%22List%20Resellers%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22list-resellers%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Freseller-packages%22%2C%22name%22%3A%22Manage%20Reseller%20Packages%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22manage-reseller-packages%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fusers%2Fadmins%2Fcreate%22%2C%22name%22%3A%22Create%20Administrator%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22create-administrator%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fusers%2Fadmins%22%2C%22name%22%3A%22List%20Administrators%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22list-administrators%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fsuspension-message%22%2C%22name%22%3A%22Suspension%20Message%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22edit-user-message%22%7D%5D%7D%2C%7B%22name%22%3A%22Server%20Manager%22%2C%22icon%22%3A%22server-manager%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A3%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Fadmin%2Fsettings%22%2C%22name%22%3A%22Administrator%20Settings%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22administrator-settings%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fcustom-httpd%22%2C%22name%22%3A%22Custom%20HTTPD%20Configurations%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22custom-httpd-configuration%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fdns%22%2C%22name%22%3A%22DNS%20Administration%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22dns-administration%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fip-manager%22%2C%22name%22%3A%22IP%20Management%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22ip-management%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fnameservers%22%2C%22name%22%3A%22Name%20Servers%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22name-servers%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fmulti-server%22%2C%22name%22%3A%22Multi%20Server%20Setup%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22multi-server-setup%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fphp-safe-mode%22%2C%22name%22%3A%22PHP%20Configuration%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22php-configuration%22%7D%2C%7B%22route%22%3A%22%2Fuser%2Fssh-keys%22%2C%22name%22%3A%22SSH%20Keys%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22ssh-keys%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fssl%22%2C%22name%22%3A%22Admin%20SSL%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22admin-ssl%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fmodsecurity%22%2C%22name%22%3A%22ModSecurity%22%2C%22enabled%22%3Atrue%7D%5D%7D%2C%7B%22name%22%3A%22Admin%20Tools%22%2C%22icon%22%3A%22admin-tools%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A3%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Fadmin%2Fbackups%22%2C%22name%22%3A%22Admin%20Backup%2FTransfer%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22admin-backup-transfer%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fbrute-force-monitor%22%2C%22name%22%3A%22Brute%20Force%20Monitor%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22brute-force-monitor%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fprocess-monitor%22%2C%22name%22%3A%22Process%20Monitor%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22process-monitor%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fmail-queue%22%2C%22name%22%3A%22Mail%20Queue%20Administration%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22mail-queue-administration%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Femail-tracking%22%2C%22name%22%3A%22E-mail%20Tracking%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22email-tracking%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fservices%22%2C%22name%22%3A%22Service%20Monitor%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22service-monitor%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fsystem-backup%22%2C%22name%22%3A%22System%20Backup%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22system-backup%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fmessage-users%22%2C%22name%22%3A%22Message%20All%20Users%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22message-all-users%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fskins%22%2C%22name%22%3A%22Skin%20Manager%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22skin-manager%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Fcustomize-skin%22%2C%22name%22%3A%22Customize%20Evolution%20Skin%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22customize-evolution-skin%22%7D%2C%7B%22slug%22%3A%22rspamd%22%2C%22href%22%3A%22%2FCMD_RSPAMD_SOCK%2F%22%2C%22name%22%3A%22Rspamd%20spam%20filtering%20system%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22spam-metrics%22%2C%22newTab%22%3Atrue%7D%2C%7B%22slug%22%3A%22netdata%22%2C%22href%22%3A%22%2FCMD_NETDATA_SOCK%2F%22%2C%22name%22%3A%22Netdata%20server%20metrics%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22netdata%22%2C%22newTab%22%3Atrue%7D%5D%7D%2C%7B%22name%22%3A%22System%20Info%20%26%20Files%22%2C%22icon%22%3A%22system-information%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A3%2C%22entries%22%3A%5B%7B%22route%22%3A%22%2Fadmin%2Fcron-jobs%22%2C%22name%22%3A%22All%20User%20Cron%20Jobs%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22all-user-cron-jobs%22%7D%2C%7B%22href%22%3A%22%2FCMD_FILE_MANAGER%22%2C%22newTab%22%3Atrue%2C%22name%22%3A%22File%20Manager%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22file-manager%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Ffile-editor%22%2C%22name%22%3A%22File%20Editor%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22file-editor%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fsystem-info%22%2C%22name%22%3A%22System%20Information%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22system-info%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Flog-viewer%22%2C%22name%22%3A%22Log%20Viewer%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22log-viewer%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fstats%22%2C%22name%22%3A%22Complete%20Usage%20Statistics%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22complete-usage-statistics%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fresource-limits%22%2C%22name%22%3A%22Resource%20Limits%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22resource-limits%22%7D%5D%7D%2C%7B%22name%22%3A%22Extra%20Features%22%2C%22icon%22%3A%22extra-features%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22slug%22%3A%22squirrelmail%22%2C%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2Fsquirrelmail%22%2C%22name%22%3A%22Webmail%3A%20Squirrelmail%22%2C%22enabled%22%3Afalse%2C%22newTab%22%3Atrue%2C%22icon%22%3A%22squirellmail%22%7D%2C%7B%22slug%22%3A%22uebimiau%22%2C%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2Fwebmail%22%2C%22name%22%3A%22Webmail%3A%20UebiMiau%22%2C%22enabled%22%3Afalse%2C%22newTab%22%3Atrue%2C%22icon%22%3A%22uebimiau%22%7D%2C%7B%22slug%22%3A%22roundcube%22%2C%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2F${rc_route_name}%22%2C%22name%22%3A%22Webmail%3A%20${C_ROUNDCUBE_CUSTOM_NAME}%22%2C%22enabled%22%3Atrue%2C%22newTab%22%3Atrue%2C%22icon%22%3A%22roundcube%22%7D%2C%7B%22route%22%3A%22phpmyadmin%22%2C%22name%22%3A%22phpMyAdmin%22%2C%22enabled%22%3Afalse%2C%22icon%22%3A%22phpmyadmin%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Fplugin-manager%22%2C%22name%22%3A%22Plugin%20Manager%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22plugin-manager%22%7D%2C%7B%22route%22%3A%22plugins%22%2C%22name%22%3A%22Plugins%20will%20be%20inserted%20after%20this%20entry%22%2C%22enabled%22%3Afalse%7D%2C%7B%22name%22%3A%22Database%3A%20${C_PHPMYADMIN_CUSTOM_NAME}%22%2C%22href%22%3A%22%7CWEBAPPS_SSL%7C%3A%2F%2F%7CHOSTNAME%7C%2F${db_route_name}%22%2C%22newTab%22%3Atrue%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22phpmyadmin%22%7D%5D%7D%2C%7B%22name%22%3A%22Support%20%26%20Help%22%2C%22icon%22%3A%22support-help%22%2C%22enabled%22%3Atrue%2C%22columnSize%22%3A5%2C%22entries%22%3A%5B%7B%22href%22%3A%22%7B%7Bhelp%7D%7D%22%2C%22name%22%3A%22Help%22%2C%22enabled%22%3Atrue%2C%22newTab%22%3Atrue%2C%22icon%22%3A%22help%22%7D%2C%7B%22route%22%3A%22%2Freseller%2Ftickets%22%2C%22name%22%3A%22Manage%20Tickets%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22manage-tickets%22%7D%2C%7B%22route%22%3A%22%2Fadmin%2Flicense%22%2C%22name%22%3A%22Licensing%20%2F%20Updates%22%2C%22enabled%22%3Atrue%2C%22icon%22%3A%22licensing-updates%22%7D%5D%7D%5D%7D%2C%22colors%22%3A%7B%22primary-dark%22%3A%7B%22hue%22%3A196%2C%22saturation%22%3A99%2C%22lightness%22%3A23.078751857348%2C%22alpha%22%3A100%7D%2C%22safe%22%3A%7B%22hue%22%3A140%2C%22saturation%22%3A41%2C%22lightness%22%3A56%7D%2C%22danger%22%3A%7B%22hue%22%3A20%2C%22saturation%22%3A76%2C%22lightness%22%3A47%7D%2C%22neutral%22%3A%7B%22hue%22%3A180%2C%22saturation%22%3A0.448430493273541%2C%22lightness%22%3A43.72549019607843%7D%7D%2C%22dateFormats%22%3A%7B%22datetime%22%3A%22dd-MMM-yyy%20HH%3Amm%20a%22%2C%22date%22%3A%22dd-MM-yyy%22%2C%22weekStart%22%3A%22monday%22%7D%2C%22theme%22%3A%22%22%2C%22adsense%22%3A%7B%22enabled%22%3Atrue%2C%22client%22%3A%22%22%2C%22slot%22%3A%22%22%2C%22css%22%3A%22display%3A%20block%3B%22%7D%2C%22mergedMenu%22%3Atrue%7D" method="POST"
      else
        _echo "$(msg red)Error, only --skin-name evolution is supported at this moment${action} $(msg end)" --name
        _exit 147
      fi
    else
      _echo "$(msg red)Error, please temporarily use the option --recommend-values for this action ${action} $(msg end)" --name
      # Add single values here
      _exit 147
    fi
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
      _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    #_exit 147
    else
      _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
      _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    fi
    # da_api_admin set-da-logo --skin-name "evolution" --logo-mode "default-logo" --logo-file "/tmp/logo.png"
  # --logo-mode with version 1.62 is default-logo, dark-logo, favicon
  # This is my own unofficial method to set logo because there is no documentation how to set this in directadmin
  # https://forum.directadmin.com/threads/cmd_api_skins-upload-skin-logo-via-curl-issue.63127/
  elif [[ "${action}" == "set-da-logo" ]]; then
    local cmd_api data method retval da_api_exec has_success logo_file_temp
    if [ ! -f "${logo_file}" ]; then
      _echo "$(msg red)Error, logo file does not exist! Please make sure the file exist!$(msg end)" --name
      _exit 147
    fi
    # Reference: https://www.directadmin.com/features.php?id=2923
    if [[ "${logo_mode}" == "default-logo" || -z "${logo_mode}" ]]; then
      logo_mode="1"
      # The upload file need to have random string append to it else it won't work:
      # I use random length of 6 because I saw directadmin always generated length of 6 when append this random string to a file
      logo_file_temp="${da_temp_dir}/logo.png$(get_rnd_alpha 6)"
    elif [ "${logo_mode}" == "dark-logo" ]; then
      logo_mode="2"
      logo_file_temp="${da_temp_dir}/logo2.png$(get_rnd_alpha 6)"
    elif [ "${logo_mode}" == "favicon" ]; then
      logo_mode="3"
      logo_file_temp="${da_temp_dir}/favicon.png$(get_rnd_alpha 6)"
    elif [ "${logo_mode}" == "default-symbol" ]; then
      logo_mode="4"
      logo_file_temp="${da_temp_dir}/symbol.png$(get_rnd_alpha 6)"
    elif [ "${logo_mode}" == "dark-symbol" ]; then
      logo_mode="5"
      logo_file_temp="${da_temp_dir}/symbol2.png$(get_rnd_alpha 6)"
    else
      _echo "$(msg red)Error, invalid logo mode$(msg end)" --name
    fi
    _echo "Current logo mode is :${logo_mode}" --name --verbose 7
    _echo "Current logo file is :${logo_file}" --name --verbose 7
    _echo "Current logo_file_temp is :${logo_file_temp}" --name --verbose 7
    # Copy the logo files (with extra string) from storage data to the temporary home directory
    cp "${logo_file}" "${logo_file_temp}"
    # Now assign the temporary logo as the logo_file
    logo_file="${logo_file_temp}"
    # The files that need to be uploaded from the temporary folder need to have nobody permission (else it wont work)
    chown nobody:nogroup "${logo_file}"
    _echo "Now the logo file is :${logo_file}" --name --verbose 7

    cmd_api="CMD_API_SKINS"
    data="action=upload_logo&file=${logo_file}&name=${skin_name}&which=${logo_mode}"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
      _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    #_exit 147
    else
      _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
      _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    fi
    rm -f "${logo_file}"
  # da_api_admin set-security-question --question "Awak suka makan budu tak?" --answer "suka"
  elif [[ "${action}" == "set-security-qna" || "${action}" == "set-security-question" ]]; then
    local cmd_api data method retval da_api_exec has_success has_cmd_api
    has_cmd_api=false
    # Note this CMD_API_SECURITY_QUESTIONS have not been released. So, we need to use json and ignore error checking
    # If the API is released, just put has_cmd_api=true
    method="POST"
    if [ "${has_cmd_api}" == "false" ]; then
      cmd_api="CMD_SECURITY_QUESTIONS"
      _echo "$(msg yellow)Note, directadmin does not have CMD_API_SECURITY_QUESTIONS call. Using CMD_SECURITY_QUESTIONS ...$(msg end)" --name
      # Note This does not work. Posted here: https://forum.directadmin.com/threads/bug-in-api-cmd_security_questions-bug-with-parameter-order.64318/
      #data="type=custom&value=${answer}&action=add&custom_question=${question}&json=yes"
      # This work
      data="type=custom&value=${answer}&json=yes&action=add&custom_question=${question}"
      curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}"
    else
      cmd_api="CMD_API_SECURITY_QUESTIONS"
      data="type=custom&value=${answer}&action=add&custom_question=${question}"
      da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
      has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
      if [ -z "${has_success}" ]; then
        _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
        _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
      #_exit 147
      else
        _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
        _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
      fi
    fi
    # da_api_admin create-user-subdomain --domain "maxibi.com" --subdomain "sales"
  elif [[ "${action}" == "create-user-subdomain" || "${action}" == "create-subdomain" ]]; then
    local cmd_api data method retval da_api_exec has_success
    # Special note: CMD_API_SUBDOMAIN AND CMD_API_SUBDOMAINS are the same thing: https://www.directadmin.com/features.php?id=1589
    cmd_api="CMD_API_SUBDOMAIN"
    data="domain=${domain}&subdomain=${subdomain}&action=create"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
      _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    #_exit 147
    else
      _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
      _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    fi
    #da_api_admin reset-dns-record --domain test.domain.com
  elif [[ "${action}" == "reset-dns-record" || "${action}" == "restore-dns-record" ]]; then
    local cmd_api data method retval da_api_exec has_success
    cmd_api="CMD_API_DNS_ADMIN"
    data="domain=${domain}&action=select&reset=yes"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
      _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    #_exit 147
    else
      _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
      _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    fi
  # da_api_admin create-user-email --mail-domain "maxibi.com" --mail-user "webmaster" --mail-password "1232123" --mail-quota "0" --mail-limit "200"
  elif [ "${action}" == "create-user-email" ]; then
    local cmd_api data method da_api_exec has_success
    cmd_api="CMD_API_EMAIL_POP"
    #https://www.directadmin.com/features.php?id=2587 not sure if this useful
    data="user=${mail_user}&passwd=${mail_password}&passwd2=${mail_password}&quota=${mail_quota}&limit=${mail_limit}&domain=${mail_domain}&action=create"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
      _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    #_exit 147
    else
      _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
      _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    fi
  #da_api_admin create-user-database --db-domain "maxibi.com" --db-name abc --db-user maxibi --db-password 12321aa (create new user database)
  #da_api_admin --db-domain "maxibi.com" create-user-database --db-name abc --existing-user maxibi  (create database with existing user)
  elif [ "${action}" == "create-user-database" ]; then
    local cmd_api data method retval da_api_exec has_success has_cmd_api
    has_cmd_api=false
    _echo "$(msg yellow)Note, directadmin does not have CMD_API_DB (https://forum.directadmin.com/threads/api-set-server-hostname.37872/post-188426). Using CMD_DB ...$(msg end)" --name
    # Note this CMD_API_DB have not been released. So, we need to use json and ignore error checking
    # If the API is released, just put has_cmd_api=true, this will automatically use the new API
    method="POST"
    # This API includes security settings and email settings (DA combined this)
    if [ "${has_cmd_api}" == "false" ]; then
      # CMD_API_DB not working but CMD_DB is working
      cmd_api="CMD_DB"
      if [ -n "${db_existing_user}" ]; then
        # This will select existing user to create database
        data="name=${db_name}&user=${db_existing_user}&domain=${db_domain}&userlist=${db_existing_user}&action=create&json=yes"
      else
        data="name=${db_name}&user=${db_user}&passwd=${db_password}&passwd2=${db_password}&domain=${db_domain}&userlist=...&action=create&json=yes"
      fi
      curl --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}"
      echo "status is: $?"

    else
      cmd_api="CMD_API_DB"
      if [ -n "${db_existing_user}" ]; then
        # This will select existing user to create database
        data="name=${db_name}&user=${db_existing_user}&domain=${db_domain}&userlist=${db_existing_user}&action=create"
      else
        data="name=${db_name}&user=${db_user}&passwd=${db_password}&passwd2=${db_password}&domain=${db_domain}&userlist=...&action=create"
      fi
      da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
      has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

      if [ -z "${has_success}" ]; then
        _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
        _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
      #_exit 147
      else
        _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
        _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
      fi
    fi
    # da_api_admin create-user-account --username abc --email abc@dsa.com --password 12321aa --domain maxibi.com --package_name USER_UNLIMITED --ip-address "${C_IPV4_ADD0}"
  elif [ "${action}" == "create-user-account" ]; then
    # da_api_admin "create-reseller-account" "user1" "user1@maxibi.com" "x1231aax" "maxibi.com" "USER_UNLIMITED"
    local cmd_api data method da_api_exec has_success
    cmd_api="CMD_API_ACCOUNT_USER"
    data="username=${username}&email=${email}&passwd=${password}&passwd2=${password}&domain=${domain}&package=${package_name}&notify=yes&ip=${ip_address}&action=create&add=yes"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
      _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    #_exit 147
    else
      _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
      _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    fi

  elif [ "${action}" == "delete-users" ]; then
    # da_api_admin "delete-users" "admin2"
    shift
    username="$1"
    command="CMD_API_SELECT_USERS"
    data="confirmed=Confirm&delete=yes&select0=${username}"
    method="POST"
    echo "Now, executing API with action name: ${action}"
    # Deprecated syntax:
    # da_api_admin "request-domain-ssl" <provider> <root_domain> <keysize> <encryption> <ssl_sub_domains_query>
    # da_api_admin "request-domain-ssl" letsencrypt codegix.com secp521r1 sha256 "le_select0=codegix.com&le_select1=www.codegix.com&le_select2=ftp.codegix.com \
    # &le_select3=mail.codegix.com&le_select4=pop.codegix.com&le_select5=smtp.codegix.com&le_select6=dashboard.codegix.com&le_select7=secure.codegix.com"
    # New syntax:
    # da_api_admin requst-domain-ssl --ssl-provider letsencrypt --ssl-root-domain test.com --ssl-subdomain-query <query_string>

  elif [ "${action}" == "request-domain-ssl" ]; then
    local cmd_api data method da_api_exec has_success
    # CMD_API_SUBDOMAIN AND CMD_API_SUBDOMAINS are the same thing: https://www.directadmin.com/features.php?id=1589
    cmd_api="CMD_API_SSL"
    method="POST"
    if [ "${ssl_provider}" == "letsencrypt" ]; then
      data="type=create&request=letsencrypt&name=${ssl_root_domain}&keysize=${C_DA_CERTIFICATE_SIZE}&encryption=${C_DA_CERTIFICATE_ENCRYPTION_ALGORITHM} \
      &wildcard=no&domain=${ssl_root_domain}&action=save&background=auto&${ssl_subdomains_query}"
    else
      # Give error because we focus on letsencrypt first
      _echo "$(msg red) Error, this provider ${ssl_provider} has no API yet to request domain for SSL$(msg end)" --name
      _exit 147
    fi

    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')

    if [ -z "${has_success}" ]; then
      _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
      _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    #_exit 147
    else
      _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
      _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    fi
    # Note this API will delete list of tickets, because I need to read message from ticket about restore-user-backup properly
    # It is alright, because we are using initial setup, ticket should not have anything important at this point.
  elif [ "${action}" == "restore-user-backup" ]; then
    # da_api_admin "create-reseller-account" "user1" "user1@maxibi.com" "x1231aax" "maxibi.com" "USER_UNLIMITED"
    local cmd_api data method da_api_exec has_success max_wait_restore
    cmd_api="CMD_API_ADMIN_BACKUP"
    # data="username=${username}&email=${email}&passwd=${password}&passwd2=${password}&domain=${domain}&package=${package_name}&notify=yes&ip=${ip_address}&action=create&add=yes"
    data="where=local&when=now&ftp_ip=&ftp_username=&ftp_password=&ftp_path=%2F&ftp_port=21&ftp_secure=no&local_path=${backup_path}&ip_choice=file&ip=${backup_ip}&action=restore&create_user_home_override=&encryption_password=${backup_password}&select0=${backup_file_name}"
    method="POST"
    da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
    has_success=$(echo "${da_api_exec}" | grep -w '^error=0')
    if [ -z "${has_success}" ]; then
      _echo "$(msg red)Error, API with action ${action} executed with the following error: $(msg end)" --name
      _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
    #_exit 147
    else
      _echo "$(msg green)OK, API with action ${action} executed with the following status: $(msg end)" --name
      _echo "$(msg green)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'

      cmd_api="CMD_API_TICKET"
      data="action=view&type=message"

      # https://forum.directadmin.com/threads/delete-all-message-system-via-ssh.47646/post-244515
      # The first 1) is not valid anymore because of this: https://www.directadmin.com/features.php?id=1696 (read at bottom)
      # We do not need to remove the tickets.list, just need to remove the file 000, 001 etc but for this purpose, I just remove it for safety reason

      # Remove ticket list
      _echo "$(msg cyan)Clearing admin ticket list from tickets.list ...$(msg end)" --name
      echo -n "" >/usr/local/directadmin/data/admin/tickets.list
      get_status_message "$?"
      echo ""
      _echo "$(msg cyan)Removing admin ticket files ...$(msg end)" --name
      rm -rf /usr/local/directadmin/data/tickets/*
      get_status_message "$?"
      echo ""

      max_wait_restore=0
      while :; do
        sleep 1
        _echo "$(msg cyan)Detecting user backup restoration status based on the directadmin ticket's subject ...$(msg end)" --name --start-spin
        ((max_wait_restore++))
        da_api_exec=$(curl --silent --request "${method}" --user "${da_api_username}":"${da_api_password}" --data "${data}" "${ssl_protocol}://${C_BOX_HOSTNAME_FQHN}:${port}/${cmd_api}")
        has_success=$(echo "${da_api_exec}" | urldecode | awksep '&' | grep -w "subject=Your User files have been restored")
        if [ -n "${has_success}" ]; then
          _echo "$(msg green)OK, file ${backup_file_name} has been successfully restored based on the directadmin ticket's subject$(msg end)" --name --stop-spin
          break
        fi
        if [ "${max_wait_restore}" -gt 120 ]; then
          _echo "$(msg red)Error, it took a very long period to obtain the restoration success message (restoration might be failed). Please inspect error below:$(msg end)" --name
          _echo "$(msg red)${da_api_exec}$(msg end)" --plain | urldecode | awksep '&'
          _exit 147
        fi
      done
    fi
  else
    _echo "$(msg red)The Directadmin API action ${action} does not exist!$(msg end)" --name
    _exit 147
  fi

}

# This will check if system needs to reboot based on /var/run/reboot-required file
# This function also will make sure if a caller function has finished executed, then we won't run that function again.
check_finish_reboot() {
  local func_name="$1"
  cat /dev/null >"${CONF_PATH}/${func_name}_executed"
  if [ -f /var/run/reboot-required ]; then
    if [ "${C_ENABLE_SETUP_REBOOT}" == "auto" ]; then
      echo "[${SCRIPT_NAME}]: [Notice]: *** System reboot required. Rebooting in 30 seconds (ctrl+c to cancel) ..."
      sleep 30
      _reboot
    elif [ "${C_ENABLE_SETUP_REBOOT}" == "interactive" ]; then
      read -r -s -n 1 -p "[${SCRIPT_NAME}]: [Notice]: *** System reboot required. Press any key to reboot (ctrl+c to cancel) ..."
      _reboot
    elif [ "${C_ENABLE_SETUP_REBOOT}" == "disabled" ]; then
      read -r -s -n 1 -p "[${SCRIPT_NAME}]: [Notice]: *** Warning, system reboot required, but C_ENABLE_SETUP_REBOOT setting is disabled!"
    fi
    echo ""
  else
    _echo "$(msg green)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
    _echo "$(msg green)[OK]: $(msg magenta)${func_name}()$(msg end) $(msg green)has been executed$(msg end)" --name
    if command -v gotify &>/dev/null; then
      # Send alert to push notification if gotify is installed (we dont use color here) because color will not display in terminal
      _echo "[OK]: ${func_name}() has been executed" --name --push-notification-silent
    fi
    # This sleep is for debugging, when finish developing this script, I should remove this sleep to speed up the script
    #sleep 1
  fi
  return 0
}

# This function will check service error and try to repair it using common solutions like log error information
# repair_services "<service_name1>" "<service_name2>" ... "<service_nameN>"
# This function is a standalone service
repair_services() {
  local service_name service_names gc retval lfd_service csf_service
  service_names="$*"
  for service_name in ${service_names}; do
    _echo "$(msg cyan)Checking ${service_name} status ...$(msg end)" --name
    sleep 2
    if [ "${service_name}" == "csf" ]; then
      # Fix that here
      csf_service=$(systemctl is-active csf)
      if [ "${csf_service}" == "active" ]; then
        _echo "$(msg green)OK, ${service_name} service is running$(msg end)" --name
      else
        # CSF fix 1 - restarting
        _echo "$(msg yellow)Warning, unable to start CSF service properly. Restarting CSF and giving extra 3 seconds wait time ...$(msg end)" --name
        systemctl restart csf
        sleep 3
        csf_service=$(systemctl is-active csf)
        if [ "${csf_service}" == "active" ]; then
          _echo "$(msg green)OK, CSF service is running$(msg end)" --name
        else
          _echo "$(msg red)Error, unable to start CSF service properly. Please check the log file for more hints$(msg end)" --name
          _exit 147
        fi
        # CSF fix 2 - pending if any
      fi
    fi

    if [ "${service_name}" == "lfd" ]; then
      lfd_service=$(systemctl is-active lfd)
      if [ "${lfd_service}" == "active" ]; then
        _echo "$(msg green)OK, ${service_name} has started$(msg end)" --name
      else
        _echo "$(msg yellow)Warning, unable to start LFD service properly. Trying to solve this based on common problems ...$(msg end)" --name
        sleep 1
        # Start lfd to generate log file because first it had no log
        _echo "$(msg cyan)Starting lfd to generate lfd log file ...$(msg end)" --name
        systemctl start lfd
        # lfd known fix 1
        _echo "$(msg cyan)Applying fix 1 to fix ${service_name} ...$(msg end)" --name
        _echo "$(msg cyan)Giving 10 seconds for ${service_name} to start properly$(msg end)" --name
        sleep 10
        lfd_service=$(systemctl is-active lfd)
        if [ "${lfd_service}" == "active" ]; then
          _echo "$(msg green)OK, ${service_name} has started$(msg end)" --name
        else
          # lfd known fix 2
          _echo "$(msg cyan)Applying fix 2 to fix ${service_name} ...$(msg end)" --name
          _echo "$(msg cyan)Clearing lfd log entry at /var/log/lfd.log ...$(msg end)" --name
          cat /dev/null >/var/log/lfd.log
          _echo "$(msg cyan)Restarting lfd and giving 10 seconds extra wait time ...$(msg end)" --name
          systemctl restart lfd
          # Waiting at least 10 seconds (so that the lfd process is up and it generates a log file for the first time)
          sleep 10
          if [ -f /var/log/lfd.log ]; then
            gc=$(grep -ic 'you may need to install the IO::Socket::INET6 module' /var/log/lfd.log)
            if [ "${gc}" -ne 0 ]; then
              _echo "$(msg yellow)Warning, found missing perl IO::Socket::INET6 module. Installing libio-socket-inet6-perl for Debian$(msg end)" --name
              # Use this function for best compatibility with other DISTRO
              required "debian@@apt:libio-socket-inet6-perl"
              _echo "$(msg cyan)Restarting lfd and giving 10 seconds extra wait time ...$(msg end)" --name
              systemctl restart lfd
              sleep 10
            fi
          else
            # This is just in case if log file not appear
            _echo "$(msg red)Error, lfd log file not generated. It should generated after given sometime. Please inspect why the lfd log file at /var/log/lfd.log is not generated!$(msg end)" --name
            _exit 147
          fi
          _echo "$(msg cyan)Rechecking lfd status ...$(msg end)" --name
          lfd_service=$(systemctl is-active lfd)
          if [ "${lfd_service}" == "active" ]; then
            _echo "$(msg green)OK, ${service_name} has started$(msg end)" --name
          else
            _echo "$(msg red)Error, unable to understand why ${service_name} cannot be started. Please check the lfd log file at /var/log/lfd.log for more hints$(msg end)" --name
            _exit 147
          fi
        fi
        # ----
        # lfd known fix 3 and more
      fi
    fi
  done
  # more services error to fix goes here ...
}

# This function is a standalone function
# It restarts software server based on the installation string provided
restart_da_web_server() {
  echo ""
  if [ "${C_DA_CB_WEBSERVER_SOFTWARE}" == "nginx_apache" ]; then
    _echo "$(msg magenta)Restarting httpd and nginx for new httpd config ...$(msg end)" --name
    systemctl restart httpd
    sudo pkill -f nginx &
    wait $!
    systemctl restart nginx
  elif [ "${C_DA_CB_WEBSERVER_SOFTWARE}" == "nginx" ]; then
    _echo "$(msg magenta)Restarting nginx  ...$(msg end)" --name
    sudo pkill -f nginx &
    wait $!
    systemctl restart nginx
  elif [ "${C_DA_CB_WEBSERVER_SOFTWARE}" == "apache" ]; then
    _echo "$(msg magenta)Restarting httpd for new httpd config ...$(msg end)" --name
    systemctl restart httpd
  elif [ "${C_DA_CB_WEBSERVER_SOFTWARE}" == "openlitespeed" ]; then
    :
  else
    :
  fi
}

# start_execute_options <option> <label or function_name>
start_execute_options() {
  local option func_name executed_function
  option="$1"
  func_name="$2"
  executed_function="${CONF_PATH}/${func_name}_executed"
  #echo "executed_function ::: ${executed_function}"
  FUNCTION_RUN=false
  SKIP_RUN=false
  if [[ "${option}" == "--skip-mark" || "${option}" == "--skip-mark-exit" ]]; then
    cat /dev/null >"${executed_function}"
    SKIP_RUN=true
  elif [[ "${option}" == "--skip" || "${option}" == "--skip-exit" ]]; then
    SKIP_RUN=true
  elif [[ "${option}" == "--run-force" || "${option}" == "--run-force-exit" ]]; then
    rm -rf "${executed_function}"
    FUNCTION_RUN=true
  elif [[ -z "${option}" || "${option}" == "--run" || "${option}" == "--run-exit" ]]; then
    FUNCTION_RUN=true
  fi

  if [[ "${FUNCTION_RUN}" == "true" && "${SKIP_RUN}" == "false" ]]; then
    exec_time start "${func_name}"
    if [ ! -f "${executed_function}" ]; then
      _echo "$(msg green)Executing $(msg magenta)${func_name}()$(msg end) $(msg cyan)with option ${option} ...$(msg end)" --name
      _echo "$(msg green)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
      echo ""
    fi
  elif [[ "${SKIP_RUN}" == "true" ]]; then
    _echo "$(msg yellow)[Skipped by user]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)has skip option: ${option} ...$(msg end)" --name
    _echo "$(msg red)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
    echo ""
  fi

}

# end_execute_options <option> <label or function_name>
end_execute_options() {
  local run_mode func_name
  run_mode="$1"
  func_name="$2"
  if [[ "$(echo "${run_mode}" | awk -F'-' '{ print $NF}')" == "exit" ]]; then
    echo ""
    _echo "$(msg red)[Terminated]: $(msg magenta)${func_name}() $(msg red)has exit option: ${run_mode} ...$(msg end)" --name
    exit 0
  fi
  exec_time total "${func_name}"
  echo ""
  echo ""
}

# This will only run on local
install_pre_packages_local() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi

  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    if [ "${DISTRO_ID}" == "centos" ]; then
      :
    elif [ "${DISTRO_ID}" == "debian" ]; then
      :
    elif [ "${DISTRO_ID}" == "ubuntu" ]; then
      _echo "$(msg cyan)Updating and upgrading ${DISTRO_ID^} OS ...$(msg end)" --name
      apt-get -y update
      apt-get -y upgrade
      echo ""
      _echo "$(msg cyan)Installing pre-requisite components for ${DISTRO_ID^} OS ...$(msg end)" --name
      apt-get -y install git sudo nmap psmisc unzip zip dnsutils net-tools rsync dos2unix ncdu htop
    elif
      [ "${DISTRO_ID}" == "almalinux" ]
    then
      :
    else
      _echo "$(msg red)Error, unknown value for distribution ID ${DISTRO_ID}. This distribution ID is not supported!$(msg end)" --name --verbose 3
      _exit 147
    fi
    echo ""
    check_finish_reboot "${func_name}"
  fi
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This is an alias function to setup_pre()
pre_setup() {
  setup_pre "$@"
}

# This is the setup pre function
# This function will install all required packages for remote server
# Remember that this required packages must be present even it is not in used
# To only install specific package, use required() function
setup_pre() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    if [ "${DISTRO_ID}" == "centos" ]; then
      _echo "$(msg magenta)Disabling SELinux policy on CentOS...$(msg end)" --name
      setenforce 0
      if [ -e /etc/selinux/config ]; then
        sed -i s/^SELINUX=.*$/SELINUX=disabled/ /etc/selinux/config
      fi
      if [ -e /usr/sbin/setenforce ]; then
        /usr/sbin/setenforce 0
      fi
    elif [ "${DISTRO_ID}" == "debian" ]; then
      # Known usability bug from Debian installer with old grub-pc
      # This only show when you have kernel set to GRUB 2
      # Fixed grub-pc appear interactive GUI when running dist-upgrade https://github.com/hashicorp/vagrant/issues/289
      # This is the Debian usability bug for grub as explained in here:
      # https://askubuntu.com/questions/23418/what-do-i-select-for-grub-install-devices-after-an-update#comment837055_23418

      _echo "$(msg cyan)Updating and upgrading ${DISTRO_ID^} OS ...$(msg end)" --name
      apt-get -y update
      apt-get -y upgrade
      echo ""

      # Note 1: By default sudo is not installed in custom distribution. It's needed for new OS
      # Note 2: psmisc is a pstree utils (needed by maxigpg script from maxicode)
      # Note 3: dnsutils contains dig command is used to find public IP
      # Note 4: net-tools for using with netstat (port troubleshooting)
      # Note 5: rsync for file transfer and backup (better than scp)
      # Note 6: dos2unix is for conversion clrf to unix format (needed by maxiaide script from maxicode)
      # Note 7: ncdu is for file management
      # Note 8: gcc is needed to compile program from source. (eg meson build need gcc to compile ipcalc c code)
      # Note 9: curl is needed on most system (for directadmin, we will use custombuild, so this will be removed before installation)
      # Note 10: wget is needed on most system
      # Note 11: ipvc6calc is used by directadmin API, maxiwall and other scripts (important to have)
      _echo "$(msg cyan)Installing pre-requisite components for ${DISTRO_ID^} OS ...$(msg end)" --name
      apt-get -y install git sudo nmap psmisc unzip zip dnsutils net-tools rsync dos2unix ncdu meson htop gcc curl wget ipv6calc
      echo ""

      # Installing program from sources:
      # Ipcalc
      _echo "$(msg cyan)Installing ipcalc from source https://gitlab.com/sofibox/ipcalc.git ...$(msg end)" --name

      # Building ipcalc from this (this is the best ipcalc calculator that work for both ipv6 and ipv4)
      # This build required meson and ninja (installed using apt-get install meson above)
      _echo "$(msg cyan)Removing previous ipcalc package ...$(msg end)" --name
      apt-get -y remove ipcalc
      rm -rf "${INST_TEMP_DIR}/ipcalc"
      rm -rf "/usr/bin/ipcalc"
      # The git will create this folder automatically
      #mkdir -p "${INST_TEMP_DIR}/ipcalc"
      git clone https://gitlab.com/sofibox/ipcalc.git "${INST_TEMP_DIR}/ipcalc"
      navigate_path "${INST_TEMP_DIR}/ipcalc"
      meson setup build --buildtype=release
      ninja -C build
      navigate_path "BACK"
      chmod +x "${INST_TEMP_DIR}/ipcalc/build/ipcalc"
      cp -p "${INST_TEMP_DIR}/ipcalc/build/ipcalc" "/usr/bin"
      ipcalc -v
      get_status_message "$?"

      # Installing grepaddr from source:
      _echo "$(msg cyan)Removing previous grepaddr ...$(msg end)" --name
      rm -f /usr/local/bin/grepaddr
      echo ""
      _echo "$(msg cyan)Installing grepaddr ...$(msg end)" --name
      wget -O /usr/local/bin/grepaddr https://raw.githubusercontent.com/sofibox/grepaddr/master/grepaddr.py
      chmod +x /usr/local/bin/grepaddr
      echo ""
      _echo "$(msg cyan)Running grepaddr -h ...$(msg end)" --name
      grepaddr -h
      get_status_message "$?"
      # Another build here

    elif

      [ "${DISTRO_ID}" == "ubuntu" ]
    then
      :
    elif [ "${DISTRO_ID}" == "almalinux" ]; then
      :
    else
      _echo "$(msg red)Error, unknown value for distribution ID ${DISTRO_ID}. This distribution ID is not supported!$(msg end)" --name --verbose 3
      _exit 147
    fi
    echo ""
    check_finish_reboot "${func_name}"
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi

}

# Install missing os requirement, such as sendmail
upgrade_os() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    # General OS upgrade
    if [[ "${DISTRO_ID}" == "centos" ]]; then
      _echo "$(msg cyan)Updating operating CentOS system ...$(msg end)" --name
      sudo dnf -y update
      sudo dnf -y install epel-release
      # Remember now use powertools not PowerTools. This is bug found in CentOS repo 2 days ago: https://bugs.centos.org/view.php?id=17920
      dnf config-manager --set-enabled powertools
    elif [ "${DISTRO_ID}" == "debian" ]; then
      # Known usability bug from Debian installer with old grub-pc
      # Fixed grub-pc appear interactive GUI when running dist-upgrade https://github.com/hashicorp/vagrant/issues/289
      # This is the Debian usability bug for grub as explained in here:
      # https://askubuntu.com/questions/23418/what-do-i-select-for-grub-install-devices-after-an-update#comment837055_23418
      # This only show when you have kernel set to GRUB 2
      _echo "$(msg cyan)Updating Debian operating system ...$(msg end)" --name
      apt-get -y update
      apt-get -y dist-upgrade
      apt-get -y autoremove
      apt clean
    else
      _echo "$(msg red)Error, unknown value for distribution ID ${DISTRO_ID}. This distribution ID is not supported!$(msg end)" --name
      _exit 147
    fi

    # Install other components based on installation type and distribution:
    if [ "${C_SERVER_TYPE}" == "general" ]; then
      if [ "${DISTRO_ID}" == "centos" ]; then
        _echo "$(msg cyan)Installing system required components for CentOS General setup ...$(msg end)" --name
        # Separate this installation because they are categorized in requirement
        sudo dnf -y install sendmail tar bind-utils git curl gcc make libevent-devel zlib-devel openssl-devel pcre2-devel wget
        sudo dnf -y install bc htop ncdu
        echo ""
        _echo "$(msg cyan)Installing perl dependencies ...$(msg end)" --name
        sudo dnf -y install @perl perl-libwww-perl net-tools perl-LWP-Protocol-https
      elif [ "${DISTRO_ID}" == "debian" ]; then
        _echo "$(msg cyan)Installing system required components for Debian General setup ...$(msg end)" --name
        # Separate this installation because they are categorized in requirement
        # curl is needed especially to download lynis latest version
        apt-get -y install curl
      else
        _echo "$(msg red)Error, unknown value for distribution ID ${DISTRO_ID}. The distribution ID is not supported!$(msg end)" --name
        _exit 147
      fi
    elif [ "${C_SERVER_TYPE}" == "directadmin" ]; then
      if [ "${DISTRO_ID}" == "centos" ]; then
        #_echo "$(msg cyan)Installing system required components for CentOS Directadmin setup ...$(msg end)" --name
        : # will determine (but RIP CentOS)
      elif [ "${DISTRO_ID}" == "debian" ]; then
        _echo "$(msg cyan)Installing system required components for Debian Directadmin setup ...$(msg end)" --name
        # Separate this installation because they are categorized in requirement
        apt-get -y install ipv6calc
      else
        _echo "$(msg red)Error, unknown value for distribution ID ${DISTRO_ID}. The distribution ID is not supported!$(msg end)" --name
        _exit 147
      fi
    elif [ "${C_SERVER_TYPE}" == "laravel" ]; then
      :
      # install laravel requirement here
    elif [ "${C_SERVER_TYPE}" == "magento" ]; then
      :
      # install magento requirement here
    elif [ "${C_SERVER_TYPE}" == "joomla" ]; then
      :
      # install joomla requirement here
    elif [ "${C_SERVER_TYPE}" == "odoo" ]; then
      :
      # install odoo requirement here
    elif [ "${C_SERVER_TYPE}" == "prestashop" ]; then
      :
      # install prestashop requirement here
    else
      _echo "$(msg red)Error, unknown server installation type ${C_SERVER_TYPE}. The server installation type is not supported!$(msg end)" --name
      _exit 147
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# For managing notification (eg. pushover, gotify)
# TODO 1 put httpd layer password
# TODO 2 Find a way to add 2 step authentication
# TODO 3 change default admin to something else that is secure
# TODO need to use https
configure_gotify() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    if [ "${C_GOTIFY_INSTALLATION}" == "true" ]; then
      if [[ ${DISTRO_ID} == "debian" || ${DISTRO_ID} == "ubuntu" ]]; then
        local gotify_version gotify_platform gotify_app_name gotify_service_name gotify_app_path gotify_config gotify_data_path gotify_config_cli \
          gotify_port_line_to_replace gotify_password_line_to_replace gotify_download_url response app_token
        gotify_version="${C_GOTIFY_VERSION}"
        gotify_platform="${C_GOTIFY_PLATFORM}"
        gotify_app_name="gotify-server"
        gotify_service_name="gotify"
        gotify_app_path="/opt/gotify"
        gotify_config="/opt/gotify/config.yml"
        gotify_data_path="/opt/gotify/data/"
        gotify_config_cli="/etc/gotify/cli.json"
        gotify_port_line_to_replace="${C_GOTIFY_PORT} # the port the HTTP server will listen on"
        gotify_password_line_to_replace="${C_GOTIFY_PASSWORD} # the password of the default user"
        gotify_download_url="https://github.com/gotify/server/releases/download/v${gotify_version}/gotify-${gotify_platform}.zip"
        # Test this one
        _echo "$(msg cyan)Stopping ${gotify_service_name}.service ... $(msg end)" --name
        systemctl stop ${gotify_service_name}
        echo ""
        _echo "$(msg cyan)Removing gotify previous installation ... $(msg end)" --name
        # Removing the temporary downloaded files
        rm -rf "${TEMP_PATH}/LICENSE" "${TEMP_PATH}/licenses" "${TEMP_PATH}/gotify-${gotify_platform}.zip"
        # Removing gotify CLI
        rm -rf "/usr/local/bin/gotify" "/etc/gotify/"
        # Removing gotify main server application (including the config.yml and data folder)
        rm -rf "${gotify_app_path}"
        # Removing gotify service name
        rm -rf "/etc/systemd/system/${gotify_service_name}.service"
        echo ""
        _echo "$(msg cyan)Removing gotify previous user and group ... $(msg end)" --name
        userdel -r "${C_GOTIFY_SYSTEM_USERNAME}"
        groupdel "${C_GOTIFY_SYSTEM_GROUP}"
        echo ""

        _echo "$(msg cyan)Creating gotify application path at ${gotify_app_path} ... $(msg end)" --name
        mkdir -p ${gotify_app_path}
        echo ""
        _echo "$(msg cyan)Downloading gotify from ${gotify_download_url} ... $(msg end)" --name
        navigate_path "${gotify_app_path}"
        wget --no-verbose "${gotify_download_url}"
        echo ""
        _echo "$(msg cyan)Extracting gotify from gotify-${gotify_platform}.zip ... $(msg end)" --name
        required "debian@@apt:unzip"
        unzip "gotify-${gotify_platform}.zip"
        echo ""
        _echo "$(msg cyan)Correcting ${gotify_app_name}'s permission for execution ... $(msg end)" --name
        mv "gotify-${gotify_platform}" "${gotify_app_name}"
        sudo chown root:root "${gotify_app_name}"
        sudo chmod 755 "${gotify_app_name}"
        echo ""
        _echo "$(msg cyan)Creating gotify user and group to control application path at ${gotify_app_path}... $(msg end)" --name
        groupadd -r "${C_GOTIFY_SYSTEM_GROUP}"
        useradd -M -d ${gotify_app_path} -s /sbin/nologin -r -g "${C_GOTIFY_SYSTEM_GROUP}" "${C_GOTIFY_SYSTEM_USERNAME}"
        echo ""
        _echo "$(msg cyan)Downloading gotify sample config file ... $(msg end)" --name
        wget --no-verbose -O ${gotify_config} https://raw.githubusercontent.com/gotify/server/master/config.example.yml
        echo ""
        _echo "$(msg cyan)Correcting gotify config file's permission for reading ... $(msg end)" --name
        chown root:root ${gotify_config}
        chmod 644 ${gotify_config}
        echo ""
        _echo "$(msg cyan)Creating and correcting gotify data path at ${gotify_data_path} ... $(msg end)" --name
        mkdir "${gotify_data_path}"
        chown -R gotify:gotify "${gotify_data_path}"
        chmod -R 755 "${gotify_data_path}"
        echo ""

        # This will get the current port of gotify from config file
        current_port=$(grep -E 'port:.*HTTP server' ${gotify_config} | awk -F[:#] '{ print $2 }' | tr -d ' ')
        _echo "$(msg cyan)Changing the gotify current port ${current_port} to ${C_GOTIFY_PORT} ... $(msg end)" --name

        # This will change the current port to config port (For non-ssl server it is 2 spaces before port:)
        sed -i "/^\(  port: \).*/s//\1${gotify_port_line_to_replace}/" ${gotify_config}
        echo ""
        _echo "$(msg cyan)Writing and correcting gotify service file at /etc/systemd/system/${gotify_service_name}.service ... $(msg end)" --name

        {
          echo "[Unit]"
          echo "Description=Gotify Push Notification Server"
          echo "Documentation=https://gotify.net/docs"
          echo "After=network-online.target"
          echo "Wants=network-online.target systemd-networkd-wait-online.service"

          echo "[Service]"
          echo "Type=simple"
          echo "Restart=on-abnormal"
          echo "User=${C_GOTIFY_SYSTEM_USERNAME}"
          echo "Group=${C_GOTIFY_SYSTEM_GROUP}"

          echo "WorkingDirectory=${gotify_app_path}"
          echo "ExecStart=${gotify_app_path}/${gotify_app_name}"
          echo "ExecStop=kill $MAINPID"
          echo "ExecReload=kill -9 $MAINPID"

          echo "PrivateTmp=true"
          echo "ProtectSystem=full"
          echo "ReadWritePaths=${gotify_data_path}"
          echo "ReadWriteDirectories=${gotify_data_path}"
          echo "TimeoutStopSec=5s"

          echo "[Install]"
          echo "WantedBy=multi-user.target"

        } >/etc/systemd/system/${gotify_service_name}.service

        chown root:root /etc/systemd/system/${gotify_service_name}.service
        chmod 644 /etc/systemd/system/${gotify_service_name}.service
        systemctl daemon-reload
        echo ""
        _echo "$(msg cyan)Enabling ${gotify_service_name}.service to run on startup ...$(msg end)" --name
        systemctl enable ${gotify_service_name}.service
        echo ""
        _echo "$(msg cyan)Starting ${gotify_service_name}.service and giving 2 seconds extra wait time ... $(msg end)" --name
        systemctl start ${gotify_service_name}.service
        sleep 2
        echo ""
        _echo "$(msg cyan)Changing gotify default password database via curl and giving 2 seconds extra wait time ...$(msg end)" --name
        required "debian@@apt:curl" "ubuntu@@apt:curl"
        curl -sSf -X POST -H "Content-Type: application/json" --user "admin:admin" "http://${C_BOX_HOSTNAME_FQHN}:${C_GOTIFY_PORT}/current/user/password" --data "{\"pass\": \"${C_GOTIFY_PASSWORD}\"}"
        sleep 2
        echo ""
        _echo "$(msg cyan)Changing gotify password from admin to ${LABEL_C_GOTIFY_PASSWORD}$(msg end)" --name
        sed -i "/^\(  pass: \).*/s//\1${gotify_password_line_to_replace}/" ${gotify_config}
        echo ""
        _echo "$(msg cyan)Stopping ${gotify_service_name} service ...$(msg end)" --name
        systemctl stop ${gotify_service_name}.service
        _echo "$(msg cyan)Starting ${gotify_service_name}.service and giving 5 seconds extra wait time ...$(msg end)" --name
        systemctl start ${gotify_service_name}
        sleep 5
        echo ""
        _echo "$(msg cyan)Testing gotify login using new user credential ...$(msg end)" --name
        response=$(curl -sSf --user "${C_GOTIFY_USERNAME}:${C_GOTIFY_PASSWORD}" "http://${C_BOX_HOSTNAME_FQHN}:${C_GOTIFY_PORT}/current/user" || echo "$?")
        # Number of response if have 3 digit: that means, this is error. eg 403 411
        if ((${#response} < 4)); then
          _echo "$(msg red)Error, login failed! Please inspect why and re-run this script to continue$(msg end)" --name
          #echo "response: ${response}"
          #echo "#response: ${#response}"
          _exit 147
        else
          _echo "$(msg green)OK, login success!$(msg end)" --name
          _echo "$(msg green)You can install gotify client application from Google Play store and put the following credentials:$(msg end)" --name
          _echo "$(msg magenta)==================================$(msg end)" --plain
          _echo "URL: http://${LABEL_C_BOX_HOSTNAME_FQHN}:${LABEL_C_GOTIFY_PORT}" --plain
          _echo "Username: ${LABEL_C_GOTIFY_USERNAME}" --plain
          _echo "Password: ${LABEL_C_GOTIFY_PASSWORD}" --plain
          _echo "$(msg magenta)==================================$(msg end)" --plain
          _pause 10
          #echo "response: ${response}"
          #echo "#response: ${#response}"
        fi
        echo ""
        _echo "$(msg cyan)Creating gotify application token ...$(msg end)" --name
        response=$(curl -sSf -X POST -H "Content-Type: application/json" --user "${C_GOTIFY_USERNAME}:${C_GOTIFY_PASSWORD}" "http://${C_BOX_HOSTNAME_FQHN}:${C_GOTIFY_PORT}/application" --data "{\"description\": \"${C_GOTIFY_APP_DESCRIPTION}\",  \"name\": \"${C_GOTIFY_APP_NAME}\"}")
        app_token=$(echo "${response}" | awk 'BEGIN { FS="\""; RS="," }; { if($2 == "token") {print $4} }')
        #echo "${app_token}"
        if ((${#response} < 4)); then
          _echo "$(msg red)Error, token creation failed! Please inspect why and re-run this script to continue$(msg end)" --name

          _exit 147
        else
          _echo "$(msg green)OK, token created!$(msg end)" --name
        fi
        echo ""

        _echo "$(msg cyan)Testing gotify push using application token created ...$(msg end)" --name
        response=$(curl -sSf -X POST -H "Content-Type: application/json" -H "X-Gotify-Key: ${app_token}" "http://${C_BOX_HOSTNAME_FQHN}:${C_GOTIFY_PORT}/message" -d "{  \"message\": \"testMessage\",  \"priority\": 0,  \"title\": \"gotify@${C_BOX_HOSTNAME_FQHN}\"}" || echo "$?")
        if ((${#response} < 4)); then
          _echo "$(msg red)Error, test gotify push using application token failed! Please inspect why and re-run this script to continue$(msg end)" --name
          _exit 147
        else
          _echo "$(msg green)OK, test gotify push using application token success!$(msg end)" --name
        fi
        echo ""

        _echo "$(msg cyan)Downloading gotify-cli v${C_GOTIFY_CLI_VERSION} into /usr/local/bin/gotify... $(msg end)" --name
        curl -Lo /usr/local/bin/gotify https://github.com/gotify/cli/releases/download/v${C_GOTIFY_CLI_VERSION}/gotify-cli-linux-amd64
        echo ""
        _echo "$(msg cyan)Correcting gotify-cli permission for execution ... $(msg end)" --name
        chmod +x /usr/local/bin/gotify
        echo ""
        _echo "$(msg cyan)Writing gotify-cli config file to use token ... $(msg end)" --name
        mkdir -p "/etc/gotify"
        echo -e "{\n\t\"token\": \"${app_token}\",\n\t\"url\": \"http://${C_BOX_HOSTNAME_FQHN}:${C_GOTIFY_PORT}\",\n\t\"defaultPriority\": 0\n}" >"${gotify_config_cli}"
        echo ""
        _echo "$(msg cyan)Testing gotify-cli to push simple message ... $(msg end)" --name
        gotify push -t "${SCRIPT_NAME}@${C_BOX_HOSTNAME_FQHN}" -p 10 "If you can read this notification, it means gotify has been successfully installed"
        retval=$?
        if [ ${retval} -eq 0 ]; then
          _echo "$(msg green)OK, gotify-cli push using application token is success!$(msg end)" --name
        else
          _echo "$(msg red)Error, gotify-cli push using application token has error!$(msg end)" --name
          _exit 147
        fi
      else
        _echo "$(msg yellow)[Skipped], warning this distribution ID is not supported for installing gotify$(msg end)" --name
      fi
    else
      _echo "$(msg yellow)[Skipped], C_GOTIFY_INSTALLATION is not set to true. Gotify will not be installed! If you want to install later, run this function again with option --run-force$(msg end)" --name
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain

  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_yq() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local arch_string
    arch_string=$(arch)
    if [[ "${C_YQ_VERSION}" != "false" ]]; then
      if [[ "${arch_string}" == "x86_64" ]]; then
        yq_version="${C_YQ_VERSION}"
        yq_binary="yq_linux_amd64"
        _echo "$(msg cyan)Downloading yq ${yq_version}-${yq_binary} ...$(msg end)" --name
        wget https://github.com/mikefarah/yq/releases/download/${yq_version}/${yq_binary} -O /usr/bin/yq
        chmod +x /usr/bin/yq
        echo ""
        check_path "/usr/bin/yq"
        echo ""
        _echo "$(msg cyan)Checking yq --version ...$(msg end)" --name
        yq --version
        get_status_message "$?"
      else
        _echo "$(msg red)Error, unknown architecture. This architecture has not yet implemented for yq installation$(msg end)" --name
        # To install other, refer to this: https://github.com/mikefarah/yq/releases
        exit 147
      fi
    else
      _echo "$(msg yellow)[Skipped]: Warning, YQ installation is disabled from config file!$(msg end)" --name
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain

  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Get the latest scripts (temporarily using git which needs to have private token defined in config)
# This private repo contains lots of security scripts for Linux (c) by Arafat Ali (aka MaXi32)
# can re-run this with option get_latest_code --run-force to force re-clone and update to latest codes
# This function also store 3rd party scripts such as dropbox_uploader
get_latest_code() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local latest_code_version current_code_version
    required "debian@@apt:git" "ubuntu@@apt:git" "centos@@dnf:git"
    if ! command -v git &>/dev/null; then
      _echo "$(msg red)Error, git binary is missing or not installed properly$(msg end)" --name
      _exit 147
    fi
    # This one work for both CentOS and Debian
    _echo "$(msg cyan)Configuring git authentication ...$(msg end)" --name
    echo ""
    cat /dev/null >"${HOME}/.git-askpass"
    echo "#!/bin/bash" >>"${HOME}/.git-askpass"
    echo "echo ${C_GIT_TOKEN}" >>"${HOME}/.git-askpass"
    chmod +x "${HOME}/.git-askpass"
    export GIT_ASKPASS="${HOME}/.git-askpass"

    _echo "$(msg cyan)Removing ${SCRIPT_NAME} existing repository from ${LATEST_CODE_PATH} ...$(msg end)" --name
    rm -rf "${LATEST_CODE_PATH}"
    mkdir -p "${LATEST_CODE_PATH}"
    echo ""
    _echo "$(msg cyan)Cloning new ${SCRIPT_NAME} repository from ${C_SETUP_GIT_URL} ... $(msg end)" --name
    echo ""
    git clone "${C_SETUP_GIT_URL}" "${LATEST_CODE_PATH}"
    echo ""
    _echo "$(msg cyan)Checking code version ...$(msg end)" --name
    current_code_version=$(grep -w "^_APP_VERSION" "${SCRIPT_PATH}/${SCRIPT_NAME}" | cut -d "=" -f 2- | sed -e 's/"//' -e 's/"$//')
    latest_code_version=$(grep -w "^_APP_VERSION" "${LATEST_CODE_PATH}/${SCRIPT_NAME}" | cut -d "=" -f 2- | sed -e 's/"//' -e 's/"$//')
    if [ -n "${latest_code_version}" ]; then
      _echo "$(msg cyan)Current code version is $(msg magenta)v${current_code_version}$(msg end)" --name
      _echo "$(msg cyan)Latest code version is $(msg magenta)v${latest_code_version}$(msg end)" --name
    else
      _echo "$(msg red)Error, could not determine the latest code version! The latest code is needed for this script to work properly$(msg end)" --name
      _exit 147
    fi
    echo ""
    # After we have the latest source code folder, now we can delete these sensitive files for security
    _echo "$(msg cyan)Removing current git authentication ...$(msg end)" --name
    rm -f "${HOME}/.git-askpass"
    unset GIT_ASKPASS
    echo ""

    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi

}
# This function updates the maxicode to the latest binary
# Very important NOTE: When use --run-force in this function, this will reset permission of the binary .. make sure all the binary is set as executable from here
update_latest_maxicode() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local maxicode_latest_path
    # This always copied the correct version of the distribution automatically
    maxicode_latest_path="${LATEST_OS_CODE_PATH}/usr/local/maxicode"

    if [ ! -d "${maxicode_latest_path}" ]; then
      _echo "$(msg red)Error, maxicode latest script does not exist in ${maxicode_latest_path}$(msg end)" --name
      _exit 147
    fi
    _echo "$(msg cyan)Removing existing maxicode scripts from /usr/local/maxicode ...$(msg end)" --name
    rm -rf "/usr/local/maxicode"
    echo ""
    _echo "$(msg cyan)Copying maxicode scripts from ${maxicode_latest_path} into /usr/local/maxicode ...$(msg end)" --name
    cp -r "${maxicode_latest_path}" /usr/local/
    echo ""

    ##########################################################################
    # TODO add maxicode folder to /usr/local/maxicode
    # TODO Make sure maxinet is binary executable (link that on startup)
    # TODO run maxinet --update-maxicode in order to get the latest version of binary from maxicode.
    # TODO make sure IDE use this maxicode directly from that private repo, so box will be always up to date
    ##########################################################################

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This function contains the security hardening for Linux
secure_os() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local latest_code_version find_au find_ar user_rsa_public_key
    # This file should exist in the root file after OS has finished installation (preseed file put this file)
    user_rsa_public_key="/root/user_${C_SSH_USERNAME}_${C_BOX_HOSTNAME_FQHN}.id_rsa.pub"
    if [ ! -f "${user_rsa_public_key}" ]; then
      if [ "${C_HIDE_SENSITIVE_TEXT}" == "true" ]; then
        _echo "$(msg yellow)Warning, the RSA public key file *hidden_key_location* not found inside operating system!$(msg end)" --name
      else
        _echo "$(msg yellow)Warning, the RSA public key file ${user_rsa_public_key} not found inside operating system!$(msg end)" --name
      fi
      _echo "$(msg yellow)Note: ${_APP_SPECIFIC_NAME} will use the user_rsa_public_key from config file. Please make sure this key is up to date$(msg end)" --name
      _pause 15
      user_rsa_public_key="${C_SSH_PUBLIC_KEY}"
    else
      _echo "$(msg cyan)Note: ${_APP_SPECIFIC_NAME} will use user RSA public key from /root/user_${LABEL_C_SSH_USERNAME}_${LABEL_C_BOX_HOSTNAME_FQHN}.id_rsa.pub for ${LABEL_C_SSH_USERNAME} SSH login ..."
      # Reassign C_SSH_PUBLIC_KEY to the latest SSH key
      user_rsa_public_key=$(cat "${user_rsa_public_key}")
    fi
    echo ""
    _echo "$(msg cyan)Changing operating system main root password ...$(msg end)" --name
    if [[ "${DISTRO_ID}" == "centos" || "${DISTRO_ID}" == "almalinux" ]]; then
      echo "${C_ROOT_USERPASS}" | passwd --stdin "${C_ROOT_USERNAME}"
    elif [[ "${DISTRO_ID}" == "debian" ]]; then
      echo "${C_ROOT_USERNAME}:${C_ROOT_USERPASS}" | chpasswd
    else
      _echo "$(msg red)Error, unknown value for distribution ID ${DISTRO_ID}. This distribution ID is not supported!$(msg end)" --name
      _exit 147
    fi
    echo ""
    _echo "$(msg cyan)Setting up server hostname to full qualified hostname (FQHN): ${LABEL_C_BOX_HOSTNAME_FQHN} ...$(msg end)" --name
    hostnamectl set-hostname "${C_BOX_HOSTNAME_FQHN}"
    _echo "$(msg magenta)[Testing]: current hostname is $(hostname)$(msg end)" --name
    echo ""
    _echo "$(msg cyan)Setting up server timezone to ${C_BOX_TIMEZONE} ...$(msg end)" --name
    timedatectl set-timezone "${C_BOX_TIMEZONE}"
    _echo "$(msg magenta)[Testing]: Current date is $(date)$(msg end)" --name
    echo ""
    if [[ "${DISTRO_ID}" == "centos" || "${DISTRO_ID}" == "almalinux" ]]; then
      _echo "$(msg cyan)Creating a non-sudo username ${LABEL_C_SSH_USERNAME} ...$(msg end)" --name
      adduser "${C_SSH_USERNAME}"
      echo ""
      _echo "$(msg cyan)Setting up password for non-sudo username ${LABEL_C_SSH_USERNAME} ...$(msg end)" --name
      echo "${C_SSH_USERPASS}" | passwd --stdin "${C_SSH_USERNAME}"
      echo ""
      _echo "$(msg cyan)Adding a non-sudo user ${LABEL_C_SSH_USERNAME} to the highest privilege group ...$(msg end)" --name
      gpasswd -a "${C_SSH_USERNAME}" wheel
      echo ""
    elif [ "${DISTRO_ID}" == "debian" ]; then
      _echo "$(msg cyan)Creating a non-sudo username ${LABEL_C_SSH_USERNAME} ...$(msg end)" --name
      useradd "${C_SSH_USERNAME}" -s /bin/bash -m
      echo ""
      _echo "$(msg cyan)Setting up password for a non-sudo username for ${LABEL_C_SSH_USERNAME} ...$(msg end)" --name
      echo "${C_SSH_USERNAME}:${C_SSH_USERPASS}" | chpasswd
      echo ""
      _echo "$(msg cyan)Adding a non-sudo user ${LABEL_C_SSH_USERNAME} to the highest privilege group ...$(msg end)" --name
      usermod -aG sudo "${C_SSH_USERNAME}"
      echo ""
    else
      _echo "$(msg red)Error, unknown value for distribution ID ${DISTRO_ID}. This distribution ID is not supported$(msg end)" --name
      _exit 147
    fi

    # These works with ubuntu, debian, centos (will check more with other distro)
    _echo "$(msg cyan) Testing login a non-sudo user ${LABEL_C_SSH_USERNAME} ...$(msg end)" --name
    if [[ "${C_HIDE_SENSITIVE_TEXT}" == "true" ]]; then
      _echo "$(msg magenta) =~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name
      sudo -H -u "${C_SSH_USERNAME}" bash -c 'echo "[Testing]: Hello, I am *hidden_username*, with uid *hidden_uuid*"'
      _echo "$(msg magenta) =~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name

    else

      _echo "$(msg magenta) =~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name
      sudo -H -u "${C_SSH_USERNAME}" bash -c 'echo "[Testing]: Hello, I am ${USER}, with uid ${UID}"'
      _echo "$(msg magenta) =~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name
    fi

    # TIP: To remove this non-sudo user we can do this:
    # userdel -r "${C_SSH_USERNAME}" , where -r will also delete his home directory
    _echo "$(msg cyan)Creating .ssh home directory for a non-sudo user ${LABEL_C_SSH_USERNAME} to store SSH public key files ...$(msg end)" --name

    sudo -H -u "${C_SSH_USERNAME}" bash -c "mkdir -p ~/.ssh"
    _echo "$(msg cyan)Creating an authorized key file ~/.ssh/authorized_keys ...$(msg end)" --name
    sudo -H -u "${C_SSH_USERNAME}" bash -c "touch ~/.ssh/authorized_keys"
    _echo "$(msg cyan)Writing an RSA public key into ~/.ssh/authorized_keys ...$(msg end)" --name
    sudo -H -u "${C_SSH_USERNAME}" bash -c "echo ${user_rsa_public_key} >~/.ssh/authorized_keys"
    _echo "$(msg cyan) Changing ~/.ssh/authorized_keys permission to chmod 700  ...$(msg end)" --name
    sudo -H -u "${C_SSH_USERNAME}" bash -c "chmod 700 ~/.ssh/authorized_keys"

    #sed -i "/AllowUsers/c\AllowUsers ${C_SSH_USERNAME}" /etc/ssh/sshd_config
    # For non-sudo user
    find_au=$(grep -w "AllowUsers ${C_SSH_USERNAME}" /etc/ssh/sshd_config)
    if [[ -n "${find_au}" ]]; then
      _echo "$(msg yellow)[Skipped] the non-sudo user ${LABEL_C_SSH_USERNAME} is already set as AllowUsers list in sshd_config ...$(msg end)" --name
    else
      _echo "$(msg yellow)Adding a non-sudo user ${LABEL_C_SSH_USERNAME} to AllowUsers list in sshd_config ...$(msg end)" --name
      echo "AllowUsers ${C_SSH_USERNAME}" >>/etc/ssh/sshd_config
    fi
    echo ""
    # For root user
    find_ar=$(grep -w "AllowUsers ${C_ROOT_USERNAME}" /etc/ssh/sshd_config)
    if [[ -n "${find_ar}" ]]; then
      _echo "$(msg yellow)[Skipped] root user ${LABEL_C_ROOT_USERNAME} is already set as AllowUsers list in sshd_config ...$(msg end)" --name

    else
      # Put at the bottom
      _echo "$(msg cyan)Adding root user ${LABEL_C_ROOT_USERNAME} to AllowUsers list in sshd_config ...$(msg end)" --name

      echo "AllowUsers ${C_ROOT_USERNAME}" >>/etc/ssh/sshd_config
    fi
    echo ""
    # Note: Temporarily allow root login only with cert and with the setting of PermitRootLogin to prohibited-password in sshd_config during installation.
    # Note: The operating system installation might have included the setting PermitRootLogin prohibited-password
    # Note: After finished installation set PermitRootLogin to no
    # This command is left for reference:
    # echo "[${SCRIPT_NAME}]: Disabling root login via sshd_config ..."
    # sed -i '/^PermitRootLogin/s/yes/no/' /etc/ssh/sshd_config
    _echo "$(msg cyan)Disabling Password authentication via sshd_config ...$(msg end)" --name
    sed -i "s/^#PasswordAuthentication.*/PasswordAuthentication no/" /etc/ssh/sshd_config
    echo ""
    _echo "$(msg cyan)Disabling empty password login via sshd_config ...$(msg end)" --name
    sed -i "s/^#PermitEmptyPasswords.*/PermitEmptyPasswords no/" /etc/ssh/sshd_config
    echo ""
    _echo "$(msg cyan)Changing SSH default port from 22 to ${LABEL_C_SSH_PORT} ...$(msg end)" --name
    _echo "$(msg yellow)Note, CSF will automatically add this port in allowed list during installation ...$(msg end)" --name
    sed -i "s/#Port 22/Port ${C_SSH_PORT}/" /etc/ssh/sshd_config
    echo ""
    _echo "$(msg cyan)Changing SSH to only listen to IPv4 (disable IPv6 SSH login) ...$(msg end)" --name
    sed -i "s/^#AddressFamily.*/AddressFamily inet/" /etc/ssh/sshd_config
    echo ""
    # Adding login banner
    echo "[${SCRIPT_NAME}]: Setting login banner for issue and issue.net ..."
    create_file "ssh-banner1" "/etc/issue"
    echo ""
    create_file "ssh-banner1" "/etc/issue.net"
    echo ""
    _echo "$(msg cyan)Enabling login banner in sshd_config ...$(msg end)" --name
    sed -i "s/^#Banner none/Banner \/etc\/issue/" /etc/ssh/sshd_config
    echo ""
    # Initial firewall configuration
    if [[ "${DISTRO_ID}" == "centos" || "${DISTRO_ID}" == "almalinux" ]]; then
      _echo "$(msg cyan)Adding SSH port ${LABEL_C_SSH_PORT}/tcp to firewalld ...$(msg end)" --name
      if [[ "${C_HIDE_SENSITIVE_TEXT}" == "true" ]]; then
        sudo firewall-cmd --quiet --permanent --zone=public --add-port="${C_SSH_PORT}/tcp"
      else
        sudo firewall-cmd --permanent --zone=public --add-port="${C_SSH_PORT}/tcp"
      fi
      echo ""
      _echo "$(msg cyan)Adding an IP address ${LABEL_C_HOST_PUBLIC_IP} from config file in firewalld to prevent locked out during setup$(msg end)" --name

      if [[ "${C_HIDE_SENSITIVE_TEXT}" == "true" ]]; then
        sudo firewall-cmd --permanent --add-source="${C_HOST_PUBLIC_IP}"
        _echo "$(msg cyan)Reloading firewall-cmd silently ...$(msg end)" --name
        firewall-cmd --quiet --reload
      else
        sudo firewall-cmd --quiet --permanent --add-source="${C_HOST_PUBLIC_IP}"
        _echo "$(msg cyan)Reloading firewall-cmd ...$(msg end)" --name
        firewall-cmd --reload
      fi
      echo ""
    elif [ "${DISTRO_ID}" == "debian" ]; then
      _echo "$(msg yellow)Warning, the default debian installation doesn't include any firewalls. UFW for Debian will be installed automatically if it does not exist ...$(msg end)" --name
      required "debian@@apt:ufw"
      echo ""
      _echo "$(msg cyan)Adding https port (443) to ufw ...$(msg end)" --name
      sudo ufw allow "https"
      echo ""
      _echo "$(msg cyan)Adding http port (80) to ufw ...$(msg end)" --name
      sudo ufw allow "http"
      echo ""
      _echo "$(msg cyan)Adding SSH port ${LABEL_C_SSH_PORT}/tcp to ufw ...$(msg end)" --name
      sudo ufw allow "${C_SSH_PORT}/tcp"
      echo ""
      if [ "${C_GOTIFY_INSTALLATION}" == "true" ]; then
        _echo "$(msg cyan)Adding gotify port ${LABEL_C_GOTIFY_PORT}/tcp to ufw ...$(msg end)" --name
        sudo ufw allow "${C_GOTIFY_PORT}/tcp"
      fi
      echo ""
      _echo "$(msg cyan)Adding an IP address ${LABEL_C_HOST_PUBLIC_IP} from config file in ufw to prevent locked out during setup$(msg end)" --name
      sudo ufw allow from "${C_HOST_PUBLIC_IP}"
      echo ""
      _echo "$(msg cyan)Enabling ufw firewall ...$(msg end)" --name
      sudo ufw --force enable
      echo ""
      _echo "$(msg cyan)Reloading ufw firewall ...$(msg end)" --name
      sudo ufw reload
      echo ""

    else
      _echo "$(msg red)Error, unknown value for distribution ID ${DISTRO_ID}. This distribution ID is not supported!$(msg end)" --name
      _exit 147
    fi

    # Hardening other settings for SSHD_CONFIG
    # Recommended by lynis
    _echo "$(msg cyan)Setting SSH LogLevel variable in sshd_config to VERBOSE ...$(msg end)" --name
    sed -i "s/^#LogLevel.*/LogLevel VERBOSE/" /etc/ssh/sshd_config
    echo ""
    # Recommended by lynis
    _echo "$(msg cyan)Setting SSH MaxAuthTries variable in sshd_config to 5 ...$(msg end)" --name
    sed -i "s/^#MaxAuthTries.*/MaxAuthTries 5/" /etc/ssh/sshd_config
    echo ""
    # Recommended by lynis
    _echo "$(msg cyan)Setting SSH MaxSessions variable in sshd_config to 10 ...$(msg end)" --name
    sed -i "s/^#MaxSessions.*/MaxSessions 10/" /etc/ssh/sshd_config
    echo ""
    # This one recommended by CSF security page:
    _echo "$(msg cyan)Setting SSH UseDNS variable in sshd_config to no ...$(msg end)" --name
    sed -i "s/^#UseDNS.*/UseDNS no/" /etc/ssh/sshd_config
    echo ""
    # Restart SSHD
    _echo "$(msg cyan)Restarting sshd service to apply new settings ...$(msg end)" --name
    # This works with debian, ubuntu and centos
    systemctl reload sshd
    echo ""
    _echo "$(msg green)[OK]: The host ${LABEL_C_BOX_HOSTNAME_FQHN} is now secured with basic security hardening protection$(msg end)" --name
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_grub() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local grep_existing grub_hash_password grub_make_pass_bin retval

    if [ "${C_SECURE_GRUB}" == "true" ]; then
      _echo "$(msg cyan)Notice, C_SECURE_GRUB is set in config file. Configuring Grub password protection bootloader ...$(msg end)" --name
      grub_make_pass_bin=$(command -v grub-mkpasswd-pbkdf2)
      grub_hash_password=$(echo -e "${C_GRUB_PASS}\n${C_GRUB_PASS}" | ${grub_make_pass_bin} | awk '/grub.pbkdf/{print$NF}')
      grep_existing=$(grep -i "password_pbkdf2" /etc/grub.d/00_header)
      if [[ -z "${grep_existing}" ]]; then
        _echo "$(msg cyan)Writing grub username and password inside /etc/grub.d/00_header ...$(msg end)" --name
        {
          echo "cat << EOF"
          echo "set superusers=\"${C_GRUB_UNAME}\""
          echo "password_pbkdf2 ${C_GRUB_UNAME} ${grub_hash_password}"
          echo "EOF"
        } >>/etc/grub.d/00_header
        echo ""
        _echo "$(msg cyan)Updating grub loader ...$(msg end)" --name
        grub-mkconfig -o /boot/grub/grub.cfg
        retval=$?
        if [ "${retval}" -ne 0 ]; then
          _echo "$(msg red)Error, there was a problem when compiling new grub config$(msg end)" --name
          _exit 147
        fi
        #or use this: sudo update-grub
      else
        _echo "$(msg yellow)Warning, failed to configure grub password because there is already a grub password setting configured in /etc/grub.d/00_header.$(msg end)" --name
      fi
    else
      _echo "$(msg yellow)[Skipped]: Notice, grub password protection C_SECURE_GRUB is not set, setup will skip enabling GRUB bootloader password protection!$(msg end)" --name
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This one configuration hostname, network etc.
configure_net() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local current_active_lan grub_search
    _echo "$(msg cyan)Obtaining current active LAN interface ...$(msg end)" --name
    # LAN can have one or more
    current_active_lan=$(ip route get 1.1.1.1 | grep -Po '(?<=dev\s)\w+' | cut -f1 -d ' ')
    # ip addr | awk '/state UP/ {print $2}' | sed 's/.$//'
    if [ "${current_active_lan}" == "${C_NIC_INTERFACE_NAME}" ]; then
      _echo "$(msg cyan)[Skipped]: OK, the current LAN interface name is equal with the value of C_NIC_INTERFACE_NAME from config file$(msg end)" --name
    else
      _echo "$(msg yellow)Warning, the current LAN interface is emulated with ${current_active_lan} but the config variable C_NIC_INTERFACE_NAME is set to use interface ${C_NIC_INTERFACE_NAME}$(msg end)" --name
      if [[ "${C_NIC_INTERFACE_NAME}" == "eth0" ]]; then
        _echo "$(msg cyan)Modifying grub file to disable interface name convention (revert to default name as eth0) ...$(msg end)" --name
        # sed -i 's/rhgb quiet/net.ifnames=0 biosdevname=0/' /etc/default/grub
        grub_search=$(grep -Ec 'GRUB_CMDLINE_LINUX=.*net.ifnames|GRUB_CMDLINE_LINUX_DEFAULT=.*net.ifnames' /etc/default/grub)
        if [ "${grub_search}" -eq 0 ]; then
          grub_search=$(grep -Ec 'GRUB_CMDLINE_LINUX=""' /etc/default/grub)
          if [ "${grub_search}" -eq 0 ]; then
            _echo "$(msg cyan)Appending net.ifnames=0 for GRUB_CMDLINE_LINUX in /etc/default/grub ...$(msg end)" --name
            sed -i 's/GRUB_CMDLINE_LINUX="[^"]*/& net.ifnames=0/' /etc/default/grub
          else
            # Adding new value (not appending)
            _echo "$(msg cyan)Adding new value net.ifnames=0 for GRUB_CMDLINE_LINUX in /etc/default/grub ...$(msg end)" --name
            sed -i 's/GRUB_CMDLINE_LINUX=""/GRUB_CMDLINE_LINUX="net.ifnames=0"/g' /etc/default/grub
          fi
        else
          _echo "$(msg yellow)[Skipped]: The value 'biosdevname' has been set previously for GRUB_CMDLINE_LINUX or GRUB_CMDLINE_LINUX_DEFAULT in /etc/default/grub ...$(msg end)" --name
        fi

        grub_search=$(grep -Ec 'GRUB_CMDLINE_LINUX=.*biosdevname|GRUB_CMDLINE_LINUX_DEFAULT=.*biosdevname' /etc/default/grub)
        if [ "${grub_search}" -eq 0 ]; then
          grub_search=$(grep -Ec 'GRUB_CMDLINE_LINUX=""' /etc/default/grub)
          if [ "${grub_search}" -eq 0 ]; then
            _echo "$(msg cyan)Appending biosdevname=0 for GRUB_CMDLINE_LINUX in /etc/default/grub ...$(msg end)" --name
            sed -i 's/GRUB_CMDLINE_LINUX="[^"]*/& biosdevname=0/' /etc/default/grub
          else
            # Adding new value (not appending)
            _echo "$(msg cyan)Adding new value biosdevname=0 for GRUB_CMDLINE_LINUX in /etc/default/grub ...$(msg end)" --name
            sed -i 's/GRUB_CMDLINE_LINUX=""/GRUB_CMDLINE_LINUX="biosdevname=0"/g' /etc/default/grub
          fi
        else
          _echo "$(msg yellow)[Skipped]: The value 'biosdevname' has been set previously for GRUB_CMDLINE_LINUX or GRUB_CMDLINE_LINUX_DEFAULT in /etc/default/grub ...$(msg end)" --name
        fi

        # Enabling serial terminal
        grub_search=$(grep -Ec 'GRUB_CMDLINE_LINUX=.*console|GRUB_CMDLINE_LINUX_DEFAULT=.*console' /etc/default/grub)
        if [ "${grub_search}" -eq 0 ]; then
          grub_search=$(grep -Ec 'GRUB_CMDLINE_LINUX=""' /etc/default/grub)
          if [ "${grub_search}" -eq 0 ]; then
            _echo "$(msg cyan)Appending console=ttyS0,19200n8 for GRUB_CMDLINE_LINUX in /etc/default/grub ...$(msg end)" --name
            sed -i 's/GRUB_CMDLINE_LINUX="[^"]*/& console=ttyS0,19200n8/' /etc/default/grub
          else
            # Adding new value (not appending)
            _echo "$(msg cyan)Adding new value console=ttyS0,19200n8 for GRUB_CMDLINE_LINUX in /etc/default/grub ...$(msg end)" --name
            sed -i 's/GRUB_CMDLINE_LINUX=""/GRUB_CMDLINE_LINUX="console=ttyS0,19200n8"/g' /etc/default/grub
          fi
        else
          _echo "$(msg yellow)[Skipped]: The value 'console' has been set previously for GRUB_CMDLINE_LINUX or GRUB_CMDLINE_LINUX_DEFAULT in /etc/default/grub ...$(msg end)" --name
        fi

        echo ""

        # Enabling serial terminal 1
        _echo "$(msg cyan)Enabling GRUB serial terminal 1 ...$(msg end)" --name
        grub_search=$(grep -Ec '^GRUB_SERIAL_COMMAND=' /etc/default/grub)
        if [ "${grub_search}" -eq 0 ]; then
          _echo "$(msg cyan)Creating empty variable GRUB_SERIAL_COMMAND= ...$(msg end)" --name
          echo "GRUB_SERIAL_COMMAND=\"\"" >>/etc/default/grub
        fi
        grub_search=$(grep -Ec 'GRUB_SERIAL_COMMAND=.*serial' /etc/default/grub)
        if [ "${grub_search}" -eq 0 ]; then
          grub_search=$(grep -Ec 'GRUB_SERIAL_COMMAND=""' /etc/default/grub)
          if [ "${grub_search}" -eq 0 ]; then
            # In case if this option need appending
            _echo "$(msg cyan)Appending serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1 for GRUB_SERIAL_COMMAND in /etc/default/grub ...$(msg end)" --name
            sed -i 's/GRUB_SERIAL_COMMAND="[^"]*/& serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1/' /etc/default/grub
          else
            # Adding new value (not appending)
            _echo "$(msg cyan)Adding new value serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1 for GRUB_SERIAL_COMMAND in /etc/default/grub ...$(msg end)" --name
            sed -i 's/GRUB_SERIAL_COMMAND=""/GRUB_SERIAL_COMMAND="serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1"/g' /etc/default/grub
          fi
        else
          _echo "$(msg yellow)[Skipped]: The value 'serial' has been set previously for GRUB_SERIAL_COMMAND in /etc/default/grub ...$(msg end)" --name
        fi

        echo ""
        # Enabling serial terminal 2
        _echo "$(msg cyan)Enabling GRUB serial terminal 2 ...$(msg end)" --name
        grub_search=$(grep -Ec '^GRUB_TERMINAL=' /etc/default/grub)
        if [ "${grub_search}" -eq 0 ]; then
          echo "$(msg cyan)Creating empty variable GRUB_TERMINAL= ...$(msg end)" --name
          echo "GRUB_TERMINAL=" >>/etc/default/grub
        fi
        grub_search=$(grep -Ec 'GRUB_TERMINAL=serial' /etc/default/grub)
        if [ "${grub_search}" -eq 0 ]; then
          # Adding new value (not appending)
          _echo "$(msg cyan)Adding new value GRUB_TERMINAL=serial for GRUB_TERMINAL in /etc/default/grub ...$(msg end)" --name
          sed -i 's/GRUB_TERMINAL=/GRUB_TERMINAL=serial/g' /etc/default/grub
        else
          _echo "$(msg yellow)[Skipped]: The value 'serial' has been set previously for GRUB_TERMINAL in /etc/default/grub ...$(msg end)" --name
        fi
        echo ""
        _echo "$(msg cyan)Recompiling grub boot loader for new config ...$(msg end)" --name
        if [[ "${DISTRO_ID}" == "centos" || "${DISTRO_ID}" == "almalinux" ]]; then
          # Recompile grub centos command
          grub2-mkconfig -o /boot/grub2/grub.cfg
          # Need to reboot here
        elif [ "${DISTRO_ID}" == "debian" ]; then
          # Recompile grub debian command
          grub-mkconfig -o /boot/grub/grub.cfg
        else
          _echo "$(msg red)Error, unknown value for distribution ID ${DISTRO_ID}. This distribution ID is not supported$(msg end)" --name
          _exit 147
        fi
      else
        # Rename interface other than eth0
        _echo "$(msg yellow)Notice, the new LAN interface is set to ${LABEL_C_NIC_INTERFACE_NAME} in config file$(msg end)" --name
        # Or recommend to use screen
        _echo "$(msg cyan)Executing configure_net2 with --run-force option to setup system network interface to ${LABEL_C_NIC_INTERFACE_NAME} before rebooting to prevent locked out ...$(msg end)" --name
        configure_net2 --run-force
        echo ""
        _echo "$(msg cyan)Creating background script ${CODE_PATH}/ssh_scripts/lan_interface_rename.sh to rename LAN interface when the SSH disconnected ...$(msg end)" --name
        mkdir -p "${CODE_PATH}/ssh_scripts"
        {
          echo "#!/bin/bash"
          echo "echo \"Turning off current LAN ${current_active_lan} interface ...\""
          echo "ip link set \"${current_active_lan}\" down"
          echo "echo \"Renaming ${current_active_lan} to ${LABEL_C_NIC_INTERFACE_NAME} ...\""
          echo "ip link set \"${current_active_lan}\" name \"${C_NIC_INTERFACE_NAME}\""
          echo "echo \"Renaming interface file ifcfg-${current_active_lan} to ifcfg-${LABEL_C_NIC_INTERFACE_NAME} ...\""
          echo "mv /etc/sysconfig/network-scripts/ifcfg-{\"${current_active_lan}\",\"${C_NIC_INTERFACE_NAME}\"}"
          echo "echo \"Turning on the new LAN interface ${LABEL_C_NIC_INTERFACE_NAME} ...\""
          echo "ip link set \"${C_NIC_INTERFACE_NAME}\" up"
          echo "echo \"Rebooting ...\""
          echo "reboot --force"
          echo ""
        } >"${CODE_PATH}/ssh_scripts/lan_interface_rename.sh"
        echo ""
        _echo "$(msg cyan)Allowing execution permission for background script ${CODE_PATH}/ssh_scripts/lan_interface_rename.sh ...$(msg end)" --name
        chmod +x "${CODE_PATH}/ssh_scripts/lan_interface_rename.sh"
        echo ""
        _echo "$(msg red)*Warning$(msg yellow), background script will be executed to rename network interface to ${LABEL_C_NIC_INTERFACE_NAME} ...$(msg end)" --name
        _echo "$(msg red)**Warning$(msg yellow), active LAN interface ${current_active_lan} will be disconnected ...$(msg end)" --name
        _echo "$(msg red)***Warning$(msg yellow), the current active network needs to be turned off in order to be able to rename a new LAN interface$(msg end)" --name
        sleep 2
        _echo "$(msg red)****Warning$(msg yellow), If you are on SSH connection, you will be disconnected from SSH but the background script will run$(msg end)" --name
        sleep 2
        _echo "$(msg red)*****Warning$(msg yellow), you will not see any output of the background process, but when it has finished running, the system will reboot automatically.$(msg end)" --name
        _echo "$(msg yellow)You can re-run this script again with action setup to recheck whether the interface is configured correctly before proceeding to the next step$(msg end)" --name
        # Because the script reboot, we need to re-run this function to check if interface is already set like in the config file
        _pause 30
        _echo "$(msg cyan)Executing background script ${CODE_PATH}/ssh_scripts/lan_interface_rename.sh to rename interface via ip link command and rebooting system automatically ...$(msg end)" --name
        nohup sh "${CODE_PATH}/ssh_scripts/lan_interface_rename.sh" >/dev/null 2>&1 &
        while :; do
          # This will display until it reboots itself,
          sleep 1
          _echo "$(msg yellow)Waiting for the system to reboot itself [Do not turn off the server] ...$(msg end)" --start-spin --name
        done
        # Use return to stop other statements because we only want the script to manage the reboot and other stuff
        return 0
      fi
      echo ""
      _echo "$(msg yellow)Creating required reboot flag for network interface to revert back to eth0 automatically after reboot ...$(msg end)" --name
      cat /dev/null >/var/run/reboot-required
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This would change like static IP, resolv.conf etc ...
# I prefer to use eth0 than a strange name like epn${x} but now this script can rename whatever interface you want
configure_net2() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local current_host host_count clean_host
    # So, at this stage we know our LAN would be ${C_NIC_INTERFACE_NAME} then we can insert network information directly into ${C_NIC_INTERFACE_NAME}
    if [[ "${DISTRO_ID}" == "centos" || "${DISTRO_ID}" == "almalinux" ]]; then
      # Create network static IP configuration
      _echo "$(msg cyan)Inserting static IP information for ${LABEL_C_NIC_INTERFACE_NAME} at /etc/sysconfig/network-scripts/ifcfg-${LABEL_C_NIC_INTERFACE_NAME} ...$(msg end)" --name
      {
        echo "# ==============================================="
        echo "# This configuration file was generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# GENERAL DEVICE CONFIGURATION "
        echo 'TYPE="Ethernet"'
        echo "DEVICE=\"${C_NIC_INTERFACE_NAME}\""
        echo "NAME=\"${C_NIC_INTERFACE_NAME}\""
        echo 'ONBOOT="yes"'
        echo 'BOOTPROTO="none"'
        echo 'PEERDNS="no"'
        # This will generate new UUID for "${C_NIC_INTERFACE_NAME}"
        echo "UUID=$(uuidgen "${C_NIC_INTERFACE_NAME}")"
        echo "DOMAIN=${C_BOX_DOMAIN}"
        echo ""
        echo "# IPv4 Configuration (Public)"
        echo 'IPV4_FAILURE_FATAL="no"'
        echo 'DEFROUTE="yes"'
        echo "IPADDR0=${C_IPV4_ADD0}"
        echo "GATEWAY0=${C_IPV4_DEF_GATEWAY0}"
        echo "PREFIX0=24"
        echo ""
        echo "# IPv4 Configuration (Private)"
        echo '# IPADDR2=""'
        echo "# PREFIX2=17"
        echo ""
        echo "# IPv6 Configuration (Public)"
        echo 'IPV6INIT="yes"'
        echo 'IPV6_AUTOCONF="yes"'
        echo 'IPV6_DEFROUTE="yes"'
        echo 'IPV6_FAILURE_FATAL="no"'
        echo 'IPV6_ADDR_GEN_MODE="stable-privacy"'
        echo '#IPV6_ADDR_GEN_MODE="eui64"'
        echo "IPV6ADDR=${C_IPV6_ADD0}/64"
        echo "IPV6_DEFAULTGW=${C_IPV6_DEF_GATEWAY0}"
        echo 'IPV6_PRIVACY="no"'
        echo ""
        echo "# resolvconf - doesn't recognize more than 3 nameservers. (IPv4 & IPv6)"
        echo "DNS1=${C_NAME_SERVER1}"
        echo "DNS2=${C_NAME_SERVER2}"
        echo "DNS3=${C_NAME_SERVER3}"
      } >"/etc/sysconfig/network-scripts/ifcfg-${C_NIC_INTERFACE_NAME}"
    elif [ "${DISTRO_ID}" == "debian" ]; then
      _echo "$(msg cyan)Inserting static IP information for ${LABEL_C_NIC_INTERFACE_NAME} at /etc/network/interfaces ...$(msg end)" --name
      {
        echo "# ==============================================="
        echo "# This configuration file was generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# This file describes the network interfaces available on your system"
        echo "# and how to activate them. For more information, see interfaces(5)."
        echo ""
        # This is not needed, it can cause bug network raised error reported from various sites
        #echo "source /etc/network/interfaces.d/*"
        #echo ""
        echo "# The loopback network interface"
        echo "auto lo"
        echo "iface lo inet loopback"
        echo ""
        echo "# auto ${C_NIC_INTERFACE_NAME} is needed to configure static IP for both IPv4 and IPv6"
        echo "auto ${C_NIC_INTERFACE_NAME}"
        echo ""
        echo "# The primary IPv4 network interface"
        echo "iface ${C_NIC_INTERFACE_NAME} inet static"
        echo "   address ${C_IPV4_ADD0}/24"
        echo "   gateway ${C_IPV4_DEF_GATEWAY0}"
        echo "   dns-nameservers ${C_NAME_SERVER1} ${C_NAME_SERVER2}"
        echo ""
        echo "# The primary IPv6 network interface"
        echo "iface ${C_NIC_INTERFACE_NAME} inet6 static"
        echo "   address ${C_IPV6_ADD0}/64"
        echo "   gateway ${C_IPV6_DEF_GATEWAY0}"
      } >/etc/network/interfaces
      _echo "$(msg cyan)Disabling IPv6 Duplicate Address Detection ...$(msg end)" --name
      # Disabling Ipv6 DAD: https://www.agwa.name/blog/post/beware_the_ipv6_dad_race_condition
      # Another way is to use this sysctl -w net.ipv6.conf.eth0.dad_transmits=0 or put in /etc/sysctl for permanent
      # Why disable? Because nginx sometimes cannot start with ipv6 unless system is restarted
      if [ -f "/proc/sys/net/ipv6/conf/${C_NIC_INTERFACE_NAME}/accept_dad" ]; then
        {
          echo "# Disable IPv6 Duplicate Address Detection"
          echo "pre-up echo 0 > /proc/sys/net/ipv6/conf/${C_NIC_INTERFACE_NAME}/accept_dad"
        } >>/etc/network/interfaces
      fi
    else
      _echo "$(msg red)Error, unknown value for distribution ID ${DISTRO_ID}. This distribution ID is not supported$(msg end)" --name
      _exit 147
    fi
    # resolvconf already installed in Debian preseed file
    # Note use /etc/resolvconf/resolv.conf.d/base instead of /etc/resolv.conf because the base file will not be overwritten
    # This insertion works for both centos, almalinux, debian and ubuntu so there is no need to put OS condition
    _echo "$(msg cyan)Inserting name server information in /etc/resolvconf/resolv.conf.d/base ...$(msg end)" --name
    {
      echo "# ==============================================="
      echo "# This configuration file was generated by ${SCRIPT_NAME}"
      echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
      echo "# ==============================================="
      #echo "search ${C_BOX_DOMAIN}"
      echo "domains ${C_BOX_HOSTNAME_FQHN}"
      echo "options rotate"
      # Only up to 3 name servers are allowed in /etc/resolv.conf: https://linux.die.net/man/5/resolv.conf
      echo "nameserver ${C_NAME_SERVER1}"
      echo "nameserver ${C_NAME_SERVER2}"
      echo "nameserver ${C_NAME_SERVER3}"
    } >/etc/resolvconf/resolv.conf.d/base
    echo ""
    # Compiling
    _echo "$(msg cyan)Updating resolvconf ...$(msg end)" --name
    sudo resolvconf -u
    get_status_message "$?"
    echo ""
    _echo "$(msg cyan)Getting the current hostname ...$(msg end)" --name
    # if it is empty, put a placeholder as old.host.com
    current_host=$(hostname --fqdn)
    # Set hostname to ${C_BOX_HOSTNAME_FQHN}
    _echo "$(msg cyan)Setting hostname to ${LABEL_C_BOX_HOSTNAME_FQHN} ...$(msg end)" --name
    hostname "${C_BOX_HOSTNAME_FQHN}"
    #echo "current_hostname: ${current_host}"
    if [ -z "${current_host}" ]; then
      current_host=old.host.com
      _echo "$(msg yellow)Warning, the current hostname was blank and is now set to ${current_host}$(msg end)" --name
    fi
    echo ""
    #Copy everything from /etc/hosts except domain.com and current hostname and comments and store in /etc/hosts.tmp
    _echo "$(msg cyan)Removing previous domain C_BOX_HOSTNAME hostnames and store in /etc/hosts.tmp ...$(msg end)" --name
    clean_host=$(grep -wv "${C_BOX_HOSTNAME_FQHN}" /etc/hosts | grep -wv ${current_host} | grep -v '#')
    echo "${clean_host}" >/etc/hosts.tmp
    echo ""
    _echo "$(msg cyan)Rewrite a new host contents based on /etc/hosts.tmp ...$(msg end)" --name
    # start a new host template:
    {
      echo "# ==============================================="
      echo "# This configuration file was generated by ${SCRIPT_NAME}"
      echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
      echo "# ==============================================="
      # This was a standard warning message from previous distro
      echo "# Do not remove the following line, or various programs"
      echo "# that require network functionality will fail."
    } >/etc/hosts

    host_count_tmp=$(grep -c "localhost" /etc/hosts.tmp)

    if [ "${host_count_tmp}" -lt 1 ]; then
      echo -e "127.0.0.1\t\t localhost.localdomain localhost" >>/etc/hosts
    fi
    echo ""
    _echo "$(msg cyan)Adding IP (IPv4) and (IPv6) and entries in /etc/hosts ...$(msg end)" --name
    {
      cat /etc/hosts.tmp
      echo ""
      echo "# IP information for ${C_BOX_HOSTNAME_FQHN}:"
      printf '%s\t%s\t%s\n' "${C_IPV4_ADD0}" "${C_BOX_HOSTNAME_FQHN}" "${C_BOX_HOSTNAME}"
      printf '%s\t%s\t%s\n' "${C_IPV6_ADD0}" "${C_BOX_HOSTNAME_FQHN}" "${C_BOX_HOSTNAME}"
    } >>/etc/hosts
    chmod 644 /etc/hosts
    _echo "$(msg cyan)Preventing /etc/hosts from being modified by other processes using chattr +i immutable$(msg end)" --name
    # When using a VPS, managed dedicated server that use auto network manager provided by registrar, it will keep replacing this hosts file.
    # So, we don't want anyone to disturb this beautiful written host file by using chattr +i on this file
    # Note directadmin setup also trying to modify this /etc/hosts file during setup using its script called: /usr/local/directadmin/scripts/hostname.sh
    # It will get an error operation not permitted but do not worry because /etc/hosts is correctly configured now.
    # Another reason why I don't want directadmin to modify this host file is because directadmin will not write IPv6 value automatically (it will mess up the /etc/hosts).
    # The file is perfect and should be readonly mode
    chattr +i /etc/hosts
    get_status_message "$?"
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This might need to set on OS level not here because it might required restart (pending write to os_initialize.sh)
configure_fstab() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local is_encrypted disk_uuid_boot has_home_partition can_switch_jquota quotaoff_bin quotacheck_bin quotaon_bin
    required "debian@@apt:quota" "ubuntu@@apt:quota"
    quotaoff_bin="$(command -v quotaoff)"
    quotacheck_bin="$(command -v quotacheck)"
    quotaon_bin="$(command -v quotaon)"

    _echo "$(msg cyan)Turning off system quota ...$(msg end)" --name
    ${quotaoff_bin} -a
    echo ""
    _echo "$(msg cyan)Checking if quota supports journaled  quota ...$(msg end)" --name
    can_switch_jquota="$(${quotacheck_bin} -avugm &> >(grep -w 'Consider switching to journaled quota'))"

    has_home_partition=$(lsblk --output MOUNTPOINT | grep -w '/home')
    # if C_DISK_ENCRYPTION is set, we must have this value crypt
    is_encrypted=$(lsblk | grep 'crypt')
    if [ -n "${is_encrypted}" ]; then
      _echo "$(msg cyan)Found disk encryption is set: ${is_encrypted}. Writing new fstab contents at /etc/fstab ...$(msg end)" --name
      # Boot must always be sda 1  (beginning of the drive)
      disk_uuid_boot=$(blkid -o value -s UUID "/dev/sda1")
      {
        echo "# ==============================================="
        echo "# This configuration file was generated by ${SCRIPT_NAME}"
        echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
        echo "# ==============================================="
        echo "# /etc/fstab: static file system information."
        echo "#"
        echo "# Use 'blkid' to print the universally unique identifier for a"
        echo "# device; this may be used with UUID= as a more robust way to name devices"
        echo "# that works even if disks are added and removed. See fstab(5)."
        echo "#"
        echo "# <file system> <mount point>   <type>  <options>       <dump>  <pass>"
        # Boot mount option
        # If home partition exist, the quota should be specify in home else it should be specify in \
        printf "UUID=%s\t/boot\text4\tdefaults\t0\t2\n" "${disk_uuid_boot}"
        # Set quota based on this quide: https://help.directadmin.com/item.php?id=42
        if [ -n "${has_home_partition}" ]; then
          # only enable quota on home partition if detected home partition
          printf "/dev/mapper/%s-root\t/\text4\terrors=remount-ro,x-systemd.device-timeout=0\t0\t1\n" "${C_LVM_GROUP_NAME}"
          if [ -n "${can_switch_jquota}" ]; then
            # Use journaled quota
            printf "/dev/mapper/%s-home\t/home\text4\tnosuid,usrjquota=aquota.user,grpjquota=aquota.group,jqfmt=vfsv0,x-systemd.device-timeout=0\t0\t2\n" "${C_LVM_GROUP_NAME}"
          else
            # Use normal quota
            printf "/dev/mapper/%s-home\t/home\text4\tnosuid,usrquota,grpquota,x-systemd.device-timeout=0\t0\t2\n" "${C_LVM_GROUP_NAME}"
          fi
        else
          # Only enable quota on root partition if /home does not exist

          if [ -n "${can_switch_jquota}" ]; then
            # Use journaled quota
            printf "/dev/mapper/%s-root\t/\text4\terrors=remount-ro,usrjquota=aquota.user,grpjquota=aquota.group,jqfmt=vfsv0,x-systemd.device-timeout=0\t0\t1\n" "${C_LVM_GROUP_NAME}"

          else
            # Use normal quota
            printf "/dev/mapper/%s-root\t/\text4\terrors=remount-ro,usrquota,grpquota,x-systemd.device-timeout=0\t0\t1\n" "${C_LVM_GROUP_NAME}"
          fi

        fi

        printf "/dev/mapper/%s-tmp\t/tmp\text4\tnodev,nosuid,noexec,x-systemd.device-timeout=0\t0\t2\n" "${C_LVM_GROUP_NAME}"
        printf "/dev/mapper/%s-swap\tnone\tswap\tsw,x-systemd.device-timeout=0\t0\t0\n" "${C_LVM_GROUP_NAME}"
      } >/etc/fstab
      echo ""
      _echo "$(msg cyan)Turning on system quota ...$(msg end)" --name

      # Turn back quota
      ${quotaon_bin} -a
    else
      _echo "$(msg yellow)[Skipped]: Warning, no disk partition encryption is found$(msg end)" --name
      # TODO: add the same fstab configuration above but for non-encrypted volume
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Tweaking swap for production
configure_kernel_swap() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    _echo "$(msg cyan)Writing disk swap information in /etc/sysctl.conf ...$(msg end)" --name
    # Swap configuration
    {
      echo "vm.swappiness = 10"
      echo "vm.vfs_cache_pressure = 50"
    } >>/etc/sysctl.conf
    echo ""
    _echo "$(msg cyan)Compiling sysctl config /etc/sysctl.conf ...$(msg end)" --name
    sysctl -p /etc/sysctl.conf
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi

}

configure_kernel_filesystem() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    _echo "$(msg cyan)Writing kernel and file system information in /etc/sysctl.conf ...$(msg end)" --name
    {
      # Disable core dumps
      # This code will ensure not to make any core dumps by setuid programs in future.
      echo "fs.suid_dumpable = 0"
      # Disable System Request debugging functionality
      echo "kernel.sysrq = 0"
      # Hide kernel pointers
      echo "kernel.kptr_restrict = 2"
    } >>/etc/sysctl.conf
    echo ""
    _echo "$(msg cyan)Compiling sysctl config /etc/sysctl.conf ...$(msg end)" --name
    sysctl -p /etc/sysctl.conf
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_kernel_ips() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    _echo "$(msg cyan)Writing ipv4 and ipv6 information in /etc/sysctl.conf ..." --name
    {
      echo "# IPV4 & IPv6 configuration"
      echo "# IPV6"
      echo "net.ipv6.conf.all.disable_ipv6 = 0"
      echo "net.ipv6.conf.default.disable_ipv6 = 0"
      echo "#net.ipv6.conf.lo.disable_ipv6 = 0"
      echo "#net.ipv6.bindv6only = 1"
      echo "net.ipv6.conf.default.accept_redirects = 0"
      echo "net.ipv6.conf.all.accept_redirects = 0"
      # This net.ipv6.ip_nonlocal_bind fixed the issue with nginx could not started because it could not listen to newly added IPv6
      # nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
      # nginx[32309]: nginx: [emerg] bind() to [IPV6]:80 failed (99: Cannot assign requested address)
      # nginx[32309]: nginx: configuration file /etc/nginx/nginx.conf test failed
      # nginx[32309]: t:none,t:urlDecode
      # systemd[1]: nginx.service: Control process exited, code=exited, status=1/FAILURE
      # nginx.service: Failed with result 'exit-code'.
      # systemd[1]: Failed to start The nginx HTTP and reverse proxy server.
      echo "net.ipv6.ip_nonlocal_bind = 1"
      # Disable IPv6 DAD in kernel
      echo "net.ipv6.conf.${C_NIC_INTERFACE_NAME}.dad_transmits = 0"
      echo "#IPV4"
      echo "net.ipv4.conf.all.accept_redirects = 0"
      echo "net.ipv4.conf.all.log_martians = 1"
      echo "net.ipv4.conf.all.send_redirects = 0"
      echo "net.ipv4.conf.default.accept_redirects = 0"
      echo "net.ipv4.conf.default.log_martians = 1"
      echo "#net.ipv6.tcp_timestamps = 0"

      echo "#Enable TCP SYN cookie protection"
      echo "net.ipv4.tcp_syncookies = 1"

      echo "#Turn off the tcp_sack"
      echo "#net.ipv4.tcp_sack = 0"

      echo "#Turn off the tcp_window_scaling"
      echo "#net.ipv4.tcp_window_scaling = 0"

      echo "### Enable this when DDOS attack occur ###"
      echo "# Decrease the time default value for tcp_fin_timeout connection"
      echo "#net.ipv4.tcp_fin_timeout = 3"

      echo "net.ipv4.ip_nonlocal_bind = 1"

    } >>/etc/sysctl.conf
    echo ""
    _echo "$(msg cyan)Compiling sysctl config /etc/sysctl.conf ...$(msg end)" --name
    sysctl -p /etc/sysctl.conf
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

## Start Directadmin related function ###
# This function allows Directadmin to restart quickly but we don't take it as high priority because we need to finish directadmin pending tasks.
# Better to restart DA with task.queue (this is what most documentation do) because DA needs to respect task.queue process
# Without using task.queue, we can restart directadmin using systemctl restart directadmin
restart_da() {
  local wait_count max_wait wait_duration task_queue_file
  # Directadmin recommends 60 seconds (or 1 minute). Longer than this something wrong with the task.queue
  wait_count=0
  max_wait=70
  wait_duration=1
  task_queue_file="/usr/local/directadmin/data/task.queue"
  while :; do
    ((wait_count = wait_count + 1))
    sleep ${wait_duration}
    if [[ -s "${task_queue_file}" && -f "${task_queue_file}" ]]; then
      _echo "$(msg cyan)Waiting for pending task(s) to finish executed. Maximum wait of ${wait_count}/${max_wait} seconds ...$(msg end)" --start-spin --name
      if [ "${wait_count}" -gt ${max_wait} ]; then
        # Force restart if waiting time is longer than max_wait. The maximum task.queue execution time is only 1 minute based on directadmin documentation
        # Another condition that can be force to restart is, if the task.queue contains more than 2 lines, it means it is not running. So we can force restart it.
        # https://docs.directadmin.com/directadmin/general-usage/task-queue-processor/
        _echo "$(msg yellow)Warning, task.queue has not finished executing task(s) for more than ${max_wait} seconds. Forcing directadmin to restart ...$(msg end)" --stop-spin --name
        echo "action=directadmin&value=restart" >>/usr/local/directadmin/data/task.queue
        /usr/local/directadmin/dataskq d2000 >/dev/null
        break
      fi
    else
      _echo "$(msg cyan)Restarting Directadmin using task.queue mode ...$(msg end)" --stop-spin --name
      # Writing restart query in task.queue to restart directadmin in queue mode
      echo "action=directadmin&value=restart" >>/usr/local/directadmin/data/task.queue
      # Force restart with debugging level d2000
      # this option force reboot if we still have pending tasks. This is optional because at this condition we know there must be no other pending tasks.
      /usr/local/directadmin/dataskq d2000 >/dev/null
      break
    fi
  done

}
# This function will get the current directadmin original / owner username
# Only execute this after directadmin has successfully installed (we know we got an admin account)
get_current_da_owner_username() {
  local admin_list da_admins da_admin current_da_owner_username
  admin_list="/usr/local/directadmin/data/admin/admin.list"
  readarray -t da_admins <"${admin_list}"
  for da_admin in "${da_admins[@]}"; do
    # There must be 1 creator in directadmin, so this one must always have value
    current_da_owner_username=$(grep -rl "^creator=root" "/usr/local/directadmin/data/users/${da_admin}/user.conf" | cut -d'/' -f7 | tail -n 1)
    if [ -n "${current_da_owner_username}" ]; then
      echo "${current_da_owner_username}"
      break
    fi
  done
  unset da_admins
  # It might be impossible that this will return empty, so just in case we add the condition
  if [ -z "${current_da_owner_username}" ]; then
    _echo "$(msg yellow)Error, there is no admin created by root exist in directadmin user data! Please make sure it exist!$(msg end)" --name
    _exit 147
  fi
}

# This function is used to setup options.conf or do something before executing directadmin installation
install_da_pre() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_latest_version da_sql_type da_sql_version da_php_mode_v1 da_php_mode_v2 da_php_mode_v3 da_php_mode_v4 count db_custom_version_txt

    db_custom_version_txt="/usr/local/directadmin/custombuild/custom_versions.txt"
    # da_latest_version=$(curl -s https://www.directadmin.com/version.php | grep -Eo "[0-9]+\.[0-9]+")
    da_latest_version=$(dig +short -t txt current-version.directadmin.com | sed 's|.*v=\([0-9.]*\).*|\1|')
    mkdir -p "/usr/local/directadmin/custombuild"
    touch "${db_custom_version_txt}"
    _echo "$(msg cyan)The latest version of Directadmin is ${da_latest_version}$(msg end)" --name
    _pause 5
    _echo "$(msg cyan)Configuring directadmin custombuild version ...$(msg end)" --name
    echo "${C_DA_CB_VERSION}" >/root/.custombuild
    echo ""
    _echo "$(msg cyan)Writing email ${LABEL_C_ROOT_EMAIL} into /root/.email.txt to override system email ...$(msg end)" --name
    #Root email will use this one
    echo "${C_ROOT_EMAIL}" >/root/.email.txt
    echo ""
    #Forward all email to admin (webmaster)
    _echo "$(msg cyan)Writing email ${LABEL_C_ADMIN_EMAIL} into /root/.forward to override directadmin admin email ...$(msg end)" --name
    echo "${C_ADMIN_EMAIL}" >/root/.forward
    echo ""
    # This will make sure preinstall command is going to be executed when starting DA installation
    _echo "$(msg cyan)Configuring directadmin to to run pre-install command ...$(msg end)" --name
    echo 1 >/root/.preinstall

    # Here I can set options.conf and php_extensions.conf to custom install.
    mkdir -p /usr/local/directadmin/custombuild
    if [ "${C_DA_INSTALL_TYPE}" == "custom" ]; then
      _echo "$(msg cyan)Directadmin installation type is set to custom. The installation will use previous custom config options.conf and php_extensions.conf without questions$(msg end)" --name
      if [ "${DISTRO_ID}" == "centos" ]; then
        :
      elif [ "${DISTRO_ID}" == "debian" ]; then
        # This one needed if clamav is included
        # https://forum.directadmin.com/threads/configure-error-libcurl-not-found-libcurl-e-g-libcurl-devel-is-required-in-order-to-build-freshclam-and-clamsubmit.62869/
        # No need to install libcurl now, it's working without installing libcurl. I have updated the post.
        # We do not need any curl versions because directadmin will install it, if we dont remove this we will have curl conflict with the following error:
        # curl: /usr/local/lib/libcurl.so.4: no version information available (required by curl)
        # apt-get -y remove curl # dont remove yet, we use system curl instead of the one from directadmin
        # echo "[${SCRIPT_NAME}]: Installing Debian libcurl ..."
        # sudo apt-get -y install libcurl4-openssl-dev
        :
      else
        _echo "$(msg red)Error, unknown value for distribution ID ${DISTRO_ID}. The distribution ID is not supported!$(msg end)" --name
        _exit 147
      fi
      _echo "$(msg cyan)Writing new custombuild custom options.conf into /usr/local/directadmin/custombuild/options.conf (as a placeholder) ...$(msg end)" --name

      {
        echo "# Note on PHP setting: At this moment if using php2 as 8.0 and php1 as 7.4 fixed roundcube issue."
        echo "# Should not use php 8.0 as main it contains bug"
        echo "php1_release=7.4"
        echo "php1_mode=php-fpm"
        echo "php2_release=8.0"
        echo "php2_mode=php-fpm"
        echo "php3_release=no"
        echo "php3_mode=php-fpm"
        echo "php4_release=no"
        echo "php4_mode=php-fpm"
        echo "secure_php=yes"
        echo "php_ini=yes"
        echo "php_timezone=Asia/Kuala_Lumpur"
        echo "php_ini_type=production"
        echo "x_mail_header=yes"
        echo ""
        echo "#MySQL Settings"
        echo "mysql=5.7"
        echo "mariadb=10.6"
        echo "mysql_inst=mariadb"
        echo "mysql_backup=yes"
        echo "mysql_backup_gzip=yes"
        echo "mysql_backup_dir=/usr/local/directadmin/custombuild/mysql_backups"
        echo "mysql_force_compile=no"
        echo ""
        echo "#WEB Server Settings"
        echo "unit=no"
        echo "webserver=nginx_apache"
        echo "http_methods=ALL"
        echo "litespeed_serialno=trial"
        echo "modsecurity=no"
        echo "modsecurity_ruleset=owasp"
        echo "apache_ver=2.4"
        echo "apache_mpm=auto"
        echo "mod_ruid2=no"
        echo "# This is a security feature, disable user directory access"
        echo "userdir_access=no"
        echo "# This is a security feature to disable FollowSymLinks and replace with SymLinksIfOwnerMatch"
        echo "harden_symlinks_patch=yes"
        echo "# Set is to redirect everyone to hostname. We set to no, and enable later in script"
        echo "use_hostname_for_alias=no"
        echo "# Place holder, change later in script"
        echo "redirect_host=\"host.domain.com\""
        echo "# This is to redirect hostname automatically to https. We set to no, and enable later in script"
        echo "redirect_host_https=no"
        echo ""
        echo "#WEB Applications Settings"
        echo "phpmyadmin=yes"
        echo "phpmyadmin_public=yes"
        echo "phpmyadmin_ver=5"
        echo "squirrelmail=no"
        echo "roundcube=yes"
        echo "webapps_inbox_prefix=no"
        echo "#ClamAV-related Settings"
        echo "clamav=no"
        echo "clamav_exim=yes"
        echo "modsecurity_uploadscan=no"
        echo "proftpd_uploadscan=no"
        echo "pureftpd_uploadscan=no"
        echo "suhosin_php_uploadscan=no"
        echo ""
        echo "#Mail Settings"
        echo "exim=yes"
        echo "eximconf=yes"
        echo "eximconf_release=4.5"
        echo "blockcracking=yes"
        echo "easy_spam_fighter=yes"
        echo "spamd=rspamd"
        echo "sa_update=daily"
        echo "dovecot=yes"
        echo "dovecot_conf=yes"
        echo "mail_compress=yes"
        echo "pigeonhole=yes"
        echo ""
        echo "#FTP Settings"
        echo "ftpd=pureftpd"
        echo ""
        echo "# Statistics Settings"
        echo "# We do not need this enabled (speed up server)"
        echo "awstats=no"
        echo "webalizer=no"
        echo ""
        echo "#CustomBuild Settings"
        echo "custombuild=2.0"
        echo "custombuild_plugin=yes"
        echo "autover=yes"
        echo "bold=yes"
        echo "clean=yes"
        echo "cleanapache=yes"
        echo "clean_old_tarballs=yes"
        echo "clean_old_webapps=yes"
        echo "downloadserver=files.directadmin.com"
        echo "unofficial_mirrors=no"
        echo ""
        echo "#Cronjob Settings"
        echo "cron=no"
        echo "cron_frequency=daily"
        echo "email=webmaster@sofibox.com"
        echo "notifications=yes"
        echo "# Do not auto update directadmin"
        echo "da_autoupdate=no"
        echo "updates=no"
        echo "webapps_updates=yes"
        echo ""
        echo "#CloudLinux Settings"
        echo "cloudlinux=no"
        echo "cloudlinux_beta=no"
        echo "cagefs=no"
        echo ""
        echo "#Advanced Settings"
        echo "# This option is used to install curl by directadmin. We will install curl by system first"
        echo "curl=no"
        echo "ssl_configuration=intermediate"
        echo ""
        echo "#PHP extensions can be found in php_extensions.conf"
      } >"/usr/local/directadmin/custombuild/options.conf"

      # _echo "$(msg cyan)Copying the latest custombuild custom options.conf into /usr/local/directadmin/custombuild/options.conf ...$(msg end)" --name
      #cp "${LATEST_OS_CODE_PATH}/usr/local/directadmin/custombuild/options.conf" "/usr/local/directadmin/custombuild/options.conf"
      echo ""

      _echo "$(msg cyan)Changing the value redirect_host= into redirect_host=${LABEL_C_BOX_HOSTNAME_FQHN} from options.conf ...$(msg end)" --name
      sed -i "s|^redirect_host=.*|redirect_host=${C_BOX_HOSTNAME_FQHN}|" /usr/local/directadmin/custombuild/options.conf
      echo ""
      _echo "$(msg cyan)Changing the value email= into email=${LABEL_C_ADMIN_EMAIL} from options.conf ...$(msg end)" --name
      sed -i "s|^email=.*|email=${C_ADMIN_EMAIL}|" /usr/local/directadmin/custombuild/options.conf
      echo ""
      _echo "$(msg cyan)Changing the value php_timezone= into php_timezone=${LABEL_C_BOX_TIMEZONE} from options.conf ...$(msg end)" --name
      sed -i "s|^php_timezone=.*|php_timezone=${C_BOX_TIMEZONE}|" /usr/local/directadmin/custombuild/options.conf
      echo ""
      # This will change the sql info in options.conf based on the value from config file C_DA_CB_SQL_VERSION

      _echo "$(msg cyan)Configuring SQL databases ...$(msg end)" --name
      da_sql_type=$(echo "${C_DA_CB_SQL_VERSION}" | awk -F'-' '{ print $1 }')
      da_sql_version=$(echo "${C_DA_CB_SQL_VERSION}" | awk -F'-' '{ print $2 }')
      _echo "$(msg cyan)Changing mysql type to ${da_sql_type} ...$(msg end)" --name
      sed -i "s|^mysql_inst=.*|mysql_inst=${da_sql_type}|" /usr/local/directadmin/custombuild/options.conf
      _echo "$(msg cyan)Changing mysql version to ${da_sql_version} ...$(msg end)" --name
      sed -i "s|^${da_sql_type}=.*|${da_sql_type}=${da_sql_version}|" /usr/local/directadmin/custombuild/options.conf
      echo ""

      # This will setup PHP version
      _echo "$(msg cyan)Configuring PHP multiple versions ...$(msg end)" --name
      da_php_mode_v1="$(echo "${C_DA_CB_PHP_VERSION}" | awk -F',' '{ print $1 }')"
      da_php_mode_v2="$(echo "${C_DA_CB_PHP_VERSION}" | awk -F',' '{ print $2 }')"
      da_php_mode_v3="$(echo "${C_DA_CB_PHP_VERSION}" | awk -F',' '{ print $3 }')"
      da_php_mode_v4="$(echo "${C_DA_CB_PHP_VERSION}" | awk -F',' '{ print $4 }')"

      count=1
      for php_mode_v in ${da_php_mode_v1} ${da_php_mode_v2} ${da_php_mode_v3} ${da_php_mode_v4}; do
        local php_version php_mode
        php_version=$(echo "${php_mode_v}" | awk -F':' '{ print $1}')
        php_mode=$(echo "${php_mode_v}" | awk -F':' '{ print $2}')

        # Use default value of php_version if empty
        if [ -z "${php_version}" ]; then
          php_version="no"
        fi

        # Use default value of php_mode if empty
        if [ -z "${php_mode}" ]; then
          php_mode="php-fpm"
        fi

        #echo "PHP version is ${php_version}"
        #echo "PHP mod is ${php_mode}"
        echo "Changing php${count}_release to ${php_version} ..."
        sed -i "s|^php${count}_release=.*|php${count}_release=${php_version}|" /usr/local/directadmin/custombuild/options.conf
        echo ""
        echo "Changing php${count}_mod to ${php_mode} ..."
        sed -i "s|^php${count}_mod=.*|php${count}_mod=${php_mode}|" /usr/local/directadmin/custombuild/options.conf
        echo ""
        ((count++))
      done
      _echo "$(msg cyan)Changing modsecurity enabled option to ${C_DA_CB_INSTALL_MODSECURITY} ...$(msg end)" --name
      sed -i "s|^modsecurity=.*|modsecurity=${C_DA_CB_INSTALL_MODSECURITY}|" /usr/local/directadmin/custombuild/options.conf
      echo ""

      _echo "$(msg cyan)Changing modsecurity ruleset option to ${C_DA_CB_MODSECURITY_RULESET} ...$(msg end)" --name
      sed -i "s|^modsecurity_ruleset=.*|modsecurity_ruleset=${C_DA_CB_MODSECURITY_RULESET}|" /usr/local/directadmin/custombuild/options.conf
      echo ""

      _echo "$(msg cyan)Changing clamav enabled option to ${C_DA_CB_INSTALL_CLAMAV} ...$(msg end)" --name
      sed -i "s|^clamav=.*|clamav=${C_DA_CB_INSTALL_CLAMAV}|" /usr/local/directadmin/custombuild/options.conf
      echo ""

      _echo "$(msg cyan)Creating new custombuild custom php_extensions.conf into /usr/local/directadmin/custombuild/php_extensions.conf ...$(msg end)" --name
      {
        echo "#PHP Extension Settings"
        echo "bz2=no"
        echo "gmp=no"
        echo "htscanner=yes"
        echo "imagick=yes"
        echo "imap=yes"
        echo "ioncube=no"
        echo "ldap=no"
        echo "opcache=yes"
        echo "phalcon=no"
        echo "redis=no"
        echo "snuffleupagus=no"
        echo "suhosin=no"
        echo "xmlrpc=no"
        echo "zend=no"
      } >"/usr/local/directadmin/custombuild/php_extensions.conf"

      #_echo "$(msg cyan)Copying the latest custombuild custom php_extensions.conf into /usr/local/directadmin/custombuild/php_extensions.conf ...$(msg end)" --name
      #cp "${LATEST_OS_CODE_PATH}/usr/local/directadmin/custombuild/php_extensions.conf" /usr/local/directadmin/custombuild/php_extensions.conf
      echo ""
      ###### Below are some fixes
      if [ "${C_DA_CB_CLAMAV_VERSION}" != "latest" ]; then
        _echo "$(msg cyan)Configuring clamav to use version ${C_DA_CB_CLAMAV_VERSION} before installation ...$(msg end)" --name
        echo "clamav:${C_DA_CB_CLAMAV_VERSION}:" >>"${db_custom_version_txt}"
        get_status_message "$?"
        echo ""
      fi

      if [ "${C_DA_ENABLE_PRE_INSTALL_TEMP_FIX}" == "true" ]; then
        _echo "$(msg cyan)Applying fixes for known issue ...$(msg end)" --name
        if [ "${DISTRO_ID}" == "debian" ]; then
          _echo "$(msg cyan)Installing required package for clamav ...$(msg end)" --name
          apt-get -y install libbz2-dev
          # https://forum.directadmin.com/threads/clamav-0-104-0-nginx-1-21-3.64522/post-335560
        fi
        echo ""
      fi

    elif
      [[ "${C_DA_INSTALL_TYPE}" == "ori" || "${C_DA_INSTALL_TYPE}" == "original" ]]
    then
      _echo "$(msg cyan)Directadmin installation type C_DA_INSTALL_TYPE is set to ori or original. This will make the installation of directadmin using its default options might have few questions$(msg end)" --name
      C_DA_INSTALL_TYPE="original"
    elif [[ "${C_DA_INSTALL_TYPE}" == "int" || "${C_DA_INSTALL_TYPE}" == "interactive" ]]; then
      _echo "$(msg cyan)Directadmin installation type C_DA_INSTALL_TYPE is set to int or interactive. This will make the installation of directadmin using more questions$(msg end)" --name
      C_DA_INSTALL_TYPE="interactive"
    elif [[ "${C_DA_INSTALL_TYPE}" == "auto" || "${C_DA_INSTALL_TYPE}" == "automatic" ]]; then
      _echo "$(msg cyan)Directadmin installation type C_DA_INSTALL_TYPE is set to auto or automatic. This will make the installation of directadmin using its common default components including CSF without any questions$(msg end)" --name
      C_DA_INSTALL_TYPE="automatic"
    else
      _echo "$(msg red)Error, invalid installation type C_DA_INSTALL_TYPE set for directadmin in config file.$(msg end)" --name
      _exit 147
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# After executing this function, to enter into directadmin temporarily do the following:
# Disable firewall
# Clear cache browser, login using setup.txt
# Note DA custom installation right now has duration of 01 H:21 M :26 S
install_da() {
  # After da is installed, we still need to open the port for default firewall. To achieve this, we can run install_da_post() function
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_install_log da_bin da_cb_bin da_conf da_script_path retval
    da_install_log="${LOG_PATH}/da-install.log"
    da_script_path="/usr/local/directadmin/scripts"
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    touch "${da_install_log}"
    _echo "$(msg cyan)Downloading directadmin setup script ...$(msg end)" --name
    navigate_path "${INST_TEMP_DIR}"
    wget -O setup.sh http://www.directadmin.com/setup.sh
    echo ""
    _echo "$(msg cyan)Setting execution permission for setup.sh ...$(msg end)" --name
    chmod 755 setup.sh
    echo ""
    # da_latest_version=$(curl -s https://www.directadmin.com/version.php | grep -Eo "[0-9]+\.[0-9]+")
    da_latest_version=$(dig +short -t txt current-version.directadmin.com | sed 's|.*v=\([0-9.]*\).*|\1|')
    _echo "$(msg magenta)=======================================================================$(msg end)" --plain
    _echo "$(msg yellow)Setup will install Directadmin ${da_latest_version} within 30 seconds. $(msg end)" --name
    _echo "$(msg yellow)This would take a long time depending on the package selection or directadmin installation type, so please be patient$(msg end)" --name
    _echo "$(msg yellow)If you don't want to install Directadmin now, press (CTRL+C) to exit$(msg end)" --name
    _echo "$(msg yellow)Remember that you can always re-run this script to resume or restart installation (even it is halt due to error)$(msg end)" --name
    _echo "$(msg yellow)In order to view full directadmin installation log in realtime, execute this command in another local terminal: $(msg end)" --name
    echo ""
    _echo "$(msg yellow)${SCRIPT_NAME} login and then, tail -f ${da_install_log}$(msg end)" --plain
    _echo "$(msg magenta)=======================================================================$(msg end)" --plain
    _pause 30
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    echo ""
    _echo "$(msg cyan)Note: Directadmin ${da_latest_version} will be installed on ${LABEL_C_BOX_HOSTNAME_FQHN} using ${C_DA_INSTALL_TYPE} mode$(msg end)"
    echo ""
    if [[ "${C_DA_INSTALL_TYPE}" == "custom" || "${C_DA_INSTALL_TYPE}" == "original" ]]; then
      # If provided options.conf, it means we use custom else we use original
      (
        ./setup.sh "${C_DA_CLIENT_ID}" "${C_DA_LICENSE_ID}" "${C_BOX_HOSTNAME_FQHN}" "${C_NIC_INTERFACE_NAME}" "${C_IPV4_ADD0}" &>"${da_install_log}"
        exit $?
      ) &
      my_pid=$!
    elif [[ "${C_DA_INSTALL_TYPE}" == "interactive" ]]; then
      # This will ask questions (so do not put in background)
      bash <(curl -Ss https://www.directadmin.com/setup.sh) | tee -a "${da_install_log}"
      retval=$?
      echo ""
      _echo "Installation return code is ${retval}" --verbose 7
    elif [[ "${C_DA_INSTALL_TYPE}" == "automatic" || "${C_DA_INSTALL_TYPE}" == "auto" ]]; then
      # This will not ask question and everything will be installed as default including CSF
      (
        bash <(curl -Ss https://www.directadmin.com/setup.sh) auto &>"${da_install_log}"
        exit $?
      ) &
      my_pid=$!
    fi

    if [ -n "${my_pid}" ]; then
      _echo "$(msg cyan)Installing directadmin ${da_latest_version} [ PID ID: ${my_pid} ] for the $(get_ordinal ${INSTALL_COUNT}) time(s) ... $(msg end)" --name
      echo ""
      while ps | grep -q " $my_pid "; do
        local progress_text memory_usage_percentage
        ((count++))
        memory_usage_percentage="$(free -m | grep Mem | awk '{printf("%.2f" ,($3/$2)*100)}')"
        progress_text="$(tail -n 1 ${da_install_log})"
        _echo "$(msg yellow)Memory: ${memory_usage_percentage}% | Elapsed time: $(show_time "${count}") | ${progress_text:0:47} ... $(msg end)" --start-spin --progress-style=".oO@*"
        sleep 1
      done
      wait $my_pid
      retval=$?
    fi
    echo ""
    _echo "Installation return code is ${retval}" --verbose 7

    ((INSTALL_COUNT++))
    if [[ "${retval}" -ne 0 ]]; then
      local error_msg total_error_line
      # How many line of errors to show:
      total_error_line=20
      _echo "$(msg red)Error, directadmin installation contains error. Please inspect the last ${total_error_line} lines of the installation log below:$(msg end)" --name
      error_msg=$(tail -n ${total_error_line} "${da_install_log}")
      echo ""
      echo "============================================"
      echo ""
      _echo "$(msg red)${error_msg}$(msg end)" --plain
      echo ""
      echo "============================================"
      # _echo "$(msg yellow)Please fix the error and re-run this setup again to restart the installation$(msg end)" --name
      # _exit 147
      _echo "$(msg yellow)Performing backup log file from ${da_install_log} as ${da_install_log}.${DATE_TIME_NOW} ...$(msg end)" --name
      cp -f "${da_install_log}" "${da_install_log}.${DATE_TIME_NOW}"
      sleep 10
      echo ""

      if [ "${C_DA_ENABLE_PRE_INSTALL_TEMP_FIX}" == "true" ]; then
        _echo "$(msg yellow)Re-executing install_da_pre ...$(msg end)" --name
        install_da_pre --run-force
        echo ""
      fi
      _echo "$(msg yellow)Reinstalling directadmin within 10 seconds for the $(get_ordinal ${INSTALL_COUNT})...$(msg end)" --name
      install_da --run
      echo ""
    else
      local install_complete_line port
      _echo "$(msg cyan)Checking if directadmin binary, custombuild and directadmin.conf are presents ...$(msg end)" --name
      check_path "${da_bin}" "${da_cb_bin}" "${da_conf}"
      echo ""
      port="$(cat /usr/local/directadmin/conf/directadmin.conf | grep '^port=' | cut -d= -f2)"
      # Here I can display the current login information (only interested on this information) the other directadmin installation output are useless.
      install_complete_line=$(grep '^## INSTALL_COMPLETE' "${da_install_log}")
      if [[ -n "${install_complete_line}" ]]; then
        echo ""
        _echo "$(msg green)${install_complete_line}$(msg end)" --plain
        _echo "$(msg red) ================================== $(msg end)" --plain
        if [ "${C_HIDE_SENSITIVE_TEXT}" == "true" ]; then
          echo "*** LOGIN INFORMATION IS HIDDEN BECAUSE C_HIDE_SENSITIVE_TEXT=true ***"
        else
          grep "^Admin username:   " "${da_install_log}"
          grep "^Admin password:   " "${da_install_log}"
          grep "^Admin email:   " "${da_install_log}"
          echo "URL:    http://${C_BOX_HOSTNAME_FQHN}:${port}"
        fi
        echo "If the above information is hidden. You can always view this from:"
        echo "cat /usr/local/directadmin/scripts/setup.txt"
        _echo "$(msg red) ================================== $(msg end)" --plain
        echo ""
      else
        _echo "$(msg yellow)Warning, directadmin installation returned success but could not found the install complete line [ ## INSTALL_COMPLETE ] in log file!$(msg end)" --name
        _pause 300
      fi
    fi

    echo ""
    _echo "$(msg cyan)Rewriting virtual host files ... $(msg end)" --name
    ${da_cb_bin} rewrite_confs
    echo ""
    _echo "$(msg cyan)Checking directadmin file path ... $(msg end)" --name
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}"
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi

}
# This post rebuild some da packages to fix issues
install_da_post() {
  # Here I can rebuild any missing or change package in DA
  # This to rebuild DA package that cause error like nginx_apache wont start for new install (bug)
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_conf da_sql_type da_sql_version da_install_log da_bin da_cb_bin da_script_path
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_script_path="/usr/local/directadmin/scripts"
    da_install_log="${LOG_PATH}/da-install.log"
    touch "${da_install_log}"

    _echo "$(msg cyan)Checking directadmin path ... $(msg end)" --name
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}" "${da_script_path}"

    echo ""

    # Rebuilding DA packages to fix some issues .
    #_echo "$(msg cyan)Updating directadmin custombuild to the new version...$(msg end)" --name
    #${da_cb_bin} update
    #echo ""

    # ClamAV and exim rebuild
    #_echo "$(msg cyan)Configuring directadmin custombuild to install ClamAV, rspamd, exim and enabling DKIM ...$(msg end)" --name

    # Antivirus
    #${da_cb_bin} set clamav yes
    #${da_cb_bin} set clamav_exim yes

    # Rspamd
    #${da_cb_bin} set blockcracking yes
    #${da_cb_bin} set easy_spam_fighter yes
    #${da_cb_bin} set spamd rspamd

    # Exim
    #${da_cb_bin} set exim yes
    #${da_cb_bin} set eximconf yes
    #${da_cb_bin} set eximconf_release "${C_DA_CB_EXIMCONF_RELEASE}"

    # Dkim
    # Enable DKIM for all domain (need to rebuild exim and exim_conf as stated somewhere)
    #${da_bin} set dkim "${C_DA_DKIM}"
    #echo ""
    #_echo "$(msg cyan)Rebuilding ClamAV, rspamd and exim ...$(msg end)" --name
    #{
    #  ${da_cb_bin} clamav
    #  ${da_cb_bin} rspamd
    #  ${da_cb_bin} exim
    #  ${da_cb_bin} exim_conf
    #} >>"${da_install_log}" 2> >(grep -v '.......... .......... .......... .......... ..........' 1>&2)
    # Mod security rebuild
    # _echo "$(msg cyan)Configuring custombuild to rebuild modsecurity with ruleset of ${LABEL_C_DA_CB_MODSECURITY_RULESET} ...$(msg end)" --name
    # ${da_cb_bin} set modsecurity yes
    # ${da_cb_bin} set modsecurity_ruleset "${C_DA_CB_MODSECURITY_RULESET}"
    #echo ""
    #_echo "$(msg cyan)Rebuilding modsecurity with ruleset of ${C_DA_CB_MODSECURITY_RULESET} ...$(msg end)" --name
    #{
    #  ${da_cb_bin} modsecurity
    #  ${da_cb_bin} modsecurity_rules
    #  ${da_cb_bin} rewrite_confs
    #} >>"${da_install_log}" 2> >(grep -v '.......... .......... .......... .......... ..........' 1>&2)
    #echo ""
    # If I install modsecurity, I need to rebuild nginx_apache because it cannot be started due to modsecurity directive issue. See this:
    # https://forum.directadmin.com/threads/nginx-and-apache-nginix-wont-start-due-to-mod_security.61427/
    # Web server setting rebuild
    #_echo "$(msg cyan)Configuring custombuild to rebuild ${C_DA_CB_WEBSERVER_SOFTWARE} web server ...$(msg end)" --name
    #${da_cb_bin} set webserver "${C_DA_CB_WEBSERVER_SOFTWARE}"
    #echo ""
    #_echo "$(msg cyan)Rebuilding ${C_DA_CB_WEBSERVER_SOFTWARE} web server ...$(msg end)" --name
    #{
    #  ${da_cb_bin} "${C_DA_CB_WEBSERVER_SOFTWARE}"
    #  ${da_cb_bin} rewrite_confs
    #} >>"${da_install_log}" 2> >(grep -v '.......... .......... .......... .......... ..........' 1>&2)
    #echo ""
    # No need to rebuild because first initial installation already did this (put this value in options.conf instead)
    # _echo "$(msg cyan)Configuring custombuild to rebuild ${da_sql_type} web server to version ${da_sql_version} ...$(msg end)" --name
    # da_sql_type=$(echo "${C_DA_CB_SQL_VERSION}" | awk -F'-' '{ print $1 }')
    # da_sql_version=$(echo "${C_DA_CB_SQL_VERSION}" | awk -F'-' '{ print $2 }')
    # _echo "$(msg magenta)SQL type is set to: ${da_sql_type} from config file$(msg end)" --name
    # _echo "$(msg magenta)SQL version is set to: ${da_sql_version} from config file$(msg end)" --name
    # ${da_cb_bin} set "${da_sql_type}" "${da_sql_version}"
    # ${da_cb_bin} set mysql_inst "${da_sql_type}"
    # ${da_cb_bin} set mysql_backup yes
    # echo ""
    #_echo "$(msg cyan)Rebuilding ${da_sql_type} web server to version ${da_sql_version} ...$(msg end)" --name
    #{
    #  ${da_cb_bin} "${da_sql_type}"
    #  ${da_cb_bin} rewrite_confs
    #} >>"${da_install_log}" 2> >(grep -v '.......... .......... .......... .......... ..........' 1>&2)
    #echo ""

    # DA port should be secure don't use 2222 unless you have reason.
    # At this point, we haven't allowed da port 2222 to be connected (blocked by firewall)
    # Below, we just enable the new da port in firewall and set the port to open later using da binary
    #echo ""
    #_echo "$(msg cyan)Changing directadmin login page redirection port from default port 2222 to port ${LABEL_C_DA_PORT}$(msg end)" --name
    #{
    #  echo "<?php"
    #  echo "header(\"Location: http://\".\$_SERVER['HTTP_HOST'].\":${C_DA_PORT}\");"
    #  echo "?>"
    #} >/var/www/html/redirect.php
    #echo ""

    if [ "${DISTRO_ID}" == "centos" ]; then
      if command -v firewall-cmd &>/dev/null; then
        _echo "$(msg cyan)Adding directadmin new port ${LABEL_C_DA_PORT}/tcp to firewalld ...$(msg end)" --name
        if [[ "${C_HIDE_SENSITIVE_TEXT}" == "true" ]]; then
          sudo firewall-cmd --quiet --permanent --zone=public --add-port="${C_DA_PORT}/tcp"
        else
          sudo firewall-cmd --permanent --zone=public --add-port="${C_DA_PORT}/tcp"
        fi
      fi
    elif [ "${DISTRO_ID}" == "debian" ]; then
      if command -v ufw &>/dev/null; then
        _echo "$(msg cyan)Adding directadmin new port ${LABEL_C_DA_PORT}/tcp to ufw ...$(msg end)" --name
        sudo ufw allow "${C_DA_PORT}/tcp"
      fi
    fi

    _echo "$(msg cyan)Changing directadmin login page redirection port from default port 2222 to port ${LABEL_C_DA_PORT}$(msg end)" --name
    {
      echo "<?php"
      echo "header(\"Location: http://\".\$_SERVER['HTTP_HOST'].\":${C_DA_PORT}\");"
      echo "?>"
    } >/var/www/html/redirect.php
    echo ""

    _echo "$(msg cyan)Setting directadmin port to ${LABEL_C_DA_PORT} ...$(msg end)" --name
    ${da_bin} set port "${C_DA_PORT}" restart
    echo ""

    _echo "$(msg cyan)Requesting directadmin to restart ...$(msg end)" --name
    restart_da
    echo ""

    echo ""
    # At this moment directadmin can be login using a new port ${LABEL_C_DA_PORT}"
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}
# This will change da related authentication.
# It also has more options to secure DA installation. Example maybe this one we can create 2 step authentication
configure_da_auth() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_scripts_path da_bin da_cb_bin retval
    da_scripts_path="/usr/local/directadmin/scripts"
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"

    _echo "$(msg cyan)Checking directadmin path ...$(msg end)" --name
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}" "${da_scripts_path}"
    echo ""

    # This one moved to configure_da_owner_accounts()
    # This will change Directadmin admin account:
    #_echo "$(msg cyan)Changing the first directadmin admin username from default $(get_current_da_owner_username) username to ${LABEL_C_DA_OWNER_USERNAME1} ...$(msg end)" --name
    #${da_scripts_path}/change_username.sh "$(get_current_da_owner_username)" "${C_DA_OWNER_USERNAME1}"
    #echo ""
    # By default, directadmin installation uses a short password which is not secured. Change it here
    #_echo "$(msg cyan)Changing the first admin (${LABEL_C_DA_OWNER_USERNAME1})'s password ...$(msg end)" --name
    # echo "${C_DA_OWNER_USERNAME1}:${C_DA_OWNER_USERPASS1}" | chpasswd
    #echo ""

    # TODO this add custom page for login (using recaptcha) to increase security
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_bind() {
  local run_mode extra_option func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  start_execute_options "${run_mode}" "${func_name}"
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local bind_named_conf grep_found

    if [ "${C_ENABLE_BIND}" == "true" ]; then
      if [ "${DISTRO_ID}" == "debian" ]; then
        bind_named_conf="/etc/bind/named.conf.options"
        if [[ ! -f "${bind_named_conf}" ]]; then
          # This bind option should exist
          _echo "$(msg yellow)Warning, file named.conf does not exist in ${bind_named_conf}! Installing bind9$(msg end)" --name
          apt-get -y install bind9
        fi

      else
        # Have not implemented for other distro
        _echo "$(msg yellow)Warning, please inspect the bind.conf location for this DISTRO ${DISTRO_ID}!$(msg end)" --name
        _exit 147
      fi

      # Make sure bind is enabled:
      if [ "${C_SERVER_TYPE}" == "directadmin" ]; then
        _echo -n "$(msg cyan)Enabling DNS service (named) in directadmin services.status ...$(msg end)" --name
        sed -i 's/named=OFF/named=ON/' /usr/local/directadmin/data/admin/services.status
        get_status_message "$?"
      fi

      _echo -n "$(msg cyan)Stopping DNS service (named) ...$(msg end)" --name
      service named start
      get_status_message "$?"
      _echo -n "$(msg cyan)Enabling DNS service (named) execution script in /etc/init.d/named ...$(msg end)" --name
      #cp -f /etc/init.d/named.original.backup /etc/init.d/named
      sed -i '/exit 0; #New line from/d' /etc/init.d/named
      get_status_message "$?"
      _echo -n "$(msg cyan)Enabling DNS service (named) from systemd startup  in /usr/lib/systemd/system/named.service ...$(msg end)" --name
      # Original: ExecStart=/usr/sbin/named -f $OPTIONS
      sed -i "s/ExecStart=.*/ExecStart=\/usr\/sbin\/named -f \$OPTIONS/" /usr/lib/systemd/system/named.service
      get_status_message "$?"
      _echo -n "$(msg cyan)Enabling DNS service (named) from systemd startup  in /etc/systemd/system/named.service...$(msg end)" --name
      # Original: ExecStart=/usr/sbin/named -f -u bind
      sed -i "s/ExecStart=.*/ExecStart=\/usr\/sbin\/named -f -u bind/" /etc/systemd/system/named.service
      get_status_message "$?"
      _echo -n "$(msg cyan)Reloading systemd startup ...$(msg end)" --name
      systemctl daemon-reload
      get_status_message "$?"
      echo ""

      # Configure bind here (if needed), based on the named.conf
      grep_found=$(grep -ic 'allow-query { localhost; };' "${bind_named_conf}")
      if [ "${grep_found}" = 0 ]; then
        _echo -n "$(msg cyan)Adding option allow-query into ${bind_named_conf}...$(msg end)" --name
        sed -i "s|\options {|&\n\tallow-query \{ localhost; }; #New line from ${SCRIPT_NAME}|" "${bind_named_conf}"
        get_status_message "$?"
      else
        _echo "$(msg yellow)[Skipped]: The allow-query value was previously set in ${bind_named_conf}$(msg end)" --name
      fi
      grep_found=$(grep -ic 'allow-recursion { localhost; };' "${bind_named_conf}")
      if [ "${grep_found}" = 0 ]; then
        _echo -n "$(msg cyan)Adding option allow-recursion into ${bind_named_conf}...$(msg end)" --name
        sed -i "s|\options {|&\n\tallow-recursion\{ localhost; }; #New line from ${SCRIPT_NAME}|" "${bind_named_conf}"
        get_status_message "$?"
      else
        _echo "$(msg yellow)[Skipped]: The allow-query value was previously set in ${bind_named_conf}$(msg end)" --name
      fi

      grep_found=$(grep -ic 'version "NA";' "${bind_named_conf}")
      if [ "${grep_found}" = 0 ]; then
        _echo -n "$(msg cyan)Adding option version N/A into ${bind_named_conf}...$(msg end)" --name
        sed -i "s|\options {|&\n\tversion \"NA\"; #New line from ${SCRIPT_NAME}|" "${bind_named_conf}"
        get_status_message "$?"
      else
        _echo "$(msg yellow)[Skipped]: The version value was previously set in ${bind_named_conf}$(msg end)" --name
      fi

      grep_found=$(grep -ic 'recursion yes;' "${bind_named_conf}")
      if [ "${grep_found}" = 0 ]; then
        _echo -n "$(msg cyan)Adding option recursion yes into ${bind_named_conf}...$(msg end)" --name
        sed -i "s|\options {|&\n\trecursion yes; #New line from ${SCRIPT_NAME}|" "${bind_named_conf}"
        get_status_message "$?"
      else
        _echo "$(msg yellow)[Skipped]: The version value was previously set in ${bind_named_conf}$(msg end)" --name
      fi
      echo ""
      # Enable DNSSEC if supported
      if [ "${C_ENABLE_DNSSEC}" == "true" ]; then
        if [[ "${DNS_PROVIDER}" == "linode" ]]; then
          # https://www.linode.com/docs/guides/dns-manager/#dnssec-limitations
          _echo "$(msg yellow)[Skipped]: Warning, the DNS provider ${DNS_PROVIDER} does not support DNSSEC$(msg end)" --name
        else
          _echo "$(msg cyan)Installing DNSSEC using directadmin script (dnssec.sh) ...$(msg end)" --name
          ${da_script_path}/dnssec.sh install
          echo ""
          _echo "$(msg cyan)Adding the some strings into the 'options { .... }' section at ${bind_named_conf} to enable DNSSEC ...$(msg end)" --name
          if [ -f "${bind_named_conf}" ]; then
            grep_found=$(grep -ic 'bindkeys-file \"\/etc\/bind\/named.iscdlv.key\";' "${bind_named_conf}")
            if [ "${grep_found}" = 0 ]; then
              sed -i "s|\options {|&\n\tbindkeys-file \"\/etc\/bind\/named.iscdlv.key\";|" "${bind_named_conf}"
            fi
            grep_found=$(grep -ic 'dnssec-lookaside auto;' "${bind_named_conf}")
            if [ "${grep_found}" = 0 ]; then
              sed -i "s|\options {|&\n\tdnssec-lookaside auto;|" "${bind_named_conf}"
            fi
            grep_found=$(grep -ic 'dnssec-enable yes;' "${bind_named_conf}")
            if [ "${grep_found}" = 0 ]; then
              sed -i "s|\options {|&\n\tdnssec-enable yes;|" "${bind_named_conf}"
            fi

            # This setting is only useful when DNSSEC is installed (by default it is disabled)
            _echo "$(msg cyan)Enabling TLSA DNS record in directadmin.conf ...$(msg end)" --name
            ${da_bin} set dns_tlsa 1
            echo ""
            _echo "$(msg cyan)Requesting directadmin to restart ...$(msg end)" --name
            restart_da
            echo ""
          else
            _echo "$(msg red)Error,the file ${bind_named_conf} does not exist! Make sure bind is installed first!$(msg end)" --name
            _exit 147
          fi
        fi
      else
        _echo "$(msg yellow)[Skipped]: The setting C_ENABLE_DNSSEC is not set to true. DNSSEC installation is skipped!$(msg end)" --name
      fi
    else
      _echo "$(msg cyan)Removing bind DNS service (named) in directadmin ...$(msg end)" --name
      echo ""
      # Guide: https://help.directadmin.com/item.php?id=25
      # Disable named or DNS service
      if [ "${C_SERVER_TYPE}" == "directadmin" ]; then
        _echo -n "$(msg cyan)Disabling DNS service (named) in directadmin services.status ...$(msg end)" --name
        sed -i 's/named=ON/named=OFF/' /usr/local/directadmin/data/admin/services.status
        get_status_message "$?"
      fi
      _echo -n "$(msg cyan)Stopping DNS service (named) ...$(msg end)" --name
      service named stop
      get_status_message "$?"

      grep_found=$(grep -ic 'exit 0; \#New line' /etc/init.d/named)
      if [ "${grep_found}" = 0 ]; then
        _echo -n "$(msg cyan)Halting DNS service (named) execution script in /etc/init.d/named ...$(msg end)" --name
        sed -i "s|\#\!\/bin\/sh -e|&\nexit 0; #New line from ${SCRIPT_NAME}|" /etc/init.d/named
        get_status_message "$?"
      else
        _echo -n "$(msg yellow)[Skipped]: Already halted DNS service (named) execution script in /etc/init.d/named ...$(msg end)" --name
      fi
      #cp -f /etc/init.d/named /etc/init.d/named.original.backup
      #{
      #  echo "#!/bin/bash"
      #  echo "exit 0;"
      #} >/etc/init.d/named
      _echo -n "$(msg cyan)Halting DNS service (named) from systemd startup  in /usr/lib/systemd/system/named.service ...$(msg end)" --name
      # Original: ExecStart=/usr/sbin/named -f $OPTIONS
      sed -i "s/ExecStart=.*/ExecStart=echo -n ''/" /usr/lib/systemd/system/named.service
      get_status_message "$?"
      _echo -n "$(msg cyan)Halting DNS service (named) from systemd startup  in /etc/systemd/system/named.service...$(msg end)" --name
      # Original: ExecStart=/usr/sbin/named -f -u bind
      sed -i "s/ExecStart=.*/ExecStart=echo -n ''/" /etc/systemd/system/named.service
      get_status_message "$?"
      _echo -n "$(msg cyan)Reloading systemd startup ...$(msg end)" --name
      systemctl daemon-reload
      get_status_message "$?"
      echo ""
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This will configure both ipv4 and ipv6 (add ipv4 or ipv6) and link them together only based on the IP from config files
# configure_da_ips --run-force --init, the option --init removes previous data and force this function configure_da_ips to start from scratch, useful if the ipv6 file is corrupted
configure_da_ips() {
  local run_mode extra_option func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  start_execute_options "${run_mode}" "${func_name}"
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_ip_list da_conf da_bin da_cb_bin \
      da_ipv4_adds da_ipv4 c_da_ipv4 da_ipv4_file ipv4_found \
      da_ipv6_adds da_ipv6 c_da_ipv6 da_ipv6_file ipv6_found linked_ips

    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"

    _echo "$(msg cyan)Checking directadmin paths ...$(msg end)" --name
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}"
    echo ""

    da_ip_list="/usr/local/directadmin/data/admin/ip.list"

    da_ipv4_adds=$(ls /usr/local/directadmin/data/admin/ips/*.* 2>/dev/null)
    da_ipv6_adds=$(ls /usr/local/directadmin/data/admin/ips/*:* 2>/dev/null)

    # Get IPv6 config file
    c_da_ipv4="${C_IPV4_ADD0}"
    # Directadmin IP file use this form 1234:1234:0:0:1234:1234 so we need to convert ipv6 from config file into this form using ipv6calc
    required "debian@@apt:ipv6calc" "ubuntu@@apt:ipv6calc"
    c_da_ipv6=$(ipv6calc --addr2uncompaddr "${C_IPV6_ADD0}")

    ipv6_da_file="/usr/local/directadmin/data/admin/ips/${c_da_ipv6}"
    # This ipv4_da_file is not required at this moment but left for reference:
    #ipv4_da_file="/usr/local/directadmin/data/admin/ips/${c_da_ipv4}"

    # Very important note. The reason we enable ipv6=1 is to enable ipv6 form to add Ipv6 in directadmin system (without this step API might have problem)
    _echo "$(msg cyan)Enabling ipv6 in directadmin.conf config before adding IPv6...$(msg end)" --name
    ${da_bin} set ipv6 1
    echo ""
    # Must restart to enable the ipv6 form
    _echo "$(msg cyan)Requesting directadmin to restart after changing directadmin.conf ...$(msg end)" --name
    restart_da
    echo ""
    # Configure IPv4 address (Check existing)
    _echo "$(msg cyan)Checking if there is any directadmin IPv4 files exist inside /usr/local/directadmin/data/admin/ips/ ...$(msg end)" --name

    if [ -z "${da_ipv4_adds}" ]; then
      # Display error instead of warning because ipv4 address based on config should exist in directadmin as default IP. If it does not exist, that means, something wrong with the DA installation
      _echo "$(msg red)Error, there is no IPv4 IP address file is found inside /usr/local/directadmin/data/admin/ips/. There must be an IPv4 address ${LABEL_C_IPV4_ADD0} exist in the location!$(msg end)" --name
      _exit 147
      # Below is not required at this moment
      #_echo "$(msg yellow)Warning, there is no IPv4 IP address file is found inside /usr/local/directadmin/data/admin/ips/ $(msg end)" --name
      #if [ "${C_DA_AUTO_ADD_IPV46_ENTRY}" == "true" ]; then
      #  _echo "$(msg cyan)Automatically added missing IPv4 IP address using directadmin API ... $(msg end)" --name
      da_api_admin add-ip --ip-address "${C_IPV4_ADD0}" --netmask "${C_IPV4_NETMASK_IP0}"
      #else
      #  _echo "$(msg yellow)Warning, C_DA_AUTO_ADD_IPV46_ENTRY is not set. Please manually add missing IPv4 IP address via GUI$(msg end)" --name
      #  # Give details how to login and add here
      #  _exit 147
      #fi
    fi

    for da_ipv4_file in $(echo "${da_ipv4_adds}" | tr ' ' '\n'); do
      # From da ip file
      da_ipv4=$(basename "${da_ipv4_file}")
      _echo "da_ipv4 is ${da_ipv4}" --verbose 7
      if [[ "${da_ipv4}" == "${c_da_ipv4}" ]]; then
        _echo "$(msg green)OK, found the IPv4 address ${LABEL_C_IPV4_ADD0} that matches with the IP file in [${da_ipv4_file}]$(msg end)" --name
        # We should break this and ignore others because we only want the IP that match in the config file
        ipv4_found=true
        break
      else
        _echo "$(msg yellow)[Ignored]: Warning, the IPv4 address ${LABEL_C_IPV4_ADD0} does not match with the IP file in [${da_ipv4_file}]$(msg end)" --name
        ipv4_found=false
      fi
    done

    if [[ "${ipv4_found}" == "false" ]]; then
      _echo "$(msg red)Error, no IPv4 matching found between config file and directadmin IP files. At least one IP should be there. Something is wrong, please inspect$(msg end)" --name
      _exit 147
    fi
    echo ""

    # IPV6 start here
    # ( deprecated ): If --init passed in extra_option, we force rebuild the IP (only IPv6 was modified so we only remove ipv6 file to start over)
    # We do not need to have this option, we force rebuild IPv6 by removing it first
    #if [ "${extra_option}" == "--init" ]; then
    _echo "$(msg cyan)Removing existing directadmin IPv6 IP files to rebuild IPv6 IP ...$(msg end)" --name
    rm -f ${da_ipv6_adds}
    echo ""
    #fi
    # So we always have empty IPv6 then we can rebuild:
    _echo "$(msg cyan)Checking if there is any directadmin Ipv6 files exist inside /usr/local/directadmin/data/admin/ips/ ...$(msg end)" --name
    if [ -z "${da_ipv6_adds}" ]; then
      # For Ipv6, we don't display error and exit, we auto add the IP based on the config file
      _echo "$(msg yellow)Warning, there is no IPv6 IP address file is found inside /usr/local/directadmin/data/admin/ips/ $(msg end)" --name
      if [ "${C_DA_AUTO_ADD_IPV46_ENTRY}" == "true" ]; then
        _echo "$(msg cyan)Automatically adding missing IPv6 IP address using directadmin API ... $(msg end)" --name
        #1) First method: Create ipv6 file using directadmin API
        # Use converted IPv6 (I don't have to convert it actually, this will be done automatically)
        da_api_admin add-ip --ip-address "${c_da_ipv6}" --netmask "${C_IPV6_NETMASK0}"

        #2) Second method: Manually create ipv6 file (alternative way) if the above method API doesn't produce the IP file (just in case)
        if [ ! -f "${ipv6_da_file}" ]; then
          # Normally API will not fail, but just in case if ipv6 file is still not created,
          # we can use this unofficial method created by me here:
          # https://forum.directadmin.com/threads/how-to-add-ip6-address-in-da-via-terminal-not-through-gui.62752/
          _echo "$(msg cyan)Automatically adding missing IPv6 IP address using manual file creation ...$(msg end)" --name
          touch "${ipv6_da_file}"
          {
            echo "gateway="
            echo "global=no"
            echo "linked_ips="
            echo "netmask=/64"
            echo "ns="
            echo "reseller="
            echo "status=free"
            echo "value="
          } >"${ipv6_da_file}"
          chmod 600 "${ipv6_da_file}"
          chown diradmin:diradmin "${ipv6_da_file}"
          grep_result=$(grep -c "${c_da_ipv6}" "${da_ip_list}")
          if [ "${grep_result}" -ne 0 ]; then
            echo "${c_da_ipv6}" >>"${da_ip_list}"
          fi
          _echo "$(msg cyan)Rebuilding server config files for new IPv6 ...$(msg end)" --name
          ${da_cb_bin} rewrite_confs >/dev/null
        fi
        # Update new variable to read IPv6
        da_ipv6_adds=$(ls /usr/local/directadmin/data/admin/ips/*:* 2>/dev/null)
      else
        _echo "$(msg yellow)Warning, IPv6 has not been setup through Directadmin and C_DA_AUTO_ADD_IPV46_ENTRY is not set to true. Please manually enter IPv6 from GUI (full form) then run this script again$(msg end)" --name
        # Enable the DA port in firewall only when pressing enter (good confirmation from user)
        read -r -s -n 1 -p "[${SCRIPT_NAME}]: Press any key to start adding TCP port ${LABEL_C_DA_PORT}/tcp in ufw to allow directadmin login ..."
        echo ""
        _echo "$(msg cyan)Allowing TCP port ${LABEL_C_DA_PORT}/tcp for accessing directadmin admin login page ...$(msg end)" --name
        sudo ufw allow "${C_DA_PORT}/tcp"
        echo ""
        # Need to restart directadmin because we did change port from 2222 to new port before calling this function
        _echo "$(msg cyan)Requesting directadmin to restart$(msg end)" --name
        restart_da
        _echo "$(msg green)Use the following login information to enter into directadmin login admin page and then add IPv6 IP address. When you are done, re-run this script again:$(msg end)" --name
        echo ""
        _echo "$(msg magenta)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
        echo "Directadmin admin login page can be accessed through http://${LABEL_C_IPV4_ADD0}:${LABEL_C_DA_PORT}"
        echo "username: ${LABEL_C_DA_OWNER_USERNAME1}"
        echo "password: ${LABEL_C_DA_OWNER_USERPASS1}"
        echo ""
        echo "Directadmin default setup.txt information:"
        awk '{ print }' /usr/local/directadmin/scripts/setup.txt
        _echo "$(msg magenta)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
        echo ""
        # Need to exit this because we need to re-run this script before mark it as executed
        _exit 147
      fi
    fi

    # This is for linking between IPv6 and IPv4
    for da_ipv6_file in $(echo "${da_ipv6_adds}" | tr ' ' '\n'); do
      # From da ip file
      da_ipv6=$(basename "${da_ipv6_file}")
      _echo "da_ipv6 is ${da_ipv6}" --verbose 7
      if [[ "${da_ipv6}" == "${c_da_ipv6}" ]]; then
        _echo "$(msg green)OK, found the IPv6 address ${LABEL_C_IPV6_ADD0} that matches with the IP file in [${da_ipv6_file}]$(msg end)" --name
        # We should break this and ignore others because we only want the IP that match in the config file
        ipv6_found=true
        echo ""
        echo "Linking Ipv4 and Ipv6 ..."
        echo ""
        _echo "$(msg green)Checking if IPs are linked based on IPv6 IP file ...$(msg end)" --name
        linked_ips=$(sed -n 's/^linked_ips=//p' "${da_ipv6_file}")
        if [[ "${linked_ips}" == "" || -z "${linked_ips}" ]]; then

          _echo "$(msg yellow)Warning, the IPv6 address linked_ip data is empty in file ${da_ipv6_file}!$(msg end)" --name
          echo ""
          if [ "${C_DA_AUTO_LINK_IP}" == "true" ]; then
            _echo "$(msg cyan)Linking IPv6 address ${da_ipv6} with IPv4 address ${LABEL_C_IPV4_ADD0} using directadmin task.queue ...$(msg end)" --name
            echo "action=linked_ips&ip_action=add&ip=${da_ipv6}&ip_to_link=${C_IPV4_ADD0}&apache=yes&dns=yes&apply=yes" >>/usr/local/directadmin/data/task.queue
            /usr/local/directadmin/dataskq d2000 >/dev/null
            echo ""
            _echo "$(msg cyan)Linking IPv4 address ${LABEL_C_IPV4_ADD0} with IPv6 address ${da_ipv6} using directadmin task.queue ...$(msg end)" --name
            echo "action=linked_ips&ip_action=add&ip=${C_IPV4_ADD0}&ip_to_link=${da_ipv6}&apache=yes&dns=yes&apply=yes" >>/usr/local/directadmin/data/task.queue
            /usr/local/directadmin/dataskq d2000 >/dev/null
            echo ""
            # Here we check if the linking progress is success, if success, break the loop
            while :; do
              # Normally directadmin task.queue completes in 1 minute but sometimes it is less than 10 seconds, so we reduce the check in seconds
              _echo "$(msg yellow)Waiting for the IPv4 address and IPv6 address are linked together from task.queue ....$(msg end)" --start-spin --name
              linked_ips=$(sed -n 's/^linked_ips=//p' "${da_ipv6_file}")
              if [[ -n "${linked_ips}" ]]; then
                _echo "$(msg green)OK, found IPv6 linked_ips with value: ${linked_ips}$(msg end)" --stop-spin --name
                # This is when success, we create that executed flag file and break the loop.
                # Good idea to break we only need first match. no reason to loop again.
                break
              fi
              sleep 5
            done
          else
            _echo "$(msg yellow)Warning C_DA_AUTO_LINK_IP is not set to true. Please manually link the IPv4 address and IPv6 address via directadmin and run this script again!$(msg end)" --start-spin --name
            # Enable the DA port in firewall only when pressing enter (good confirmation from user)
            read -r -s -n 1 -p "[${SCRIPT_NAME}]: Press any key to start adding TCP port ${LABEL_C_DA_PORT}/tcp in ufw to allow directadmin login ..."
            echo ""
            _echo "$(msg cyan)Allowing TCP port ${LABEL_C_DA_PORT}/tcp for accessing directadmin admin login page ...$(msg end)" --name
            sudo ufw allow "${C_DA_PORT}/tcp"
            echo ""
            # Need to restart directadmin because we did change port from 2222 to new port before calling this function
            _echo "$(msg cyan)Requesting directadmin to restart$(msg end)" --name
            restart_da
            _echo "$(msg green)Use the following login information to enter into directadmin login admin page and then link the IPv4 IP address with IPv6 IP address. When you are done, re-run this script again:$(msg end)" --name
            echo ""
            _echo "$(msg magenta)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
            echo "Directadmin admin login page can be accessed through http://${LABEL_C_IPV4_ADD0}:${LABEL_C_DA_PORT}"
            echo "username: ${LABEL_C_DA_OWNER_USERNAME1}"
            echo "password: ${LABEL_C_DA_OWNER_USERPASS1}"
            echo ""
            echo "Directadmin default setup.txt information:"
            awk '{ print }' /usr/local/directadmin/scripts/setup.txt
            _echo "$(msg magenta)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
            echo ""
            # Need to exit this because we need to re-run this script before mark it as executed
            _exit 147
          fi
        else
          _echo "$(msg green)OK, already found IPv6 linked_ips with value: ${linked_ips}$(msg end)" --name
        fi
        break
      else
        _echo "$(msg yellow)[Ignored]: Warning, the IPv6 address ${LABEL_C_IPV6_ADD0} does not match with the IP file in [${da_ipv6_file}]$(msg end)" --name
        ipv6_found=false
      fi
    done

    if [[ "${ipv6_found}" == "false" ]]; then
      _echo "$(msg red)Error, no IPv6 matching found between config file and directadmin IP files. At least one IP should be there. Something is wrong, please inspect$(msg end)" --name
      _exit 147
    fi

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Install CSF Firewall in DA way
# Important note, CSF will auto add port 2222 if detect directadmin BUT if the port is changed before installation, it will not add custom port!
# So at this point DA is not accesible using custom port
# To add custom port for directadmin call configure_csf() function
install_da_csf() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    # This fixed lfd cannot started
    required "debian@@apt:libio-socket-inet6-perl"
    if [[ "${C_DA_INSTALL_TYPE}" == "auto" ]]; then
      _echo "$(msg yellow)[Skipped]: Directadmin installation type is set to AUTO which already included CSF installation$(msg end)" --name
    else
      if ! command -v csf &>/dev/null; then
        local csf_conf da_conf inst_result csf_pignore inst_result csf_pignore
        _echo "$(msg cyan)No CSF binary is found (CSF is not installed)$(msg end)" --name
        _echo "$(msg cyan)Installing CSF on ${LABEL_C_BOX_HOSTNAME_FQHN} for directadmin based on (poralix steps) ...$(msg end)" --name
        sleep 2

        csf_conf=/etc/csf/csf.conf
        da_conf=/usr/local/directadmin/conf/directadmin.conf

        _echo "$(msg cyan)Checking whether directadmin config is exist ...$(msg end)" --name

        if [ ! -s "${da_conf}" ]; then
          if [ -s /usr/local/directadmin/data/templates/directadmin.conf ]; then
            # this template contains the default value for directadmin.conf
            da_conf=/usr/local/directadmin/data/templates/directadmin.conf
            _echo "$(msg yellow)Warning, directadmin is not yet installed. Will use ${da_conf} for settings$(msg end)" --name
          else
            _echo "$(msg red)Error, cannot find conf/directadmin.conf, nor data/templates/directadmin.conf. Please install directadmin first$(msg end)" --name
            exit 147
          fi
        fi
        echo ""
        _echo "$(msg cyan)Downloading Config Server Firewall (CSF) ...$(msg end)" --name
        navigate_path /usr/local/src
        wget --no-verbose -O csf.tgz https://download.configserver.com/csf.tgz
        if [ ! -s csf.tgz ]; then
          _echo "$(msg red)Error, download failed for csf.tgz. Please inspect manually and re-run this script to continue$(msg end)" --name
          _exit 147
        else
          _echo "$(msg cyan)Unzipping downloaded file csf.tgz ... $(msg end)" --name
          tar -zxf csf.tgz
          navigate_path ./csf
          echo ""
        fi

        inst_result=$(./csftest.pl | tail -n 1 | grep -c 'RESULT: csf should function on this server')
        if [ "${inst_result}" != "1" ]; then
          ./csftest.pl
          echo ""
          echo ""
          _echo "$(msg red)Error, CSF installation test did not pass. Please inspect manually and re-run this script to continue$(msg end)" --name
          _exit 147
        else
          _echo "$(msg green)OK, CSF installation test passed! Installing CSF for Directadmin ...$(msg end)" --name
          echo ""
          ./install.directadmin.sh
          echo ""
          if [ ! -s "${csf_conf}" ]; then
            _echo "$(msg red)Error, cannot find ${csf_conf} after installation. Please inspect manually and re-run this script to continue$(msg end)" --name
            _exit 147
          fi
        fi
        echo ""
        _echo "$(msg cyan)Ignoring CSF alert for some users in csf.pignore ...$(msg end)" --name
        csf_pignore=/etc/csf/csf.pignore
        if [ -e "${csf_pignore}" ]; then
          if ! grep -m1 -q '^user:mysql$' "${csf_pignore}"; then
            echo "user:mysql" >>"${csf_pignore}"
          fi
          if ! grep -m1 -q '^user:diradmin$' "${csf_pignore}"; then
            echo "user:diradmin" >>"${csf_pignore}"
          fi
        fi
        echo ""
        _echo "$(msg cyan)Downloading other directadmin-csf script integration ...$(msg end)" --name
        navigate_path /usr/local/directadmin/scripts/custom/
        wget --no-verbose --no-check-certificate -O block_ip.sh http://files.plugins-da.net/dl/csf_block_ip.sh.txt
        wget --no-verbose --no-check-certificate -O unblock_ip.sh http://files.plugins-da.net/dl/csf_unblock_ip.sh.txt
        wget --no-verbose --no-check-certificate -O show_blocked_ips.sh http://files.plugins-da.net/dl/csf_show_blocked_ips.sh.txt
        wget --no-verbose --no-check-certificate -O brute_force_notice_ip.sh http://files.directadmin.com/services/all/brute_force_notice_ip.sh
        echo ""
        _echo "$(msg cyan)Correcting the permission of the downloaded scripts ...$(msg end)" --name
        chmod 700 block_ip.sh show_blocked_ips.sh unblock_ip.sh brute_force_notice_ip.sh
        echo ""
        _echo "$(msg cyan)Creating the empty block list and exempt list files ...$(msg end)" --name
        touch /root/blocked_ips.txt
        touch /root/exempt_ips.txt
        echo ""
        # Set this using directadmin binary instead
        #_echo "$(msg cyan)Hiding directadmin bruteforce notification ...$(msg end)" --name
        #grep_count=$(grep -c hide_brute_force_notifications /usr/local/directadmin/conf/directadmin.conf)
        #if [ "${grep_count}" = "0" ]; then
        #  echo "hide_brute_force_notifications=1" >>/usr/local/directadmin/conf/directadmin.conf
        #fi
        # Credit to poralix for giving idea how to integrate CSF on directadmin:
        echo ""
        echo ""
        echo "Install complete!"
        echo "To access the plugin, go to:"
        echo "  Admin Level -> ConfigServer Firewall\&Security"
        echo ""
        echo "This is a modified version based on the guide at https://help.poralix.com/articles/how-to-block-ips-with-csf-directadmin-bfm"
        echo ""
        echo ""
        #wget http://files.directadmin.com/services/all/csf/csf_install.sh
        # Or alternatively way to install CSF is to use my own script file from maxicode
        #da_install_scripts_path="${LATEST_OS_CODE_PATH}/usr/local/directadmin/install_scripts"
        #if [ ! -d "${da_install_scripts_path}" ]; then
        #  _echo "$(msg red)Error, directadmin install script path does not exist in ${maxicode_latest_path}. The script should be there!$(msg end)" --name
        #  _exit 147
        #fi
        #navigate_path "${INST_TEMP_DIR}"
        #cp "${da_install_scripts_path}/csf_install.sh" "${INST_TEMP_DIR}/csf_install.sh"
        #chmod +x csf_install.sh
        #/bin/sh ./csf_install.sh
      else
        # CSF binary found,
        grep_count=$(csf -v 2>/dev/null | grep -c 'csf:')
        if [ "${grep_count}" = "0" ]; then
          _echo "$(msg yellow)Warning, CSF already installed but it does not show its version. CSF Installation might have been corrupted$(msg end)" --name
          echo "Uninstalling csf and lfd..."
          echo
          sed -i 's/lfd=ON/lfd=OFF/' /usr/local/directadmin/data/admin/services.status
          /usr/sbin/csf -f
          if test "$(cat /proc/1/comm)" = "systemd"; then
            systemctl disable csf.service
            systemctl disable lfd.service
            systemctl stop lfd.service
            systemctl stop csf.service
            rm -fv /usr/lib/systemd/system/csf.service
            rm -fv /usr/lib/systemd/system/lfd.service
            systemctl daemon-reload
          else
            if [ -f /etc/redhat-release ]; then
              /sbin/chkconfig csf off
              /sbin/chkconfig lfd off
              /sbin/chkconfig csf --del
              /sbin/chkconfig lfd --del
            elif [ -f /etc/debian_version ] || [ -f /etc/lsb-release ]; then
              update-rc.d -f lfd remove
              update-rc.d -f csf remove
            elif [ -f /etc/gentoo-release ]; then
              rc-update del lfd default
              rc-update del csf default
            elif [ -f /etc/slackware-version ]; then
              rm -vf /etc/rc.d/rc3.d/S80csf
              rm -vf /etc/rc.d/rc4.d/S80csf
              rm -vf /etc/rc.d/rc5.d/S80csf
              rm -vf /etc/rc.d/rc3.d/S85lfd
              rm -vf /etc/rc.d/rc4.d/S85lfd
              rm -vf /etc/rc.d/rc5.d/S85lfd
            else
              /sbin/chkconfig csf off
              /sbin/chkconfig lfd off
              /sbin/chkconfig csf --del
              /sbin/chkconfig lfd --del
            fi
            rm -fv /etc/init.d/csf
            rm -fv /etc/init.d/lfd
          fi

          rm -fv /etc/chkserv.d/lfd
          rm -fv /usr/sbin/csf
          rm -fv /usr/sbin/lfd
          rm -fv /etc/cron.d/csf_update
          rm -fv /etc/cron.d/lfd-cron
          rm -fv /etc/cron.d/csf-cron
          rm -Rfv /usr/local/directadmin/plugins/csf
          rm -fv /etc/logrotate.d/lfd
          rm -fv /usr/local/man/man1/csf.man.1
          rm -Rfv /etc/csf /usr/local/csf /var/lib/csf
          echo
          echo "...Done"
          install_da_csf
        else
          _echo "$(msg green)OK, CSF already installed with the following version status: $(msg end)" --name
          echo ""
          csf -v
          echo ""
        fi
      fi
    fi
    # TIPS. CSF can be removed with this command:
    # sh /etc/csf/uninstall.sh
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

install_general_csf() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    # If DA INSTALL TYPE IS auto don't run this because it will install CSF automatically (as stated in documentation)
    local gc csf_ipv4_tcp_in ipv4_tcp_out ipv6_tcp_in ipv6_tcp_out extra_allow_ports kernel_numericver
    local bl_ip_html_source bl_ip_html_dest gc retval

    if ! command -v csf &>/dev/null; then
      echo "[${SCRIPT_NAME}]: No CSF binary is found (CSF is not installed)"
      sleep 2
      if [ "${C_SERVER_TYPE}" == "general" ]; then
        echo "[${SCRIPT_NAME}]: Script installation type is set to 'general'. Installing and Setting up CSF for ${LABEL_C_BOX_HOSTNAME_FQHN} ..."
        sleep 2
        echo "[${SCRIPT_NAME}]: Removing existing CSF if exist using built-in script ..."
        sh /etc/csf/uninstall.sh
        echo "[${SCRIPT_NAME}]: Removing previous downloaded file ..."
        rm -fv "${INST_TEMP_DIR}/csf.tgz"
        navigate_path "${INST_TEMP_DIR}"
        echo "[${SCRIPT_NAME}]: Downloading and extracting CSF file in ${INST_TEMP_DIR} ..."
        curl -SL https://download.configserver.com/csf.tgz | tar -xzf -
        # Now after extracted we have csf folder, let's enter to this path
        navigate_path "./csf"

        echo "[${SCRIPT_NAME}]: Testing CSF pre-installation requirement ..."
        gc=$(./csftest.pl | tail -n 1 | grep -c 'RESULT: csf should function on this server')
        if [ "${gc}" != "1" ]; then
          ./csftest.pl
          echo ""
          echo ""
          echo "CSF test did not pass. Will not continue. Solve the issue and rerun this script again"
          _exit 2
        else
          echo "[OK]: CSF test passed!"
        fi

        echo "[${SCRIPT_NAME}]: Now installing CSF ..."
        chmod +x install.sh
        sh "install.sh"
        # When finished, we go back to original path

        # CSF recommends to disable and remove APF+BFD (if exist). Check APF:
        echo "[${SCRIPT_NAME}]: Checking and removing existing APF+BFD (recommended) ..."
        if command -v apf &>/dev/null; then
          echo "[${SCRIPT_NAME}]: Warning, Found apf command. Removing apf bfd with remove_apf_bfd.sh ..."
          #sh /usr/local/csf/bin/disable_apf_bfd.sh #Script disabled because not found in the csf bin folder
          sh /usr/local/csf/bin/remove_apf_bfd.sh
        else
          echo "[${SCRIPT_NAME}]: [Skipped]: OK, No existing APF+BFD installation to remove"
        fi
      elif [ "${C_SERVER_TYPE}" == "directadmin" ]; then
        echo "[${SCRIPT_NAME}]: Script installation type is set to DIRECTADMIN. Installing CSF on ${LABEL_C_BOX_HOSTNAME_FQHN} using DA script by Poralix..."
        sleep 2
        #wget http://files.directadmin.com/services/all/csf/csf_install.sh
        navigate_path "${INST_TEMP_DIR}"
        cp "${DATA_PATH}/maxinet/storage/os/${DISTRO_ID}/usr/local/directadmin/install_scripts/csf_install.sh" "${INST_TEMP_DIR}/csf_install.sh"
        chmod +x csf_install.sh
        /bin/sh ./csf_install.sh
      fi
    else
      echo "[${SCRIPT_NAME}]: Found CSF binary (CSF already installed). Continuing setup ..."
    fi
    # After install CSF definitely we got this
    if [ -f /etc/csf/csf.conf ]; then
      echo "[${SCRIPT_NAME}]: Now configuring CSF config at /etc/csf/csf.conf ..."
      sleep 1
      # This also must have comma,
      if [ -n "${C_CSF_EXTRA_ALLOW_PORTS}" ]; then
        extra_allow_ports=",${C_DA_PORT},${C_CSF_EXTRA_ALLOW_PORTS}"
      else
        extra_allow_ports=",${C_DA_PORT}"
      fi
      echo "DEBUG: extra_allow_ports=${extra_allow_ports}"
      grep -wq "^TCP_IN = .*${extra_allow_ports}" /etc/csf/csf.conf
      if [ $? = 1 ]; then
        echo "[${SCRIPT_NAME}]: Adding extra port(s) ${extra_allow_ports} in CSF firewall in CSF for TCP_IN ..."
        csf_ipv4_tcp_in=$(grep -i '^TCP_IN' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep="${extra_allow_ports}" '{ print $1 ep }')
        sed -i "s/TCP_IN = .*/TCP_IN = \"${csf_ipv4_tcp_in}\"/" /etc/csf/csf.conf
      else
        echo "[${SCRIPT_NAME}]: [Skipped]: Extra port(s) ${extra_allow_ports} has already added in CSF for TCP_IN before"
      fi
      grep -wq "^TCP_OUT = .*${extra_allow_ports}" /etc/csf/csf.conf
      if [ $? = 1 ]; then
        echo "[${SCRIPT_NAME}]: Adding extra port(s) ${extra_allow_ports} in CSF firewall in CSF for TCP_OUT ..."
        ipv4_tcp_out=$(grep -i '^TCP_OUT' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep="${extra_allow_ports}" '{ print $1 ep }')
        sed -i "s/TCP_OUT = .*/TCP_OUT = \"${ipv4_tcp_out}\"/" /etc/csf/csf.conf
      else
        echo "[${SCRIPT_NAME}]: [Skipped]: Extra port(s) ${extra_allow_ports} has already added in CSF for TCP_OUT before"
      fi
      grep -wq "^TCP6_IN = .*${extra_allow_ports}" /etc/csf/csf.conf
      if [ $? = 1 ]; then
        echo "[${SCRIPT_NAME}]: Adding extra port(s) ${extra_allow_ports} in CSF firewall in CSF for TCP6_IN ..."
        ipv6_tcp_in=$(grep -i '^TCP6_IN' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep="${extra_allow_ports}" '{ print $1 ep }')
        sed -i "s/TCP6_IN = .*/TCP6_IN = \"${ipv6_tcp_in}\"/" /etc/csf/csf.conf
      else
        echo "[${SCRIPT_NAME}]: [Skipped]: Extra port(s) ${extra_allow_ports} has already added in CSF for TCP6_IN before"
      fi
      grep -wq "^TCP6_OUT = .*${extra_allow_ports}" /etc/csf/csf.conf
      if [ $? = 1 ]; then
        echo "[${SCRIPT_NAME}]: Adding extra port(s) ${extra_allow_ports} in CSF firewall in CSF for TCP6_OUT ..."
        ipv6_tcp_out=$(grep -i '^TCP6_OUT' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep="${extra_allow_ports}" '{ print $1 ep }')
        sed -i "s/TCP6_OUT = .*/TCP6_OUT = \"${ipv6_tcp_out}\"/" /etc/csf/csf.conf
      else
        echo "[${SCRIPT_NAME}]: [Skipped]: Extra port(s) ${extra_allow_ports} has already added in CSF for TCP6_OUT before"
      fi
      # Disable CSF testing mode
      echo "[${SCRIPT_NAME}]: Disabling CSF testing mode ..."
      sed -i 's/TESTING = "1"/TESTING = "0"/g' /etc/csf/csf.conf
      #echo "[${SCRIPT_NAME}]: Setting CONNLIMIT and PORTFLOOD best setting ..."
      #sed -i 's/CONNLIMIT = ""/CONNLIMIT = "22;5,80;20,443;20"/g' /etc/csf/csf.conf
      #sed -i 's/PORTFLOOD = ""/PORTFLOOD = "22;tcp;5;300,80;tcp;20;5,443;tcp;20;5"/g' /etc/csf/csf.conf
      echo "[${SCRIPT_NAME}]: Enabling CSF email alert from 0 to 1 ..."
      sed -i 's/LF_SSH_EMAIL_ALERT = "0"/LF_SSH_EMAIL_ALERT = "1"/g' /etc/csf/csf.conf
      echo "[${SCRIPT_NAME}]: Setting CSF email alert to ${C_ADMIN_EMAIL} ..."
      sed -i "s/LF_ALERT_TO = .*/LF_ALERT_TO = '\"${C_ADMIN_EMAIL}\"'/" /etc/csf/csf.conf
      echo "[${SCRIPT_NAME}]: Enabling CSF SMTP_BLOCK ..."
      sed -i 's/SMTP_BLOCK = "0"/SMTP_BLOCK = "1"/g' /etc/csf/csf.conf
      echo "[${SCRIPT_NAME}]: Setting CSF RESTRICT_SYSLOG from 0 to 3 to avoid warning ..."
      sed -i 's/RESTRICT_SYSLOG = "0"/RESTRICT_SYSLOG = "3"/g' /etc/csf/csf.conf
      echo "[${SCRIPT_NAME}]: Setting CSF SYSLOG_CHECK to ${C_CSF_SYSLOG_CHECK} ..."
      sed -i "s/SYSLOG_CHECK = .*/SYSLOG_CHECK = \"${C_CSF_SYSLOG_CHECK}\"/" /etc/csf/csf.conf
      sleep 1
      echo "[${SCRIPT_NAME}]: Testing CSF after changing configuration ..."
      echo ""
      perl /usr/local/csf/bin/csftest.pl
      echo ""
      echo "[${SCRIPT_NAME}]: Setting CSF PT_LOAD_ACTION ..."
      sed -i "s/^PT_LOAD_ACTION = .*/PT_LOAD_ACTION = \"\/usr\/local\/maxicode\/maxicsf\/csfload\"/" /etc/csf/csf.conf
      echo "[${SCRIPT_NAME}]: Setting CSF to send security alert to ${C_ADMIN_EMAIL} ..."
      csf -m "${C_ADMIN_EMAIL}"

      echo "[${SCRIPT_NAME}]: Setting CSF RBL email ${C_ADMIN_EMAIL} ..."
      csf --rbl "${C_ADMIN_EMAIL}"

      echo "[${SCRIPT_NAME}]: Enabling IPSET large IP for CSF ..."
      # inspired by: https://community.centminmod.com/threads/what-should-be-the-right-value-for-lf_ipset-on-csf-config.2045/
      kernel_numericver=$(uname -r | awk -F. '{ printf("%d%03d%03d%03d\n", $1,$2,$3,$4); }')
      # shellcheck disable=SC2143
      if [[ ! -f /proc/user_beancounters ]] && [[ "$(uname -r | grep linode)" || "$(find "/lib/modules/$(uname -r)" -name 'ipset')" ]] || [[ -f /proc/user_beancounters && "${kernel_numericver}" -ge '3000000000' ]]; then
        if [[ ! -f /usr/sbin/ipset ]]; then
          if [ "${DISTRO_ID}" == "centos" ]; then
            yum -q -y install ipset ipset-devel
          elif [ "${DISTRO_ID}" == "debian" ]; then
            sudo apt-get install ipset -y
          fi
          sed -i 's/LF_IPSET = \"0\"/LF_IPSET = \"1\"/' /etc/csf/csf.conf
        elif [[ -f /usr/sbin/ipset ]]; then
          sed -i 's/LF_IPSET = \"0\"/LF_IPSET = \"1\"/' /etc/csf/csf.conf
        fi
      fi
      # Increase block limit from 200 to 2500 (specified in config)
      echo "[${SCRIPT_NAME}]: Setting CSF DENY_IP_LIMIT to ${C_CSF_DENY_IP_LIMIT} ..."
      sed -i "s/DENY_IP_LIMIT = .*/DENY_IP_LIMIT = '\"${C_CSF_DENY_IP_LIMIT}\"'/" /etc/csf/csf.conf
      # CSF Messenger: TODO haven't tested this messenger
      echo "[${SCRIPT_NAME}]: Enabling CSF Messenger ..."
      sleep 1
      sed -i "s/MESSENGER = \"0\"/MESSENGER = \"1\"/" /etc/csf/csf.conf
      echo "[${SCRIPT_NAME}]: Inserting CSF RECAPTCHA_SITEKEY ..."
      sleep 1
      sed -i "s/RECAPTCHA_SITEKEY = \"\"/RECAPTCHA_SITEKEY = \"${C_GOOGLE_RECAPTCHA_SITE_V2}\"/" /etc/csf/csf.conf
      echo "[${SCRIPT_NAME}]: Inserting CSF RECAPTCHA_SECRET ..."
      sleep 1
      sed -i "s/RECAPTCHA_SECRET = \"\"/RECAPTCHA_SECRET = \"${C_GOOGLE_RECAPTCHA_SECRET_V2}\"/" /etc/csf/csf.conf
      echo "[${SCRIPT_NAME}]: Adding csf user in the system ..."
      useradd csf -s /bin/false
      echo "[${SCRIPT_NAME}]: Setting up CSF firewall blacklist template ..."
      mkdir -p /usr/local/directadmin/data/templates/custom
      bl_ip_html_source="${DATA_PATH}/maxinet/storage/os/${DISTRO_ID}/usr/local/directadmin/data/templates/custom/blacklisted_ip.html"
      bl_ip_html_dest="/usr/local/directadmin/data/templates/custom/blacklisted_ip.html"
      cp -r "${bl_ip_html_source}" "${bl_ip_html_dest}"
      chmod 644 "${bl_ip_html_dest}"
      chown diradmin:diradmin "${bl_ip_html_dest}"
      echo "[${SCRIPT_NAME}]: Starting CSF and LFD for the first time ..."
      echo "[${SCRIPT_NAME}]: Before we start it up, please confirm that your sshd port is listed in this output:"
      echo "-----------------"
      grep ^TCP_IN /etc/csf/csf.conf
      echo ""
      echo "If you do NOT see the port listed, press ctrl-c to immediately abort the script (you can add port missing port in maxinet.conf), then re-run this setup"
      echo "If you DO, the port correctly added, press enter to continue"
      _pause 60
      if [ "${DISTRO_ID}" == "centos" ]; then
        echo "[${SCRIPT_NAME}]: Disabling built-in firewall (firewalld) in CentOS ..."
        systemctl disable firewalld
        systemctl stop firewalld
      elif [ "${DISTRO_ID}" == "debian" ]; then
        echo "[${SCRIPT_NAME}]: Disabling and removing firewall (ufw) in Debian ..."
        sudo ufw disable
        sudo apt-get -y remove ufw
        sudo apt-get -y purge ufw
      else
        echo "[${SCRIPT_NAME}]: Error, unknown value for distribution ID ${DISTRO_ID}"
        _exit 147
      fi
      echo "-----------------"
      echo "[${SCRIPT_NAME}]: Starting CSF ..."
      systemctl start csf
      # Check and fix csf process error here automatically
      repair_services "csf"
      # By default behaviour, LFD should start automatically when we run csf start
      # service lfd start
      repair_services "lfd"
      # This is a temporary allowed IP during setup which won't be blocked by firewall.
      echo "[${SCRIPT_NAME}]: Temporarily allow IP ${LABEL_C_HOST_PUBLIC_IP} in /etc/etc/csf/csf.allow during setup in CSF"
      csf -a "${C_HOST_PUBLIC_IP}" "Added by ${SCRIPT_NAME} for ${C_BOX_HOSTNAME_FQHN} as temporary allowed IP during setup"
      # After that, the next step is requesting SSL and seems like the box need to restart
      # The reason it needs to restart here because if I don't restart at this point, the front page is not accessible (seems like port 80 is blocked)
      # If I don't restart at this point, I will not be able to renew cert (letsencrypt will produce error like firewall problem but it's not).
      # This is related to Ipv6 DAD. Look at function configure_da_ips() for more information
      # DAD disable is not working. Still need to restart system. Just restart it and resume later.
      #echo "[${SCRIPT_NAME}]: Creating reboot flag to restart system after installing CSF ..."
      #cat /dev/null >/var/run/reboot-required
      #echo "[${SCRIPT_NAME}]: Warning, system will reboot and you can run this script again to continue setup"
      #_pause
    else
      echo "[${SCRIPT_NAME}]: This is the weirdest error. Where the heck is /etc/csf/csf.conf? ..."
      _exit 147
    fi
    # System will reboot automatically from above flag

    # TIPS. CSF can be removed with this command:
    #sh /etc/csf/uninstall.sh
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}
# This will configure csf port and other csf related configs
# Note if you use --run-force and want to reinstall CSF at this stage, please execute this command first:
# sh /etc/csf/uninstall.sh (I don't include this command inside this function because CSF should not be reinstalled without permission)
configure_csf() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local extra_allow_ports retval \
      csf_ipv4_tcp_in csf_ipv4_tcp_out csf_ipv6_tcp_in csf_ipv6_tcp_out kernel_numericver

    # After install CSF definitely we got this
    if [ -f /etc/csf/csf.conf ]; then
      _echo "$(msg cyan)Configuring CSF config at /etc/csf/csf.conf ...$(msg end)" --name

      if [ -n "${C_CSF_EXTRA_ALLOW_PORTS}" ]; then
        extra_allow_ports="${C_GOTIFY_PORT},${C_DROP_BEAR_PORT},${C_DA_PORT},${C_CSF_EXTRA_ALLOW_PORTS}"
      else
        extra_allow_ports="${C_GOTIFY_PORT},${C_DROP_BEAR_PORT},${C_DA_PORT}"
      fi
      _echo "$(msg magenta)The extra allowed port to be added in CSF are: extra_allow_ports=${extra_allow_ports}$(msg end)" --name --verbose 7
      echo ""

      _echo "$(msg cyan)Adding extra port(s) ${extra_allow_ports} in CSF firewall in CSF config for TCP_IN ...$(msg end)" --name
      grep -wq "^TCP_IN = .*${extra_allow_ports}" /etc/csf/csf.conf
      retval=$?
      if [ "${retval}" -eq 1 ]; then
        csf_ipv4_tcp_in=$(grep -i '^TCP_IN' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep=",${extra_allow_ports}" '{ print $1 ep }')
        sed -i "s/TCP_IN = .*/TCP_IN = \"${csf_ipv4_tcp_in}\"/" /etc/csf/csf.conf
      else
        _echo "$(msg yellow)[Skipped]: Extra port(s) ${extra_allow_ports} has already been added in CSF config for TCP_IN before$(msg end)" --name
      fi
      echo ""
      _echo "$(msg cyan)Adding extra port(s) ${extra_allow_ports} in CSF firewall in CSF config for TCP_OUT ...$(msg end)" --name
      grep -wq "^TCP_OUT = .*${extra_allow_ports}" /etc/csf/csf.conf
      retval=$?
      if [ "${retval}" -eq 1 ]; then
        csf_ipv4_tcp_out=$(grep -i '^TCP_OUT' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep=",${extra_allow_ports}" '{ print $1 ep }')
        sed -i "s/TCP_OUT = .*/TCP_OUT = \"${csf_ipv4_tcp_out}\"/" /etc/csf/csf.conf
      else
        _echo "$(msg yellow)[Skipped]: Extra port(s) ${extra_allow_ports} has already been added in CSF config for TCP_OUT before$(msg end)" --name
      fi
      echo ""
      _echo "$(msg cyan)Adding extra port(s) ${extra_allow_ports} in CSF firewall in CSF config for TCP6_IN ...$(msg end)" --name
      grep -wq "^TCP6_IN = .*${extra_allow_ports}" /etc/csf/csf.conf
      retval=$?
      if [ "${retval}" -eq 1 ]; then

        csf_ipv6_tcp_in=$(grep -i '^TCP6_IN' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep=",${extra_allow_ports}" '{ print $1 ep }')
        sed -i "s/TCP6_IN = .*/TCP6_IN = \"${csf_ipv6_tcp_in}\"/" /etc/csf/csf.conf
      else
        _echo "$(msg yellow)[Skipped]: Extra port(s) ${extra_allow_ports} has already been added in CSF config for TCP6_IN before$(msg end)" --name
      fi
      echo ""
      _echo "$(msg cyan)Adding extra port(s) ${extra_allow_ports} in CSF firewall in CSF config for TCP6_OUT ...$(msg end)" --name
      grep -wq "^TCP6_OUT = .*${extra_allow_ports}" /etc/csf/csf.conf
      retval=$?
      if [ "${retval}" -eq 1 ]; then
        csf_ipv6_tcp_out=$(grep -i '^TCP6_OUT' /etc/csf/csf.conf | tr -d '"' | cut -d "=" -f2 | sed 's/^ *//g' | awk -v ep=",${extra_allow_ports}" '{ print $1 ep }')
        sed -i "s/TCP6_OUT = .*/TCP6_OUT = \"${csf_ipv6_tcp_out}\"/" /etc/csf/csf.conf
      else
        _echo "$(msg yellow)[Skipped]: Extra port(s) ${extra_allow_ports} has already been added in CSF config for TCP6_OUT before$(msg end)" --name
      fi
      echo ""

      # This is used only if server is in bruteforce mode
      #echo "[${SCRIPT_NAME}]: Setting CONNLIMIT and PORTFLOOD best setting ..."
      #sed -i 's/CONNLIMIT = ""/CONNLIMIT = "22;5,80;20,443;20"/g' /etc/csf/csf.conf
      #sed -i 's/PORTFLOOD = ""/PORTFLOOD = "22;tcp;5;300,80;tcp;20;5,443;tcp;20;5"/g' /etc/csf/csf.conf

      # Disable CSF testing mode
      _echo "$(msg cyan)Disabling CSF testing mode ...$(msg end)" --name
      sed -i 's/TESTING = "1"/TESTING = "0"/g' /etc/csf/csf.conf
      echo ""
      _echo "$(msg cyan)Enabling CSF SSH email alert LF_SSH_EMAIL_ALERT from 0 to 1 ...$(msg end)" --name
      sed -i 's/LF_SSH_EMAIL_ALERT = "0"/LF_SSH_EMAIL_ALERT = "1"/g' /etc/csf/csf.conf
      echo ""
      _echo "$(msg cyan)Setting CSF LF email alert to email ${C_ADMIN_EMAIL} ...$(msg end)" --name
      sed -i "s/LF_ALERT_TO = .*/LF_ALERT_TO = '\"${C_ADMIN_EMAIL}\"'/" /etc/csf/csf.conf
      echo ""
      _echo "$(msg cyan)Enabling CSF SMTP_BLOCK ...$(msg end)" --name
      sed -i 's/SMTP_BLOCK = "0"/SMTP_BLOCK = "1"/g' /etc/csf/csf.conf
      echo ""
      _echo "$(msg cyan)Setting CSF RESTRICT_SYSLOG from 0 to 3 to avoid warning ...$(msg end)" --name
      sed -i 's/RESTRICT_SYSLOG = "0"/RESTRICT_SYSLOG = "3"/g' /etc/csf/csf.conf
      echo ""
      _echo "$(msg cyan)Setting CSF SYSLOG_CHECK to ${C_CSF_SYSLOG_CHECK} ...$(msg end)" --name
      sed -i "s/SYSLOG_CHECK = .*/SYSLOG_CHECK = '\"${C_CSF_SYSLOG_CHECK}\"'/" /etc/csf/csf.conf
      echo ""
      _echo "$(msg cyan)Setting CSF PT_LOAD_ACTION script path ...$(msg end)" --name
      # TODO this script must be improved to detect server highload issue. I posted an answer to someone here why this is needed:
      # https://forum.directadmin.com/threads/random-instances-of-systemd-user-running-for-24-hours.64353/#post-335092
      sed -i "s/^PT_LOAD_ACTION = .*/PT_LOAD_ACTION = \"\/usr\/local\/maxicode\/maxicsf\/csfload\"/" /etc/csf/csf.conf
      echo ""
      _echo "$(msg cyan)Setting CSF to send security alert to ${C_ADMIN_EMAIL} ...$(msg end)" --name
      csf -m "${C_ADMIN_EMAIL}"
      echo ""
      _echo "$(msg cyan)Enabling LF_IPSET large IP for CSF (if compatible) ...$(msg end)" --name
      # This method is inspired by this post: https://community.centminmod.com/threads/what-should-be-the-right-value-for-lf_ipset-on-csf-config.2045/
      kernel_numericver=$(uname -r | awk -F. '{ printf("%d%03d%03d%03d\n", $1,$2,$3,$4); }')
      if [[ ! -f /proc/user_beancounters ]] && [[ "$(uname -r | grep linode)" || "$(find "/lib/modules/$(uname -r)" -name 'ipset')" ]] || [[ -f /proc/user_beancounters && "${kernel_numericver}" -ge '3000000000' ]]; then
        if [[ ! -f $(command -v ipset) ]]; then
          required "centos@@dnf:ipset" "debian@@apt:ipset"
          sed -i 's/LF_IPSET = \"0\"/LF_IPSET = \"1\"/' /etc/csf/csf.conf
        elif [[ -f $(command -v ipset) ]]; then
          sed -i 's/LF_IPSET = \"0\"/LF_IPSET = \"1\"/' /etc/csf/csf.conf
        fi
      fi
      echo ""
      # Increase block limit from 200 to C_CSF_DENY_IP_LIMIT (specified in config)
      _echo "$(msg cyan)Setting CSF DENY_IP_LIMIT to ${C_CSF_DENY_IP_LIMIT} ....$(msg end)" --name
      sed -i "s/DENY_IP_LIMIT = .*/DENY_IP_LIMIT = '\"${C_CSF_DENY_IP_LIMIT}\"'/" /etc/csf/csf.conf
      echo ""
      # TODO test CSF messenger
      # This is CSF Messenger setting:
      _echo "$(msg cyan)Enabling CSF Messenger ...$(msg end)" --name
      sed -i "s/MESSENGER = \"0\"/MESSENGER = \"1\"/" /etc/csf/csf.conf
      echo ""
      _echo "$(msg cyan)Adding csf user in the system ...$(msg end)" --name
      useradd csf -s /bin/false
      echo ""
      _echo "$(msg cyan)Inserting CSF RECAPTCHA_SITEKEY ...$(msg end)" --name
      sed -i "s/RECAPTCHA_SITEKEY = \"\"/RECAPTCHA_SITEKEY = \"${C_GOOGLE_RECAPTCHA_SITE_V2}\"/" /etc/csf/csf.conf
      echo ""
      _echo "$(msg cyan)Inserting CSF RECAPTCHA_SECRET ...$(msg end)" --name
      sed -i "s/RECAPTCHA_SECRET = \"\"/RECAPTCHA_SECRET = \"${C_GOOGLE_RECAPTCHA_SECRET_V2}\"/" /etc/csf/csf.conf
      echo ""

      if [[ "${C_SERVER_TYPE}" == "directadmin" ]]; then
        _echo "$(msg cyan)Setting LF_DIRECTADMIN = 5 ...$(msg end)" --name
        sed -i "s|^LF_DIRECTADMIN=.*|LF_DIRECTADMIN = \"5\"|" /etc/csf/csf.conf
        echo ""
        _echo "$(msg cyan)Setting LF_DIRECTADMIN_PERM = 1 ...$(msg end)" --name
        sed -i "s|^LF_DIRECTADMIN_PERM=.*|LF_DIRECTADMIN_PERM = \"5\"|" /etc/csf/csf.conf
        echo ""
        _echo "$(msg cyan)Setting PORTS_directadmin into ${LABEL_C_DA_PORT} ...$(msg end)" --name
        sed -i "s|^PORTS_directadmin=.*|PORTS_directadmin = \"${C_DA_PORT}\"|" /etc/csf/csf.conf
        echo ""

        _echo "$(msg cyan)Writing new CSF firewall blacklist template ...$(msg end)" --name
        mkdir -p /usr/local/directadmin/data/templates/custom
        {
          echo "<!DOCTYPE html>"
          echo "<html lang=\"en\">"
          echo "<head>"
          echo "    <title>Maxiwall Information</title>"
          echo "    <meta charset=\"utf-8\">"
          echo "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">"
          echo "</head>"
          echo "<body>"
          echo ""
          echo "<div class=\"container\">"
          echo "    <h1>Maxiwall Information</h1>"
          echo "    <p>Warning: For security reason, your IP has been blacklisted by our firewall due to repeated authorization failures.</p>"
          echo "    <h3> Solutions: </h3>"
          echo "    <p>1) Normally this is a temporary block and our firewall will unblock your IP within few minutes or few hours</p>"
          echo "    <p>2) If you think this is a mistake and need to have your IP whitelisted immediately, please email us at ${C_ADMIN_EMAIL}</p>"
          echo "    <p>3) If you are using a dynamic IP (most people do), you could try is to restart your main ISP router to get a new IP address </p>"
          echo "    <p>4) If you are using a static IP please, the step 3) might not be possible. Please contact us ${C_ADMIN_EMAIL} to unblock your IP with valid reason </p>"
          echo "</div>"
          echo ""
          echo "</body>"
          echo "</html>"
        } >"/usr/local/directadmin/data/templates/custom/blacklisted_ip.html"
        # _echo "$(msg cyan)Setting up CSF firewall blacklist template taken from maxicode ...$(msg end)" --name
        # mkdir -p /usr/local/directadmin/data/templates/custom
        # cp "${LATEST_OS_CODE_PATH}/usr/local/directadmin/data/templates/custom/blacklisted_ip.html" "/usr/local/directadmin/data/templates/custom/blacklisted_ip.html"
        chmod 644 "/usr/local/directadmin/data/templates/custom/blacklisted_ip.html"
        chown diradmin:diradmin "/usr/local/directadmin/data/templates/custom/blacklisted_ip.html"
        echo ""
      fi

      _echo "$(msg cyan)Testing CSF after changing configuration ...$(msg end)" --name
      while :; do
        inst_result=$(perl /usr/local/csf/bin/csftest.pl | tail -n 1 | grep -c 'RESULT: csf should function on this server')
        if [ "${inst_result}" != "1" ]; then
          _echo "$(msg red)Error, CSF installation test did not pass. Re-testing CSF installation in 5 seconds ...$(msg end)" --name
          sleep 5
        else
          _echo "$(msg green)OK, CSF installation test passed! Installing CSF for Directadmin ...$(msg end)" --name
          break
        fi
      done
      echo ""
      _echo "$(msg cyan)Starting CSF and LFD for the first time ...$(msg end)" --name
      _echo "$(msg cyan)Before we start it up, please confirm that your sshd port is listed in this output:$(msg end)" --name
      echo "-----------------"
      grep ^TCP_IN /etc/csf/csf.conf
      echo ""
      _echo "$(msg cyan)If you do NOT see the port listed, press ctrl-c to immediately abort the script (you can add port missing port in maxinet.conf), then re-run this setup$(msg end)" --name
      _echo "$(msg cyan)If the port correctly added, press enter to continue$(msg end)" --name
      _pause 30
      if [ "${DISTRO_ID}" == "centos" ]; then
        _echo "$(msg cyan)Disabling built-in firewall (firewalld) in CentOS ...$(msg end)" --name
        systemctl disable firewalld
        systemctl stop firewalld
      elif [ "${DISTRO_ID}" == "debian" ]; then
        _echo "$(msg cyan)Disabling and removing firewall (ufw) in Debian ...$(msg end)" --name
        sudo ufw disable
        sudo apt-get -y remove ufw
        sudo apt-get -y purge ufw
      else
        _echo "$(msg red)Error, unknown value for distribution ID ${DISTRO_ID}. This distribution ID is not supported$(msg end)" --name
        _exit 147
      fi
      echo "-----------------"
      echo "[${SCRIPT_NAME}]: Starting CSF ..."
      systemctl start csf

      repair_services "csf" "lfd"
      # By default behaviour, LFD should start automatically when we run csf start
      # service lfd start

      # Since CSF is running without problem after the above check, we temporarily allow current host public IP
      # This is a temporary allowed IP during setup which won't be blocked by firewall.
      _echo "$(msg cyan)Temporarily allow IP ${LABEL_C_HOST_PUBLIC_IP} in /etc/etc/csf/csf.allow during setup in CSF$(msg end)" --name
      csf -a "${C_HOST_PUBLIC_IP}" "Added by ${SCRIPT_NAME} for ${C_BOX_HOSTNAME_FQHN} as temporary allowed IP during setup"
      # After that, the next step is requesting SSL and seems like the box need to restart
      # The reason it needs to restart here because if I don't restart at this point, the front page is not accessible (seems like port 80 is blocked)
      # If I don't restart at this point, I will not be able to renew cert (letsencrypt will produce error like firewall problem but it's not).
      # This is related to Ipv6 DAD. Look at function configure_da_ips() for more information
      # DAD disable is not working. Still need to restart system. Just restart it and resume later.
      #echo "[${SCRIPT_NAME}]: Creating reboot flag to restart system after installing CSF ..."
      #cat /dev/null >/var/run/reboot-required
      #echo "[${SCRIPT_NAME}]: Warning, system will reboot and you can run this script again to continue setup"
      #_pause
    else
      _echo "$(msg red)Error, cannot configure CSF because csf.conf is missing. Where the hell is /etc/csf/csf.conf? If the installer might be broken, please reinstall CSF$(msg end)" --name
      _exit 147
    fi
    # System will reboot automatically from above flag

    # TIPS. CSF can be removed with this command:
    #sh /etc/csf/uninstall.sh
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_sql() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    # Note that during installation MySQL generates a short password and da uses this root password. See the text message below:
    ##### MySQL root password seems to be unset, setting using MySQL queries...
    ####Setting password: SET PASSWORD FOR 'root'@'localhost' = PASSWORD('*******');
    # Mysql root password is also stored in setup.txt file
    local da_scripts_path mysql_on_my_cnf_etc mysql_on_my_cnf_da mysql_on_non_cnf mysql_granted my_cnf_db_root my_cnf_db_da_admin mysql_conf_db_da_admin \
      randomBlowfishSecret replace_pma_blowfish replace_pma_authtype retval loop_count grep_count mysql_authentication_test

    da_scripts_path="/usr/local/directadmin/scripts"
    mysql_conf_db_da_admin="/usr/local/directadmin/conf/mysql.conf"
    my_cnf_db_da_admin="/usr/local/directadmin/conf/my.cnf"
    my_cnf_db_root="/etc/my.cnf"

    # This mysqld method can be used only if correct password is supplied in /etc/my.cnf or blank password with no entries in /etc/my.cnf

    # Checking if mysqld binary exist
    _echo "$(msg cyan)Checking whether mysqld process is running ...$(msg end)" --name
    if [ "$(systemctl is-active mysqld)" == "active" ]; then
      :
    else
      _echo "$(msg red)Error, mysqld is not running. Please inspect why and re-run this script to continue$(msg end)" --name
      _exit 147
    fi
    echo ""
    _echo "$(msg cyan)Checking whether mysql is installed (binary file exist) ...$(msg end)" --name
    if ! command -v mysql &>/dev/null; then
      _echo "$(msg red)Error, mysql binary is not found. Please inspect why and re-run this script to continue$(msg end)" --name
      _exit 147
    fi
    echo ""
    _echo "$(msg cyan)Checking which mysql authentication to use ...$(msg end)" --name
    echo ""
    # 1) Test using mysql if it's running and can be authenticated.
    _echo "$(msg cyan)Testing mysql authentication using non .cnf file ...$(msg end)" --name
    mysql_on_non_cnf=$(
      mysql -e 'exit' 2>/dev/null
      echo $?
    )
    if [ "${mysql_on_non_cnf}" -eq 0 ]; then
      # In case password is empty then use this (normally initial setup server is empty but directadmin is not, so low chance this will be executed):
      mysql_granted="mysql -e"
      _echo "$(msg green)OK, the mysql will be authenticated without specifying config file with the following option: [ ${mysql_granted} ] ...$(msg end)" --name
    else
      _echo "$(msg yellow)Warning, failed to authenticate mysql using non .cnf file$(msg end)" --name
      echo ""
      # 2) Test using config password from /etc/my.cnf"
      _echo "$(msg cyan)Testing mysql authentication using non /etc/my.cnf file ...$(msg end)" --name
      mysql_on_my_cnf_etc=$(
        mysql --defaults-extra-file=${my_cnf_db_root} -e 'exit' 2>/dev/null
        echo $?
      )
      echo ""
      if [ "${mysql_on_my_cnf_etc}" -eq 0 ]; then
        mysql_granted="mysql --defaults-extra-file=${my_cnf_db_root} -e"
        _echo "$(msg green)OK, the mysql will be authenticated using ${my_cnf_db_root} with the following option: [ ${mysql_granted} ]  ...$(msg end)" --name

      else
        _echo "$(msg yellow)Warning, failed to authenticate mysql using /etc/my.cnf file$(msg end)" --name
        echo ""
        # 3) Test using config password from /usr/local/directadmin/conf/my.cnf
        _echo "$(msg cyan)Testing mysql authentication using non /usr/local/directadmin/conf/my.cnf file ...$(msg end)" --name
        mysql_on_my_cnf_da=$(
          mysql --defaults-extra-file=${my_cnf_db_da_admin} -e 'exit' 2>/dev/null
          echo $?
        )
        echo ""
        if [ "${mysql_on_my_cnf_da}" -eq 0 ]; then
          mysql_granted="mysql --defaults-extra-file=${my_cnf_db_da_admin} -e"
          _echo "$(msg green)OK, the mysql will be authenticated using ${my_cnf_db_da_admin} with the following option: [ ${mysql_granted} ] ...$(msg end)" --name
        #sleep 1
        else
          _echo "$(msg yellow)Warning, failed to authenticate mysql using /usr/local/directadmin/conf/my.cnf file$(msg end)" --name
          echo ""
          # If above not working I can use this: https://help.directadmin.com/item.php?id=45
          # or this: https://www.directadmin.com/features.php?id=2677
          _echo "$(msg red)Error, local SQL authentication is needed. If you know your root password, please supply it in ${my_cnf_db_root} or ${my_cnf_db_da_admin}$(msg end)" --name
          _echo "$(msg red)If you don't know, you may need to reset root password manually using this article: https://help.directadmin.com/item.php?id=45$(msg end)" --name
          _exit 147
        fi
      fi
    fi

    _echo "$(msg cyan)Changing mysql root password ...$(msg end)" --name
    ${mysql_granted} "ALTER USER 'root'@'localhost' IDENTIFIED BY '${C_DA_ROOT_SQLPASS}';"
    echo ""
    if [ -w "${my_cnf_db_root}" ]; then
      grep_count=$(grep -ic '^password=.*\|^password.*=.*' "${my_cnf_db_root}")
      #grep -ic '^password=.*\|^password.*=.*' /etc/my.cnf
      if [ "${grep_count}" = 0 ]; then
        # Appending the config, because password did not exist
        _echo "$(msg cyan)Updating new SQL root password in ${my_cnf_db_root} under [client] section ...$(msg end)" --name
        sed -i "s|\[client\]|&\npassword=${C_DA_ROOT_SQLPASS}|" "${my_cnf_db_root}"
      else
        _echo "$(msg cyan)Updating new SQL username root in ${my_cnf_db_root} ...$(msg end)" --name
        # Password already exist, we just replace
        sed -i "/\[client\]/,/^\[/ s/password=.*/password=${C_DA_ROOT_SQLPASS}/" "${my_cnf_db_root}"
      fi
      echo ""
      grep_count=$(grep -ic '^user=.*\|^user.*=.*' "${my_cnf_db_root}")
      if [ "${grep_count}" = 0 ]; then
        _echo "$(msg cyan)Writing new SQL root username in ${my_cnf_db_root} under [client] section ...$(msg end)" --name
        #sleep 1
        # Append under client because did not exist
        sed -i 's|\[client\]|&\nuser=root|' "${my_cnf_db_root}"
      else
        _echo "$(msg cyan)Updating SQL user to root in ${my_cnf_db_root} ...$(msg end)" --name
        # Already exist, so we replace
        sed -i "/\[client\]/,/^\[/ s/user=.*/user=root/" "${my_cnf_db_root}"
      fi
      echo ""

      grep_count=$(grep -ic '^bind-address=.*\|^bind-address.*=.*' "${my_cnf_db_root}")
      if [ "${grep_count}" = 0 ]; then
        _echo "$(msg cyan)Writing new config to disable mysql remote access in ${my_cnf_db_root} under [mysqld] section ...$(msg end)" --name
        # Append under client because not exist
        sed -i 's|\[mysqld\]|&\nbind-address=127.0.0.1|' "${my_cnf_db_root}"
      else
        _echo "$(msg cyan)Updating config to disable remote access in ${my_cnf_db_root} under [mysqld] section ...$(msg end)" --name
        # Already exist, but we replace
        sed -i "/\[mysqld\]/,/^\[/ s/bind-address=.*/bind-address=127.0.0.1/" "${my_cnf_db_root}"
      fi
    else
      _echo "$(msg red)Error, the file ${my_cnf_db_root} is missing. It should exist in that location if mysql is installed through directadmin$(msg end)" --name
      _exit 147
    fi
    echo ""

    _echo "$(msg cyan)Removing unsecured anonymous users from database ...$(msg end)" --name
    ${mysql_granted} "DELETE FROM mysql.user WHERE user='';"
    echo ""
    _echo "$(msg cyan)Removing root users from non-localhost for security ...$(msg end)" --name
    ${mysql_granted} "DELETE FROM mysql.user WHERE User='root' AND Host NOT IN ('localhost', '127.0.0.1', '::1');"
    echo ""
    _echo "$(msg cyan)Removing test database if exist for security ...$(msg end)" --name
    ${mysql_granted} "DROP DATABASE IF EXISTS test;"
    echo ""
    _echo "$(msg cyan)Flushing mysql privileges ...$(msg end)" --name
    ${mysql_granted} "FLUSH PRIVILEGES;"
    echo ""
    # There is no recommendation to change da_admin sql username to something else at this moment,
    # so ignore username change for sql, just change password.
    _echo "$(msg cyan)Changing Directadmin da_admin default SQL password ...$(msg end)" --name
    ${mysql_granted} "ALTER USER 'da_admin'@'localhost' IDENTIFIED BY '${C_DA_ADMIN_SQLPASS}';"
    echo ""
    _echo "$(msg cyan)Updating da_admin SQL authentication information at ${mysql_conf_db_da_admin} ...$(msg end)" --name
    if [ -s ${mysql_conf_db_da_admin} ]; then
      sed -i "s/^passwd=.*/passwd=${C_DA_ADMIN_SQLPASS}/" ${mysql_conf_db_da_admin}
    else
      echo -n '' >${mysql_conf_db_da_admin}
      chmod 600 ${mysql_conf_db_da_admin}
      chown diradmin:diradmin ${mysql_conf_db_da_admin}
      echo "user=da_admin" >>${mysql_conf_db_da_admin}
      echo "passwd=${C_DA_ADMIN_SQLPASS}" >>${mysql_conf_db_da_admin}
    fi
    echo ""
    _echo "$(msg cyan)Updating da_admin SQL authentication information at ${my_cnf_db_da_admin} ...$(msg end)" --name
    if [ -s ${my_cnf_db_da_admin} ]; then
      sed -i "s/^password=.*/password=${C_DA_ADMIN_SQLPASS}/" ${my_cnf_db_da_admin}
    else
      echo -n '' >${my_cnf_db_da_admin}
      chmod 600 ${my_cnf_db_da_admin}
      chown diradmin:diradmin ${my_cnf_db_da_admin}
      echo "[client]"
      echo "user=da_admin" >>${my_cnf_db_da_admin}
      echo "password=${C_DA_ADMIN_SQLPASS}" >>${my_cnf_db_da_admin}
    fi

    echo ""
    mysql_authentication_test=$(
      mysql -e 'exit'
      echo $?
    )

    if [ "${mysql_authentication_test}" -eq 0 ]; then
      _echo "$(msg green)OK, mysql local system authentication test was correctly setup!$(msg end)" --name
    else
      _echo "$(msg red)Error, mysql local system authentication test was failed! Please inspect why and re-run this setup again$(msg end)" --name
      _exit 147
    fi
    echo ""

    _echo "$(msg cyan)Backing up original phpmyadmin config.inc.php at /var/www/html/phpMyAdmin as config.inc.php_original_${DATE_TIME_NOW}...$(msg end)" --name
    cp -p "/var/www/html/phpMyAdmin/config.inc.php" "/var/www/html/phpMyAdmin/config.inc.php_backup_original_${DATE_TIME_NOW}"
    echo ""

    if [ ! -f /var/www/html/phpMyAdmin/config.inc.php ]; then
      _echo "$(msg red)Error, phpMyAdmin config file /var/www/html/phpMyAdmin/config.inc.php is missing. Please inspect manually and re-run this script to continue$(msg end)" --name
      _exit 147
    fi
    # Enabling cookie authentication (so that we can use htpasswd for this)
    # To enable cookie authentication we need to have blow fish string
    # Some character might break sed like '/' so we don't want this character because this character can have problem later on.
    # No need to escape https://stackoverflow.com/questions/65528031/how-to-generate-openssl-blowfish-without-certain-characters-or-allow-certain-set
    _echo "$(msg cyan)Generating new blowfish secret key for phpMyAdmin in config.inc.php ...$(msg end)" --name
    loop_count=0
    while :; do
      ((loop_count++))
      randomBlowfishSecret=$(openssl rand -base64 32)
      replace_pma_blowfish="\$cfg['blowfish_secret'] = '${randomBlowfishSecret}'; \/* YOU MUST FILL IN THIS FOR COOKIE AUTH! *\/"
      sed -i "s/\$cfg\[.blowfish_secret.\]\s*=.*/${replace_pma_blowfish}/" /var/www/html/phpMyAdmin/config.inc.php 2>/dev/null
      retval=$?
      if [ "${retval}" = 0 ]; then
        _echo "$(msg green)OK, successfully inserted blowfish secret key into /var/www/html/phpMyAdmin/config.inc.php after ${loop_count} retry(s)$(msg end)" --name
        break
      fi
    done
    # Warning only use cookie authentication for development
    _echo "$(msg cyan)Setting phpMyAdmin authentication from http to cookie in config.inc.php to enable page login and httpd protection ...$(msg end)" --name
    replace_pma_authtype="\$cfg['Servers'][\$i]['auth_type'] = 'cookie';"
    sed -i "s/\$cfg\['Servers'\]\[\$i\]\['auth_type'\] = 'http';/${replace_pma_authtype}/" /var/www/html/phpMyAdmin/config.inc.php

    echo ""

    # We can setup theme for directadmin here.
    # For custom phpMyAdmin theme (not using theme yet). Theme we must get it from maxinet
    # echo "[${SCRIPT_NAME}]: Setting up phpMyAdmin custom themes ..."

    # cp -p "phpMyAdmin_theme_from_maxinet_called_sofibox" into "/var/www/html/phpMyAdmin/themes/sofibox"
    # Temporarily no theme yet. In the future put theme here
    # And all the themes must have this permissions:
    # chmod 644 for files, chmod 755 for folders
    # And all must have this users:
    #chown webapps:webapps /var/www/html/phpMyAdmin/themes/*

    # This is used to fix problem with phpMyAdmin Storage: https://help.directadmin.com/item.php?id=564
    _echo "$(msg cyan)Creating phpMyAdmin configuration storage database ...$(msg end)" --name
    navigate_path "${INST_TEMP_DIR}"
    _echo "$(msg cyan)Removing existing create_tables.sh file ...$(msg end)" --name

    rm -f create_tables.sh
    echo ""
    _echo "$(msg cyan)Downloading create_tables.sh file ...$(msg end)" --name
    wget --no-verbose -O create_tables.sh http://files1.directadmin.com/services/all/phpMyAdmin/create_tables.sh
    chmod 755 create_tables.sh
    _echo "$(msg cyan)Executing create_tables.sh to create phpMyAdmin configuration storage database ...$(msg end)" --name
    ./create_tables.sh
    echo ""

    #[Sample my.cnf at /etc/my.cnf](https://gitlab.com/arafatx/sofibox-luks-earth/-/blob/master/etc/my.cnf)

    # Another alternative way to change directadmin da_admin SQL password:
    #_echo "$(msg cyan)Changing Directadmin da_admin SQL password using directadmin script reset_da_admin_password.sh ... $(msg end)" --name
    # This script requires that we have root or da_admin password in setup.txt or defined in cnf, else it's not working
    #${da_scripts_path}/reset_da_admin_password.sh --password "${C_DA_ADMIN_SQLPASS}"
    #retval=$?
    #echo "${retval}"

    # Create mysql symlink here to home directory to solve system backup issue on mysql
    # https://forum.directadmin.com/threads/system-backup-mysql-problem.57146/
    echo ""
    _echo "$(msg cyan)Fixing issue with sql system backup in directadmin ...$(msg end)" --name
    if [[ "${DISTRO_ID}" == "debian" ]]; then
      local mysql_path
      mysql_path="/var/lib/mysql"
      check_path "${mysql_path}"
      echo ""
      _echo "$(msg cyan)Removing previous symlink file ...$(msg end)" --name
      # Don't use -r because this is just a file of symlink
      rm -f /home/mysql
      get_status_message "$?"
      echo ""
      _echo "$(msg cyan)Creating symlink from /var/lib/mysql to /home/mysql to resolve sql system backup issue ...$(msg end)" --name
      ln -s /var/lib/mysql /home/mysql
      get_status_message "$?"
    else
      echo "[Skipped]: Note check if this distribution ID ${DISTRO_ID} has mysql symlink to /home/mysql if it has issue with sql system backup?"
      _confirm
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This will configure everything about sql security
# Also configure https route for phpmyadmin here
configure_da_sql_security() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local httpd_alias_conf
    httpd_alias_conf="/etc/httpd/conf/extra/httpd-alias.conf"
    _echo "$(msg cyan)Configuring sql security ...$(msg end)" --name
    echo ""
    # Important, this will make the phpmyadmin connection using SSL, so at this point phpmyadmin might not accessible or has certificate error because SSL is needed
    # Setup will install SSL in another function
    # Configuring phpmyadmin htaccess
    _echo "$(msg cyan)Creating https redirection .htaccess for mysql management (phpMyAdmin) ...$(msg end)" --name
    touch /var/www/html/phpMyAdmin/.htaccess
    {
      echo "RewriteEngine On"
      echo "RewriteCond %{HTTPS} !=on"
      echo "RewriteRule ^/?(.*) https://%{SERVER_NAME}${C_PHPMYADMIN_LOGIN_ROUTE}\$1 [R=301,L]"
    } >/var/www/html/phpMyAdmin/.htaccess
    chmod 644 /var/www/html/phpMyAdmin/.htaccess
    chown webapps:webapps /var/www/html/phpMyAdmin/.htaccess
    echo ""
    # This is just temporary, in order to test whether phpmyadmin URL is working (this will be rebuild by the function configure_server_security())
    if [ "${C_PHPMYADMIN_SECURE_ROUTE}" == "true" ]; then
      _echo "$(msg yellow)Warning, C_PHPMYADMIN_SECURE_ROUTE is set to true, so you will not be able to use custom route for phpmyadmin set in config file at this point$(msg end)" --name
    else
      _echo "$(msg cyan)Adding a temporary phpmyadmin custom URL route to ${LABEL_C_PHPMYADMIN_LOGIN_ROUTE} ...$(msg end)" --name
      {
        echo "# PHPMYADMIN custom URL (temporary):"
        echo "Alias ${C_PHPMYADMIN_LOGIN_ROUTE} \"/var/www/html/phpMyAdmin/\""
      } >>"${httpd_alias_conf}"
    fi
    echo ""
    restart_da_web_server
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This configure_da_mail can be roundcube squirrelmail or others
configure_da_mail() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local rc_index_file
    rc_index_file="/var/www/html/roundcube/index.php"
    if [ -f ${rc_index_file} ]; then
      local grep_count rc_version my_cnf_rc_file rc_config_file rc_built_in_plugins \
        replace_rc_authconf replace_rc_prodname replace_rc_rcguard_recaptcha_privatekey replace_rc_rcguard_recaptcha_publickey

      rc_version=$(grep '| Version' /var/www/html/roundcube/index.php | awk '{ print $3 }')
      my_cnf_rc_file="/var/www/html/roundcube/config/my.cnf"
      rc_config_file="/var/www/html/roundcube/config/config.inc.php"
      _echo "$(msg cyan)Roundcube version ${rc_version} has been detected installed in the system$(msg end)" --name
      echo ""
      _echo "$(msg cyan)Backing up roundcube config at ${rc_config_file} as config.inc.php_original_${DATE_TIME_NOW}...$(msg end)" --name
      cp -p "${rc_config_file}" "${rc_config_file}_backup_original_${DATE_TIME_NOW}"
      echo ""
      # By default roundcube is installed with a very short and weak password. We need to change the password to secured one
      # Remember roundcube password cannot contains character '@ , & and :' because config.inc.php use this separator and won't accept that password.
      _echo "$(msg cyan)Changing da_roundcube password in user database ...$(msg end)" --name
      mysql -e "ALTER USER 'da_roundcube'@'localhost' IDENTIFIED BY '${C_DA_ROUNDCUBE_SQLPASS}'; FLUSH PRIVILEGES;"
      echo ""
      _echo "$(msg cyan)Updating da_roundcube password in config.inc.php ...$(msg end)" --name
      replace_rc_authconf="\$config['db_dsnw'] = 'mysql:\/\/da_roundcube:${C_DA_ROUNDCUBE_SQLPASS}@localhost\/da_roundcube';"
      sed -i "s/\$config\[.db_dsnw.\]\s*=.*/${replace_rc_authconf}/" "${rc_config_file}"
      echo ""
      _echo "$(msg cyan)Changing roundcube product name in config.inc.php for display purpose ...$(msg end)" --name
      replace_rc_prodname="\$config['product_name'] = '${C_ROUNDCUBE_CUSTOM_NAME}';"
      sed -i "s/\$config\[.product_name.\]\s*=.*/${replace_rc_prodname}/" "${rc_config_file}"
      echo ""

      grep_count=$(grep -ic "\$config\['force_https'\]" "${rc_config_file}")
      if [ "${grep_count}" = 0 ]; then
        _echo "$(msg cyan)Enabling force_https for roundcube at config.inc.php ...$(msg end)" --name
        #sleep 1
        echo "\$config['force_https'] = true;" >>"${rc_config_file}"
      else
        _echo "$(msg yellow)[Skipped]: The force_https has already been set in roundcube setting config.inc.php previously$(msg end)" --name
      fi
      echo ""
      if [ -s "${my_cnf_rc_file}" ]; then
        _echo "$(msg cyan)Updating SQL da_roundcube username in ${my_cnf_rc_file} ...$(msg end)" --name
        sed -i "/\[client\]/,/^\[/ s/user=.*/user=da_roundcube/" "${my_cnf_rc_file}"
        echo ""
        _echo "$(msg cyan)Updating SQL da_roundcube password in ${my_cnf_rc_file} ...$(msg end)" --name
        sed -i "/\[client\]/,/^\[/ s/password=.*/password=${C_DA_ROUNDCUBE_SQLPASS}/" ${my_cnf_rc_file}
      else
        # If no file was created, we write this file for my.cnf (roundcube auth sql config)
        echo -n '' >${my_cnf_rc_file}
        chmod 600 ${my_cnf_rc_file}
        chown diradmin:diradmin ${my_cnf_rc_file}
        echo "[client]"
        echo "user=da_roundcube" >>${my_cnf_rc_file}
        echo "password=${C_DA_ROUNDCUBE_SQLPASS}" >>${my_cnf_rc_file}
      fi

      _echo "$(msg cyan)Enabling some roundcube built-in plugins ...$(msg end)" --name
      # You can add extra plugin here inside this array:
      rc_built_in_plugins=("'password',"
        "'archive',"
        "'zipdownload',"
        "'newmail_notifier',"
        "'managesieve',"
        "'markasjunk',"
        "'emoticons',"
        "'attachment_reminder',"
        "'new_user_dialog',"
      )
      #printf "%s\n" "${rc_built_in_plugins[@]}"
      for rc_built_in_plugin in "${rc_built_in_plugins[@]}"; do
        grep_count=$(grep -ic "${rc_built_in_plugin}" "${rc_config_file}")
        if [ "${grep_count}" -eq 0 ]; then
          # Use this code and loop above rc_plugins must be array
          _echo "$(msg cyan)Adding ${rc_built_in_plugin} into roundcube plugin list ...$(msg end)" --name
          sed -i "s|\$config\[.plugins.\] = array(|&\n    ${rc_built_in_plugin}|" "${rc_config_file}"
        else
          _echo "$(msg yellow)[Skipped] The plugin ${rc_built_in_plugin} has already been set in ${rc_config_file}$(msg end)" --name
        fi
      done
      echo ""
      _echo "$(msg cyan)Installing roundcube 3rd party plugins ...$(msg end)" --name
      # Here we install roundcube 3rd party plugins
      if [ "${C_ENABLE_ROUNDCUBE_RCGUARD}" == "true" ]; then
        # I posted bug here: https://github.com/dsoares/roundcube-rcguard/issues/39, but just that server restart fixed the problem

        #sleep 1
        navigate_path "/var/www/html/roundcube/plugins/"
        _echo "$(msg cyan)Removing existing rcguard plugin for roundcube ...$(msg end)" --name
        rm -rf rcguard
        echo ""
        _echo "$(msg cyan)Installing rcguard (Google recaptcha) to protect roundcube ...$(msg end)" --name
        GIT_SSL_NO_VERIFY=true git clone https://github.com/dsoares/rcguard.git rcguard
        chown -R webapps:webapps rcguard/
        chmod 755 rcguard
        navigate_path "/var/www/html/roundcube/plugins/rcguard/"
        find . -type d -exec chmod 0755 {} \;
        find . -type f -exec chmod 0644 {} \;
        mv config.inc.php.dist config.inc.php
        echo ""

        _echo "$(msg cyan)Configuring rcguard recaptcha_publickey in config.inc.php ...$(msg end)" --name
        replace_rc_rcguard_recaptcha_publickey="\$config['recaptcha_publickey'] = '${C_GOOGLE_RECAPTCHA_SITE_V2}';"
        sed -i "s/\$config\[.recaptcha_publickey.\]\s*=.*/${replace_rc_rcguard_recaptcha_publickey}/" /var/www/html/roundcube/plugins/rcguard/config.inc.php
        echo ""
        _echo "$(msg cyan)Configuring rcguard recaptcha_privatekey in config.inc.php ...$(msg end)" --name
        replace_rc_rcguard_recaptcha_privatekey="\$config['recaptcha_privatekey'] = '${C_GOOGLE_RECAPTCHA_SECRET_V2}';"
        sed -i "s/\$config\[.recaptcha_privatekey.\]\s*=.*/${replace_rc_rcguard_recaptcha_privatekey}/" /var/www/html/roundcube/plugins/rcguard/config.inc.php
        echo ""
        _echo "$(msg cyan)Creating mysql table for rcguard ...$(msg end)" --name
        # The plugin already provide initial script to create rcguard table in roundcube. So we can just add this sql file under da_roundcube username
        mysql da_roundcube </var/www/html/roundcube/plugins/rcguard/SQL/mysql.initial.sql
        echo ""
        # Add rcguard plugin into roundcube config if doesn't exist
        grep_count=$(grep -ic "'rcguard'," ${rc_config_file})
        if [ "${grep_count}" -eq 0 ]; then
          # Use this code and loop above rc_plugins must be array
          _echo "$(msg cyan)Adding 'rcguard', into roundcube plugin list ...$(msg end)" --name
          sed -i "s|\$config\[.plugins.\] = array(|&\n    'rcguard',|" ${rc_config_file}
        else
          _echo "$(msg yellow)[Skipped] The plugin 'rcguard', has already been set in ${rc_config_file}$(msg end)" --name
        fi

      else
        _echo "$(msg yellow)[Skipped]: rcguard plugin installation config C_ENABLE_ROUNDCUBE_RCGUARD is not set to true$(msg end)" --name
      fi
    else
      _echo "$(msg cyan)[Skipped]: Warning, unable to detect roundcube version (${rc_index_file} was missing)$(msg end)" --name
    fi
    # configure other mail here, like squirrelmail from here
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This will add another extra scurity for email config or settings
# This also will configure custom route for mail app like roundcube
configure_da_mail_security() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local httpd_alias_conf
    httpd_alias_conf="/etc/httpd/conf/extra/httpd-alias.conf"
    _echo "$(msg cyan)Configuring mail security ...$(msg end)" --name
    echo ""
    # This is just temporary, in order to test whether roundcube custom URL is working (this will be rebuild by the function configure_server_security())
    if [ "${C_ROUNDCUBE_SECURE_ROUTE}" == "true" ]; then
      _echo "$(msg yellow)Warning, C_ROUNDCUBE_SECURE_ROUTE is set to true, so you will not be able to use custom route for roundcube set in config file at this point$(msg end)" --name
    else
      _echo "$(msg cyan)Adding a temporary roundcube custom URL route to ${LABEL_C_ROUNDCUBE_SECURE_ROUTE} ...$(msg end)" --name
      {
        echo "# ROUNDCBE custom URL (temporary):"
        echo "Alias ${C_ROUNDCUBE_LOGIN_ROUTE} \"/var/www/html/roundcube/\""
      } >>"${httpd_alias_conf}"
    fi
    echo ""
    restart_da_web_server
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_ftp() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    if [ "${C_DA_CB_FTP_SOFTWARE}" == "pureftpd" ]; then
      local grep_count
      _echo "$(msg cyan)Setting up pure-ftpd to use log at /var/log/pureftpd.log ...$(msg end)" --name
      grep_count=$(grep -ic '\-\/var\/log\/pureftpd\.log' /etc/rsyslog.conf)
      if [ "${grep_count}" -eq 0 ]; then
        printf "ftp.*\t\t\t\t-/var/log/pureftpd.log\n" >>/etc/rsyslog.conf
      else
        _echo "$(msg yellow)[Skipped]: Found ftp log entry '-/var/log/pureftpd.log' at /etc/ryslog.conf$(msg end)" --name
      fi
    elif [ "${C_DA_CB_FTP_SOFTWARE}" == "proftpd" ]; then
      _echo "$(msg yellow)[Skipped]: FTP software proftpd configuration is not yet implemented$(msg end)" --name
    else
      _echo "$(msg yellow)[Skipped]: FTP software ${C_DA_CB_FTP_SOFTWARE} configuration is not yet implemented$(msg end)" --name
    fi
    # No need to remove ftp log from rsyslog.conf using ftp.none because DA BFM and LFD from CSF needs the log to auto block
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This function will configure server (nginx, apache, nginx_apache) for security
# Example creating alias name for db, mail, setting up server for production and more
configure_server_security() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local httpd_alias_conf httpd_include_conf httpd_default_conf
    httpd_alias_conf="/etc/httpd/conf/extra/httpd-alias.conf"
    httpd_include_conf="/etc/httpd/conf/extra/httpd-includes.conf"
    httpd_default_conf="/etc/httpd/conf/extra/httpd-default.conf"

    check_path "${httpd_alias_conf}" "${httpd_include_conf}" "${httpd_default_conf}"

    _echo "$(msg cyan)Backing up original httpd-alias.conf at /etc/httpd/ as httpd-alias.conf_backup_original_${DATE_TIME_NOW} ...$(msg end)" --name
    cp -p "${httpd_alias_conf}" "${httpd_alias_conf}_backup_original_${DATE_TIME_NOW}"
    echo ""
    _echo "$(msg cyan)Writing httpd custom config for httpd-alias.conf in ${httpd_alias_conf} ...$(msg end)" --name
    {
      echo "# ==============================================="
      echo "# This configuration file was generated by ${SCRIPT_NAME}"
      echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
      echo "# ==============================================="
      echo "RewriteEngine On"
      echo "Alias /config \"/var/www/html/redirect.php\""
      echo "Alias /.well-known/acme-challenge \"/var/www/html/.well-known/acme-challenge\""
      echo ""
      # Here we can specify what URL should be blocked (with 404.html page)
      echo "# BLOCKED common route for security:"
      echo "Alias /phpMyAdmin \"/var/www/html/server/error_docs/404.html\""
      echo "Alias /phpmyadmin \"/var/www/html/server/error_docs/404.html\""
      echo "Alias /pma \"/var/www/html/server/error_docs/404.html\""
      echo "Alias /squirrelmail \"/var/www/html/server/error_docs/404.html\""
      echo "Alias /webmail \"/var/www/html/server/error_docs/404.html\""
      echo "Alias /roundcube \"/var/www/html/server/error_docs/404.html\""
      echo ""
      echo "# CUSTOM URLs:"
      echo "# PHPMYADMIN custom URL:"
      echo "Alias ${C_PHPMYADMIN_LOGIN_ROUTE} \"/var/www/html/phpMyAdmin/\""
      echo "# ROUNDCUBE custom URL:"
      echo "Alias ${C_ROUNDCUBE_LOGIN_ROUTE} \"/var/www/html/roundcube/\""
      echo "# HTPASSWD secure directories:"
      echo ""
    } >"${httpd_alias_conf}"
    echo ""

    if [ "${C_SECURE_LOGIN_ROUTE}" == "true" ]; then
      if command -v htpasswd &>/dev/null; then
        # Create htpasswd for phpmyadmin URL: (only create user information but not enabled it)
        _echo "$(msg cyan)Creating httpasswd for restricting phpMyAdmin URL route ... $(msg end)" --name
        # Supply -c for first user, this will produce sensitive output with standard error, hide with 2>
        htpasswd -b -c /etc/httpd/.htpasswd "${C_HTTPASSWD_PHPMYADMIN_USERNAME}" "${C_HTTPASSWD_PHPMYADMIN_PASS}" 2>/dev/null
        echo ""
        #only create user information but not enabled it
        _echo "$(msg cyan)Creating httpasswd for restricting roundcube URL route ... $(msg end)" --name
        # Don't supply -c for next user (if supply -c, it will replace the previous one), this will produce sensitive output with standard error, hide with 2>
        htpasswd -b /etc/httpd/.htpasswd "${C_HTTPASSWD_ROUNDCUBE_USERNAME}" "${C_HTTPASSWD_ROUNDCUBE_PASS}" 2>/dev/null
        echo ""
        _echo "$(msg cyan)Correcting the permission of /etc/httpd/.htpasswd ... $(msg end)" --name
        chown apache:apache /etc/httpd/.htpasswd
        chmod +r /etc/httpd/.htpasswd
        echo ""
      else
        _echo "$(msg red)Error, htpasswd binary does not exist! Make sure it exist and rerun this setup again$(msg end)" --name
        _exit 147
      fi
      _echo "$(msg cyan)Protecting phpMyAdmin and roundcube with htpasswd because C_SECURE_LOGIN_ROUTE is se to true ...$(msg end)" --name
      {
        echo "#Protect phpMyAdmin directory:"
        echo "<Directory \"/var/www/html/phpMyAdmin/\">"
        echo "#AllowOverride AuthConfig"
        echo "AuthType Basic"
        echo "AuthName \"${C_BOX_HOSTNAME_FQHN}": DB-Auth\"
        echo "AuthUserFile /etc/httpd/.htpasswd"
        echo "Require user ${C_HTTPASSWD_PHPMYADMIN_USERNAME}"
        echo "</Directory>"
        echo ""
        echo "#Protect roundcube directory:"
        echo "<Directory \"/var/www/html/roundcube/\">"
        echo "#AllowOverride AuthConfig"
        echo "AuthType Basic"
        echo "AuthName \"${C_BOX_HOSTNAME_FQHN}": Mail-Auth\"
        echo "AuthUserFile /etc/httpd/.htpasswd"
        echo "Require user ${C_HTTPASSWD_ROUNDCUBE_USERNAME}"
        echo "</Directory>"
      } >>"${httpd_alias_conf}"

    else
      _echo "$(msg cyan)[Skipped]: C_SECURE_LOGIN_ROUTE is not set. Custom URL routes are not protected$(msg end)" --name

    fi
    echo ""
    ######## Temporarily disable this because we do not need to force redirection (might have issue), just backup
    _echo "$(msg cyan)Backing up original httpd-includes.conf at ${httpd_include_conf} as ${httpd_include_conf}_backup_original_${DATE_TIME_NOW} ...$(msg end)" --name
    cp -p "${httpd_include_conf}" "${httpd_include_conf}_backup_original_${DATE_TIME_NOW}"

    ## It is a new file, so we make sure it is exist
    #cat /dev/null >"${httpd_include_conf}"
    # _echo "$(msg cyan)Writing https redirection for all routes in httpd-includes.conf ...$(msg end)" --name
    #{
    #  # Make https for all directories (This will take over force https setting at Directadmin)
    #  echo "# ==============================================="
    #  echo "# This configuration file was generated by ${SCRIPT_NAME}"
    #  echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
    #  echo "# ==============================================="
    #  echo "<location /*>"
    #  echo "RewriteEngine On"
    #  echo "RewriteCond %{HTTPS} off"
    #  echo "RewriteRule (.*) https://%{HTTP_HOST}%{REQUEST_URI}"
    #  echo "</location>"
    #} >>${httpd_include_conf}
    #echo ""

    # This will set server for production
    _echo "$(msg cyan)Backing up original httpd-default.conf at ${httpd_default_conf} as ${httpd_default_conf}_backup_original_${DATE_TIME_NOW} ...$(msg end)" --name
    cp -p "${httpd_default_conf}" "${httpd_default_conf}_backup_original_${DATE_TIME_NOW}"
    echo ""
    _echo "$(msg cyan)Customizing server config at ${httpd_default_conf} ...$(msg end)" --name
    sed -i 's|^ServerTokens .*|ServerTokens Prod|' ${httpd_default_conf}
    sed -i 's|^ServerSignature .*|ServerSignature Off|' ${httpd_default_conf}
    echo ""
    # Restarting web server based on config file ( do not rewrite_confs because that command will replace everything to default )
    # Warning, do not run rewrite_confs at this point until configure_da_custom_configs() is called.
    _echo "$(msg cyan)Requesting to restart web server ...$(msg end)" --name
    restart_da_web_server
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This function will create / copy all custom configs like roundcube, phpmyadmin, apache etc in DA custom folder
# So when we update Directadmin, it won't replace these files.
configure_da_custom_configs() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    # This will build custom config for DA with secured settings
    local da_conf da_bin da_cb_bin da_cb_custom_conf_path httpd_alias_conf httpd_include_conf phpmyadmin_path roundcube_path

    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    da_cb_custom_conf_path="/usr/local/directadmin/custombuild/custom"
    httpd_alias_conf="/etc/httpd/conf/extra/httpd-alias.conf"
    httpd_include_conf="/etc/httpd/conf/extra/httpd-includes.conf"
    httpd_default_conf="/etc/httpd/conf/extra/httpd-default.conf"
    phpmyadmin_path="/var/www/html/phpMyAdmin"
    roundcube_path="/var/www/html/roundcube"

    mkdir -p "${da_cb_custom_conf_path}"

    _echo "$(msg cyan)Checking required paths ...$(msg end)" --name
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}" "${da_cb_custom_conf_path}" "${httpd_alias_conf}" "${httpd_include_conf}" "${httpd_default_conf}" "${phpmyadmin_path}" "${phpmyadmin_path}"
    echo ""

    # For apache2 (ap2)
    # 1) create custom folder at /usr/local/directadmin/custombuild/custom/ap2/conf/extra
    _echo "$(msg cyan)Creating a custom config folder for apache/httpd (ap2) at ${da_cb_custom_conf_path}/ap2/conf/extra ...$(msg end)" --name
    mkdir -p "${da_cb_custom_conf_path}/ap2/conf/extra"
    echo ""
    _echo "$(msg cyan)Copying httpd-alias.conf into DA custom ap2 folder ...$(msg end)" --name
    cp -p "${httpd_alias_conf}" "${da_cb_custom_conf_path}/ap2/conf/extra/httpd-alias.conf"
    echo ""
    _echo "$(msg cyan)Copying httpd-includes.conf into ${da_cb_custom_conf_path}/ap2/conf/extra/httpd-includes.conf ...$(msg end)" --name
    cp -p "${httpd_include_conf}" "${da_cb_custom_conf_path}/ap2/conf/extra/httpd-includes.conf"
    echo ""

    _echo "$(msg cyan)Copying httpd-default.conf into ${da_cb_custom_conf_path}/ap2/conf/extra/httpd-default.conf ...$(msg end)" --name
    cp -p "${httpd_default_conf}" "${da_cb_custom_conf_path}/ap2/conf/extra/httpd-default.conf"
    echo ""

    # 2 For phpmyadmin custom config
    _echo "$(msg cyan)Creating a custom config folder for phpMyAdmin at ${da_cb_custom_conf_path}/phpMyAdmin ...$(msg end)" --name
    mkdir -p "${da_cb_custom_conf_path}/phpmyadmin"
    echo ""
    # .htaccess
    _echo "$(msg cyan)Copying phpMyAdmin .htaccess into phpmyadmin DA custom folder ...$(msg end)" --name
    cp -p "/var/www/html/phpMyAdmin/.htaccess" "/usr/local/directadmin/custombuild/custom/phpmyadmin/.htaccess"
    echo ""
    # config.inc.php
    _echo "$(msg cyan)Copying original phpmyadmin config from ${phpmyadmin_path}/config.inc.php into ${da_cb_custom_conf_path}/phpmyadmin/config.inc.php ...$(msg end)" --name
    #sleep 1
    cp -p "${phpmyadmin_path}/config.inc.php" "${da_cb_custom_conf_path}/phpmyadmin/config.inc.php"
    echo ""

    # For custom phpMyAdmin theme (not using theme yet) leave this comment until I have new custom theme
    #mkdir -p /usr/local/directadmin/custombuild/custom/phpmyadmin/themes
    #echo "[${SCRIPT_NAME}]: Copying custom phpMyAdmin themes ..."
    #cp -p "/var/www/html/phpMyAdmin/themes/sofibox" "/usr/local/directadmin/custombuild/custom/phpmyadmin/themes/sofibox"
    #sleep 1

    #3 - For main roundcube (2 important files: config.inc.php, my.cnf)
    _echo "$(msg cyan)Creating a custom config folder for roundcube at ${da_cb_custom_conf_path}/roundcube ...$(msg end)" --name
    mkdir -p "${da_cb_custom_conf_path}/roundcube"
    echo ""
    _echo "$(msg cyan)Copying original roundcube config from into DA roundcube custom folder ...$(msg end)" --name
    #sleep 1
    cp -p "${roundcube_path}/config/config.inc.php" "${da_cb_custom_conf_path}/roundcube/config.inc.php"
    echo ""
    # Remember when rebuild roundcube ./build roundcube DA will automatically update my.cnf. Don't touch that.
    # I wrote answer here: https://forum.directadmin.com/threads/script-to-reset-da_admin-da_roundcube-password.57101/#post-324944

    #4 - For roundcube rcguard plugin (copy the whole folder)
    _echo "$(msg cyan)Creating a custom config folder for roundcube plugins ${da_cb_custom_conf_path}/roundcube/plugins ...$(msg end)" --name
    mkdir -p /usr/local/directadmin/custombuild/custom/roundcube/plugins/
    echo ""
    _echo "$(msg cyan)Copying custom roundcube custom plugins ...$(msg end)" --name
    cp -p -r ${roundcube_path}/plugins/rcguard ${da_cb_custom_conf_path}/roundcube/plugins/
    echo ""

    #n - For others later in here

    # TODO if problem with modsecurity use this custom config (monitoring this):
    #    cd /usr/local/directadmin/custombuild/
    #mkdir -p custom/nginx_reverse/conf/
    #[ -f "custom/nginx_reverse/conf/nginx-modsecurity.conf" ] || cp -p configure/nginx_reverse/conf/nginx-modsecurity.conf custom/nginx_reverse/conf/nginx-modsecurity.conf
    #perl -pi -e "s/^SecDefaultAction /#SecDefaultAction /" custom/nginx_reverse/conf/nginx-modsecurity.conf
    #./build rewrite_confs

    #n-Create custom php ini file here (create custom php ini file here with the following information) -- what is the purpose? find it out
    # increase memory consumption or upload sql size, make custom path in custom/php.conf.d
    #https://forum.directadmin.com/threads/solved-customized-50-webapps-ini-and-10-directadmin-ini.61045/#post-312326

    # at the end must do build phpmyadmin, roundcube, rewrite_confs to save httpd changes.
    # Need to rebuild this because previously we change config.inc.php. Better rebuild for new setting.
    _echo "$(msg cyan)Rebuilding phpMyAdmin for new settings ...$(msg end)" --name
    ${da_cb_bin} phpmyadmin
    echo ""
    _echo "$(msg cyan)Rebuilding roundcube for new settings ...$(msg end)" --name
    ${da_cb_bin} roundcube
    echo ""
    _echo "$(msg cyan)Rebuilding server configs for new settings ...$(msg end)" --name
    ${da_cb_bin} rewrite_confs 1>/dev/null 2>/dev/null

    # Rebuilding other directadmin package more starting here if needed ...
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Configure apps in /var/www/html
configure_web_apps() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local c_ipv4add0_escaped
    c_ipv4add0_escaped="${C_IPV4_ADD0//./\\.}"
    _echo "$(msg cyan)Writing .htaccess rule at /var/www/html/.htaccess ...$(msg end)" --name
    {
      echo "DirectoryIndex index.php index.html"
      echo "RewriteEngine On"
      echo "DirectoryIndex index.php index.html"
      echo ""
      echo "# First condition if IP is given, redirect to hostname"
      echo "RewriteCond %{HTTP_HOST} ^${c_ipv4add0_escaped}(:[0-9]+)?\$"
      echo "RewriteRule ^(.*)$ https://${C_BOX_HOSTNAME_FQHN}/\$1 [L,R=301]"
      echo ""

      echo "# Second condition, if https is off, redirect to"
      echo "RewriteCond %{HTTPS} off"
      echo "RewriteCond %{HTTP:X-Forwarded-Proto} !https"
      echo "RewriteRule ^(.*)$ https://${C_BOX_HOSTNAME_FQHN}/\$1 [L,R=301]"
    } >"/var/www/html/.htaccess"

    chmod 644 /var/www/html/.htaccess
    chown webapps:webapps /var/www/html/.htaccess

    # TODO update and copy that webapps here (it should from storage) - below is just a temporary file as place holder

    # 1) Replace index.html by calling index.php (index.html by default has root permission and root group)
    _echo "$(msg cyan)Redirect index.html to index.php ...$(msg end)" --name
    {
      echo "<!DOCTYPE html>"
      echo "<html lang=\"en\">"
      echo "  <META HTTP-EQUIV=\"Refresh\""
      echo "  CONTENT=\"0; URL=https://${C_BOX_HOSTNAME_FQHN}/index.php\">"
      echo "</html>"
    } >"/var/www/html/index.html"
    echo ""

    # every custom webapps like /billing should be here
    _echo "$(msg cyan)Configuring server frontpage ...$(msg end)" --name

    cat /dev/null >/var/www/html/index.php
    {
      echo "<?php"
      echo "echo \"MaXi32 - Arafat Ali - Rebuilding server ...\""
      echo "?>"
      echo "<!DOCTYPE html>"
      echo "<html lang=\"en\">"
      echo "<!--"
      echo "Author: Arafat Ali"
      echo "Email: arafat@maxibi.com"
      echo "-->"
      echo "<head>"
      echo "  <meta charset=\"UTF-8\">"
      echo "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\">"
      echo "<title>${C_BOX_HOSTNAME_FQHN^} Server - Sofibox Cloud Hosting</title>"
      echo "</head>"
      echo "<body>"
      echo "</body>"
      echo "</html>"
    } \
      >/var/www/html/index.php

    chmod 644 /var/www/html/index.php
    chown webapps:webapps /var/www/html/index.php

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This is for configuring all directadmin.conf settings
# For configuring admin setting and extra hardening any DA related installation
configure_da_settings() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_conf da_bin da_cb_bin

    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    _echo "$(msg cyan)Checking if directadmin binary, custombuild and directadmin.conf are presents ...$(msg end)" --name
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}"
    echo ""

    # Using API (some values are not present in directadmin.conf), so we use this extra API
    # For DA Administrator Settings:
    _echo "$(msg cyan)Configuring Directadmin Admin settings with recommend values ...$(msg end)" --name
    da_api_admin set-da-admin-settings --recommend-values

    _echo "$(msg cyan)Configuring Directadmin Server, Security and Email settings with recommend values ...$(msg end)" --name
    da_api_admin set-da-server-settings --recommend-values

    # Need this before changing or adding directadmin username
    # Set the maximum length of directadmin username (default is 14) for higher than 14 make sure mariadb or mysql is latest version
    # TODO: Set max_username_length based on this rule: https://www.directadmin.com/features.php?id=2294
    _echo "$(msg cyan)Setting directadmin max username to ${LABEL_C_DA_MAX_USERNAME_LENGTH} ...$(msg end)" --name
    ${da_bin} set max_username_length "${C_DA_MAX_USERNAME_LENGTH}"
    echo ""
    _echo "$(msg cyan)Enforcing Directadmin difficult password ...$(msg end)" --name
    ${da_bin} set enforce_difficult_passwords "${C_DA_ENFORCE_DIFFICULT_PASSWORDS}"
    # This setting force_hostname will only allow hostname url login in Directadmin. For example, without this option you can use any domain within directadmin system to login.
    # eg: userdomain.com:2222 . Sometimes this user does not have valid certificate, thus this will cause security issue.
    # so, it is better to redirect to one hostname with a valid certificate:
    # Also explained in here: https://www.directadmin.com/features.php?id=917
    # It is recommend to enable this option for security
    # Note before directadmin installation, this already set by hostname.sh script
    _echo "$(msg cyan)Enabling directadmin to force login with only hostname ${LABEL_C_BOX_HOSTNAME_FQHN} ...$(msg end)" --name
    ${da_bin} set force_hostname "${C_BOX_HOSTNAME_FQHN}"
    _echo "$(msg cyan)Enabling directadmin backup encryption ...$(msg end)" --name
    ${da_bin} set allow_backup_encryption "${C_DA_ALLOW_BACKUP_ENCRYPTION}"
    _echo "$(msg cyan)Setting directadmin online document ...$(msg end)" --name
    ${da_bin} set admin_helper "${C_DA_ADMIN_HELPER}"
    ${da_bin} set reseller_helper "${C_DA_RESELLER_HELPER}"
    ${da_bin} set user_helper "${C_DA_USER_HELPER}"
    echo ""
    _echo "$(msg cyan)Setting directadmin servername ...$(msg end)" --name
    ${da_bin} set servername "${C_BOX_HOSTNAME_FQHN}"
    echo ""
    _echo "$(msg cyan)Setting directadmin nameservers ...$(msg end)" --name
    ${da_bin} set ns1 "${C_BOX_NS1}"
    ${da_bin} set ns2 "${C_BOX_NS2}"
    echo ""
    _echo "$(msg cyan)Setting directadmin execution timeout ...$(msg end)" --name
    # Set the timeout setting in second for directadmin execution before generating a timeout signal and aborting (default 60 seconds)
    ${da_bin} set timeout "${C_DA_TIMEOUT}"
    echo ""
    # https://www.directadmin.com/features.php?id=930
    ${da_bin} set tokenizer_debug "${C_DA_TOKENIZER_DEBUG}"
    echo ""
    #_echo "$(msg cyan)Setting directadmin session minutes ...$(msg end)" --name
    # Set the login session timeout in minutes (when idle), session counter reset to 0 if any da page is reload (default 60 minutes / 1 hour)
    # 2880 = 2 days / 48 hours
    # TODO This session_minutes contain bug and have not resolved yet (enable later):
    #  This one session_minutes has bug, wait until there is a fix https://forum.directadmin.com/threads/bug-cannot-set-session_minutes-using-directadmin-set-command.64280/#post-334271
    # ${da_bin} set session_minutes "${C_DA_SESSION_MINUTES}"
    #echo ""
    _echo "$(msg cyan)Setting directadmin max file size ...$(msg end)" --name
    # Increase upload max file size in bytes
    # 5368709120 = 5GB
    ${da_bin} set maxfilesize "${C_DA_MAXFILESIZE}"
    echo ""
    _echo "$(msg cyan)Setting directadmin login history ...$(msg end)" --name
    # Set directadmin login history (default 10)
    ${da_bin} set login_history "${C_DA_LOGIN_HISTORY}"
    # Do not disable disable_ip_check (this one is session security) - default is 0
    ${da_bin} set disable_ip_check "${C_DA_DISABLE_IPCHECK}"
    # Disable foreign IP when login - default is 0
    ${da_bin} set allow_foreign_key "${C_DA_ALLOW_FOREIGN_KEY}"
    # Enable simple disk usage - lowering disk access (this might increase performance)
    ${da_bin} set simple_disk_usage "${C_DA_SIMPLE_DISK_USAGE}"
    # Enable zip compression in file manager (allow zip and unzip feature)
    ${da_bin} set zip "${C_DA_ZIP}"
    # Disable awstats (disable by default) and webalizer (enabled by default) and rotation (enabled by default)
    ${da_bin} set awstats "${C_DA_AWSTATS}"
    ${da_bin} set webalizer "${C_DA_WEBALIZER}"
    ${da_bin} set rotation "${C_DA_ROTATION}"
    # Disable this feature increase performance (default is enabled)
    ${da_bin} set count_pop_usage "${C_DA_COUNT_POP_USAGE}"
    # Purge spam email every 1 day (this can increase performance if value is low)
    ${da_bin} set purge_spam_days "${C_DA_PURGE_SPAM_DAYS}"
    # Skip some backups path
    ${da_bin} set skip_hometargz_in_backups "${C_DA_SKIP_HOMETARGZ_IN_BACKUPS}"
    ${da_bin} set skip_domains_in_backups "${C_DA_SKIP_DOMAINS_IN_BACKUPS}"
    ${da_bin} set skip_imap_in_backups "${C_DA_SKIP_IMAP_IN_BACKUPS}"
    ${da_bin} set skip_databases_in_backups "${C_DA_SKIP_DATABASES_IN_BACKUPS}"
    # Skip database usage show (default 1 - show all databases size)
    ${da_bin} set show_db_usage "${C_DA_SHOW_DB_USAGE}"
    # Enable domain owner checking for unique subdomain
    ${da_bin} set check_subdomain_owner "${C_DA_CHECK_SUBDOMAIN_OWNER}"
    # Set bruteforce and blacklist setting
    ${da_bin} set bruteforce "${C_DA_BRUTEFORCE}"
    # Prevent local IP block:
    ${da_bin} set exempt_local_block "${C_DA_EXEMPT_LOCAL_BLOCK}"
    ${da_bin} set brute_force_time_limit "${C_DA_BRUTE_FORCE_TIME_LIMIT}"
    ${da_bin} set clear_blacklist_ip_time "${C_DA_CLEAR_BLACKLIST_IP_TIME}"
    ${da_bin} set clear_brute_log_entry_time "${C_DA_CLEAR_BRUTE_LOG_ENTRY_TIME}"
    ${da_bin} set clear_brute_log_time "${C_DA_CLEAR_BRUTE_LOG_TIME}"
    ${da_bin} set hide_brute_force_notifications "${C_DA_HIDE_BRUTE_FORCE_NOTIFICATIONS}"
    ${da_bin} set ip_brutecount "${C_DA_IP_BRUTECOUNT}"
    ${da_bin} set unblock_brute_ip_time "${C_DA_UNBLOCK_BRUTE_IP_TIME}"
    ${da_bin} set brute_dos_count "${C_DA_BRUTE_DOS_COUNT}"
    # Set ability for directadmin to scan bruteforce log
    ${da_bin} set brute_force_log_scanner "${C_DA_BRUTE_FORCE_LOG_SCANNER}"
    # Scan domain log for bruteforce like wordpress, 1=manual entry, 2=auto entry in /usr/local/directadmin/data/admin/brute.conf
    ${da_bin} set brute_force_scan_apache_logs "${C_DA_BRUTE_FORCE_SCAN_APACHE_LOGS}"
    # Don't bother the bruteforce count (increase performance for bruteforce page in directadmin)
    ${da_bin} set user_brutecount "${C_DA_USER_BRUTECOUNT}"
    # Enable directadmin security question
    ${da_bin} set security_questions "${C_DA_SECURITY_QUESTIONS}"
    # Check partition usage
    ${da_bin} set check_partitions "${C_DA_CHECK_PARTITIONS}"
    ${da_bin} set partition_usage_threshold "${C_DA_PARTITION_USAGE_THRESHOLD}"
    # Set backup compression format
    ${da_bin} set backup_gzip "${C_DA_BACKUP_GZIP}"
    # Demo for skin
    ${da_bin} set demodocsroot "${C_DA_DEMODOCSROOT}"
    # Do not allow password reset in UI (default is not set to allow)
    ${da_bin} set lost_password "${C_DA_LOST_PASSWORD}"
    # Set user can set email limit sent
    ${da_bin} set user_can_set_email_limit "${C_DA_USER_CAN_SET_EMAIL_LIMIT}"
    # Set max per email send limit
    ${da_bin} set max_per_email_send_limit "${C_DA_MAX_PER_EMAIL_SEND_LIMIT}"
    # Set webmail link
    ${da_bin} set webmail_link "${C_DA_WEBMAIL_LINK}"
    # Based on this: https://directadmin.com/features.php?id=1932
    bind_current_version=$(echo "$(named -v)" | awk '{ print $2 }' | grep -oP [0-9]+\.[0-9]+\.[0-9]+)
    dns_caa_bind_required_version="9.9.6"

    if is_valid version_required "${dns_caa_bind_required_version}" "${bind_current_version}"; then
      _echo "$(msg cyan)Enabling directadmin DNS CAA record ... $(msg end)" --name
      ${da_bin} set dns_caa 1
    else
      _echo "$(msg yellow)[Skipped] Disabling directadmin DNS CAA record because current bind version does not meet requirement (required bind v${dns_caa_bind_required_version}+)... $(msg end)" --name
      ${da_bin} set dns_caa 0
    fi

    # This will enable hsts for hostname on login port only
    # Important, this will not work until SSL certificate is requested by calling configure_da_host_server_ssl()
    if [[ "${C_DA_ENABLE_HOST_HSTS}" != "false" ]]; then
      ${da_bin} set hsts "${C_DA_ENABLE_HOST_HSTS}"
      # The document also recommend to enable force_hostname (this was done on top)
    fi

    # This will either hide DA version or show in header
    ${da_bin} set show_info_in_header "${C_DA_SHOW_INFO_IN_HEADER}"

    # # This will either hide DA version or show in web title
    ${da_bin} set show_info_in_title "${C_DA_SHOW_INFO_IN_TITLE}"

    # This will sync restore
    ${da_bin} set tally_after_restore "${C_DA_TALLY_AFTER_RESTORE}"
    echo ""
    # A lot of setting have been changed, now we need to restart directadmin
    _echo "$(msg cyan)Requesting directadmin to restart ...$(msg end)" --name
    restart_da
    # Add more security concern here for directadmin installation
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This is for configuring all the custombuild extra settings
configure_da_cb_settings() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_bin da_cb_bin c_da_php_enable_dangerous_function
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    da_cb_custom_path="/usr/local/directadmin/custombuild/custom/"

    mkdir -p "${da_cb_custom_path}"
    _echo "$(msg cyan)Checking if directadmin binary, custombuild and directadmin.conf are presents ...$(msg end)" --name
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}" "${da_cb_custom_path}"
    echo ""

    if [ -n "${C_DA_PHP_DISABLE_DANGEROUS_FUNCTION}" ]; then
      local c_da_php_enable_dangerous_function
      _echo "$(msg cyan)Removing previous file php_disable_functions ...$(msg end)" --name
      rm -f ${da_cb_custom_path}/php_disable_functions
      echo ""
      _echo "$(msg cyan)Disabling PHP dangerous function through custombuild ...$(msg end)" --name
      touch "${da_cb_custom_path}/php_disable_functions"
      c_da_php_enable_dangerous_function=$(printf ",%s" "${C_DA_PHP_DISABLE_DANGEROUS_FUNCTION[@]}")
      c_da_php_enable_dangerous_function=${c_da_php_enable_dangerous_function:1}
      echo "${c_da_php_enable_dangerous_function}" >"${da_cb_custom_path}/php_disable_functions"
      echo ""
      _echo "$(msg cyan)Securing all php installation ...$(msg end)" --name
      ${da_cb_bin} set secure_php yes
      ${da_cb_bin} secure_php
      echo ""
      _echo -n "$(msg cyan)Checking whether current PHP global disabled_functions exist ...$(msg end)" --name
      has_php_disable_function="$(grep -w "${c_da_php_enable_dangerous_function}" /usr/local/php*/lib/php.ini | wc -l)"
      if [[ "${has_php_disable_function}" -gt 0 ]]; then
        _echo "$(msg green)[ OK ] written on ${has_php_disable_function} PHP(s) version$(msg end)"
      else
        _echo "$(msg red)[ FAILED ]$(msg end)"
        exit 1
      fi
      echo ""
      _echo -n "$(msg cyan)Setting userdir_access into ${C_DA_CB_USERDIR_ACCESS} ... $(msg end)" --name
      ${da_cb_bin} set userdir_access "${C_DA_CB_USERDIR_ACCESS}"
    else
      _echo "$(msg yellow)****Warning, the value C_DA_PHP_DISABLE_DANGEROUS_FUNCTION is empty. This means all PHP dangerous functions might not be disabled$(msg end)" --name
      sleep 3
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi

}

configure_da_redis() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    if [ "${C_DA_INSTALL_REDIS}" == "true" ]; then
      local da_conf da_bin da_cb_bin
      da_bin="/usr/local/directadmin/directadmin"
      da_cb_bin="/usr/local/directadmin/custombuild/build"
      da_conf="/usr/local/directadmin/conf/directadmin.conf"

      _echo "$(msg cyan)Checking if directadmin binary, custombuild and directadmin.conf are presents ...$(msg end)" --name
      check_path "${da_bin}" "${da_cb_bin}" "${da_conf}"
      echo ""

      da_install_log="${LOG_PATH}/da-install.log"
      touch "${da_install_log}"
      _echo "$(msg cyan)Installing redis in system level ...$(msg end)" --name
      ${da_cb_bin} set redis yes
      {
        ${da_cb_bin} redis
      } >>da_install_log
      echo ""
      _echo "$(msg cyan)Installing redis as php-extension ...$(msg end)" --name
      ${da_cb_bin} set php_redis yes
      {
        ${da_cb_bin} php_redis
      } >>da_install_log
      echo ""
      # Create system service for redis, run the redis-server in background..
    else
      _echo "$(msg yellow)[Skipped], C_DA_INSTALL_REDIS is not set to true in config file. Redis will not be installed on this system$(msg end)" --name
    fi
    #build php_redis and build redis
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This will install OS memcached and php memcached extension (mostly needed by other platform such as prestashop 1.7)
configure_da_memcached() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local search_count
    echo "[${SCRIPT_NAME}]: Installing memcached components in OS level ..."
    # Remember libmemcached-dev is needed for Debian. In CentOS it's called libmemcached-devel
    apt-get -y install memcached libmemcached-tools libmemcached-dev
    check_path "/etc/memcached.conf"
    echo ""
    search_count=$(grep -ic "\-l ::1" /etc/memcached.conf)
    if [ "${search_count}" = 0 ]; then
      echo "[${SCRIPT_NAME}]: Setting memcached to listen to IPv6 ..."
      sleep 1
      sed -i "s/^\-l.*/\-l 127.0.0.1 \-l ::1/" /etc/memcached.conf
    else
      echo "[${SCRIPT_NAME}]: [Skipped] memcached config is already set to listen to IPv6"
      sleep 1
    fi
    echo "[${SCRIPT_NAME}]: Restarting memcached ... "
    systemctl restart memcached
    get_status_message "$?"
    echo ""
    echo "[${SCRIPT_NAME}]: Checking memcached status ... "
    systemctl --no-pager status memcached
    get_status_message "$?"
    echo ""
    echo "[${SCRIPT_NAME}]: Installing memcached for php-extension using Poralix script ..."

    echo "[${SCRIPT_NAME}]: Removing previous php-extension.sh ..."
    rm -f "php-extension.sh"
    # cp "${DATA_PATH}/maxinet/storage/os/${DISTRO_ID}/usr/local/directadmin/install_scripts/php_extension.sh" "${INST_TEMP_DIR}/php_extension.sh"
    echo "[${SCRIPT_NAME}]: Downloading php-extension.sh ..."
    wget https://raw.githubusercontent.com/sofibox/directadmin-utils/master/php/php-extension.sh
    echo ""
    echo "[${SCRIPT_NAME}]: Making php-extension.sh executable ..."
    chmod +x "${INST_TEMP_DIR}/php-extension.sh"
    # This one just checking not verifying, so whether exist or not we just execute install
    # echo "[${SCRIPT_NAME}]: Checking existing php-memcached installation ..."
    # /bin/sh ./php-extension.sh status memcached
    echo ""
    echo "[${SCRIPT_NAME}]: Installing php-memcached for all PHP versions ..."
    sh "${INST_TEMP_DIR}"/php-extension.sh install memcached
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi

}

configure_da_geoip() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    echo "[${SCRIPT_NAME}]: Installing geoip components in OS level ..."
    # Just like the memcached need libmemcache-dev, this geoip needs libgeoip-dev
    apt-get -y install libgeoip-dev geoip-bin geoip-database

    echo "[${SCRIPT_NAME}]: Installing geoip for php-extension using Poralix script ..."
    sleep 1
    navigate_path "${INST_TEMP_DIR}"
    cp "${DATA_PATH}/maxinet/storage/os/${DISTRO_ID}/usr/local/directadmin/install_scripts/php_extension.sh" "${INST_TEMP_DIR}/php_extension.sh"
    chmod +x php_extension.sh
    # This one just checking not verifying, so whether exist or not we just execute install
    echo "[${SCRIPT_NAME}]: Checking existing php-geoip installation ..."
    sleep 1
    /bin/sh ./php_extension.sh status geoip
    echo "[${SCRIPT_NAME}]: Installing php-geoip for all PHP versions ..."
    sleep 2
    # For geoip from poralix script, it needs to select --beta because stable release has error during installation
    /bin/sh ./php_extension.sh install geoip --beta

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Note this function creates custom template dns for directadmin,
# currently nothing to adjust because the latest version of directadmin already included this by default.
configure_da_dns_templates() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local da_template_custom da_conf da_bin da_cb_bin ipv6_full_uncompressed da_current_version dns_compatible_version

    da_template_custom="/usr/local/directadmin/data/templates/custom"
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    dns_compatible_version="1.63.0"

    _echo "$(msg cyan)Checking if directadmin binary, custombuild and directadmin.conf are presents ...$(msg end)" --name
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}"
    echo ""

    _echo "$(msg cyan)Creating directadmin DNS custom template folder ...$(msg end)" --name
    mkdir -p "${da_template_custom}"
    chown diradmin:diradmin ${da_template_custom}
    echo ""

    _echo "$(msg cyan)Creating SPF, DKIM and DMARC DNS custom template for directadmin server ...$(msg end)" --name
    da_current_version=$(${da_bin} v | awk '{ print $3 }')
    if [ "${da_current_version}" == "v.${dns_compatible_version}" ]; then
      :
    else
      _echo "$(msg yellow)Warning, current DNS config has been tested with directadmin ${dns_compatible_version} but directadmin version is ${da_current_version}$(msg end)" --name
      # Whether to continue or not without changing the variable dns_compatible_version
      _confirm
    fi

    touch "${da_template_custom}/dns_txt.conf"
    {
      # Note 1: since directadmin version 1.61.6 (unreleased) SPF is enabled by default (it has its own template): https://www.directadmin.com/features.php?id=2946
      # Note 2: The new SPF template is already defined in /usr/local/directadmin/data/templates/dns_txt.conf with the following contents:
      # If ipv4
      # echo "|DOMAIN|.=\"v=spf1 a mx ip4:|SERVER_IP||EXTRA_SPF| ~all\""
      # If ipv6
      echo "|DOMAIN|.=\"v=spf1 a mx ip4:|SERVER_IP||EXTRA_SPF||SPF_IPV6| ~all\""
      echo "_dmarc=\"v=DMARC1; p=none; sp=none; rua=mailto:spam-reports@|DOMAIN|\""
      # Note 1: Directadmin currently have issue using this record '_domainkey' with API (only work with GUI). So the following echo lines does nothing on API
      # So, in API must manually add dns record for _domainkey
      # https://forum.directadmin.com/threads/possible-bug-when-using-dns_txt-conf-with-api-include-step-to-reproduce.63247/
      echo "_domainkey=\"o=~; r=webmaster@|DOMAIN|\""

      # TODO Google site verification should be here

    } >"${da_template_custom}/dns_txt.conf"
    echo ""
    # rewrite_confs here so that dns_txt.conf is updated
    # Fixed DNS new record updated:
    _echo "$(msg cyan)Updating DNS template by executing custombuild rewrite_confs ...$(msg end)" --name
    ${da_cb_bin} rewrite_confs
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This function is used to configure place.server.com DKIM, DMARC, SPF and other related records
configure_da_fqhn_server() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_conf da_bin da_cb_bin da_scripts_path

    da_scripts_path="/usr/local/directadmin/scripts"
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"

    _echo "$(msg cyan)Checking if required files are presents ...$(msg end)" --name
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}" "${da_scripts_path}/dkim_create.sh"
    echo ""

    # DKIM for hostname can only be created using script (old way) as mentioned here:
    # https://forum.directadmin.com/threads/configure-dkim-for-host-domain-com-email-addresses.59809/post-309496
    # Remember this script does not touch the DNS zone directly, it uses taskq DNS so we have to wait at least 1 minute before it inserts into DNS record
    _echo "$(msg cyan) Creating DKIM for hostname ${C_BOX_HOSTNAME_FQHN} ...$(msg end)" --name
    ${da_scripts_path}/dkim_create.sh ${C_BOX_HOSTNAME_FQHN} force
    echo ""

    # This is a very important API call to restore the DNS record to default states based on customized option. If IPv6 is configured, the old DNS record will not have IPv6 DNS records
    # If we execute this, it will add IPv6 records automatically. In addition, a new custom template also will be used to write DNS record here like the _dmarc from /usr/local/directadmin/data/templates/custom
    # This API call also speeds up the dkim_create.sh taskq call. So, we can see immediate records being inserted into DNS record without having to wait for at least 1 minute
    _echo "$(msg cyan)Restoring/resetting domain DNS records to default state ...$(msg end)" --name
    da_api_admin restore-dns-record --domain ${C_BOX_HOSTNAME_FQHN}
    echo ""

    _echo "$(msg cyan)Creating DKIM signing policy TXT record for ${C_BOX_HOSTNAME_FQHN} ...$(msg end)" --name
    # This value "o%3D%7E%3B+r%3Dwebmaster%40${da_reseller_domain_first}" (encoded) is equal to "_domainkey="o=~; r=webmaster@${da_reseller_domain_first}"
    # No need to encode the value, it's working it seems like directadmin know how to handle this data in API, in debug mode it added extra quote for the value
    da_api_admin create-admin-dns-record --domain "${C_BOX_HOSTNAME_FQHN}" --record-type TXT --record-name "_domainkey" --record-value "o=~; r=webmaster@${C_BOX_HOSTNAME_FQHN}" --record-ttl 30 --affect-pointers yes
    echo ""

    copy_local_dns_to_external_dns "${C_BOX_HOSTNAME_FQHN}"
    # Very important, by default the test.domain.com was created by directadmin as the server hostname,
    # This record must also exists and propagated properly in either local or external DNS. That means, we should create this record first before any other records
    # It is not possible to create this record later because for example if using directadmin, it needs to detect server hostname propagated (license matter) before it can successfully install.
    # So when we call copy_local_dns_to_external_dns, it create this hostname and it is only useful for creating DNS record start from scratch (or rebuild dns record for test.domain.com).
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Here, we update the first owner account information (the original admin)
configure_da_owner_accounts() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_scripts_path da_bin da_cb_bin da_conf retval

    da_scripts_path="/usr/local/directadmin/scripts"
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"

    _echo "$(msg cyan)Checking if required files are presents ...$(msg end)" --name
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}" "${da_scripts_path}/change_username.sh"
    echo ""

    # There is only 1 owner, so use this:
    if [[ "${C_DA_OWNER_RESTORE_PROFILE_BACKUP1}" == "true" && "${C_DA_GLOBAL_BACKUP_RESTORE}" == "true" ]]; then
      local da_scripts_path da_bin da_cb_bin da_conf retval da_owner_creator da_owner_username \
        backup_source_location da_owner_backup_location

      da_scripts_path="/usr/local/directadmin/scripts"
      da_bin="/usr/local/directadmin/directadmin"
      da_cb_bin="/usr/local/directadmin/custombuild/build"
      da_conf="/usr/local/directadmin/conf/directadmin.conf"

      _echo "$(msg cyan)Checking if required files are presents ...$(msg end)" --name
      check_path "${da_bin}" "${da_cb_bin}" "${da_conf}" "${da_scripts_path}/change_username.sh"
      echo ""

      # 1) First make sure that the admin root creator has the correct username (refer to config username). If different rename it
      current_da_owner_username=$(get_current_da_owner_username)
      echo "current_da_owner_username: ${current_da_owner_username}"
      ###
      echo ""
      da_owner_role="${C_DA_OWNER_ROLE1}"
      da_owner_creator="${C_DA_OWNER_CREATOR1}"
      da_owner_username="${C_DA_OWNER_USERNAME1}"
      echo "da_owner_role: ${da_owner_role}"
      echo "da_owner_creator: ${da_owner_creator}"
      echo "da_owner_username: ${da_owner_username}"
      echo ""
      if [ "${current_da_owner_username}" != "${da_owner_username}" ]; then
        echo "Warning, current directadmin owner username is not equal to owner username in config file"
        ${da_scripts_path}/change_username.sh "$(get_current_da_owner_username)" "${C_DA_OWNER_USERNAME1}"
      else
        echo "OK, current directadmin owner username is equal owner username in config file"
      fi

      # 2) Then check if the backup file exist for this owner (refer to config username) - must be pushed from scp to root folder admin_backups/*
      # The role is admin (left name) and the creator is root (middle name)
      # ) If exist let say the backup file name is admin.root.xxxx.tar.gz,

      if [[ -f "${SCRIPT_PATH}/admin_backups/${da_owner_role}.${da_owner_creator}.${da_owner_username}.tar.gz" ]]; then
        backup_source_location="${SCRIPT_PATH}/admin_backups/${da_owner_role}.${da_owner_creator}.${da_owner_username}.tar.gz"
      elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_owner_role}.${da_owner_creator}.${da_owner_username}.tar.gz.enc" ]]; then
        backup_source_location="${SCRIPT_PATH}/admin_backups/${da_owner_role}.${da_owner_creator}.${da_owner_username}.tar.gz.enc"
      else
        echo "Backup file not exist for this owner. Make sure the backup file is exist. If you don't care, put disable restore from this user in config file "
        _exit 147
      fi
      echo "Backup source location: ${backup_source_location}"
      echo ""
      da_owner_backup_location=/home/$(get_current_da_owner_username)/admin_backups/$(basename -- ${backup_source_location})

      echo "Copying backup from ${backup_source_location} to ${da_owner_backup_location}..."
      cp -fp "${backup_source_location}" "${da_owner_backup_location}"
      get_status_message "$?"
      if [ ! -f "${da_owner_backup_location}" ]; then
        echo "User backup path ${da_owner_backup_location} not found!"
        _exit 147
      fi
      echo ""
      echo "Changing file owner ..."
      chown -v "$(get_current_da_owner_username):$(get_current_da_owner_username)" "${da_owner_backup_location}"
      get_status_message "$?"
      echo ""
      echo "Changing file permission ..."
      chmod -v 640 "${da_owner_backup_location}"
      get_status_message "$?"
      echo ""

      da_api_admin restore-user-backup --backup-ip "${C_IPV4_ADD0}" --backup-path "$(dirname ${da_owner_backup_location})" --backup-file-name "$(basename -- ${da_owner_backup_location})" --backup-password ${C_DA_USER_BACKUP_PASSWORD}

      _echo "$(msg cyan) Getting list of all domains created ...$(msg end)" --name
      readarray -t da_domains <<<"$(grep -w "${da_owner_username}" "/etc/virtual/domainowners" | cut -d ":" -f 1)"
      echo "Domains list for ${da_owner_username}:"
      echo "${da_domains[*]}"
      echo ""
      if [ -n "${da_domains}" ]; then
        for da_domain in "${da_domains[@]}"; do
          _echo "$(msg cyan) Writing all DNS record for domain ${da_domain} to external DNS ...$(msg end)" --name
          copy_local_dns_to_external_dns "${da_domain}"
          echo ""
        done
      fi
    else
      # This will change Directadmin admin account username:
      _echo "$(msg cyan)Changing the first directadmin owner username from $(get_current_da_owner_username) username to ${LABEL_C_DA_OWNER_USERNAME1} ...$(msg end)" --name
      ${da_scripts_path}/change_username.sh "$(get_current_da_owner_username)" "${C_DA_OWNER_USERNAME1}"
      echo ""
      # By default, directadmin installation uses a short password which is not secured. Change it here
      _echo "$(msg cyan)Changing the first directadmin owner ($(get_current_da_owner_username))'s password ...$(msg end)" --name
      echo "$(get_current_da_owner_username)":"${C_DA_OWNER_USERPASS1}" | chpasswd
      echo ""

      _echo "$(msg cyan)Renaming owner account name to ${LABEL_C_DA_OWNER_NAME1} ...$(msg end)" --name
      # No need to sign as owner1 we dont know if owner1 has changed ts username
      da_api_admin modify-user --where-username-is "$(get_current_da_owner_username)" --name "${C_DA_OWNER_NAME1}"
      echo ""

    fi

    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This function is used to configure da_admin accounts
# eg: You can create any extra admin accounts here or create multiple reseller packages that only can be done by admin or owner.
# Note 1: The rule in directadmin, only owner or existing admin can create another admin account
# Note 2: It is not compulsory to create domain for admin for security purpose.
# Note 3: There will be security risk, if the web application is compromised, your directadmin admin username will be compromised too. So do not create domain for admin.
# Note 4: For best practice and security in directadmin, we must use admin account to fully manage directadmin users instead of using an owner account.
# Note 5: Optional you can suspend the owner account via directadmin and lock the user account in the system
configure_da_admin_accounts() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_bin da_cb_bin da_conf
    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    _echo "$(msg cyan)Checking if required files are presents ...$(msg end)" --name
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}"
    echo ""

    echo ""
    da_admin_role="${C_DA_ADMIN_ROLE1}"
    da_admin_creator="${C_DA_ADMIN_CREATOR1}"
    da_admin_username="${C_DA_ADMIN_USERNAME1}"
    echo "da_admin_role: ${da_admin_role}"
    echo "da_owner_creator: ${da_owner_creator}"
    echo "da_owner_username: ${da_owner_username}"

    if [[ "${C_DA_ADMIN_RESTORE_PROFILE_BACKUP1}" == "true" && "${C_DA_GLOBAL_BACKUP_RESTORE}" == "true" ]]; then
      local backup_source_location da_owner_backup_location
      echo "${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar.gz"

      if [[ -f "${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar.gz" ]]; then
        backup_source_location="${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar.gz"
      elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar.gz.enc" ]]; then
        backup_source_location="${SCRIPT_PATH}/admin_backups/${da_admin_role}.${da_admin_creator}.${da_admin_username}.tar.gz.enc"
      else
        echo "Backup file ${backup_source_location} does not exist for this user ${da_admin_username}. If you want to ignore this backup, disable this user backup restoration from config file "
        _exit 147
      fi

      _echo "Backup source location: ${backup_source_location}" --name --verbose 7
      _echo "$(msg newline)" --plain --verbose 7

      da_owner_backup_location=/home/$(get_current_da_owner_username)/admin_backups/$(basename -- ${backup_source_location})
      _echo "$(msg cyan)Copying backup from ${backup_source_location} to ${da_owner_backup_location}... $(msg end)" --name
      cp -fp "${backup_source_location}" "${da_owner_backup_location}"
      get_status_message "$?"
      if [ ! -f "${da_owner_backup_location}" ]; then
        _echo "$(msg red)Error, The backup path ${da_owner_backup_location} not found after performed a copy! $(msg end)" --name
        _exit 147
      fi
      echo ""
      _echo "$(msg cyan)Changing file owner permission for ${da_owner_backup_location} ...$(msg end)" --name
      chown "$(get_current_da_owner_username):$(get_current_da_owner_username)" "${da_owner_backup_location}"
      get_status_message "$?"
      echo ""
      _echo "$(msg cyan)Changing file permission for ${da_owner_backup_location} ...$(msg end)" --name
      chmod 640 "${da_owner_backup_location}"
      get_status_message "$?"
      echo ""
      da_api_admin restore-user-backup --backup-ip "${C_IPV4_ADD0}" --backup-path "$(dirname ${da_owner_backup_location})" --backup-file-name "$(basename -- ${da_owner_backup_location})" --backup-password ${C_DA_USER_BACKUP_PASSWORD}
      _echo "$(msg cyan) Getting list of all domains created ...$(msg end)" --name
      readarray -t da_domains <<<"$(grep -w "${da_admin_username}" "/etc/virtual/domainowners" | cut -d ":" -f 1)"
      echo "Domains list for ${da_admin_username}:"
      echo "${da_domains[*]}"
      echo ""
      if [ -n "${da_domains}" ]; then
        for da_domain in "${da_domains[@]}"; do
          _echo "$(msg cyan) Writing all DNS record for domain ${da_domain} to external DNS ...$(msg end)" --name
          copy_local_dns_to_external_dns "${da_domain}"
          echo ""
        done
      fi
    else
      _echo "$(msg cyan) Creating the first new directadmin admin account ${LABEL_C_ADMIN_USERNAME1} ...$(msg end)" --name
      # Must sign in as owner to create a new admin account. To use owner, account put --sign-as owner1 or --sign-as [owner_username] or leave --sign-as option
      # because by default, this script will use the first owner username and password for API if it is not supplied.
      da_api_admin create-admin-account --username "${C_DA_ADMIN_USERNAME1}" --email "${C_DA_ADMIN_SYSTEM_EMAIL1}" --password "${C_DA_ADMIN_USERPASS1}"
      echo ""
      _echo "$(msg cyan)Renaming admin account default name to ${LABEL_C_DA_ADMIN_NAME1} ...$(msg end)" --name
      da_api_admin modify-user --sign-as admin1 --where-username-is "${C_DA_ADMIN_USERNAME1}" --name "${C_DA_ADMIN_NAME1}"
      echo ""
      _echo "$(msg cyan)Creating a new  unlimited package with recommend values for resellers with the following name: ${C_DA_RESELLER_PACKAGE_NAME1} ...$(msg end)" --name
      da_api_admin create-reseller-package --sign-as admin1 --package-name "${C_DA_RESELLER_PACKAGE_NAME1}" --recommend-values
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This function is used to create reseller accounts including its domain
# Note 1: For security purpose, all reseller users creation depend on an admin or owner account. So, we must create at least an admin account or use owner account to manage this
# Note 2: In directadmin rule, a reseller package must be created first from admin or owner. Only after a reseller package is created, then we can create a reseller account
# Note 3: For best security practice, when creating a package for reseller, do not enable anonymous FTP accounts and SSH access
# Some info & and references: Check if reseller package is created
# https://forum.directadmin.com/threads/server-migration-how-to-use-the-existing-configuration-during-setup.62937/
# https://forum.directadmin.com/threads/default-user-package-s-for-resellers.49156/
# Note 4: Very important note, when create a reseller, it will create a domain, and this means it create DNS records. So, if directadmin ipv6 is enable. This will cause timeouut
configure_da_reseller_accounts() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_reseller_packages_list count_reseller1 \
      da_reseller_creator da_reseller_role da_reseller_restore_profile_backup da_reseller_uname da_reseller_password da_reseller_name da_reseller_system_email \
      da_reseller_mail_users da_reseller_mail_passwords da_reseller_domains da_reseller_ip_type da_reseller_package_name da_reseller_enable_domain_ssl grep_count

    # This file contains list of packages for admin and reseller (use this file for checking existing package)
    da_reseller_packages_list="/usr/local/directadmin/data/admin/packages.list"
    # We can restart directadmin to clear pending Directadmin cron
    #_echo "$(msg cyan)Requesting directadmin to restart before configuring directadmin accounts ...$(msg end)" --name
    #restart_da
    #echo ""

    count_reseller1=1
    # !C_DA_RESELLER_USERNAME@ = Assign all reseller account based on the variable of C_DA_RESELLER_USERNAME[N] :
    while [[ ${count_reseller1} -le $(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w) ]]; do
      _echo "$(msg cyan)Getting all required variables from config file ...$(msg end)" --name --verbose 7
      typeset -n da_reseller_creator="C_DA_RESELLER_CREATOR${count_reseller1}"
      typeset -n da_reseller_role="C_DA_RESELLER_ROLE${count_reseller1}"
      typeset -n da_reseller_restore_profile_backup="C_DA_RESELLER_RESTORE_PROFILE_BACKUP${count_reseller1}"
      typeset -n da_reseller_uname="C_DA_RESELLER_USERNAME${count_reseller1}"
      typeset -n da_reseller_password="C_DA_RESELLER_USERPASS${count_reseller1}"
      typeset -n da_reseller_name="C_DA_RESELLER_NAME${count_reseller1}"
      typeset -n da_reseller_system_email="C_DA_RESELLER_SYSTEM_EMAIL${count_reseller1}"
      typeset -n da_reseller_mail_users="C_DA_RESELLER_MAIL_USER${count_reseller1}"
      typeset -n da_reseller_mail_passwords="C_DA_RESELLER_MAIL_PASSWORD${count_reseller1}"
      typeset -n da_reseller_domains="C_DA_RESELLER_DOMAIN${count_reseller1}"
      typeset -n da_reseller_ip_type="C_DA_RESELLER_IP_TYPE${count_reseller1}"
      typeset -n da_reseller_package_name="C_DA_RESELLER_PACKAGE_NAME${count_reseller1}"
      typeset -n da_reseller_enable_domain_ssl="C_DA_RESELLER_ENABLE_DOMAIN_SSL${count_reseller1}"

      # TODO this information is sensitive, hide later
      _echo "$(msg cyan)Checking if reseller package name ${da_reseller_package_name} was created by previous admin before ...$(msg end)" --name
      grep_count=$(grep -ic "${da_reseller_package_name}" "${da_reseller_packages_list}")
      if [ "${grep_count}" -gt 0 ]; then
        _echo "$(msg green)OK, reseller package name ${da_reseller_package_name} found$(msg end)" --name
        echo ""
      else
        _echo "$(msg yellow)Warning, ${da_reseller_package_name} does not exist in ${da_reseller_packages_list}. Please inspect why!$(msg end)" --name
        _exit 147
      fi
      # Get the total domain count for this reseller
      da_reseller_domain_count="${#da_reseller_domains[@]}"
      # The first domain in array is used to create account (default domain for that reseller)
      da_reseller_domain_first=$(echo "${da_reseller_domains[@]}" | awk '{ print $1 }')

      _echo "$(msg newline)" --plain --verbose 7
      _echo "$(msg yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(msg end)" --name --verbose 7
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name
      _echo "Reseller config variables:" --name --verbose 7
      _echo "Reseller count ${count_reseller1}/$(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w)" --name
      _echo "da_reseller_creator: ${da_reseller_creator}" --name --verbose 7
      _echo "da_reseller_role: ${da_reseller_role}" --name --verbose 7
      _echo "da_reseller_restore_profile_backup: ${da_reseller_restore_profile_backup}" --name --verbose 7
      _echo "da_reseller_uname: ${da_reseller_uname}" --name --verbose 7
      _echo "da_reseller_password: ${da_reseller_password}" --name --verbose 7
      _echo "da_reseller_name: ${da_reseller_name}" --name --verbose 7
      _echo "da_reseller_system_email: ${da_reseller_system_email}" --name --verbose 7
      _echo "da_reseller_mail_users: ${da_reseller_mail_users[*]}" --name --verbose 7
      _echo "da_reseller_mail_passwords: ${da_reseller_mail_passwords}" --name --verbose 7
      _echo "da_reseller_domains: ${da_reseller_domains[*]}" --name --verbose 7
      _echo "da_reseller_ip_type: ${da_reseller_ip_type}" --name --verbose 7
      _echo "da_reseller_package_name: ${da_reseller_package_name}" --name --verbose 7
      _echo "da_reseller_enable_domain_ssl: ${da_reseller_enable_domain_ssl}" --name --verbose 7
      _echo "$(msg newline)" --plain --verbose 7
      _echo "Domain information for reseller ${da_reseller_uname}:" --name --verbose 7
      _echo "Domain total (config): ${da_reseller_domain_count}" --name --verbose 7
      _echo "Domain list (config): ${da_reseller_domains[*]}" --name --verbose 7
      _echo "First domain (config): ${da_reseller_domain_first}" --name --verbose 7
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name
      _echo "$(msg newline)" --plain --verbose 7

      if [[ "${da_reseller_restore_profile_backup}" == "true" && "${C_DA_GLOBAL_BACKUP_RESTORE}" == "true" ]]; then
        local backup_source_location da_owner_backup_location
        echo "${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar.gz"

        if [[ -f "${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar.gz" ]]; then
          backup_source_location="${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar.gz"
        elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar.gz.enc" ]]; then
          backup_source_location="${SCRIPT_PATH}/admin_backups/${da_reseller_role}.${da_reseller_creator}.${da_reseller_uname}.tar.gz.enc"
        else
          echo "Backup file ${backup_source_location} does not exist for this user ${da_reseller_uname}. If you want to ignore this backup, disable this user backup restoration from config file "
          _exit 147
        fi

        _echo "Backup source location: ${backup_source_location}" --name --verbose 7
        _echo "$(msg newline)" --plain --verbose 7

        da_owner_backup_location=/home/$(get_current_da_owner_username)/admin_backups/$(basename -- ${backup_source_location})
        _echo "$(msg cyan)Copying backup from ${backup_source_location} to ${da_owner_backup_location}... $(msg end)" --name
        cp -fp "${backup_source_location}" "${da_owner_backup_location}"
        get_status_message "$?"
        if [ ! -f "${da_owner_backup_location}" ]; then
          _echo "$(msg red)Error, The backup path ${da_owner_backup_location} not found after performed a copy! $(msg end)" --name
          _exit 147
        fi
        echo ""
        _echo "$(msg cyan)Changing file owner permission for ${da_owner_backup_location} ...$(msg end)" --name
        chown "$(get_current_da_owner_username):$(get_current_da_owner_username)" "${da_owner_backup_location}"
        get_status_message "$?"
        echo ""
        _echo "$(msg cyan)Changing file permission for ${da_owner_backup_location} ...$(msg end)" --name
        chmod 640 "${da_owner_backup_location}"
        get_status_message "$?"
        echo ""
        da_api_admin restore-user-backup --backup-ip "${C_IPV4_ADD0}" --backup-path "$(dirname ${da_owner_backup_location})" --backup-file-name "$(basename -- ${da_owner_backup_location})" --backup-password ${C_DA_USER_BACKUP_PASSWORD}

        _echo "$(msg cyan) Getting list of all domains created ...$(msg end)" --name
        readarray -t da_domains <<<"$(grep -w "${da_reseller_uname}" "/etc/virtual/domainowners" | cut -d ":" -f 1)"
        echo "Domains list for ${da_reseller_uname}:"
        echo "${da_domains[*]}"
        echo ""
        if [ -n "${da_domains}" ]; then
          for da_domain in "${da_domains[@]}"; do
            _echo "$(msg cyan) Writing all DNS record for domain ${da_domain} to external DNS ...$(msg end)" --name
            copy_local_dns_to_external_dns "${da_domain}"
            echo ""
          done
        fi
      else
        # Note 1: To create a reseller, we need to use an admin account:
        _echo "$(msg cyan)Creating a new reseller account ${da_reseller_uname} ${count_reseller1} out of $(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w) user(s) ... $(msg end)" --name
        da_api_admin create-reseller-account --sign-as admin1 --username "${da_reseller_uname}" --email "${da_reseller_system_email}" --password "${da_reseller_password}" --domain "${da_reseller_domain_first}" --package-name "${da_reseller_package_name}" --ip-type "${da_reseller_ip_type}"
        echo ""
        _echo "$(msg cyan)Renaming reseller account name to ${da_reseller_name} ...$(msg end)" --name
        da_api_admin modify-user --sign-as admin1 --where-username-is "${da_reseller_uname}" --name "${da_reseller_name}"
        echo ""
        # Now login as reseller and enable its own email DKIM. We can use reseller account to configure its own user-level variable settings like DKIM or DNS records
        _echo "$(msg cyan)Enabling email/domain DKIM for user ${da_reseller_uname} with default domain of ${da_reseller_domain_first} ...$(msg end)" --name
        # Note 1: We dont use reseller1 because currently reseller can have 1 or more (this script support multiple creation of reseller)
        # eg: --sign-as ${da_reseller_uname}
        da_api_admin enable-email-dkim --sign-as "${da_reseller_uname}" --domain "${da_reseller_domain_first}"
        echo ""

        # Use reseller above and create TXT record _domainkey for DKIM signing policy (this should have have been done using dns_txt.conf but it has bug)
        # so, we manually add this using API here: https://forum.directadmin.com/threads/possible-bug-when-using-dns_txt-conf-with-api-include-step-to-reproduce.63247/
        _echo "$(msg cyan)Creating DKIM signing policy TXT record for ${da_reseller_domain_first} ...$(msg end)" --name
        # This value "o%3D%7E%3B+r%3Dwebmaster%40${da_reseller_domain_first}" (encoded) is equal to "_domainkey="o=~; r=webmaster@${da_reseller_domain_first}"
        # No need to encode the value, it's working it seems like directadmin know how to handle this data in API, in debug mode it added extra quote for the value
        da_api_admin create-dns-record --sign-as "${da_reseller_uname}" --domain "${da_reseller_domain_first}" --record-type TXT --record-name "_domainkey" --record-value "o=~; r=webmaster@${da_reseller_domain_first}" --record-ttl 30 --affect-pointers yes
        echo ""
        _echo "$(msg cyan)Creating Mail MX record for ${da_reseller_domain_first} without subdomain ...$(msg end)" --name
        #da_api_admin create-dns-record --sign-as "${da_reseller_uname}" --domain "${da_reseller_domain_first}" --record-type MX --record-domain "${da_reseller_domain_first}." --record-priority "${record_priority}" --record-subdomain "${record_subdomain}" --record-ttl 30 --affect-pointers yes
        da_api_admin create-dns-record --sign-as "${da_reseller_uname}" --domain "${da_reseller_domain_first}" --record-type MX --record-domain "${da_reseller_domain_first}." --record-priority "10" --record-subdomain "${da_reseller_domain_first}." --record-ttl 30 --affect-pointers yes
        echo ""
        copy_local_dns_to_external_dns "${da_reseller_domain_first}"

        # This will be executed if reseller has more than 1 domains. We add the extra domains here and skipped the default domain:
        if [ "${da_reseller_domain_count}" -gt 1 ]; then
          _echo "$(msg cyan)Notice, this reseller ${da_reseller_uname} has ${da_reseller_domain_count} domains$(msg end)" --name
          for extra_domain in "${da_reseller_domains[@]}"; do
            # Here, we don't add the first domain, we did that before when we first create reseller user account where directadmin automatically add this default or first domain
            if [[ "${extra_domain}" == "${da_reseller_domain_first}" ]]; then
              _echo "$(msg cyan)Skipped adding the default domain: ${da_reseller_domain_first}$(msg end)" --name
              continue
            fi
            _echo "$(msg cyan)Creating extra domain ${extra_domain} for reseller ${da_reseller_uname} ...$(msg end)" --name
            da_api_admin create-domain --sign-as "${da_reseller_uname}" --domain "${extra_domain}" --recommend-values
            echo ""
            _echo "$(msg cyan)Enabling email/domain DKIM for user ${da_reseller_uname} with extra domain of ${extra_domain} ...$(msg end)" --name
            da_api_admin enable-email-dkim --sign-as "${da_reseller_uname}" --domain "${extra_domain}"
            echo ""
            _echo "$(msg cyan)Creating DKIM signing policy TXT record for extra domain ${extra_domain} ...$(msg end)" --name
            da_api_admin create-dns-record --sign-as "${da_reseller_uname}" --domain "${extra_domain}" --record-type TXT --record-name "_domainkey" --record-value "o=~; r=webmaster@${extra_domain}" --record-ttl 30 --affect-pointers yes
            echo ""
            _echo "$(msg cyan)Creating Mail MX record for ${extra_domain} without subdomain ...$(msg end)" --name
            da_api_admin create-dns-record --sign-as "${da_reseller_uname}" --domain "${extra_domain}" --record-type MX --record-domain "${extra_domain}." --record-priority "10" --record-subdomain "${da_reseller_domain_first}." --record-ttl 30 --affect-pointers yes
            copy_local_dns_to_external_dns "${extra_domain}"
          done # End looping for adding extra domains
        fi
      fi
      ((count_reseller1++))
      echo ""
    done
    echo ""
    # Now we create user unlimited package. A reseller account is needed to create user package (da_api_admin will check this condition)
    # Note here we user package name from C_DA_USER_PACKAGE_NAME1 (user1) because it's the first package for for first user
    # We use reseller account to create user package:
    if [ "${da_reseller_restore_profile_backup}" == "true" ]; then
      _echo "$(msg cyan)Creating user unlimited package with the following name: ${C_DA_USER_PACKAGE_NAME1} ...$(msg end)" --name
      da_api_admin create-user-package --sign-as "${C_DA_RESELLER_USERNAME1}" --package-name "${C_DA_USER_PACKAGE_NAME1}" --recommend-values
      echo ""
    fi
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# By default the root domain were created in directadmin. Only add in external DNS
# This function will scan the current domain list of reseller and automatically add root, A or AAAA records to external DNS
# Remember that all record created here need to wait for propagation time before they become available
configure_da_reseller_root_domains() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    # initial value to loop
    count_reseller1=1
    # !C_DA_RESELLER_USERNAME@ = Assign all reseller account based on the variable of C_DA_RESELLER_USERNAME[N] :
    while [[ ${count_reseller1} -le $(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w) ]]; do
      _echo "$(msg cyan)Getting all required variables from config file ...$(msg end)" --name --verbose 7
      typeset -n da_reseller_uname="C_DA_RESELLER_USERNAME${count_reseller1}"
      typeset -n da_reseller_password="C_DA_RESELLER_USERPASS${count_reseller1}"

      typeset -n da_reseller_domains="C_DA_RESELLER_DOMAIN${count_reseller1}"
      # Get the total domain count for this reseller from config
      da_reseller_domain_count="${#da_reseller_domains[@]}"
      # The first domain in array is used to create account (default domain for that reseller) from config
      da_reseller_domain_first=$(echo "${da_reseller_domains[@]}" | awk '{ print $1 }')
      # From system
      da_reseller_system_domain_list=$(cat "/usr/local/directadmin/data/users/${da_reseller_uname}/domains.list")

      # Debug:
      _echo "$(msg newline)" --plain --verbose 7
      _echo "$(msg yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(msg end)" --name --verbose 7
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name
      _echo "Reseller config variables:" --name --verbose 7
      _echo "Reseller count ${count_reseller1}/$(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w)" --name --verbose 7
      _echo "da_reseller_uname: ${da_reseller_uname}" --name --verbose 7
      _echo "da_reseller_password: ${da_reseller_password}" --name --verbose 7
      _echo "$(msg newline)" --plain --verbose 7
      _echo "Domain information for reseller ${da_reseller_uname}:" --name --verbose 7
      _echo "Domain total: ${da_reseller_domain_count}" --name --verbose 7
      _echo "Domain list (config): ${da_reseller_domains[*]}" --name --verbose 7
      _echo "Domain list (system) (below):" --name --verbose 7
      _echo "${da_reseller_system_domain_list}" --verbose 7
      _echo "First domain: ${da_reseller_domain_first}" --name --verbose 7
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name
      _echo "$(msg newline)" --plain --verbose 7

      #reseller_domain_count=1
      for da_reseller_system_domain in ${da_reseller_system_domain_list}; do
        echo "${da_reseller_system_domain}"
        if [ "${DNS_PROVIDER_NAME}" == "linode" ]; then
          # Since the record is supplied with --build option, we do not need to delete the record before adding
          _echo "$(msg cyan)Adding root domain ${da_reseller_system_domain} record for IPv4 in linode$(msg end)" --name
          linode_api_admin add-dns-record --domain "${da_reseller_system_domain}" --record-type "A" --record-name "${da_reseller_system_domain}" --record-value "${C_IPV4_ADD0}" --record-ttl 30
          echo ""
          _echo "$(msg cyan)Adding root domain ${da_reseller_system_domain} record for IPv6 in linode$(msg end)" --name
          linode_api_admin add-dns-record --domain "${da_reseller_system_domain}" --record-type "AAAA" --record-name "${da_reseller_system_domain}" --record-value "${C_IPV6_ADD0}" --record-ttl 30
          echo ""
        fi
      done
      ((count_reseller1++))
    done
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This is the pre-requirement before getting ssl
# Configure the wildcard certificate option here for external DNS
configure_da_ssl_pre() {

  # Note the following are the same (server certificate)
  #+ cp -f /usr/local/directadmin/conf/cakey.pem /etc/httpd/conf/ssl.key/server.key
  #+ cp -f /usr/local/directadmin/conf/cacert.pem /etc/httpd/conf/ssl.crt/server.crt
  #+ cp -f /usr/local/directadmin/conf/carootcert.pem /etc/httpd/conf/ssl.crt/server.ca

  # Must run this functions (configure_da_host_server_ssl) after running CSF because we need to make sure all appropriate ports are opened to request certs
  # Warning do not overused configure_da_host_server_ssl function because when requesting the same cert for the same domain 7 times for a week, you will get blocked.
  # This will set the hosting to SSL:
  # It's best to call SSL after domain propagation few hours later.

  # Call certificate request at the end because we want to create DNS entry and propagate first
  # Don't worry if some domains are not able to have SSL because of the propagation problem using external DNS
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_bin da_cb_bin da_conf

    da_bin="/usr/local/directadmin/directadmin"
    da_cb_bin="/usr/local/directadmin/custombuild/build"
    da_conf="/usr/local/directadmin/conf/directadmin.conf"
    _echo "$(msg cyan)Checking if directadmin required files ...$(msg end)" --name
    check_path "${da_bin}" "${da_cb_bin}" "${da_conf}"
    echo ""

    #https://help.directadmin.com/item.php?id=629
    #1) Make sure enable_ssl_sni=1 in directadmin.conf (internal value is already default to 1, so if enable_ssl_sni has no entry this code does nothing)
    _echo "$(msg cyan):Enabling enable_ssl_sni=1 in directadmin.conf config...$(msg end)" --name
    ${da_bin} set enable_ssl_sni 1
    echo ""
    #2) Make sure letsencrypt=1 is set in directadmin.conf to install letsencrypt
    _echo "$(msg cyan)Setting letsencrypt=1 in directadmin.conf config ...$(msg end)" --name
    ${da_bin} set letsencrypt 1
    echo ""
    # (OPTIONAL) This option is to enable wildcard certificate
    _echo "$(msg cyan)Setting directadmin dns_ttl=1 to enable wildcard certificate at directadmin.conf ...$(msg end)" --name
    ${da_bin} set dns_ttl ${C_DA_DNS_TTL}
    echo ""

    # Disable ssl=0. This one fixed issue where you cannot request cert using ssl=1.
    # only enable ssl=1 after request certificate success. From my notes few years, I disabled this first before renew else it wont work.
    _echo "$(msg cyan)Disabling ssl=0 in directadmin.conf config...$(msg end)" --name
    ${da_bin} set ssl 0
    echo ""

    _echo "$(msg cyan)Enabling ECC_CERTIFICATE for highest SSL encryption key ...$(msg end)" --name
    ${da_bin} set ecc_certificates 1
    echo ""

    #5) Install letsencrypt latest version at pre function
    # install the latest letsencrypt here (this will only get the latest letsencrypt.sh)
    _echo "$(msg cyan)Installing the latest letsencrypt.sh for Directadmin ...$(msg end)" --name
    ${da_cb_bin} letsencrypt
    echo ""

    # 6) Restart directadmin
    _echo "$(msg cyan)Restarting directadmin after changing directadmin.conf ...$(msg end)" --name
    restart_da
    # No need to reboot
    #echo "[${SCRIPT_NAME}]: Creating reboot flag to restart system before requesting SSL certificate for Directadmin ..."
    #cat /dev/null >/var/run/reboot-required
    #echo "[${SCRIPT_NAME}]: Warning, system will reboot and you can run this script again to continue setup"
    #_pause 10
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_host_server_ssl() {
  # Request SSL failed due to DAD (until server restart)
  # Interesting answer: https://serverfault.com/questions/602700/debian-ipv6-is-not-asssigned-to-interface
  # Nice reading: https://www.agwa.name/blog/post/beware_the_ipv6_dad_race_condition
  # https://serverfault.com/questions/421460/nginx-failed-to-start-cannot-assign-requested-address
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    if [ "${C_ENABLE_DA_HOST_SSL}" == "true" ]; then
      local da_bin da_cb_bin dataskq da_conf task_queue da_script_path lego_data_path

      da_bin="/usr/local/directadmin/directadmin"
      da_cb_bin="/usr/local/directadmin/custombuild/build"
      dataskq="/usr/local/directadmin/dataskq"
      da_conf="/usr/local/directadmin/conf/directadmin.conf"
      da_conf_path="/usr/local/directadmin/conf"
      da_script_path="/usr/local/directadmin/scripts"
      # This file does not exist by default
      task_queue="/usr/local/directadmin/data/task.queue.cb"

      _echo "$(msg cyan)Checking directadmin required files ...$(msg end)" --name
      check_path "${da_bin}" "${da_cb_bin}" "${dataskq}" "${da_conf}" "${da_script_path}" "${da_conf_path}"
      echo ""

      _echo "$(msg cyan)Configuring Directadmin SSL for host certificate ...$(msg end)" --name
      # Set the ssl_redirect_host (remove later) :
      # This options is deprecated in directadmin 1.62+ https://www.directadmin.com/features.php?id=801 (it replaced with javascript redirection)
      # echo "[${SCRIPT_NAME}]: Setting ssl_redirect_host to ${LABEL_C_BOX_HOSTNAME_FQHN} in directadmin.conf config ..."
      # ${da_bin} set ssl_redirect_host "${C_BOX_HOSTNAME_FQHN}"

      if [ "${C_DA_RESTORE_PREVIOUS_HOSTNAME_SSL}" == "true" ]; then

        # Note there is another script that can also use to restore previous certificate forked from Porallix here:
        # https://github.com/sofibox/directadmin-utils/blob/master/ssl/install_server_wide_cert.sh
        # It does the same thing, but mine is following exactly like what DA letsencrypt.sh does

        _echo "$(msg cyan)Restoring host SSL certificate (from previous backup) ...$(msg end)" --name

        local key cert cacert eximkey eximcert lego_cert_path lego_data_path lego_key_path lego_issuer_cert_path set_da_cacert

        # This guide is based on directadmin letsencrypt.sh

        # By default the path .lego does not exist
        lego_data_path="/usr/local/directadmin/data/.lego"
        mkdir -p "${lego_data_path}/certificates"
        # This 3 files must be pushed from SSH into ${lego_data_path} then check them if they exist
        lego_cert_path="${lego_data_path}/certificates/${C_BOX_HOSTNAME_FQHN}.crt"
        lego_key_path="${lego_data_path}/certificates/${C_BOX_HOSTNAME_FQHN}.key"
        lego_issuer_cert_path=$(echo "${lego_cert_path}" | sed 's/\.crt/.issuer.crt/')
        lego_cert_json_path="${lego_data_path}/certificates/${C_BOX_HOSTNAME_FQHN}.json"

        echo -n "Copying ${SCRIPT_PATH}/${C_BOX_HOSTNAME_FQHN}.crt into ${lego_cert_path} ... "
        cp "${SCRIPT_PATH}/${C_BOX_HOSTNAME_FQHN}.crt" "${lego_cert_path}"
        get_status_message "$?"
        echo -n "Copying ${SCRIPT_PATH}/${C_BOX_HOSTNAME_FQHN}.key into ${lego_key_path} ... "
        cp "${SCRIPT_PATH}/${C_BOX_HOSTNAME_FQHN}.key" "${lego_key_path}"
        get_status_message "$?"
        echo -n "Copying ${SCRIPT_PATH}/${C_BOX_HOSTNAME_FQHN}.issuer.key into ${lego_issuer_cert_path} ... "
        cp "${SCRIPT_PATH}/${C_BOX_HOSTNAME_FQHN}.issuer.crt" "${lego_issuer_cert_path}"
        get_status_message "$?"
        echo -n "Copying ${SCRIPT_PATH}/${C_BOX_HOSTNAME_FQHN}.json into ${lego_cert_json_path} ... "
        cp "${SCRIPT_PATH}/${C_BOX_HOSTNAME_FQHN}.json" "${lego_cert_json_path}"
        get_status_message "$?"
        _echo "$(msg cyan)Correcting permission of certificates ...$(msg end)" --name
        chmod 600 "${lego_cert_path}" "${lego_key_path}" "${lego_issuer_cert_path}" "${lego_cert_json_path}"
        get_status_message "$?"
        echo ""
        _echo "$(msg cyan)Checking certificate path for ${LABEL_C_BOX_HOSTNAME_FQHN} ...$(msg end)" --name
        check_path "${lego_cert_path}" "${lego_key_path}" "${lego_issuer_cert_path}" "${lego_cert_json_path}"
        echo ""

        key=$(${da_bin} c | grep ^cakey= | cut -d= -f2)
        cert=$(${da_bin} c | grep ^cacert= | cut -d= -f2)
        cacert=$(${da_bin} c | grep ^carootcert= | cut -d= -f2)

        set_da_cacert=false
        if [ "${cacert}" = "" ] || [ "${cert}" = "${da_conf_path}/carootcert.pem" ]; then
          cert="${da_conf_path}/cacert.pem"
          cacert="${da_conf_path}/carootcert.pem"
          set_da_cacert=true
        fi

        if [ -s "${lego_cert_path}" ] && [ -s "${lego_key_path}" ]; then
          if [ $(grep -c "BEGIN CERTIFICATE" "${lego_cert_path}") -eq 1 ]; then
            cp -pf "${lego_cert_path}" ${cert}
          else
            openssl x509 -in "${lego_cert_path}" -out ${cert}
            get_status_message "$?"
          fi
          cp -pf "${lego_key_path}" ${key}
          if [ -s "${lego_issuer_cert_path}" ]; then
            cp -pfv "${lego_issuer_cert_path}" ${cacert}
            cat ${cert} ${cacert} >${cert}.combined
          else
            cp -pfv "${lego_cert_path}" ${cert}.combined
          fi
          date +%s >${cert}.creation_time
          chown diradmin:${C_DA_SECURE_ACCESS_GROUP} ${key} ${cert} ${cert}.combined ${cacert} ${cert}.creation_time
          # This file is the one that renew certificate, if this is deleted, renewal will be disable
          chmod 640 ${key} ${cert} ${cert}.combined ${cacert} ${cert}.creation_time
          echo "Certificate for ${C_BOX_HOSTNAME_FQHN} has been created successfully!"
        else
          echo "New key/certificate is empty. Exiting..."
          exit 1
        fi

        echo "DirectAdmin certificate for ${C_BOX_HOSTNAME_FQHN} has been setup."

        if grep -m1 -q "^cacert=${da_conf_path}/carootcert.pem$" /usr/local/directadmin/conf/directadmin.conf; then
          ${da_bin} set cacert ${da_conf_path}/cacert.pem
        fi
        if ${set_da_cacert}; then
          ${da_bin} set carootcert ${cacert}
        fi
        if ${da_bin} c | grep -m1 -q "^ssl=0$"; then
          ${da_bin} set ssl 1
        fi

        #Exim
        echo "Setting up cert for Exim..."
        if command -v exim &>/dev/null; then
          local eximkey eximcert
          eximkey="/etc/exim.key"
          eximcert="/etc/exim.cert"
          cp -fv ${key} ${eximkey}
          cat ${cert} ${cacert} >${eximcert}
          chown -v mail:mail ${eximkey} ${eximcert}
          chmod -v 600 ${eximkey} ${eximcert}

          echo "action=exim&value=restart" >>${task_queue}
          echo "action=dovecot&value=restart" >>${task_queue}
        fi
        #Apache
        echo "Setting up cert for WWW server..."
        if [ -d /etc/httpd/conf/ssl.key ] && [ -d /etc/httpd/conf/ssl.crt ]; then
          local apachekey apachecert apachecacert apachecertcombined httpd_action graceful
          apachekey="/etc/httpd/conf/ssl.key/server.key"
          apachecert="/etc/httpd/conf/ssl.crt/server.crt"
          apachecacert="/etc/httpd/conf/ssl.crt/server.ca"
          apachecertcombined="${apachecert}.combined"

          cp -fv ${key} ${apachekey}
          cp -fv ${cert} ${apachecert}
          cp -fv ${cacert} ${apachecacert}
          cat ${apachecert} ${apachecacert} >${apachecertcombined}
          chown -v root:root ${apachekey} ${apachecert} ${apachecacert} ${apachecertcombined}
          chmod -v 600 ${apachekey} ${apachecert} ${apachecacert} ${apachecertcombined}

          httpd_action=restart
          graceful=$(${da_bin} c | grep ^graceful_restarts= | cut -d= -f2)
          if [ "${graceful}" = "1" ]; then
            local systemd
            systemd=$(${da_bin} c | grep ^systemd= | cut -d= -f2)
            if [ "${systemd}" = "1" ]; then
              httpd_action=reload
            else
              httpd_action=graceful
            fi
          fi
          echo "action=httpd&value=${httpd_action}&affect_php_fpm=no" >>${task_queue}
        fi

        #Nginx
        if [ -d /etc/nginx/ssl.key ] && [ -d /etc/nginx/ssl.crt ]; then
          local nginxkey nginxcert nginxcacert nginxcertcombined
          nginxkey="/etc/nginx/ssl.key/server.key"
          nginxcert="/etc/nginx/ssl.crt/server.crt"
          nginxcacert="/etc/nginx/ssl.crt/server.ca"
          nginxcertcombined="${nginxcert}.combined"
          cp -fv ${key} ${nginxkey}
          cp -fv ${cert} ${nginxcert}
          cp -fv ${cacert} ${nginxcacert}
          cat ${nginxcert} ${nginxcacert} >${nginxcertcombined}
          chown -v root:root ${nginxkey} ${nginxcert} ${nginxcacert} ${nginxcertcombined}
          chmod -v 600 ${nginxkey} ${nginxcert} ${nginxcacert} ${nginxcertcombined}

          echo "action=nginx&value=restart&affect_php_fpm=no" >>${task_queue}
        fi

        #OLS
        if [ -d /usr/local/lsws/ssl.key ] && [ -d /usr/local/lsws/ssl.crt ]; then
          local olskey olscer olscacert olscertcombined
          olskey="/usr/local/lsws/ssl.key/server.key"
          olscert="/usr/local/lsws/ssl.crt/server.crt"
          olscacert="/usr/local/lsws/ssl.crt/server.ca"
          olscertcombined="${olscert}.combined"
          cp -fv ${key} ${olskey}
          cp -fv ${cert} ${olscert}
          cp -fv ${cacert} ${olscacert}
          cat ${olscert} ${olscacert} >${olscertcombined}
          chown -v root:root ${olskey} ${olscert} ${olscacert} ${olscertcombined}
          chmod -v 600 ${olskey} ${olscert} ${olscacert} ${olscertcombined}
          echo "action=openlitespeed&value=restart&affect_php_fpm=no" >>${task_queue}
        fi

        #FTP
        if command -v pure-ftpd &>/dev/null; then
          echo "Setting up cert for FTP server..."
          cat ${key} ${cert} ${cacert} >/etc/pure-ftpd.pem
          chmod -v 600 /etc/pure-ftpd.pem
          chown -v root:root /etc/pure-ftpd.pem

          if ${da_bin} c | grep -m1 -q "^pureftp=1\$"; then
            echo "action=pure-ftpd&value=restart" >>${task_queue}
          else
            echo "action=proftpd&value=restart" >>${task_queue}
          fi
        fi

        echo ""
        _echo "$(msg cyan)Enabling ssl=1 in directadmin.conf config...$(msg end)" --name
        ${da_bin} set ssl 1
        echo ""
        # This is to redirect hostname automatically to https
        _echo "$(msg cyan)Setting redirect_host_https yes in Directadmin options.conf config ...$(msg end)" --name
        ${da_cb_bin} set redirect_host_https yes
        echo ""
        # if you want everyone to be redirected on hostname use this
        _echo "$(msg cyan)Setting use_hostname_for_alias yes in Directadmin options.conf config ...$(msg end)" --name
        ${da_cb_bin} set use_hostname_for_alias yes
        echo ""

        echo "action=directadmin&value=restart" >>${task_queue}
        echo "The services will be restarted in about 1 minute via the dataskq."
        ${dataskq} --custombuild

      else
        # Below for requesting new certificate with staging test request
        _echo "$(msg cyan)Enabling ssl=1 in directadmin.conf config...$(msg end)" --name
        ${da_bin} set ssl 1
        echo ""
        _echo "$(msg cyan)Enabling cacert in directadmin.conf config...$(msg end)" --name
        ${da_bin} set cacert /usr/local/directadmin/conf/cacert.pem
        echo ""
        _echo "$(msg cyan)Enabling cakey in directadmin.conf config...$(msg end)" --name
        ${da_bin} set cakey /usr/local/directadmin/conf/cakey.pem
        echo ""
        # Add wellknown-alias by rewrite_confs
        _echo "$(msg cyan)Creating dummy acme-challenge texts through custombuild rewrite_confs ...$(msg end)" --name
        ${da_cb_bin} rewrite_confs
        echo ""

        # Make sure IP and domain are resolved
        ensure_domain_server_resolved
        ensure_fqhn_server_resolved

        echo ""
        # Staging call first
        has_ecc_certificates=$(cat "${da_conf}" | grep "^ecc_certificates=" | cut -d= -f2)
        _echo "$(msg cyan)Staging request SSL certificate for ${LABEL_C_BOX_HOSTNAME_FQHN} ...$(msg end)" --name
        if [ -n "${has_ecc_certificates}" ]; then
          staging=yes ${da_script_path}/letsencrypt.sh request_single ${C_BOX_HOSTNAME_FQHN} ${C_DA_CERTIFICATE_SIZE}
        else
          staging=yes ${da_script_path}/letsencrypt.sh request_single ${C_BOX_HOSTNAME_FQHN}
        fi
        retval=$?
        if [ "${retval}" -eq 0 ]; then
          _echo "$(msg green)OK, certificate staging request test return success code$(msg end)" --name

        else
          _echo "$(msg red)Error, certificate staging request test failed with return code ${retval}$(msg end)" --name
          _exit 147
        fi
        echo ""
        #7) Now let's request the real certificate after staging
        _echo "$(msg cyan)Requesting SSL certificate for ${LABEL_C_BOX_HOSTNAME_FQHN} ...$(msg end)" --name
        has_ecc_certificates=$(cat "${da_conf}" | grep "^ecc_certificates=" | cut -d= -f2)
        if [ -n "${has_ecc_certificates}" ]; then
          ${da_script_path}/letsencrypt.sh request_single ${C_BOX_HOSTNAME_FQHN} ${C_DA_CERTIFICATE_SIZE}
        else
          ${da_script_path}/letsencrypt.sh request_single ${C_BOX_HOSTNAME_FQHN}
        fi

        retval=$?
        if [ "${retval}" -eq 0 ]; then
          _echo "$(msg green)OK, certificate request return success code$(msg end)" --name
          echo ""
          _echo "$(msg cyan)Enabling ssl=1 in directadmin.conf config...$(msg end)" --name
          ${da_bin} set ssl 1
          echo ""

          # This fixed http protocol problem if cert has been requested as I reported here https://forum.directadmin.com/threads/might-be-bug-api-http-protocol-is-not-working-after-requesting-certificate.64408/
          # I also have another workaround to let the script select http or https (if available). To use this workaround enable this setting:
          # C_DA_AUTO_SELECT_API_PROTOCOL=true (remember this is beta feature. When directadmin released bug fixed, this feature will be disabled by default)

          # If I disable ssl below (set ssl=0 in directadmin.conf and restart), I can use both http and https on API for host domain:
          # BUT at this point, I decided to use my workaround using C_DA_AUTO_SELECT_API_PROTOCOL=true (so, I don't have to disable ssl option below. Only uncomment below if this failed)
          #_echo "$(msg cyan)Disabling ssl=0 in directadmin.conf config...$(msg end)" --name
          #${da_bin} set ssl 0

          # This is to redirect hostname automatically to https
          _echo "$(msg cyan)Setting redirect_host_https yes in Directadmin options.conf config ...$(msg end)" --name
          ${da_cb_bin} set redirect_host_https yes
          echo ""
          # if you want everyone to be redirected on hostname use this
          _echo "$(msg cyan)Setting use_hostname_for_alias yes in Directadmin options.conf config ...$(msg end)" --name
          ${da_cb_bin} set use_hostname_for_alias yes
          echo ""
          # Always a good idea to restart directadmin after changing directadmin.conf
          _echo "$(msg cyan)Restarting directadmin after changing directadmin.conf ...$(msg end)" --name
          restart_da
          echo ""
          while :; do
            local test_login
            _echo "$(msg cyan)Testing login into directadmin API using the main admin username ...$(msg end)" --name
            test_login=$(da_api_admin test-login --username $(get_current_da_owner_username) --scripting | grep "error=0")
            if [ -n "${test_login}" ]; then
              _echo "$(msg green) OK$(msg end)" --plain
              break
            else
              _echo "$(msg red) FAILED$(msg end)" --plain
              ensure_internet_connected
              ensure_domain_server_resolved
              ensure_fqhn_server_resolved
              echo ""
              _echo "$(msg cyan)Retrying login into directadmin API using the main admin username ...$(msg end)" --name
            fi
            sleep 3
          done
        else
          _echo "$(msg red)Error, server SSL certificate installation failed with return code ${retval}$(msg end)" --name
          _exit 147
        fi
      fi
    else
      _echo "$(msg yellow)Warning, skipped requesting certificate for ${LABEL_C_BOX_HOSTNAME_FQHN} because C_ENABLE_DA_HOST_SSL is not set to true $(msg end)" --name
      sleep 5
    fi

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This is a directadmin way to add IP into the interface
add_da_ip() {
  # This is to add DA script to add IP into device.
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local addip_script
    addip_script="/usr/local/directadmin/scripts/addip"
    echo "[${SCRIPT_NAME}]: Adding ipv6 address for Directadmin using DA addip official script ..."
    #echo "Usage: $0 <ip> (<netmask> (<eth dev> (<broadcast>)))";
    #echo "example: $0 1.2.3.4 255.255.255.0 eth0";
    if [ -f ${addip_script} ]; then
      "${addip_script}" "${C_IPV6_ADD0}" "255.255.255.0" "${C_NIC_INTERFACE_NAME}"
    else
      echo "[${SCRIPT_NAME}]: Warning, the directadmin script file ${addip_script} was not found. Bye!"
      _exit 147
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_hook_scripts() {
  :
}

# This maxibox is only used for backup purpose
configure_maxibox() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    ###
    # TODO: Add maxibox backup script here (PENDING)
    ###
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This is the pre-requisite components or packages for all maxicode binary
configure_maxicode_pre() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    ####
    # TODO: Add maxicode pre components here
    ###
    # WARNING do not install gawk it will break this script. This script doesn't work with gawk.
    #apt-get -y install bc jq gawk
    #required "debian@@apt:bc,jq,gawk"
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# maxicode will be the place to upgrade maxicode binaries (even when script finished running).
# example running maxibox --update-maxicode or maxibox --checkout-all maxibox
# usage: maxicode --update <package_name> or maxicode -u <package_name>
# eg: To update all package: maxicode -u all. To update just maxiwall: maxicode -u maxiwall
configure_maxicode() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    maxicode_bin="/usr/local/maxicode/maxicode"
    if [ -f ${maxicode_bin} ]; then
      echo "[${SCRIPT_NAME}]: Creating symlink and executable for ${maxicode_bin} ..."
      chmod +x ${maxicode_bin}
      # Symbolic name
      ln -s ${maxicode_bin} /usr/local/bin
    else
      echo "[${SCRIPT_NAME}]: Warning, maxicode doesn't exist in /usr/local/maxicode !"
      _exit 147
    fi

    # 1) Install aide and copy maxiaide files (make sure it works)
    # 2) Install rsync and copy maxinet files (make sure it works)
    # 3) Install suricata and copy maxiwall files (make sure it works)
    # 4) Copy maxicbuild

    #local ORI_PWD
    #echo "[${SCRIPT_NAME}]: Installing OSSEC ..."
    #sleep 2
    #echo "[${SCRIPT_NAME}]: Creating directory /usr/src if doesn't exist ..."
    #mkdir -p "${INST_TEMP_DIR}"
    #echo "[${SCRIPT_NAME}]: Removing previous download file ..."
    #rm -fv "${INST_TEMP_DIR}/3.6.0.tar.gz"
    #echo "[${SCRIPT_NAME}]: Downloading and extracting OSSEC file ..."
    #ORI_PWD="${PWD}"
    #cd "${INST_TEMP_DIR}" || {
    #  echo "Failed to enter into directory"
    #  _exit 147
    #}
    #wget https://github.com/ossec/ossec-hids/archive/3.6.0.tar.gz
    #tar xzf 3.6.0.tar.gz

    #cd ossec-hids-3.6.0/ || {
    #  echo "Failed to enter into directory"
    #  _exit 147
    #}
    #sh "install.sh"
    # If want to silent install follow this documentation: https://www.ossec.net/docs/manual/installation/install-source-unattended.html
    # Need to change the config file (uncomment setting)
    # Tip: To remove OSSEC use this
    # /var/ossec/bin/ossec-control stop && rm -rf /var/ossec && rm /etc/init.d/*ossec* && rm /etc/ossec-init.conf
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_maxiperm() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local maxiperm_bin
    echo "[${SCRIPT_NAME}]: Configuring maxiperm installation in maxicode ..."
    maxiperm_bin="/usr/local/maxicode/maxiperm/perm"
    if [ -f ${maxiperm_bin} ]; then
      echo "[${SCRIPT_NAME}]: Creating symlink and executable for ${maxiperm_bin} ..."
      chmod +x ${maxiperm_bin}
      # Symbolic name
      ln -s ${maxiperm_bin} /usr/local/bin
      echo "[${SCRIPT_NAME}]: Running perm -V ${maxiperm_bin} ..."
      perm -V
      get_status_message "$?"
    else
      echo "[${SCRIPT_NAME}]: Warning, maxiperm doesn't exist in /usr/local/maxicode !"
      _exit 147
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Harden server based on lynis suggestion
configure_maxinis() {
  # Here we do extra hardening for SSHD (based on lynis suggestion)
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local lynis_latest_version maxinis_bin
    maxinis_bin="/usr/local/maxicode/maxinis/maxinis"
    # SSHD config enough. No more
    # TODO MORE HERE for others based on lynis suggestion.. (Need to obtain the scan ID first and get that value)
    # Use that value and auto apply hardening here
    # Install latest lynis using:
    # Get latest version tar.gz inspired by: https://stackoverflow.com/questions/22510705/get-the-latest-download-link-programmatically
    echo "[${SCRIPT_NAME}]: Getting latest version of lynis ..."
    lynis_latest_version=$(curl 'https://downloads.cisofy.com/lynis/' | grep -oP 'href="lynis-\K[0-9]+\.[0-9]+\.[0-9]+' | sort -t. -rn -k1,1 -k2,2 -k3,3 | head -1)
    echo "[${SCRIPT_NAME}]: Latest version detected as ${lynis_latest_version}. Downloading lynis version ${lynis_latest_version} ..."
    mkdir -p /usr/local/lynis
    navigate_path "/usr/local"
    wget --no-verbose "https://cisofy.com/files/lynis-${lynis_latest_version}.tar.gz"
    echo "[${SCRIPT_NAME}]: Extracting lynis.tar.gz ..."
    tar xfvz "lynis-${lynis_latest_version}.tar.gz"
    rm -f "lynis-${lynis_latest_version}.tar.gz"
    navigate_path "lynis"
    # TODO: Configure maxinis binary here
    echo "[${SCRIPT_NAME}]: Checking system security with lynis ..."
    # No need to audit system during setup because ain't nobody got time for this
    #./lynis audit system
    if [ -f ${maxinis_bin} ]; then
      echo "[${SCRIPT_NAME}]: Creating symlink and executable for ${maxinis_bin} ..."
      chmod +x ${maxinis_bin}
      # Symbolic name
      ln -s ${maxinis_bin} /usr/local/bin
    else
      echo "[${SCRIPT_NAME}]: Warning, maxinis doesn't exist in /usr/local/maxicode !"
      _exit 147
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This function will configure GPG key management
# maxigpg need to init first before caching password: run: maxigpg --init
configure_maxigpg() {
  # Importatnt set passphrase https://www.gnupg.org/documentation/manuals/gnupg/Invoking-gpg_002dpreset_002dpassphrase.html
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local maxigpg_bin
    maxigpg_bin="/usr/local/maxicode/maxigpg/maxigpg"
    gpg_cache_duration_test=3
    # Install gpg here if does not exist but most distribution came with gpg installed
    if command -v gpg &>/dev/null; then
      _echo "OK gpg is installed with the following details: "
      echo ""
      gpg --version
    else
      _echo "Warning, required gpg binary is not found!"
      _exit 147
    fi
    echo ""
    _echo "$(msg cyan)Removing previous maxigpg symlink shortcut in /usr/local/bin ...$(msg end)" --name
    rm -f /usr/local/bin/maxigpg
    if [ -f ${maxigpg_bin} ]; then
      _echo "$(msg cyan)Setting ${maxigpg_bin} script to have executable permission ...$(msg end)" --name
      chmod +x "${maxigpg_bin}"
      _echo "$(msg cyan)Creating symlink for ${maxigpg_bin} ...$(msg end)" --name
      ln -s "${maxigpg_bin}" /usr/local/bin
      _echo "$(msg cyan)Running maxigpg -V ...$(msg end)" --name
      maxigpg -V
      get_status_message "$?"
      echo ""
    else
      _echo "$(msg red)Warning, maxigpg binary doesn't exist inside /usr/local/maxicode ...$(msg end)" --name
      _exit 147
    fi
    echo ""

    _echo "$(msg cyan)Removing existing .gnupg folder ...$(msg end)" --name
    rm -rf "${HOME}/.gnupg"
    mkdir -p "${HOME}/.gnupg"
    {
      echo "allow-preset-passphrase"
      echo "default-cache-ttl ${gpg_cache_duration_test}"
      echo "max-cache-ttl ${gpg_cache_duration_test}"
    } >"${HOME}/.gnupg/gpg-agent.conf"

    chmod 700 "${HOME}/.gnupg"
    chmod 600 "${HOME}/.gnupg/gpg-agent.conf"

    _echo "Writing a new gpg-agent socket file at /etc/systemd/system/gpg-agent.socket ... " --name
    # Writing gpg-agent.socket file
    {
      echo "[Unit]"
      echo "Description=GnuPG cryptographic agent and passphrase cache"
      echo "Documentation=man:gpg-agent(1)"
      # Must put this partOf if I want to stop gpg-agent, this will also automatically stop the socket
      echo "PartOf=gpg-agent.service"

      echo "[Socket]"
      echo "ListenStream=%t/gnupg/S.gpg-agent"
      echo "FileDescriptorName=std"
      echo "SocketMode=0600"
      echo "DirectoryMode=0700"
      echo ""
      echo "[Install]"
      echo "WantedBy=sockets.target"
    } >"/etc/systemd/system/gpg-agent.socket"
    echo ""
    # Writing gpg-agent.service file
    _echo "Writing a new gpg-agent service file at /etc/systemd/system/gpg-agent.service ... " --name
    {
      echo "[Unit]"
      echo "Description=GnuPG cryptographic agent and passphrase cache"
      echo "Documentation=man:gpg-agent(1)"
      echo "Requires=gpg-agent.socket"
      echo ""
      echo "[Service]"
      echo "ExecStart=/usr/bin/gpg-agent --options ${HOME}/.gnupg/gpg-agent.conf --supervised"
      echo "ExecReload=/usr/bin/gpgconf --reload gpg-agent"

    } >"/usr/lib/systemd/user/gpg-agent.service"

    chown root:root "/usr/lib/systemd/user/gpg-agent.service" "/etc/systemd/system/gpg-agent.socket"
    chmod 644 "/usr/lib/systemd/user/gpg-agent.service" "/etc/systemd/system/gpg-agent.socket"

    systemctl --user daemon-reload

    systemctl --user --global enable gpg-agent.socket

    systemctl --user stop gpg-agent.service
    #echo "Starting gpg-agent.service ..."
    systemctl --user start gpg-agent.service

    if [ "${C_GPG_USE_EXISTING_KEY}" == "true" ]; then
      _echo "$(msg cyan)Note: Using existing GPG key because C_GPG_USE_EXISTING_KEY variable is set to true in config file  ...$(msg end)" --name
      local gpg_priv_key gpg_priv_key_encrypted retval

      # This file must be encrypted (coming from maxicode)
      gpg_priv_key_encrypted="${SCRIPT_PATH}/gpg_private_key.gpg"

      if [ ! -f "${gpg_priv_key_encrypted}" ]; then
        _echo "$(msg cyan)Error, the GPG private key does not exist in ${gpg_priv_key_encrypted}. Make sure it exists before continue$(msg end)" --name
        _exit 147
      fi
      # This is the path for unencrypted key
      gpg_priv_key="${SCRIPT_PATH}/gpg_private_key"
      _echo "$(msg cyan)Removing existing unencrypted private key ${gpg_priv_key} ...$(msg end)" --name
      rm -f "${gpg_priv_key}"
      echo ""
      _echo "$(msg cyan)Unlocking existing encrypted private key ${gpg_priv_key_encrypted} ...$(msg end)" --name
      gpg --pinentry-mode=loopback --passphrase "${C_GPG_PASSPHRASE}" -d -o "${gpg_priv_key}" "${gpg_priv_key_encrypted}"
      echo ""
      echo "[${SCRIPT_NAME}]: Importing existing key into gpg-agent ..."
      gpg --pinentry-mode=loopback --passphrase "${C_GPG_PASSPHRASE}" --import "${gpg_priv_key}"
      retval=$?
      if [[ "${retval}" -eq 0 ]]; then
        local test_file
        _echo "$(msg green)Import OK$(msg end)" --name
        echo ""
        # Set trust to 5 for the key so we can encrypt without prompt.
        _echo "$(msg cyan)Setting trust to 5 for the key ${LABEL_C_GPG_OWNER_EMAIL} so we can encrypt without prompt ...$(msg end)" --name
        echo -e "5\ny\n" | gpg --command-fd 0 --expert --edit-key "${C_GPG_OWNER_EMAIL}" trust
        echo ""
        test_file="${SECURE_PATH}/gpg-test-file"
        echo "test" >"${test_file}"
        _echo "$(msg cyan)Testing key for encrypting on file ${test_file} ...$(msg end)" --name
        rm -f "${test_file}.asc" && gpg --verbose -e -a -r "${C_GPG_OWNER_EMAIL}" "${test_file}"
        retval=$?
        if [ "${retval}" -eq 0 ]; then
          _echo "$(msg green)Encryption test OK$(msg end)" --name
          rm -f "${test_file}"
          echo ""
        else
          _echo "$(msg red)Encryption test FAILED$(msg end)" --name
          _exit 147
        fi
        _echo "$(msg cyan)Testing key for decrypting on file ${test_file}.asc ...$(msg end)" --name
        rm -f "${test_file}"
        # When running this command, I actually cache the current passphrase in GPG
        gpg --pinentry-mode=loopback --passphrase ${C_GPG_PASSPHRASE} --output "${test_file}" --decrypt "${test_file}.asc" >/dev/null
        retval=$?

        if [ "${retval}" -eq 0 ]; then
          local elapsed_time retval
          _echo "$(msg green)Decryption test OK$(msg end)" --name
          echo ""
          _echo "$(msg yellow)Note at this moment, the passphrase is cached in GPG agent with PID: $(pidof gpg-agent)$(msg end)"
          echo ""
          # rm -f "${test_file}.asc" # Do not remove this, because we still want to test the timer below
          test_elapsed=0
          while :; do
            rm -f "${test_file}"
            _echo "$(msg cyan)Testing GPG decryption cache timer with test value less than ${gpg_cache_duration_test} second(s) ...$(msg end)" --name --start-spin
            echo 123 | gpg -q --pinentry-mode=loopback --passphrase-fd 0 --output "${test_file}" -d "${test_file}.asc" 2>/dev/null
            retval=$?
            if [ "${retval}" -ne 0 ]; then
              echo ""
              _echo "$(msg green)OK, passphrase cache was expired based on cache test duration$(msg end)" --name
              break
            else
              # if [ "${test_elapsed}" -gt 3 ]; then # Testing
              if [ "${test_elapsed}" -gt ${gpg_cache_duration_test} ]; then
                echo ""
                _echo "$(msg red)Error, passphrase cache is not expired based on cache test duration$(msg end)" --name --verbose 3
                _exit 147
              fi
            fi
            sleep 1
            ((test_elapsed++))
          done
          echo ""
          _echo "$(msg cyan)Creating new gpg-agent config setting to have cache duration based on config file ...$(msg end)" --name
          {
            echo "allow-preset-passphrase"
            echo "default-cache-ttl ${C_GPG_CACHE_DURATION}"
            echo "max-cache-ttl ${C_GPG_CACHE_DURATION}"
          } >"${HOME}/.gnupg/gpg-agent.conf"
          echo ""
          #_echo "$(msg cyan)Restarting gpg-agent to use new config ...$(msg end)" --name
          #systemctl --user restart gpg-agent
          _echo "$(msg cyan)Running maxigpg init ...$(msg end)" --name
          echo ""
          maxigpg init
          echo ""
          _echo "Any files that were encrypted using the newly created cert above can be unlocked automatically without passphrase"
          _echo "The cache passphrase has duration of ${C_GPG_CACHE_DURATION} second(s) based on config file ${HOME}/.gnupg/gpg-agent.conf"
          _echo "The new passphrase will be cached in gpg-agent on PID $(systemctl --user show --property MainPID --value gpg-agent)"
          echo ""
          _echo "$(msg green)OK, done configuring existing GPG key!${gpg_priv_key} ...$(msg end)" --name
        else
          _echo "$(msg red)Decryption test FAILED$(msg end)" --name
          _exit 147
        fi

      else
        _echo "$(msg red)Import FAILED$(msg end)" --name
        _exit 147
      fi
    else

      local gpgkey_temp gpg_success_mark test_generate has_success test_file retval
      gpgkey_temp="${SECURE_PATH}/gpgkey_temp.$(get_rnd_alpha 8)"
      gpg_success_mark=$(get_rnd_alpha 10)
      _echo "$(msg cyan)Creating a new GPG key template file ...$(msg end)" --name
      # Since we use this in bash built-in echo, do not worry about password leak in process (actually I dont like heredoc)
      {
        echo "%echo Generating a basic OpenPGP key for ${C_BOX_HOSTNAME_FQHN}"
        echo "Key-Type: RSA"
        echo "Key-Length: 4096"
        echo "Subkey-Type: RSA"
        echo "Subkey-Length: 4096"
        echo "Name-Real: ${C_ADMIN_NAME}"
        echo "Name-Comment: This is the main GPG key for ${C_ADMIN_NAME} in ${C_BOX_HOSTNAME_FQHN}"
        echo "Name-Email: ${C_GPG_OWNER_EMAIL}"
        echo "Expire-Date: 0"
        echo "Passphrase: ${C_GPG_PASSPHRASE}"
        echo "# Do a commit here, so that we can later print \"done\" :-)"
        echo "%commit"
        echo "%echo done"
        echo "%echo success: ${gpg_success_mark}"
      } >"${gpgkey_temp}"

      echo ""
      _echo "$(msg cyan)Generating a new GPG key based on the template file ${gpgkey_temp} ...$(msg end)" --name
      # Generate the key based on the above information
      test_generate=$(gpg --verbose --batch --generate-key ${gpgkey_temp} <<<"${passphrase}" 2>&1)
      retval=$?
      echo ""
      has_success="$(echo "${test_generate}" | grep "success: ${gpg_success_mark}")"
      echo "${test_generate}"
      echo ""

      if [[ -n "${has_success}" && "${retval}" -eq 0 ]]; then
        echo "OK, success"
        # Delete the options and decrypt the original to stdout.
        _echo "$(msg cyan)Removing the gpg key template ${gpgkey_temp} ...$(msg end)" --name
        rm -f "${gpgkey_temp}"
        echo ""
      else
        echo "Error, failed. Please check the template file syntax and make sure the file is accessible"
        exit 1
      fi
      echo ""

      # Set trust to 5 for the key so we can encrypt without prompt.
      _echo "$(msg cyan)Setting trust to 5 for the key ${LABEL_C_GPG_OWNER_EMAIL} so we can encrypt without prompt ...$(msg end)" --name
      echo -e "5\ny\n" | gpg --command-fd 0 --expert --edit-key "${C_GPG_OWNER_EMAIL}" trust
      echo ""
      test_file="${SECURE_PATH}/gpg-test-file"
      echo "test" >"${test_file}"
      # Test the key can encrypt and decrypt using the unused gpgkey_temp file we created
      _echo "$(msg cyan)Testing key for encrypting on file ${test_file} ...$(msg end)" --name
      rm -f "${test_file}.asc" && gpg --verbose -e -a -r "${C_GPG_OWNER_EMAIL}" "${test_file}"
      retval=$?
      if [ "${retval}" -eq 0 ]; then
        _echo "$(msg green)Encryption test OK$(msg end)" --name
        rm -f "${test_file}"
      else
        _echo "$(msg red)Encryption test FAILED$(msg end)" --name
        _exit 147
      fi

      _echo "$(msg cyan)Testing key for decrypting on file ${test_file}.asc ...$(msg end)" --name
      rm -f "${test_file}"
      # When running this command, I actually cache the current passphrase in GPG
      gpg --pinentry-mode=loopback --passphrase ${C_GPG_PASSPHRASE} --output "${test_file}" --decrypt "${test_file}.asc" >/dev/null
      retval=$?
      if [ "${retval}" -eq 0 ]; then
        local elapsed_time retval
        _echo "$(msg green)Decryption test OK$(msg end)" --name
        echo ""
        _echo "$(msg yellow)Note at this moment, the passphrase is cached in GPG agent with PID: $(pidof gpg-agent)$(msg end)"
        echo ""
        # rm -f "${test_file}.asc" # Do not remove this, because we still want to test the timer below
        test_elapsed=0
        while :; do
          rm -f "${test_file}"
          _echo "$(msg cyan)Testing GPG decryption cache timer with test value less than ${gpg_cache_duration_test} second(s) ...$(msg end)" --name --start-spin
          echo 123 | gpg -q --pinentry-mode=loopback --passphrase-fd 0 --output "${test_file}" -d "${test_file}.asc" 2>/dev/null
          retval=$?
          if [ "${retval}" -ne 0 ]; then
            echo ""
            _echo "$(msg green)OK, passphrase cache was expired based on cache test duration$(msg end)" --name
            break
          else
            # if [ "${test_elapsed}" -gt 3 ]; then # Testing
            if [ "${test_elapsed}" -gt ${gpg_cache_duration_test} ]; then
              echo ""
              _echo "$(msg red)Error, passphrase cache is not expired based on cache test duration$(msg end)" --name --verbose 3
              _exit 147
            fi
          fi
          sleep 1
          ((test_elapsed++))
        done
        echo ""
        _echo "$(msg cyan)Creating new gpg-agent config setting to have cache duration based on config file ...$(msg end)" --name
        {
          echo "allow-preset-passphrase"
          echo "default-cache-ttl ${C_GPG_CACHE_DURATION}"
          echo "max-cache-ttl ${C_GPG_CACHE_DURATION}"
        } >"${HOME}/.gnupg/gpg-agent.conf"
        echo ""
        #_echo "$(msg cyan)Restarting gpg-agent to use new config ...$(msg end)" --name
        #systemctl --user restart gpg-agent
        _echo "$(msg cyan)Running maxigpg init ...$(msg end)" --name
        echo ""
        maxigpg init
        echo ""
        _echo "Any files that were encrypted using the newly created cert above can be unlocked automatically without passphrase"
        _echo "The cache passphrase has duration of ${C_GPG_CACHE_DURATION} second(s) based on config file ${HOME}/.gnupg/gpg-agent.conf"
        _echo "The new passphrase will be cached in gpg-agent on PID $(systemctl --user show --property MainPID --value gpg-agent)"
        # Note I can use API to kill this gpg process (such as da_api_admin; the service variable). So that the password will not be used by other app
        echo ""
        _echo "$(msg green)OK, done configuring new GPG key!${gpg_priv_key} ...$(msg end)" --name
      else
        _echo "$(msg red)Decryption test FAILED$(msg end)" --name
        _exit 147
      fi

    fi
    echo ""
    _echo "$(msg cyan)Removing unprotected GPG key ${gpg_priv_key} ...$(msg end)" --name
    rm -f "${gpg_priv_key}"
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_maxinance() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local maxinance_bin
    maxinance_bin="/usr/local/maxicode/maxinance/maxinance"
    _echo "$(msg cyan)Removing previous maxinance symlink shortcut in /usr/local/bin ...$(msg end)" --name
    rm -f /usr/local/bin/maxinance
    if [ -f ${maxinance_bin} ]; then
      _echo "$(msg cyan)Setting ${maxinance_bin} script to have executable permission ...$(msg end)" --name
      chmod +x "${maxinance_bin}"
      _echo "$(msg cyan)Creating symlink for ${maxinance_bin} ...$(msg end)" --name
      ln -s "${maxinance_bin}" /usr/local/bin
      maxinance --version
      echo ""
    else
      _echo "$(msg red)Warning, maxinance binary doesn't exist inside /usr/local/maxicode ...$(msg end)" --name
      _exit 147
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_maxiaide() {
  # Under testing for new version AIDE. New AIDE version has different config format.
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local maxiaide_bin
    # install aide here
    #echo "[${SCRIPT_NAME}]: Installing AIDE file monitoring ..."
    apt-get -y remove aide aide-common
    apt-get -y purge aide-common
    required "debian@@apt:aide" "ubuntu@@apt:aide"
    maxiaide_bin="/usr/local/maxicode/maxiaide/maxiaide"
    _echo "$(msg cyan)Removing previous maxiaide symlink shortcut in /usr/local/bin ...$(msg end)" --name
    rm -f /usr/local/bin/maxiaide
    if [ -f ${maxiaide_bin} ]; then
      _echo "$(msg cyan)Setting ${maxiaide_bin} script to have executable permission ...$(msg end)" --name
      chmod +x "${maxiaide_bin}"
      _echo "$(msg cyan)Creating symlink for ${maxiaide_bin} ...$(msg end)" --name
      ln -s "${maxiaide_bin}" /usr/local/bin

      _echo "$(msg cyan)Running maxiaide -V ...$(msg end)" --name
      maxiaide -V
      get_status_message "$?"
      echo ""
      # Do not scan, we do not interest with this yet
      #_echo "$(msg cyan)Scanning maxiaide ...$(msg end)" --name
      #echo ""
      # maxiaide --scan

      # Do not remove this (MaxiAIDE will handle this)
      # Remove this to start from scratch (the maxiaide script will automatically copy the original custom config)
      #_echo "$(msg cyan)Removing existing aide config file at /usr/local/maxicode/maxiaide/conf/custom_aide.conf$(msg end)"
      #rm -rf /usr/local/maxicode/maxiaide/conf/custom_aide.conf
      echo ""
    else
      _echo "$(msg red)Warning, maxiaide binary doesn't exist inside /usr/local/maxicode ...$(msg end)" --name
      _exit 147
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_wpcli() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    curl -O https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar
    chmod +x wp-cli.phar
    sudo mv wp-cli.phar /usr/local/bin/wp
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_maxicli() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local maxicli_bin
    maxicli_bin="/usr/local/maxicode/maxicli/maxicli"
    _echo "$(msg cyan)Removing previous maxicli symlink shortcut in /usr/local/bin ...$(msg end)" --name
    rm -f /usr/local/bin/maxicli
    if [ -f ${maxicli_bin} ]; then
      _echo "$(msg cyan)Setting ${maxicli_bin} script to have executable permission ...$(msg end)" --name
      chmod +x "${maxicli_bin}"
      _echo "$(msg cyan)Creating symlink for ${maxicli_bin} ...$(msg end)" --name
      ln -s "${maxicli_bin}" /usr/local/bin
      maxicli --version
      echo ""
    else
      _echo "$(msg red)Warning, maxicli binary doesn't exist inside /usr/local/maxicode ...$(msg end)" --name
      _exit 147
    fi

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# maxida is used to manage directadmin functionalities including APIs.
# This is a very important tool if installed with directadmin
# the alias binary name is dacli
configure_maxida() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    if [ "${C_SERVER_TYPE}" == "directadmin" ]; then
      local dacli_bin
      dacli_bin="/usr/local/maxicode/maxida/dacli"
      _echo "$(msg cyan)Removing previous maxinance symlink shortcut in /usr/local/bin ...$(msg end)" --name
      rm -f /usr/local/bin/dacli
      if [ -f ${dacli_bin} ]; then
        _echo "$(msg cyan)Setting ${dacli_bin} script to have executable permission ...$(msg end)" --name
        chmod +x "${dacli_bin}"
        _echo "$(msg cyan)Creating symlink for ${dacli_bin} ...$(msg end)" --name
        ln -s "${dacli_bin}" /usr/local/bin
        echo ""
        _echo "$(msg cyan)Running dacli -V ...$(msg end)" --name
        dacli -V
        get_status_message "$?"
        echo ""
      else
        _echo "$(msg red)Warning, dacli  binary doesn't exist inside /usr/local/maxicode ...$(msg end)" --name
        _exit 147
      fi
    else
      _echo "$(msg yellow)[Skipped]: maxida is only for server with directadmin installation$(msg end)" --name
    fi

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_maxicron() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local maxicron_bin
    maxicron_bin="/usr/local/maxicode/maxicron/maxicron"
    if [ -f ${maxicron_bin} ]; then
      echo "[${SCRIPT_NAME}]: Creating symlink and executable for ${maxicron_bin} ..."
      chmod +x ${maxicron_bin}
      # Symbolic name
      ln -s ${maxicron_bin} /usr/local/bin
    else
      echo "[${SCRIPT_NAME}]: Warning, maxicron doesn't exist in /usr/local/maxicode !"
      _exit 147
    fi

    # Stopping some services to reduce memory usage like clamav:
    maxicron --stop-some-services
    # TODO add this:

    # 23 */12 * * * /usr/local/subcode/centmin/csfcf.sh csf >/dev/null 2>&1
    # Add the above command in crontab so it will run on startup
    {
      echo "# Stop some high memory processes 180 seconds (3 minutes) after reboot"
      echo "@reboot sleep 180 && maxicron --stop-some-services"
    } >>/etc/crontab

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_maxirbl() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local blcheck_bin
    blcheck_bin="/usr/local/maxicode/maxirbl/blcheck"
    _echo "$(msg cyan)Removing previous blcheck symlink shortcut in /usr/local/bin ...$(msg end)" --name
    rm -f /usr/local/bin/blcheck
    if [ -f ${blcheck_bin} ]; then
      _echo "$(msg cyan)Setting ${blcheck_bin} script to have executable permission ...$(msg end)" --name
      chmod +x "${blcheck_bin}"
      _echo "$(msg cyan)Creating symlink for ${blcheck_bin} ...$(msg end)" --name
      ln -s "${blcheck_bin}" /usr/local/bin
      echo ""
      _echo "$(msg cyan)Running blcheck -V ...$(msg end)" --name
      blcheck -V
      get_status_message "$?"
      echo ""
    else
      _echo "$(msg red)Warning, blcheck  binary doesn't exist inside /usr/local/maxicode ...$(msg end)" --name
      _exit 147
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_maxiwall() {
  #Fixed bug from this helpful solution:
  #https://forum.suricata.io/t/latest-suricata-6-0-2-with-rustc-has-trouble-installing-with-error-could-not-compile-lexical-core/1461/3
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local latest_suricata_version suricata_preferred_version rustup_preferred_version maxiwall_bin rblscan_bin # suricata_conf suricata_service is_masked

    if ! command -v blcheck &>/dev/null; then
      rblscan_bin="/usr/local/maxicode/maxiwall/rblscan"

      if [ -f ${rblscan_bin} ]; then
        echo "[${SCRIPT_NAME}]: Creating symlink and executable for ${rblscan_bin} ..."
        chmod +x ${rblscan_bin}
        # Symbolic name
        ln -s ${rblscan_bin} /usr/local/bin
      else
        echo "[${SCRIPT_NAME}]: Warning, rblscan doesn't exist in /usr/local/maxicode !"
        _exit 147
      fi
    fi

    # Must write config first because maxiwall -V needs this
    # Writing a new maxiwall.conf file (all sensitive variables should be declared in maxinet.conf and pass here)
    echo "[${SCRIPT_NAME}]: Writing default maxiwall.conf config file ..."
    sleep 1
    {
      echo "# CONFIG VERSION:"
      echo "CONFIG_VERSION=\"1.0\""
      echo ""
      echo "BOX_HOSTNAME_FQHN=\"${BOX_HOSTNAME_FQDN}\""
      echo ""
      echo "# GENERAL CONFIG:"
      echo "ENABLE_LOG=\"true\""
      echo ""
      echo "# SURICATA setting"
      echo "SURICATA_ENABLE_SCRIPT_LOG=\"true\""
      echo ""
      echo "# MAXIWALL.lua config"
      echo "MAXIWALL_ENABLE_LOG_RULE=\"true\""
      echo "MAXIWALL_REPORT_EMAIL=\"webmaster@sofibox.com\""
      echo "MAXIWALL_ENABLE_MAIL_REPORT=\"true\""
      echo "MAXIWALL_ENABLE_MAIL_ERROR_REPORT=\"true\""
      echo "MAXIWALL_ENABLE_AUTO_ACTION=\"true\""
      echo "MAXIWALL_ENABLE_SCRIPT_LOG=\"true\""
      echo "# These log names are located at /var/log/suricata/"
      echo "MAXIWALL_SCRIPT_LOG_NAME=\"maxiwall.log\""
      echo "MAXIWALL_ALERT_LOG_NAME=\"maxiwall-alert.log\""
      echo "MAXIWALL_MAIL_REPORT_LOG_NAME=\"mail-report.log\""
      echo "MAXIWALL_ENABLE_WHITELIST_IP=\"true\""
      echo "MAXIWALL_ENABLE_IGNORE_IP=\"true\""
      echo "MAXIWALL_ENABLE_SUPPRESS_IP=\"true\""
      echo "MAXIWALL_ENABLE_SUPPRESS_MSG=\"true\""
      echo "# Put value 0 to disable"
      echo "MAXIWALL_IP_ALERT_SLEEP_DURATION=\"3\""
      echo "# This is limit for IP SUSPICIOUS LOG"
      echo "MAXIWALL_IP_LOG_ALERT_MAX_COUNT=\"100\""
      echo "MAXIWALL_LIMIT_EMAIL_ALERT_REPORT_RATE=\"50\""
      echo "MAXIWALL_LIMIT_EMAIL_ERROR_REPORT_RATE=\"5\""
      echo "# Normally alert will have infinite alert count in log file"
      echo "# and it can crash the system if the count is so big"
      echo "# This will limit the number of alert and restart them automatically if they reached N count"
      echo "# Benefit of limiting this, it will reduce script reading the log file."
      echo "# Maximum is 100000"
      echo "# NOTE BLCHECK has its own limit"
      echo "MAXIWALL_LUA_ALERT_MAX_COUNT=\"1000\""
      echo ""
      echo "# GOTIFY CONFIG:"
      echo "ENABLE_GOTIFY_REPORT=\"true\""
      echo ""
      echo "# BLCHECK CONFIG:"
      echo "BLCHECK_ENABLE_RULE=\"true\""
      echo ""
      echo "# CSF CONFIG:"
      echo "CSF_ENABLE_AUTO_BLOCK=\"true\""
      echo "CSF_ENABLE_IPV4_CIDR_24_NETWORK_BLOCK=\"true\""
      echo "CSF_ENABLE_IP_WEB_REPORT=\"true\""
      echo ""
      echo "# AIPDB CONFIG:"
      echo "AIPDB_ENABLE_RULE=\"true\""
      echo "AIPDB_ENABLE_IP_WEB_REPORT=\"true\""
      echo "AIPDB_ENABLE_CACHE=\"true\""
      echo "# After N second, AIPDB IP info cache that has timestamp over this duration will be removed"
      echo "# 3600 = 1 hour"
      echo "AIPDB_IP_CACHE_INFO_DURATION=\"3600\""
      echo "# After N second, AIPDB IP report cache that has timestamp over this duration will be removed"
      echo "# 900 = 15 minutes"
      echo "AIPDB_IP_CACHE_REPORT_DURATION=\"900\""
      echo "AIPDB_CHECK_URL=\"${C_MAXIWALL_AIPDB_CHECK_URL}\""
      echo "AIPDB_REPORT_URL=\"${C_MAXIWALL_AIPDB_REPORT_URL}\""
      echo "# The main AIPDB key"
      echo "AIPDB_API_KEY=\"${C_MAXIWALL_AIPDB_API_KEY}\""
      echo ""
      echo "LINODE_ENABLE_FIREWALL=\"true\""
      echo "LINODE_AIPDB_API_KEY=\"${C_LINODE_API}\""

    } \
      >"/usr/local/maxicode/maxiwall/maxiwall.conf"

    _echo "$(msg cyan)Removing previous maxiwall symlink shortcut in /usr/local/bin ...$(msg end)" --name
    rm -f /usr/local/bin/maxiwall

    maxiwall_bin="/usr/local/maxicode/maxiwall/maxiwall"

    if [ -f ${maxiwall_bin} ]; then

      echo "[${SCRIPT_NAME}]: Creating symlink and executable for ${maxiwall_bin} ..."
      chmod +x ${maxiwall_bin}
      # Symbolic name
      ln -s ${maxiwall_bin} /usr/local/bin
      echo "[${SCRIPT_NAME}]: Running maxiwall -V ..."
      maxiwall -V
      get_status_message "$?"
    else
      echo "[${SCRIPT_NAME}]: Warning, maxiwall doesn't exist in /usr/local/maxicode !"
      _exit 147
    fi

    # Remove built-in package of rustc
    _echo "$(msg cyan)Removing rustc existing installation (with purge command)...$(msg end)" --name
    apt -y remove --purge rustc
    echo ""
    _echo "$(msg cyan)Removing cargo existing installation ...$(msg end)" --name
    apt -y remove cargo
    echo ""
    # Removing suricata compiled source:
    _echo "$(msg cyan)Removing suricata existing installation, log and service files ...$(msg end)" --name
    apt -y remove suricata
    echo ""
    _echo "$(msg cyan)Cleaning up old dependencies ...$(msg end)" --name
    apt -y autoremove
    echo ""
    _echo "$(msg cyan)Purging suricata ...$(msg end)" --name

    apt -y purge suricata
    echo ""
    _echo "$(msg cyan)Removing suricata leftover files ...$(msg end)" --name

    # Removing leftover files:
    rm -rf /usr/share/suricata
    rm -rf /etc/suricata
    rm -rf /var/lib/suricata
    rm -rf /var/log/suricata
    rm -f /usr/local/bin/suricata
    rm -f /etc/default/suricata
    rm -f /etc/init.d/suricata
    rm -f /etc/systemd/system/suricata.service
    echo ""

    if command -v rustup &>/dev/null; then
      _echo "$(msg cyan)Removing rustup using rustup self uninstall command ...$(msg end)" --name
      rustup self uninstall -y
      echo ""
    fi
    _echo "Reloading systemctl daemon service after making changes to systemd service ..."
    systemctl daemon-reload
    echo ""

    # What version should be installed
    suricata_preferred_version="${C_SURICATA_SELECT_VERSION}"
    rustup_preferred_version="${C_INSTALL_RUSTC_VERSION}"

    if [ "${suricata_preferred_version}" == "distro" ]; then
      if [ ${DISTRO_CODENAME} == "bullseye" ]; then
        local suricata_log_file suricata_config_file retval
        suricata_log_file="/var/log/suricata/suricata.log"
        suricata_config_file="/etc/suricata/suricata.yaml"

        _echo "$(msg cyan)Installing suricata version on Debian Bullseye using distro package ...$(msg end)" --name
        apt -y install suricata
        sleep 3
        echo ""
        # Check the path after install suricata
        check_path "${suricata_log_file}" "${suricata_config_file}"
        echo ""

        # This will update all the code
        maxiwall update-scripts
        # This will add extra rules (3rd party)
        maxiwall add-extra-rules
        # This will initialize and run suricata with rule update
        maxiwall init

        # The rule file must exist:
        check_path "/var/lib/suricata/rules/suricata.rules"
        echo ""

        _echo "$(msg cyan)Checking whether suricata log file contains <Warning> line ...$(msg end)" --name
        grep "<Warning>" "${suricata_log_file}"
        retval=$?
        if [ "${retval}" -eq 0 ]; then
          _echo "$(msg red)Error, there is a <Warning> log in ${suricata_log_file}. Please inspect the log file$(msg end)" --name
          _exit 147
        else
          _echo "$(msg green)OK$(msg end)" --name
        fi
        echo ""
      else

        _echo "$(msg yellow)Warning, this distro is not supported code name ${C_OS_SET_CODE_NAME}.$(msg end)" --name
        _exit 147
      fi
    elif [ "${suricata_preferred_version}" == "backport" ]; then
      if [ "${DISTRO_ID}" == "debian" ]; then
        if [ ${DISTRO_CODENAME} == "buster" ]; then
          _echo "Installing suricata backport version on Debian Buster..."
          echo "deb http://http.debian.net/debian buster-backports main" >/etc/apt/sources.list.d/backports.list
          apt-get -y install suricata -t buster-backports
        else
          _echo "$(msg yellow)Warning, this backport is not supported in this debian code name ${DISTRO_CODENAME}.$(msg end)" --name
          echo "Please go to suricata website to get the new instruction how to install the backport for debian!"
          _exit 147
        fi
      else
        _echo "Invalid DISTRO_ID selection. This DISTRO ${DISTRO_ID} is not supported in ${SCRIPT_NAME} to install suricata!"
        _exit 147
      fi
    else # This one compatible with suricata 6.0.2
      if [ "${latest_suricata_version}" != "${suricata_preferred_version}" ]; then
        _echo "Warning, suricata latest version is: ${latest_suricata_version} but selected version in config file is ${C_SURICATA_SELECT_VERSION}"
        _pause 5
      fi

      # suricata_conf="/etc/suricata/suricata.yaml"
      # Instruction: https://forum.suricata.io/t/install-suricata-6-0-1-on-debian-10-from-source/992
      # Install required components for suricata:
      _echo "$(msg cyan)Installing required components for suricata & maxiwall ...$(msg end)" --name
      echo ""
      _echo "$(msg cyan)Installing essential tools for compilation ...$(msg end)" --name
      apt-get install make autoconf automake libtool
      echo ""
      _echo "$(msg cyan)Installing suricata required components ...$(msg end)" --name
      apt-get -y install libpcre3 libpcre3-dbg libpcre3-dev build-essential libpcap-dev \
        libnet1-dev libyaml-0-2 libyaml-dev pkg-config zlib1g zlib1g-dev liblz4-dev \
        libcap-ng-dev libcap-ng0 libmagic-dev libjansson-dev libnspr4-dev \
        libnss3-dev libgeoip-dev liblua5.1-dev libhiredis-dev libevent-dev \
        python-yaml python3-distutils python3-pip #rustc cargo
      echo ""
      _echo "$(msg cyan)Installing suricata python required library...$(msg end)" --name
      pip3 install PyYAML
      # NOTE! Do not install rustc and cargo
      # This will fix this error -> ERROR: Suricata now requires Rust to build (Debian has bug with rustc package)
      # Bug details: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=976601 | https://redmine.openinfosecfoundation.org/issues/4204
      # workaround step: https://stackoverflow.com/questions/65330382/building-suricata-could-not-compile-der-parser
      echo ""

      navigate_path "${INST_TEMP_DIR}"
      # source configuration
      # Do not use apt to install. Currently Debian package uses old version 4.1.2 but the latest is 6.0.2
      # For CentOS rpm package will install only version 5. So the best is to compile from source using this trick:

      latest_suricata_version=$(curl 'https://www.openinfosecfoundation.org/download/' | grep -oP 'href="suricata-\K[0-9]+\.[0-9]+\.[0-9]+' | sort -t. -rn -k1,1 -k2,2 -k3,3 | head -1)

      _echo "Installing the latest rustc package manually ..."
      rustup_install=$(curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y 2>&1 | grep 'likely because of mounting /tmp')
      # If the error message of 'likely because of mounting /tmp' is shown, then we need to get the location of the mentioned file in tmp
      if [ -n "${rustup_install}" ]; then

        rustup_tmp_init=$(echo "${rustup_install}" | awk '{ print $3 }')
        _echo "Error found. Resolving error of message of: ${rustup_install} ..."
        _echo "The rustup-init file is at this location: ${rustup_tmp_init}"
        #sleep 2
        cp "${rustup_tmp_init}" "${INST_TEMP_DIR}/rustup-init"
        # Execute the rustup-init installation silently. For more info look at rustup-init --help
        _echo "Executing rustup-init file ..."
        "${INST_TEMP_DIR}/rustup-init" -y
        # Some fixes if rustup does not execute:
        #source "$HOME/.profile"
        #export PATH="$HOME/.cargo/bin:$PATH"
      else
        _echo green "OK, rustup installation directory is writeable"
      fi

      _echo "Changing rustup version to ${rustup_preferred_version} ..."
      rustup install "${rustup_preferred_version}"
      export RUSTUP_TOOLCHAIN="${rustup_preferred_version}"

      # Need to source once in order to use rustrc  source "$HOME/.cargo/env"
      _echo "Sourcing cargo env file ..."
      source "$HOME/.cargo/env"

      _echo "Removing suricata downloaded file suricata-${suricata_preferred_version}.tar.gz ..."
      rm -f "${INST_TEMP_DIR}/suricata-${suricata_preferred_version}.tar.gz"
      get_status_message "$?"
      _echo "Downloading suricata latest version-${suricata_preferred_version} ..."
      wget --no-verbose "https://www.openinfosecfoundation.org/download/suricata-${suricata_preferred_version}.tar.gz"
      _echo "Extracting suricata version-${suricata_preferred_version} ..."
      tar xzvf "suricata-${suricata_preferred_version}.tar.gz"
      get_status_message "$?"
      navigate_path "suricata-${suricata_preferred_version}/"
      _echo "Configuring script for getting ready to build suricata ... "
      # Dont enable IPS because we will integrate blocking with CSF (using my script called maxicode/maxiwall)
      ./configure --libdir=/usr/lib64 --prefix=/usr/local --sysconfdir=/etc --localstatedir=/var --datarootdir=/usr/local/share --enable-lua --enable-rust
      #make
      #sudo make install
      _echo "Installing suricata with make install-full ... "
      sudo RUSTUP_TOOLCHAIN="${C_INSTALL_RUSTC_VERSION}" make install-full

      # Use this ldconfig to prevent error described here:
      # https://stackoverflow.com/questions/65330382/building-suricata-could-not-compile-der-parser
      # sudo ldconfig
      # suricata -V
      # Backport latest version as for now is 6.0.1
    fi

    if command -v suricata &>/dev/null; then
      _echo "Suricata is installed with the following details: "
      suricata -V
      sleep 2
    else
      _echo "Warning, no suricata binary is found! Please inspect the log file why"
      _exit 147
    fi
    # Maxiwall --init will do all the commented below (already have this function long time ago).

    # Then Create the service file
    #echo "[${SCRIPT_NAME}]: Creating a new suricata.service file ..."
    #sleep 1

    #{
    #  echo "# ==============================================="
    #  echo "# This configuration file was generated by ${SCRIPT_NAME}"
    #  echo "# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}"
    #  echo "# ==============================================="
    #  echo "[Unit]"
    #  echo "Description=Suricata IDS/IDP Service"
    #  echo "Wants=network.target syslog.target"
    #  echo "After=network.target syslog.target"
    #  echo "Documentation=man:suricata(8) man:suricatasc(8)"
    #  echo "Documentation=https://redmine.openinfosecfoundation.org/projects/suricata/wiki"
    #  echo ""
    #  echo "[Service]"
    #  echo "Type=forking"
    #  echo "Environment=LD_PREDLOAD=/usr/lib/x86_64-linux-gnu/libtcmalloc_minimal.so.4"
    #  echo "# Debug level ---> -v: INFO | -vv: INFO+PERF | -vvv: INFO+PERF+CONFIG | -vvvv: INFO+PERF+CONFIG+DEBUG"
    #  echo "# D - means in daemon | -c read config | --pidfile <file> write pidfile on a file"
    #  echo "ExecStart=suricata --af-packet -vvv -D -c /etc/suricata/suricata.yaml --pidfile /var/run/suricata.pid"
    #  echo "ExecStartPre=rm -f /var/run/suricata.pid"
    #  echo "ExecStop=kill \$MAINPID && rm -f /var/run/suricata.pid"
    #  echo "ExecReload=kill -9 \$MAINPID"
    #  echo ""
    #  echo "[Install]"
    #  echo "WantedBy=multi-user.target"
    #} >/etc/systemd/system/suricata.service
    #sleep 1
    #echo "[${SCRIPT_NAME}]: Checking if suricata.service is masked ..."
    #sleep 1
    #is_masked=$(systemctl status suricata | grep -c 'masked')
    #is_masked=$(ls -l /etc/systemd/system/suricata.service | grep -c '/dev/null')
    #if [ "${is_masked}" -gt 0 ]; then
    #  echo "[${SCRIPT_NAME}]: Warning, the suricata.service is masked. Unmasking the service file ..."
    #  sleep 1
    #  systemctl unmask suricata
    #else
    #  echo "[${SCRIPT_NAME}]: OK, the suricata.service is not masked"
    #fi

    # Enable suricata before starting at /etc/default/suricata (doesn't seems important when I use the above script)
    # Before starting suricata, I need to use custom config file (suricata.yaml) for best performance:

    #echo "[${SCRIPT_NAME}]: Copying suricata.yaml configuration file template into ${suricata_conf} ..."
    #sleep 1
    #cp "${DATA_PATH}/maxinet/storage/os/${DISTRO_ID}/usr/local/maxicode/maxiwall/code/etc/suricata/suricata.yaml" "${suricata_conf}"

    #echo "[${SCRIPT_NAME}]: Copying maxiwall.lua into /etc/suricata/lua-output ..."
    #mkdir -p /etc/suricata/lua-output
    #sleep 1

    #cp "${DATA_PATH}/maxinet/storage/os/${DISTRO_ID}/usr/local/maxicode/maxiwall/code/etc/suricata/lua-output/maxiwall.lua" "/etc/suricata/lua-output/maxiwall.lua"
    #chmod +x "/etc/suricata/lua-output/maxiwall.lua"

    #echo "[${SCRIPT_NAME}]: Copying maxiwall-http.lua into /etc/suricata/lua-output ..."
    #mkdir -p /etc/suricata/lua-output
    #sleep 1
    #cp "${DATA_PATH}/maxinet/storage/os/${DISTRO_ID}/usr/local/maxicode/maxiwall/code/etc/suricata/lua-output/maxiwall-http.lua" "/etc/suricata/lua-output/maxiwall-http.lua"
    #chmod +x "/etc/suricata/lua-output/maxiwall-http.lua"

    #echo "[${SCRIPT_NAME}]: Starting suricata ... "
    #sleep 1
    #systemctl start suricata
    #suricata_service=$(systemctl is-active suricata)

    #if [ "${suricata_service}" == "active" ]; then
    #  echo "[${SCRIPT_NAME}]: OK, suricata is running"
    #else
    #  echo "[${SCRIPT_NAME}]: Warning, suricata process is not active [unknown reason]. Please inspect log file to understand the reason"
    #  _exit 147
    #fi

    # maxiwall --initfull will handle 3rd party rules and signature update
    # suricata-update update-sources
    #echo "[${SCRIPT_NAME}]: Updating suricata new signature ..."
    #sleep 1
    #suricata-update

    # Maxiwall --initfull will do all the commented above (already have this function long time ago).
    # Must have maxiwall.conf file first before running --initfull
    echo "[${SCRIPT_NAME}]: Running maxiwall init ..."
    sleep 1
    maxiwall init

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# For managing cloud storage. Like mounting cloud storage, send file or receive file from cloud. maxicloud will handle that.
# Todo configure maxicloud for backup in DA
configure_maxicloud() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local maxiaide_bin
    local maxicloud_bin maxicloud_conf maxicloud_conf_sample
    maxicloud_bin="/usr/local/maxicode/maxicloud/maxicloud"
    maxicloud_conf="/usr/local/maxicode/maxicloud/maxicloud.conf"
    maxicloud_conf_sample="/usr/local/maxicode/maxicloud/maxicloud.conf.sample"

    if [ -f ${maxicloud_conf_sample} ]; then
      echo "[${SCRIPT_NAME}]: Copying maxicloud sample config into ${maxicloud_conf} ..."
      cp -f ${maxicloud_conf_sample} ${maxicloud_conf}
    else
      echo "[${SCRIPT_NAME}]: Warning, the sample config file ${maxicloud_conf_sample} does not exist. Please inspect the file!"
      _exit 147
    fi
    if [ -f ${maxicloud_bin} ]; then
      echo "[${SCRIPT_NAME}]: Creating symlink and executable for ${maxicloud_bin} ..."
      sleep 1
      chmod +x ${maxicloud_bin}
      # Symbolic name
      ln -s ${maxicloud_bin} /usr/local/bin
    else
      echo "[${SCRIPT_NAME}]: Warning, maxicloud doesn't exist in /usr/local/maxicode !"
      _exit 147
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This function configure password management of maxipass
configure_maxipass() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local maxipass_bin maxipass_conf maxipass_conf_sample #maxipass_da_conf maxipass_da_conf_sample
    maxipass_bin="/usr/local/maxicode/maxipass/maxipass"
    maxipass_conf="/usr/local/maxicode/maxipass/maxipass.conf"
    maxipass_conf_sample="/usr/local/maxicode/maxipass/maxipass.conf.sample"
    #maxipass_da_conf="/usr/local/maxicode/maxipass/secure/da/da.conf"
    #maxipass_da_conf_sample="/usr/local/maxicode/maxipass/secure/da/da.conf.sample"

    if [ -f ${maxipass_conf_sample} ]; then
      echo "[${SCRIPT_NAME}]: Copying maxipass sample config into ${maxipass_conf} ..."
      cp -f ${maxipass_conf_sample} ${maxipass_conf}
    else
      echo "[${SCRIPT_NAME}]: Warning, the sample config file ${maxipass_conf_sample} does not exist. Please inspect the file!"
      _exit 147
    fi

    #if [ -f ${maxipass_da_conf_sample} ]; then
    #  echo "[${SCRIPT_NAME}]: Copying maxipass-da sample config into ${maxipass_da_conf} ..."
    #  cp -f ${maxipass_da_conf_sample} ${maxipass_da_conf}
    #  sleep 1
    # Put admin authentication (this should be encrypted and only accessed by GPG agent):
    #  sed -i "s/^API_USERNAME=.*/API_USERNAME=\"${C_DA_OWNER_USERNAME1}\"/" ${maxipass_da_conf}
    #  sed -i "s/^API_USERPASS=.*/API_USERPASS=\"${C_DA_OWNER_USERPASS1}\"/" ${maxipass_da_conf}
    #else
    #  echo "[${SCRIPT_NAME}]: Warning, the sample config file ${maxipass_da_conf_sample} does not exist. Please inspect the file!"
    #  _exit 147
    #fi

    if [ -f ${maxipass_bin} ]; then
      echo "[${SCRIPT_NAME}]: Creating symlink and executable for ${maxipass_bin} ..."
      sleep 1
      chmod +x ${maxipass_bin}
      # Symbolic name
      ln -s ${maxipass_bin} /usr/local/bin
    else
      echo "[${SCRIPT_NAME}]: Warning, maxipass doesn't exist in /usr/local/maxicode !"
      _exit 147
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Configure database management tools
configure_maxidb() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    mkdir -p /usr/local/maxicode/maxidb
    _echo "$(msg cyan)Removing existing mysqltuner files from /usr/local/maxicode/maxidb/mysqltuner ...$(msg end)" --name
    rm -f /usr/local/maxicode/maxidb/mysqltuner
    rm -f /usr/local/maxicode/maxidb/basic_passwords.txt
    rm -f /usr/local/maxicode/maxidb/vulnerabilities.csv
    rm -f /usr/local/sbin/mysqltuner
    echo ""
    _echo "$(msg cyan)Downloading and setup mysqltuner ...$(msg end)" --name
    wget --no-verbose -O /usr/local/maxicode/maxidb/mysqltuner mysqltuner.pl
    wget --no-verbose -O /usr/local/maxicode/maxidb/basic_passwords.txt https://raw.githubusercontent.com/major/MySQLTuner-perl/master/basic_passwords.txt
    wget --no-verbose -O /usr/local/maxicode/maxidb/vulnerabilities.csv https://raw.githubusercontent.com/major/MySQLTuner-perl/master/vulnerabilities.csv
    chmod 710 /usr/local/maxicode/maxidb/mysqltuner
    ln -s /usr/local/maxicode/maxidb/mysqltuner /usr/local/sbin/mysqltuner
    if command -v mysqltuner &>/dev/null; then
      _echo "$(msg green)OK, mysqltuner has been installed$(msg end)" --name
    else
      _echo "$(msg red)Error, mysqltuner command is missing. Please inspect manually and re-run this script to continue$(msg end)" --name
      _exit 147
    fi
    echo ""

    _echo "$(msg cyan)Checking mysqltuner related files ...$(msg end)" --name
    check_path "/usr/local/maxicode/maxidb/mysqltuner" "/usr/local/maxicode/maxidb/basic_passwords.txt" "/usr/local/maxicode/maxidb/vulnerabilities.csv"
    echo ""
    _echo "$(msg cyan)Scanning mysqltuner ...$(msg end)" --name
    mysqltuner --passwordfile /usr/local/maxicode/maxidb/basic_passwords.txt --cvefile /usr/local/maxicode/maxidb/vulnerabilities.csv
    # TODO will auto fix mysqltuner suggestion
    #  https://stackoverflow.com/questions/47082865/mariadb-optimization-and-mysqltuner-pl-ram-and-tuning
    #when you execute mysqltuner, you will get suggestion what to tweak for your sql.
    #The mysqltuner will read directadmin mysql.conf password that you have specified before.
    #In case it cannot read and trigger an error.
    #Make sure the password doesn't contain this character > or < because mysqltuner does not support it.
    # Mysqltuner also does not accept this password: )

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_maxify() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    #sudo ./gotify-${platform}
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}
# TODO configure log functions
configure_logs() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    :

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Note: it's best not to use owner. Use admin instead to manage DA user for security purpose
# There is no official documentation how to upload a directadmin logo using API through bash/curl.
# It's a a bit tricky how to do this. This is my own method also written in here:
# https://forum.directadmin.com/threads/cmd_api_skins-upload-skin-logo-via-curl-issue.63127/
configure_da_owner_skins() {
  # We can customize this skin evolution based on this file /usr/local/directadmin/data/users/username/skin_customization/evolution/user_options.json
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_conf_file da_temp_dir logo_path default_logo_file dark_mode_logo_file
    da_conf_file="/usr/local/directadmin/conf/directadmin.conf"
    if [ ! -f "${da_conf_file}" ]; then
      _echo "$(msg red)Error, the directadmin configuration file does not exist!$(msg end)" --name
      _exit 147
    fi
    _echo "$(msg cyan)Setting directadmin skin setting with recommend values for owner1 ...$(msg end)" --name
    da_api_admin set-da-skin-settings --skin-name "evolution" --recommend-values
    echo ""

    # This is the part to upload logo
    # Directadmin needs this home temporary folder to hold upload file (this is a must)
    da_temp_dir=$(grep "^tmpdir" "${da_conf_file}" | cut -d= -f2)
    if [ -z "${da_temp_dir}" ]; then
      da_temp_dir="/home/tmp"
    fi
    mkdir -p "${da_temp_dir}"
    logo_path="${LATEST_OS_CODE_PATH}/usr/local/directadmin/logo"

    _echo "$(msg cyan)Setting directadmin default logo owner1 ...$(msg end)" --name
    if [[ -f "${logo_path}/default_logo.png" ]]; then
      da_api_admin set-da-logo --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/default_logo.png"
    else
      _echo "$(msg yellow)Warning, missing logo file default_logo.png. Make sure this file exist in ${logo_path}/default_logo.png!" --name
      _echo "$(msg yellow)If you want to have this logo, just put it at ${logo_path}/default_logo.png$(msg end)" --name
    fi
    echo ""

    _echo "$(msg cyan)Setting directadmin dark logo owner1 ...$(msg end)" --name
    if [[ -f "${logo_path}/dark_mode_logo.png" ]]; then
      da_api_admin set-da-logo --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/dark_mode_logo.png"
    else
      _echo "$(msg yellow)Warning, missing logo file dark_mode_logo.png. Make sure this file exist in ${logo_path}/dark_mode_logo.png!" --name
      _echo "$(msg yellow)If you want to have this logo, just put it at ${logo_path}/dark_mode_logo.png$(msg end)" --name
    fi
    echo ""

    _echo "$(msg cyan)Setting directadmin favourite icon logo owner1 ...$(msg end)" --name
    if [[ -f "${logo_path}/favicon.png" ]]; then
      da_api_admin set-da-logo --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/favicon.png"
    else
      _echo "$(msg yellow)Warning, missing logo file favicon.png. Make sure this file exist in ${logo_path}/favicon.png!" --name
      _echo "$(msg yellow)If you want to have this logo, just put it at ${logo_path}/favicon.png$(msg end)" --name
    fi
    echo ""

    _echo "$(msg cyan)Setting directadmin default symbol logo owner1 ...$(msg end)" --name
    if [[ -f "${logo_path}/default_symbol.png" ]]; then
      da_api_admin set-da-logo --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/default_symbol.png"
    else
      _echo "$(msg yellow)Warning, missing logo file default_symbol.png. Make sure this file exist in ${logo_path}/default_symbol.png!" --name
      _echo "$(msg yellow)If you want to have this logo, just put it at ${logo_path}/default_symbol.png$(msg end)" --name
    fi
    echo ""

    _echo "$(msg cyan)Setting directadmin dark symbol logo owner1 ...$(msg end)" --name
    if [[ -f "${logo_path}/dark_symbol.png" ]]; then
      da_api_admin set-da-logo --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/dark_symbol.png"
    else
      _echo "$(msg yellow)Warning, missing logo file dark_symbol.png. Make sure this file exist in ${logo_path}/dark_symbol.png!" --name
      _echo "$(msg yellow)If you want to have this logo, just put it at ${logo_path}/dark_symbol.png$(msg end)" --name
    fi

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_owner_security() {
  # Set owner security and answer questions:
  # da_api_admin "set-security-qna" "Sekolah menengah dulu aliran apa ?" "sains"
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_owner_username da_owner_security_qna da_owner_security_qna_count owner_count question_count

    da_owner_usernames_count=$(echo "${!C_DA_OWNER_USERNAME@}" | wc -w)
    owner_count=1
    while [ ${owner_count} -le "${da_owner_usernames_count}" ]; do
      # Assign all variables from the config file as array index
      typeset -n "da_owner_username=C_DA_OWNER_USERNAME${owner_count}"
      typeset -n "da_owner_security_qna=C_DA_OWNER_SECURITY_QNA${owner_count}"
      da_owner_security_qna_count="${#da_owner_security_qna[@]}"

      _echo "$(msg newline)" --plain --verbose 7
      _echo "$(msg yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(msg end)" --name --verbose 7
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7
      _echo "Owner security question details:" --name --verbose 7
      _echo "Owner count ${owner_count} out of ${da_owner_usernames_count}" --name --verbose 7
      _echo "da_owner_username: ${da_owner_username}" --name --verbose 7
      _echo "da_owner_security_qna  ${da_owner_security_qna[*]}" --name --verbose 7
      _echo "da_owner_security_qna_count: ${da_owner_security_qna_count[*]}" --name --verbose 7
      _echo "$(msg newline)" --plain --verbose 7

      question_count=1
      if [[ "${#da_owner_security_qna}" == 0 ]]; then
        echo "[${SCRIPT_NAME}]: [skipped]: Value defined for security_question for user ${da_owner_username} is empty"
      else
        while [ "${question_count}" -le ${da_owner_security_qna_count} ]; do
          local security_question_answer security_question security_answer
          security_question_answer=${da_owner_security_qna[question_count - 1]}
          security_question="$(echo ${security_question_answer} | awk -F'\|\|\|' '{ print $1 }')"
          security_answer="$(echo ${security_question_answer} | awk -F'\|\|\|' '{ print $2 }')"

          _echo "Security question count ${question_count} out of ${da_owner_security_qna_count}" --name --verbose 7
          _echo "Security question for owner: ${da_owner_username}" --name --verbose 7
          _echo "Security question_answer: ${security_question_answer}" --name --verbose 7
          _echo "Security question: ${security_question}" --name --verbose 7
          _echo "Security answer: ${security_answer}" --name --verbose 7
          _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7

          _echo "$(msg cyan)Setting up security questions and answers for user ${da_owner_username}$(msg end)" --name
          da_api_admin set-security-qna --question "${security_question}" --answer "${security_answer}"
          #echo ""
          ((question_count++))
        done

      fi
      ((owner_count++))
    done
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Configure DA skins like set the time format, set logo (focus on Evolution Skin)
configure_da_admin_skins() {
  # We can customize this skin evolution based on this file /usr/local/directadmin/data/users/username/skin_customization/evolution/user_options.json
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_conf_file da_temp_dir logo_path default_logo_file dark_mode_logo_file
    da_conf_file="/usr/local/directadmin/conf/directadmin.conf"
    if [ ! -f "${da_conf_file}" ]; then
      _echo "$(msg red)Error, the directadmin configuration file does not exist!$(msg end)" --name
      _exit 147
    fi
    _echo "$(msg cyan)Setting directadmin skin setting with recommend values for admin1...$(msg end)" --name
    da_api_admin set-da-skin-settings --sign-as "admin1" --skin-name "evolution" --recommend-values
    echo ""
    # There is no official documentation how to upload a directadmin logo using API. This is my own method also written in here:
    # https://forum.directadmin.com/threads/cmd_api_skins-upload-skin-logo-via-curl-issue.63127/

    # This is the part to upload logo
    # Directadmin needs this home temporary folder to hold upload file (this is a must)
    da_temp_dir=$(grep "^tmpdir" "${da_conf_file}" | cut -d= -f2)
    if [ -z "${da_temp_dir}" ]; then
      da_temp_dir="/home/tmp"
    fi
    mkdir -p "${da_temp_dir}"
    logo_path="${LATEST_OS_CODE_PATH}/usr/local/directadmin/logo"

    _echo "$(msg cyan)Setting directadmin default logo for admin1 ...$(msg end)" --name
    if [[ -f "${logo_path}/default_logo.png" ]]; then
      da_api_admin set-da-logo --sign-as "admin1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/default_logo.png"
    else
      _echo "$(msg yellow)Warning, missing logo file default_logo.png. Make sure this file exist in ${logo_path}/default_logo.png!" --name
      _echo "$(msg yellow)If you want to have this logo, just put it at ${logo_path}/default_logo.png$(msg end)" --name
    fi
    echo ""

    _echo "$(msg cyan)Setting directadmin dark logo for admin1 ...$(msg end)" --name
    if [[ -f "${logo_path}/dark_mode_logo.png" ]]; then
      da_api_admin set-da-logo --sign-as "admin1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/dark_mode_logo.png"
    else
      _echo "$(msg yellow)Warning, missing logo file dark_mode_logo.png. Make sure this file exist in ${logo_path}/dark_mode_logo.png!" --name
      _echo "$(msg yellow)If you want to have this logo, just put it at ${logo_path}/dark_mode_logo.png$(msg end)" --name
    fi
    echo ""

    _echo "$(msg cyan)Setting directadmin favourite icon logo for admin1 ...$(msg end)" --name
    if [[ -f "${logo_path}/favicon.png" ]]; then
      da_api_admin set-da-logo --sign-as "admin1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/favicon.png"
    else
      _echo "$(msg yellow)Warning, missing logo file favicon.png. Make sure this file exist in ${logo_path}/favicon.png!" --name
      _echo "$(msg yellow)If you want to have this logo, just put it at ${logo_path}/favicon.png$(msg end)" --name
    fi
    echo ""

    _echo "$(msg cyan)Setting directadmin default symbol logo for admin1 ...$(msg end)" --name
    if [[ -f "${logo_path}/default_symbol.png" ]]; then
      da_api_admin set-da-logo --sign-as "admin1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/default_symbol.png"
    else
      _echo "$(msg yellow)Warning, missing logo file default_symbol.png. Make sure this file exist in ${logo_path}/default_symbol.png!" --name
      _echo "$(msg yellow)If you want to have this logo, just put it at ${logo_path}/default_symbol.png$(msg end)" --name
    fi
    echo ""

    _echo "$(msg cyan)Setting directadmin dark symbol logo for admin1 ...$(msg end)" --name
    if [[ -f "${logo_path}/dark_symbol.png" ]]; then
      da_api_admin set-da-logo --sign-as "admin1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/dark_symbol.png"
    else
      _echo "$(msg yellow)Warning, missing logo file dark_symbol.png. Make sure this file exist in ${logo_path}/dark_symbol.png!" --name
      _echo "$(msg yellow)If you want to have this logo, just put it at ${logo_path}/dark_symbol.png$(msg end)" --name
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_reseller_skins() {
  # We can customize this skin evolution based on this file /usr/local/directadmin/data/users/username/skin_customization/evolution/user_options.json
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_conf_file da_temp_dir logo_path default_logo_file dark_mode_logo_file
    da_conf_file="/usr/local/directadmin/conf/directadmin.conf"
    if [ ! -f "${da_conf_file}" ]; then
      _echo "$(msg red)Error, the directadmin configuration file does not exist!$(msg end)" --name
      _exit 147
    fi
    _echo "$(msg cyan)Setting directadmin skin setting with recommend values for admin1...$(msg end)" --name
    da_api_admin set-da-skin-settings --sign-as "reseller1" --skin-name "evolution" --recommend-values
    echo ""
    # There is no official documentation how to upload a directadmin logo using API. This is my own method also written in here:
    # https://forum.directadmin.com/threads/cmd_api_skins-upload-skin-logo-via-curl-issue.63127/

    # This is the part to upload logo
    # Directadmin needs this home temporary folder to hold upload file (this is a must)
    da_temp_dir=$(grep "^tmpdir" "${da_conf_file}" | cut -d= -f2)
    if [ -z "${da_temp_dir}" ]; then
      da_temp_dir="/home/tmp"
    fi
    mkdir -p "${da_temp_dir}"
    logo_path="${LATEST_OS_CODE_PATH}/usr/local/directadmin/logo"

    _echo "$(msg cyan)Setting directadmin default logo for reseller1 ...$(msg end)" --name
    if [[ -f "${logo_path}/default_logo.png" ]]; then
      da_api_admin set-da-logo --sign-as "reseller1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/default_logo.png"
    else
      _echo "$(msg yellow)Warning, missing logo file default_logo.png. Make sure this file exist in ${logo_path}/default_logo.png!" --name
      _echo "$(msg yellow)If you want to have this logo, just put it at ${logo_path}/default_logo.png$(msg end)" --name
    fi
    echo ""

    _echo "$(msg cyan)Setting directadmin dark logo for reseller1 ...$(msg end)" --name
    if [[ -f "${logo_path}/dark_mode_logo.png" ]]; then
      da_api_admin set-da-logo --sign-as "reseller1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/dark_mode_logo.png"
    else
      _echo "$(msg yellow)Warning, missing logo file dark_mode_logo.png. Make sure this file exist in ${logo_path}/dark_mode_logo.png!" --name
      _echo "$(msg yellow)If you want to have this logo, just put it at ${logo_path}/dark_mode_logo.png$(msg end)" --name
    fi
    echo ""

    _echo "$(msg cyan)Setting directadmin favourite icon logo for reseller1 ...$(msg end)" --name
    if [[ -f "${logo_path}/favicon.png" ]]; then
      da_api_admin set-da-logo --sign-as "reseller1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/favicon.png"
    else
      _echo "$(msg yellow)Warning, missing logo file favicon.png. Make sure this file exist in ${logo_path}/favicon.png!" --name
      _echo "$(msg yellow)If you want to have this logo, just put it at ${logo_path}/favicon.png$(msg end)" --name
    fi
    echo ""

    _echo "$(msg cyan)Setting directadmin default symbol logo for reseller1 ...$(msg end)" --name
    if [[ -f "${logo_path}/default_symbol.png" ]]; then
      da_api_admin set-da-logo --sign-as "reseller1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/default_symbol.png"
    else
      _echo "$(msg yellow)Warning, missing logo file default_symbol.png. Make sure this file exist in ${logo_path}/default_symbol.png!" --name
      _echo "$(msg yellow)If you want to have this logo, just put it at ${logo_path}/default_symbol.png$(msg end)" --name
    fi
    echo ""

    _echo "$(msg cyan)Setting directadmin dark symbol logo for reseller1 ...$(msg end)" --name
    if [[ -f "${logo_path}/dark_symbol.png" ]]; then
      da_api_admin set-da-logo --sign-as "reseller1" --skin-name "evolution" --logo-mode default-logo --logo-file "${logo_path}/dark_symbol.png"
    else
      _echo "$(msg yellow)Warning, missing logo file dark_symbol.png. Make sure this file exist in ${logo_path}/dark_symbol.png!" --name
      _echo "$(msg yellow)If you want to have this logo, just put it at ${logo_path}/dark_symbol.png$(msg end)" --name
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_admin_admin_settings() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    ###
    # TODO
    ###

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Remember that all record created here need to wait for propagation time before they become available
configure_da_reseller_wildcard_domains() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local reseller_count da_reseller_usernames_count
    reseller_count=1
    da_reseller_usernames_count=$(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w)
    while [ ${reseller_count} -le "${da_reseller_usernames_count}" ]; do
      local da_reseller_username da_reseller_wildcard_domains da_reseller_wildcard_domains_count wildcard_domain_count
      typeset -n "da_reseller_username=C_DA_RESELLER_USERNAME${reseller_count}"
      typeset -n "da_reseller_wildcard_domains=C_DA_RESELLER_WILDCARD_DOMAIN${reseller_count}"
      da_reseller_wildcard_domains_count="${#da_reseller_wildcard_domains[@]}"
      _echo "$(msg newline)" --plain --verbose 7
      _echo "$(msg yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(msg end)" --name --verbose 7
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7
      _echo "Reseller domain wildcard details:" --name --verbose 7
      _echo "Reseller count ${reseller_count} out of ${da_reseller_usernames_count}" --name --verbose 7
      _echo "da_reseller_username: ${da_reseller_username}" --name --verbose 7
      _echo "da_reseller_wildcard_domains: ${da_reseller_wildcard_domains[*]}" --name --verbose 7
      _echo "da_reseller_wildcard_domains_count: ${da_reseller_wildcard_domains_count}" --name --verbose 7
      _echo "$(msg newline)" --plain --verbose 7

      wildcard_domain_count=0
      while [ ${wildcard_domain_count} -le $((da_reseller_wildcard_domains_count - 1)) ]; do
        for wildcard_domain in ${da_reseller_wildcard_domains}; do
          _echo "Wildcard domain for reseller: ${da_reseller_username}" --name --verbose 7
          _echo "Wildcard domain: ${wildcard_domain}" --name --verbose 7
          _echo "$(msg newline)" --plain --verbose 7
          _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7
          _echo "$(msg cyan)Creating wildcard entry for domain ${wildcard_domain} for IPv4 in directadmin ...$(msg end)" --name
          # By default DA don't create wildcard entry for this domain (unless wildcard option is enabled)
          # Note, if record already exist, it won't create in directadmin DNS record
          da_api_admin create-dns-record --sign-as "${da_reseller_username}" --domain "${wildcard_domain}" --record-type "A" --record-name "*" --record-value "${C_IPV4_ADD0}" --record-ttl 30 --affect-pointers yes
          echo ""
          _echo "$(msg cyan)Creating wildcard entry for domain ${wildcard_domain} for IPv6 in directadmin ...$(msg end)" --name
          # For directadmin need to convert IPv6 address, else it will not accept
          da_api_admin create-dns-record --sign-as "${da_reseller_username}" --domain "${wildcard_domain}" --record-type "AAAA" --record-name "*" --record-value "$(ipv6calc --addr2uncompaddr "${C_IPV6_ADD0}")" --record-ttl 30 --affect-pointers yes
          echo ""

          if [ "${DNS_PROVIDER_NAME}" == "linode" ]; then
            _echo "$(msg cyan)Notice, DNS provider is set to linode. Using linode API ...$(msg end)" --name
            # We do not need to delete existing record in linode because we ran the --rebuild command to create this domain.
            _echo "$(msg cyan)Adding wildcard domain ${wildcard_domain} record for IPv4 in linode$(msg end)" --name
            linode_api_admin create-dns-record --domain "${wildcard_domain}" --record-type "A" --record-name "*" --record-value "${C_IPV4_ADD0}" --record-ttl 30
            echo ""
            _echo "$(msg cyan)Adding wildcard domain ${wildcard_domain} record for IPv6 in linode$(msg end)" --name
            linode_api_admin create-dns-record --domain "${wildcard_domain}" --record-type "AAAA" --record-name "*" --record-value "${C_IPV6_ADD0}" --record-ttl 30
            echo ""
          elif [ "${DNS_PROVIDER_NAME}" == "digitalocean" ]; then
            _echo "$(msg cyan)Notice, DNS provider is set to digitalocean$(msg end)" --name
            # Call digitalocean_api_admin
            # elif other provider
          elif [ "${DNS_PROVIDER_NAME}" == "local" ]; then
            _echo "$(msg cyan)Notice, DNS provider is set to local (Internal DNS)$(msg end)" --name
            # Do nothing
          fi
        done
        ((wildcard_domain_count++))
      done
      ((reseller_count++))
    done
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Note directadmin will automatically add www to each subdomain
# For example if we create subdomain shop, it will add another subdomain called www.shop automatically
configure_da_reseller_subdomains() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local reseller_count da_reseller_usernames_count
    da_reseller_usernames_count=$(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w)
    reseller_count=1
    while [[ ${reseller_count} -le ${da_reseller_usernames_count} ]]; do
      local da_reseller_username da_reseller_subdomains da_reseller_subdomains_count subdomain_count
      typeset -n "da_reseller_username=C_DA_RESELLER_USERNAME${reseller_count}"
      typeset -n "da_reseller_subdomains=C_DA_RESELLER_SUBDOMAIN${reseller_count}"
      da_reseller_subdomains_count="${#da_reseller_subdomains[@]}"

      _echo "$(msg newline)" --plain --verbose 7
      _echo "$(msg yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(msg end)" --name --verbose 7
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7
      _echo "Reseller subdomains details:" --name --verbose 7
      _echo "Reseller count ${reseller_count} out of ${da_reseller_usernames_count}" --name --verbose 7
      _echo "da_reseller_username: ${da_reseller_username}" --name --verbose 7
      _echo "da_reseller_subdomains: ${da_reseller_subdomains[*]}" --name --verbose 7
      _echo "da_reseller_subdomains_count: ${da_reseller_subdomains_count}" --name --verbose 7
      _echo "$(msg newline)" --plain --verbose 7

      subdomain_count=0
      while [ ${subdomain_count} -le $((da_reseller_subdomains_count - 1)) ]; do
        local root_domain sub_domains_raw
        root_domain=$(echo "${da_reseller_subdomains[subdomain_count]}" | awk -F':' '{ print $1 }')
        sub_domains_raw=$(echo "${da_reseller_subdomains[subdomain_count]}" | awk -F':' '{ print $2 }')
        sub_domains=$(echo "${sub_domains_raw}" | awk -F',' '{for (i=1;i<=NF;i++)print $i}')

        _echo "root_domain: ${root_domain}" --name --verbose 7
        _echo "sub_domains_raw: ${sub_domains_raw[*]}" --name --verbose 7
        _echo "sub_domains list (below):" --name --verbose 7
        _echo "${sub_domains}" --plain --verbose 7
        _echo "$(msg newine)" --plain --verbose 7

        for sub_domain in ${sub_domains}; do
          _echo "Subdomain for reseller: ${da_reseller_username}" --name --verbose 7
          _echo "subdomain: ${sub_domain}" --name --verbose 7
          _echo "$(msg newline)" --plain --verbose 7
          _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7

          # Now we got sub_domain and root_domain, call the da_api_admin:
          # Note that reseller and user share the same API
          _echo "$(msg cyan)Creating reseller ${da_reseller_username} subdomain ${sub_domain}$(msg end)" --name
          da_api_admin create-user-subdomain --sign-as "${da_reseller_username}" --domain "${root_domain}" --subdomain "${sub_domain}"
          echo ""

          if [ "${DNS_PROVIDER_NAME}" == "linode" ]; then
            _echo "$(msg cyan)Notice, DNS provider is set to linode. Using linode API ...$(msg end)" --name
            # Add delete and add subdomain for linode API here
            _echo "$(msg cyan)Deleting subdomain ${sub_domain} record for IPv4 from linode$(msg end)" --name
            linode_api_admin delete-dns-record --domain "${root_domain}" --record-name "${sub_domain}" --record-type "A"
            echo ""
            _echo "$(msg cyan)Deleting subdomain ${sub_domain} record for IPv6 from linode$(msg end)" --name
            linode_api_admin delete-dns-record --domain "${root_domain}" --record-name "${sub_domain}" --record-type "AAAA"
            echo ""
            _echo "$(msg cyan)Adding subdomain ${sub_domain} record for IPv4 in linode ...$(msg end)" --name
            linode_api_admin add-dns-record --domain "${root_domain}" --record-type "A" --record-name "${sub_domain}" --record-value "${C_IPV4_ADD0}" --record-ttl 30
            echo ""
            _echo "$(msg cyan)Adding subdomain ${sub_domain} record for IPv6 in linode ...$(msg end)" --name
            linode_api_admin add-dns-record --domain "${root_domain}" --record-type "AAAA" --record-name "${sub_domain}" --record-value "${C_IPV6_ADD0}" --record-ttl 30
            echo ""
          elif [ "${DNS_PROVIDER_NAME}" == "digitalocean" ]; then
            _echo "$(msg cyan)Notice, DNS provider is set to digitalocean$(msg end)" --name
            # Call digitalocean_api_admin
            # elif other provider
          elif [ "${DNS_PROVIDER_NAME}" == "local" ]; then
            _echo "$(msg cyan)Notice, DNS provider is set to local (Internal DNS)$(msg end)" --name
            # Do nothing
          fi
        done
        ((subdomain_count++))
      done
      ((reseller_count++))
    done
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_reseller_email_accounts() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local reseller_count da_reseller_usernames_count
    da_reseller_usernames_count=$(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w)
    reseller_count=1
    while [[ ${reseller_count} -le ${da_reseller_usernames_count} ]]; do
      local da_reseller_username da_reseller_mail_accounts da_reseller_mail_accounts_count
      typeset -n "da_reseller_username=C_DA_RESELLER_USERNAME${reseller_count}"
      typeset -n "da_reseller_mail_accounts=C_DA_RESELLER_MAIL_ACCOUNT${reseller_count}"
      da_reseller_mail_accounts_count="${#da_reseller_mail_accounts[@]}"

      _echo "$(msg newline)" --plain --verbose 7
      _echo "$(msg yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(msg end)" --name --verbose 7
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7
      _echo "Reseller email details:" --name --verbose 7
      _echo "Reseller count ${reseller_count} out of ${da_reseller_usernames_count}" --name --verbose 7
      _echo "da_reseller_username: ${da_reseller_username}" --name --verbose 7
      _echo "da_reseller_mail_accounts: ${da_reseller_mail_accounts[@]}" --name --verbose 7
      _echo "da_reseller_mail_accounts_count: ${da_reseller_mail_accounts_count}" --name --verbose 7

      if [ "${da_reseller_mail_accounts_count}" -eq 0 ]; then
        _echo "$(msg yellow)Notice, this reseller ${da_reseller_username} does not have email set$(msg end)" --name
      else
        mail_count=1
        while [ ${mail_count} -le ${da_reseller_mail_accounts_count} ]; do
          local mail_user_domain mail_user mail_domain mail_password
          mail_user_domain=$(echo "${da_reseller_mail_accounts[mail_count - 1]}" | awk -F'\|\|\|' '{ print $1 }')
          mail_user=$(echo "${mail_user_domain}" | awk -F'@' '{ print $1 }')
          mail_domain=$(echo "${mail_user_domain}" | awk -F'@' '{ print $2 }')
          mail_password=$(echo "${da_reseller_mail_accounts[mail_count - 1]}" | awk -F'\|\|\|' '{ print $2 }')
          _echo "$(msg newline)" --plain --verbose 7
          _echo "Reseller email count ${mail_count}/$((da_reseller_mail_accounts_count))" --name --verbose 7
          _echo "Reseller_username: ${da_reseller_username}" --name --verbose 7
          _echo "mail_user_domain (full email): ${mail_user_domain}" --name --verbose 7
          _echo "mail_user (without @domain.com): ${mail_user}" --name --verbose 7
          _echo "mail_domain: ${mail_domain}" --name --verbose 7
          _echo "mail_password: ${mail_password}" --name --verbose 7
          _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7

          # da_api_admin create-user-email --mail-domain "maxibi.com" --mail-user "webmaster" --mail-password "1232123" --mail-quota "0" --mail-limit "200"
          _echo "$(msg cyan)Creating new reseller email ${mail_user_domain} ...$(msg end)" --name
          da_api_admin create-user-email --sign-as ${da_reseller_username} --mail-domain "${mail_domain}" --mail-user "${mail_user}" --mail-password "${mail_password}" --mail-quota "0" --mail-limit "200"

          ((mail_count++))
        done
      fi
      ((reseller_count++))
    done

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Deprecated function
configure_da_reseller_emails() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local reseller_count da_reseller_usernames_count
    da_reseller_usernames_count=$(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w)
    reseller_count=1
    while [[ ${reseller_count} -le ${da_reseller_usernames_count} ]]; do

      local da_reseller_username da_reseller_mail_users da_reseller_mail_passwords

      typeset -n "da_reseller_username=C_DA_RESELLER_USERNAME${reseller_count}"
      typeset -n "da_reseller_mail_users=C_DA_RESELLER_MAIL_USER${reseller_count}"
      typeset -n "da_reseller_mail_passwords=C_DA_RESELLER_MAIL_PASSWORD${reseller_count}"
      da_reseller_mail_users_count="${#da_reseller_mail_users[@]}"

      _echo "$(msg newline)" --plain --verbose 7
      _echo "$(msg yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(msg end)" --name --verbose 7
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7
      _echo "Reseller email details:" --name --verbose 7
      _echo "Reseller count ${reseller_count} out of ${da_reseller_usernames_count}" --name --verbose 7
      _echo "da_reseller_username: ${da_reseller_username}" --name --verbose 7
      _echo "da_reseller_mail_users: ${da_reseller_mail_users[@]}" --name --verbose 7
      _echo "da_reseller_mail_passwords: ${da_reseller_mail_passwords[@]}" --name --verbose 7
      _echo "da_reseller_mail_users_count: ${da_reseller_mail_users_count}" --name --verbose 7
      _echo "$(msg newline)" --plain --verbose 7
      mail_count=1

      while [ ${mail_count} -le ${da_reseller_mail_users_count} ]; do
        mail_user=$(echo "${da_reseller_mail_users[mail_count - 1]}" | awk -F'@' '{ print $1 }')
        mail_domain=$(echo "${da_reseller_mail_users[mail_count - 1]}" | awk -F'@' '{ print $2 }')
        mail_password=${da_reseller_mail_passwords[mail_count - 1]}
        _echo "Reseller email count ${mail_count}/$((da_reseller_mail_users_count))" --name --verbose 7
        _echo "Reseller_username: ${da_reseller_username}" --name --verbose 7
        _echo "Reseller full user email address: [${mail_count}]: ${da_reseller_mail_users[mail_count - 1]}" --name --verbose 7
        _echo "Reseller user email address (without @domain.com): ${mail_user}" --name --verbose 7
        _echo "Reseller email domain: ${mail_domain}" --name --verbose 7
        _echo "Reseller email password:[${mail_count}]: ${da_reseller_mail_passwords[mail_count - 1]}" --name --verbose 7
        _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7

        ## da_api_admin create-user-email --mail-domain "maxibi.com" --mail-user "webmaster" --mail-password "1232123" --mail-quota "0" --mail-limit "200"
        _echo "$(msg cyan)Creating new user email ${da_reseller_mail_users[mail_count - 1]} ...$(msg end)" --name
        da_api_admin create-user-email --sign-as ${da_reseller_username} --mail-domain "${mail_domain}" --mail-user "${mail_user}" --mail-password "${mail_password}" --mail-quota "0" --mail-limit "200"

        ((mail_count++))
      done
      ((reseller_count++))
    done

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Function to create all reseller databases
configure_da_reseller_databases() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local reseller_count da_reseller_usernames_count
    da_reseller_usernames_count=$(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w)
    reseller_count=1
    while [[ ${reseller_count} -le ${da_reseller_usernames_count} ]]; do
      typeset -n "da_reseller_username=C_DA_RESELLER_USERNAME${reseller_count}"
      typeset -n "da_reseller_db_accounts=C_DA_RESELLER_DB_ACCOUNT${reseller_count}"
      _echo "$(msg newline)" --plain --verbose 7
      _echo "$(msg yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(msg end)" --name --verbose 7
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7
      _echo "Reseller database details:" --name --verbose 7
      _echo "Reseller count ${reseller_count} out of ${da_reseller_usernames_count}" --name --verbose 7
      _echo "da_reseller_username: ${da_reseller_username}" --name --verbose 7
      _echo "da_reseller_db_accounts: ${da_reseller_db_accounts[*]}" --name --verbose 7
      da_reseller_db_accounts_count="${#da_reseller_db_accounts[@]}"
      database_count=1

      if [[ "${#da_reseller_db_accounts}" == 0 ]]; then
        _echo "$(msg yellow)[skipped]: Value defined for this reseller ${da_reseller_username} database is empty$(msg end)" --name
      else
        while [ ${database_count} -le ${da_reseller_db_accounts_count} ]; do
          db_domain_name_user=$(echo "${da_reseller_db_accounts[database_count - 1]}" | awk -F'\|\|\|' '{ print $1 }')
          db_password=$(echo "${da_reseller_db_accounts[database_count - 1]}" | awk -F'\|\|\|' '{ print $2 }')
          db_domain=$(echo "${db_domain_name_user}" | awk -F':' '{ print $1 }')
          db_name=$(echo "${db_domain_name_user}" | awk -F':' '{ print $2 }')
          db_user=$(echo "${db_domain_name_user}" | awk -F':' '{ print $3 }')
          sql_users=$(mysql -e "SELECT USER FROM mysql.user;" | jq -rR .)
          sql_user_exist=$(echo "${sql_users}" | grep "${da_reseller_username}_${db_user}")

          _echo "Reseller database count ${database_count}/$((da_reseller_db_accounts_count))" --name --verbose 7
          [[ -n "${sql_user_exist}" ]] && _echo "sql_user_exist in mysql system: ${sql_user_exist}" --name --verbose 7
          _echo "db_domain: ${db_domain}" --name --verbose 7
          _echo "db_name: ${db_name}" --name --verbose 7
          _echo "db_user: ${db_user}" --name --verbose 7
          _echo "db_password: ${db_password}" --name --verbose 7
          _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7
          _echo "$(msg newline)" --plain --verbose 7

          #da_api_admin create-user-database --db-domain "maxibi.com" --db-name abc --db-user maxibi --db-password 12321aa (create new user database)

          #da_api_admin --db-domain "maxibi.com" create-user-database --db-name abc --existing-user maxibi  (create database with existing user)

          if [[ -z "${sql_user_exist}" ]]; then
            _echo "$(msg cyan)Creating new database name ${db_name} for reseller ${da_reseller_username} on domain ${db_domain} ...$(msg end)" --name
            da_api_admin create-user-database --sign-as "${da_reseller_username}" --db-domain "${db_domain}" --db-name "${db_name}" --db-user "${db_user}" --db-password "${db_password}"
          else
            _echo "$(msg cyan)Creating new database name ${db_name} for reseller ${da_reseller_username} on domain ${db_domain} using existing username ${db_user} ...$(msg end)" --name
            da_api_admin create-user-database --sign-as "${da_reseller_username}" --db-domain "${db_domain}" --db-name "${db_name}" --db-existing-user "${db_user}"
          fi

          ((database_count++))
        done
      fi
      ((reseller_count++))
    done

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This will create user accounts and domains
configure_da_user_accounts() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local da_user_packages_list count_user1 \
      da_user_creator da_user_role da_user_restore_profile_backup da_user_uname da_user_password da_user_name da_user_system_email \
      da_user_mail_users da_user_mail_passwords da_user_domains da_user_ip_type da_user_package_name da_user_enable_domain_ssl grep_count

    # This file contains list of user packages (use this file for checking existing package)
    da_user_packages_list="/usr/local/directadmin/data/users/${C_DA_RESELLER_USERNAME1}/packages.list"
    # We can restart directadmin to clear pending Directadmin cron
    #_echo "$(msg cyan)Requesting directadmin to restart before configuring directadmin accounts ...$(msg end)" --name
    #restart_da
    #echo ""

    count_user1=1
    # !C_DA_USER_USERNAME@ = Assign all user account based on the variable of C_DA_USER_USERNAME[N] :
    while [[ ${count_user1} -le $(echo "${!C_DA_USER_USERNAME@}" | wc -w) ]]; do
      _echo "$(msg cyan)Getting all required variables from config file ...$(msg end)" --name --verbose 7
      typeset -n da_user_creator="C_DA_USER_CREATOR${count_user1}"
      typeset -n da_user_role="C_DA_USER_ROLE${count_user1}"
      typeset -n da_user_restore_profile_backup="C_DA_USER_RESTORE_PROFILE_BACKUP${count_user1}"
      typeset -n da_user_uname="C_DA_USER_USERNAME${count_user1}"
      typeset -n da_user_password="C_DA_USER_USERPASS${count_user1}"
      typeset -n da_user_name="C_DA_USER_NAME${count_user1}"
      typeset -n da_user_system_email="C_DA_USER_SYSTEM_EMAIL${count_user1}"
      typeset -n da_user_mail_users="C_DA_USER_MAIL_USER${count_user1}"
      typeset -n da_user_mail_passwords="C_DA_USER_MAIL_PASSWORD${count_user1}"
      typeset -n da_user_domains="C_DA_USER_DOMAIN${count_user1}"
      typeset -n da_user_package_name="C_DA_USER_PACKAGE_NAME${count_user1}"
      typeset -n da_user_enable_domain_ssl="C_DA_USER_ENABLE_DOMAIN_SSL${count_user1}"

      # TODO this information is sensitive, hide later
      _echo "$(msg cyan)Checking if user package name ${da_user_package_name} was created by previous admin before ...$(msg end)" --name
      grep_count=$(grep -ic "${da_user_package_name}" "${da_user_packages_list}")
      if [ "${grep_count}" -gt 0 ]; then
        _echo "$(msg green)OK, user package name ${da_user_package_name} found$(msg end)" --name
        echo ""
      else
        _echo "$(msg yellow)Warning, ${da_user_package_name} does not exist in ${da_user_packages_list}. Please inspect why!$(msg end)" --name
        _exit 147
      fi
      # Get the total domain count for this user
      da_user_domain_count="${#da_user_domains[@]}"
      # The first domain in array is used to create account (default domain for that user)
      da_user_domain_first=$(echo "${da_user_domains[@]}" | awk '{ print $1 }')

      _echo "$(msg newline)" --plain --verbose 7
      _echo "$(msg yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(msg end)" --name --verbose 7
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name
      _echo "User config variables:" --name --verbose 7
      _echo "User count ${count_user1}/$(echo "${!C_DA_USER_USERNAME@}" | wc -w)" --name
      _echo "da_user_creator: ${da_user_creator}" --name --verbose 7
      _echo "da_user_role: ${da_user_role}" --name --verbose 7
      _echo "da_user_restore_profile_backup: ${da_user_restore_profile_backup}" --name --verbose 7
      _echo "da_user_uname: ${da_user_uname}" --name --verbose 7
      _echo "da_user_password: ${da_user_password}" --name --verbose 7
      _echo "da_user_name: ${da_user_name}" --name --verbose 7
      _echo "da_user_system_email: ${da_user_system_email}" --name --verbose 7
      _echo "da_user_mail_users: ${da_user_mail_users[*]}" --name --verbose 7
      _echo "da_user_mail_passwords: ${da_user_mail_passwords}" --name --verbose 7
      _echo "da_user_domains: ${da_user_domains[*]}" --name --verbose 7
      _echo "da_user_package_name: ${da_user_package_name}" --name --verbose 7
      _echo "da_user_enable_domain_ssl: ${da_user_enable_domain_ssl}" --name --verbose 7
      _echo "$(msg newline)" --plain --verbose 7
      _echo "Domain information for user ${da_user_uname}:" --name --verbose 7
      _echo "Domain total (config): ${da_user_domain_count}" --name --verbose 7
      _echo "Domain list (config): ${da_user_domains[*]}" --name --verbose 7
      _echo "First domain (config): ${da_user_domain_first}" --name --verbose 7
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name
      _echo "$(msg newline)" --plain --verbose 7

      if [[ "${da_user_restore_profile_backup}" == "true" && "${C_DA_GLOBAL_BACKUP_RESTORE}" == "true" ]]; then
        local backup_source_location da_owner_backup_location
        echo "${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar.gz"

        if [[ -f "${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar.gz" ]]; then
          backup_source_location="${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar.gz"
        elif [[ -f "${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar.gz.enc" ]]; then
          backup_source_location="${SCRIPT_PATH}/admin_backups/${da_user_role}.${da_user_creator}.${da_user_uname}.tar.gz.enc"
        else
          echo "Backup file ${backup_source_location} does not exist for this user ${da_user_uname}. If you want to ignore this backup, disable this user backup restoration from config file "
          _exit 147
        fi

        _echo "Backup source location: ${backup_source_location}" --name --verbose 7
        _echo "$(msg newline)" --plain --verbose 7

        da_owner_backup_location=/home/$(get_current_da_owner_username)/admin_backups/$(basename -- ${backup_source_location})
        _echo "$(msg cyan)Copying backup from ${backup_source_location} to ${da_owner_backup_location}... $(msg end)" --name
        cp -fp "${backup_source_location}" "${da_owner_backup_location}"
        get_status_message "$?"
        if [ ! -f "${da_owner_backup_location}" ]; then
          _echo "$(msg red)Error, The backup path ${da_owner_backup_location} not found after performed a copy! $(msg end)" --name
          _exit 147
        fi
        echo ""
        _echo "$(msg cyan)Changing file owner permission for ${da_owner_backup_location} ...$(msg end)" --name
        chown "$(get_current_da_owner_username):$(get_current_da_owner_username)" "${da_owner_backup_location}"
        get_status_message "$?"
        echo ""
        _echo "$(msg cyan)Changing file permission for ${da_owner_backup_location} ...$(msg end)" --name
        chmod 640 "${da_owner_backup_location}"
        get_status_message "$?"
        echo ""
        da_api_admin restore-user-backup --backup-ip "${C_IPV4_ADD0}" --backup-path "$(dirname ${da_owner_backup_location})" --backup-file-name "$(basename -- ${da_owner_backup_location})" --backup-password ${C_DA_USER_BACKUP_PASSWORD}

        _echo "$(msg cyan) Getting list of all domains created ...$(msg end)" --name
        readarray -t da_domains <<<"$(grep -w "${da_user_uname}" "/etc/virtual/domainowners" | cut -d ":" -f 1)"
        echo "Domains list for ${da_user_uname}:"
        echo "${da_domains[*]}"
        echo ""
        if [ -n "${da_domains}" ]; then
          for da_domain in "${da_domains[@]}"; do
            _echo "$(msg cyan) Writing all DNS record for domain ${da_domain} to external DNS ...$(msg end)" --name
            copy_local_dns_to_external_dns "${da_domain}"
            echo ""
          done
        fi
      else
        # Note 1: To create a user, we need to use an reseller account:
        _echo "$(msg cyan)Creating a new user account ${da_user_uname} ${count_user1} out of $(echo "${!C_DA_USER_USERNAME@}" | wc -w) user(s) ... $(msg end)" --name
        # da_api_admin create-user-account --username abc --email abc@dsa.com --password 12321aa --domain maxibi.com --package_name USER_UNLIMITED --ip-address "${C_IPV4_ADD0}"
        da_api_admin create-user-account --sign-as reseller1 --username "${da_user_uname}" --email "${da_user_system_email}" --password "${da_user_password}" \
          --domain "${da_user_domain_first}" --package-name "${da_user_package_name}" --ip-address "${C_IPV4_ADD0}"
        echo ""
        _echo "$(msg cyan)Renaming user account name to ${da_user_name} ...$(msg end)" --name
        da_api_admin modify-user --sign-as reseller1 --where-username-is "${da_user_uname}" --name "${da_user_name}"
        echo ""
        # Now login as user and enable its own email DKIM. We can use user account to configure its own user-level variable settings like DKIM or DNS records
        _echo "$(msg cyan)Enabling email/domain DKIM for user ${da_user_uname} with default domain of ${da_user_domain_first} ...$(msg end)" --name
        # Note 1: We dont use user1 because currently user can have 1 or more (this script support multiple creation of user)
        # eg: --sign-as ${da_user_uname}
        da_api_admin enable-email-dkim --sign-as "${da_user_uname}" --domain "${da_user_domain_first}"
        echo ""

        # Use user above and create TXT record _domainkey for DKIM signing policy (this should have have been done using dns_txt.conf but it has bug)
        # so, we manually add this using API here: https://forum.directadmin.com/threads/possible-bug-when-using-dns_txt-conf-with-api-include-step-to-reproduce.63247/
        _echo "$(msg cyan)Creating DKIM signing policy TXT record for ${da_user_domain_first} ...$(msg end)" --name
        # This value "o%3D%7E%3B+r%3Dwebmaster%40${da_user_domain_first}" (encoded) is equal to "_domainkey="o=~; r=webmaster@${da_user_domain_first}"
        # No need to encode the value, it's working it seems like directadmin know how to handle this data in API, in debug mode it added extra quote for the value
        da_api_admin create-dns-record --sign-as "${da_user_uname}" --domain "${da_user_domain_first}" --record-type TXT --record-name "_domainkey" --record-value "o=~; r=webmaster@${da_user_domain_first}" --record-ttl 30 --affect-pointers yes
        echo ""
        _echo "$(msg cyan)Creating Mail MX record for ${da_user_domain_first} without subdomain ...$(msg end)" --name
        da_api_admin create-dns-record --sign-as "${da_user_uname}" --domain "${da_user_domain_first}" --record-type MX --record-domain "${da_user_domain_first}." --record-priority "10" --record-subdomain "${da_reseller_domain_first}." --record-ttl 30 --affect-pointers yes
        echo ""
        copy_local_dns_to_external_dns "${da_user_domain_first}"

        # This will be executed if user has more than 1 domains. We add the extra domains here and skipped the default domain:
        if [ "${da_user_domain_count}" -gt 1 ]; then
          _echo "$(msg cyan)Notice, this user ${da_user_uname} has ${da_user_domain_count} domains$(msg end)" --name
          for extra_domain in "${da_user_domains[@]}"; do
            # Here, we don't add the first domain, we did that before when we first create user user account where directadmin automatically add this default or first domain
            if [[ "${extra_domain}" == "${da_user_domain_first}" ]]; then
              _echo "$(msg cyan)Skipped adding the default domain: ${da_user_domain_first}$(msg end)" --name
              continue
            fi
            _echo "$(msg cyan)Creating extra domain ${extra_domain} for user ${da_user_uname} ...$(msg end)" --name
            da_api_admin create-domain --sign-as "${da_user_uname}" --domain "${extra_domain}" --recommend-values
            echo ""
            _echo "$(msg cyan)Enabling email/domain DKIM for user ${da_user_uname} with extra domain of ${extra_domain} ...$(msg end)" --name
            da_api_admin enable-email-dkim --sign-as "${da_user_uname}" --domain "${extra_domain}"
            echo ""
            _echo "$(msg cyan)Creating DKIM signing policy TXT record for extra domain ${extra_domain} ...$(msg end)" --name
            da_api_admin create-dns-record --sign-as "${da_user_uname}" --domain "${extra_domain}" --record-type TXT --record-name "_domainkey" --record-value "o=~; r=webmaster@${extra_domain}" --record-ttl 30 --affect-pointers yes
            echo ""
            _echo "$(msg cyan)Creating Mail MX record for ${extra_domain} without subdomain ...$(msg end)" --name
            da_api_admin create-dns-record --sign-as "${da_user_uname}" --domain "${extra_domain}" --record-type MX --record-domain "${extra_domain}." --record-priority "10" --record-subdomain "${da_reseller_domain_first}." --record-ttl 30 --affect-pointers yes
            echo ""
            copy_local_dns_to_external_dns "${extra_domain}"
          done # End looping for adding extra domains
        fi
      fi
      ((count_user1++))
      echo ""
    done
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_user_root_domains() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_user_domains da_user_domains_count this_da_user_username this_da_user_userpass \
      this_da_user_domains this_da_user_domains_count
    local count_x count_n count_o domain
    # Get list of all user subdomains
    da_user_domains="${!C_DA_USER_DOMAIN@}"
    # Count the total domains
    da_user_domains_count=$(echo "${da_user_domains}" | wc -w)
    # Debug:
    echo "da_user_domains: ${da_user_domains}"
    echo "da_user_domains_count ${da_user_domains_count}"
    # initial value to loop
    count_x=1
    while [[ ${count_x} -le ${da_user_domains_count} ]]; do
      echo "Count_x: ${count_x}"
      echo "DA_USER_DOMAINS_COUNT ${da_user_domains_count}"
      echo "=~=~=~=~=~=~=~=~=~+~+~+~=~=~"
      echo "count_user_domain_loop = ${count_x}"
      echo ""
      typeset -n "this_da_user_username"="C_DA_USER_USERNAME${count_x}"
      typeset -n "this_da_user_userpass"="C_DA_USER_USERPASS${count_x}"

      this_da_user_domains=$(cat "/usr/local/directadmin/data/users/${this_da_user_username}/domains.list")
      # Debug:
      echo "this_da_user_username: ${this_da_user_username}"
      echo "this_da_user_userpass: ${this_da_user_userpass}"

      echo "this_da_user_domains: ${this_da_user_domains[*]}"
      this_da_user_domains_count=$(echo "${this_da_user_domains}" | wc -w)
      echo "this_da_user_domains_count: ${this_da_user_domains_count}"
      count_n=1
      while [ ${count_n} -le "${this_da_user_domains_count}" ]; do
        echo "------------------------"
        echo "Total count: ${count_n}"
        count_o=0
        for domain in ${this_da_user_domains}; do
          echo "count_o: ${count_o}"
          # Debug
          echo "domain is set: ${domain}"
          echo ""

          echo "[${SCRIPT_NAME}]: Creating root domain ${domain} for both IPv4 and IPv6 ..."
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
          da_api_admin "signas+${this_da_user_username}+${this_da_user_userpass}"
          # Note if record exist, it won't create in DA
          da_api_admin "create-dns-record" "${domain}" "A" "${domain}." "${C_IPV4_ADD0}"
          da_api_admin "create-dns-record" "${domain}" "AAAA" "${domain}." "$(ipv6calc --addr2uncompaddr "${C_IPV6_ADD0}")"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
          echo ""
          if [ "${DNS_PROVIDER_NAME}" == "linode" ]; then
            # In linode DNS record are duplicated, we don't want so must delete previous record first before adding new
            echo "[${SCRIPT_NAME}]: DNS provider is set to linode. Using linode API"

            echo "[${SCRIPT_NAME}]: Deleting root ${domain} record for IPv4 and IPv6 from linode"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
            # In linode empty there means hostname or I can use @ or try domain.com
            linode_api_admin "delete-dns-record" "${domain}" "" "A"
            linode_api_admin "delete-dns-record" "${domain}" "" "AAAA"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
            echo ""

            # Also add wildcard domain for linode API here
            echo "[${SCRIPT_NAME}]: Adding wildcard domain ${domain} record for IPv4 and IPv6 from linode"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
            #In linode empty there means hostname or I can use @ or try domain.com
            linode_api_admin "add-dns-record" "${domain}" "A" "" "${C_IPV4_ADD0}" "5"
            linode_api_admin "add-dns-record" "${domain}" "AAAA" "" "${C_IPV6_ADD0}" "5"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
            echo ""
          elif [ "${DNS_PROVIDER_NAME}" == "digitalocean" ]; then
            echo "[${SCRIPT_NAME}]: DNS provider is set to digitalocean"
            # Call digitalocean_api_admin
            #elif other provider
          elif [ "${DNS_PROVIDER_NAME}" == "local" ]; then
            echo "[${SCRIPT_NAME}]: DNS provider is set to local (Internal DNS)"
            # Do nothing
          fi
          ((count_o++))
        done
        ((count_n++))
      done
      ((count_x++))
    done
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_user_wildcard_domains() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_user_wildcard_domains da_user_wildcard_domains_count this_da_user_username this_da_user_userpass \
      this_da_user_wildcard_domains this_da_user_wildcard_domains_count
    local count_x count_n count_o wildcard_domain wildcard_domains
    # Get list of all user wildcard domains
    da_user_wildcard_domains="${!C_DA_USER_WILDCARD_DOMAIN@}"
    # Count the total subdomains
    da_user_wildcard_domains_count=$(echo "${da_user_wildcard_domains}" | wc -w)
    # Debug:
    echo "da_user_wildcard_domains: ${da_user_wildcard_domains}"
    echo "da_user_wildcard_domains_count ${da_user_wildcard_domains_count}"
    # initial value to loop
    count_x=1
    while [[ ${count_x} -le ${da_user_wildcard_domains_count} ]]; do
      echo "=~=~=~=~=~=~=~=~=~+~+~+~=~=~"
      echo "count_user_wildcard_domain_loop = ${count_x}"
      echo ""
      typeset -n "this_da_user_username"="C_DA_USER_USERNAME${count_x}"
      typeset -n "this_da_user_userpass"="C_DA_USER_USERPASS${count_x}"
      typeset -n "this_da_user_wildcard_domains"="C_DA_USER_WILDCARD_DOMAIN${count_x}"

      # Debug:
      echo "this_da_user_username: ${this_da_user_username}"
      echo "this_da_user_userpass: ${this_da_user_userpass}"
      echo "this_da_user_wildcard_domains: ${this_da_user_wildcard_domains[*]}"
      this_da_user_wildcard_domains_count="${#this_da_user_wildcard_domains[@]}"

      count_n=0
      while [ ${count_n} -le $((this_da_user_wildcard_domains_count - 1)) ]; do
        echo "------------------------"
        echo "Total count: ${count_n}"

        wildcard_domains=$(echo "${this_da_user_wildcard_domains}" | awk -F':' '{for (i=1;i<=NF;i++)print $i}') #or tr ":" "\n"
        count_o=0
        for wildcard_domain in ${wildcard_domains}; do
          echo "count_o: ${count_o}"
          # Debug
          echo "wildcard_domain is set for domain: ${wildcard_domain}"
          echo ""

          echo "[${SCRIPT_NAME}]: Creating wildcard entry for domain ${wildcard_domain} for both IPv4 and IPv6 ..."
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
          da_api_admin "signas+${this_da_user_username}+${this_da_user_userpass}"
          # By default DA don't create wildcard entry for this domain (unless wildcard option is enabled)
          # Note if record exist, it won't create in DA
          da_api_admin "create-dns-record" "${wildcard_domain}" "A" "*" "${C_IPV4_ADD0}"
          da_api_admin "create-dns-record" "${wildcard_domain}" "AAAA" "*" "$(ipv6calc --addr2uncompaddr "${C_IPV6_ADD0}")"
          echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
          echo ""
          if [ "${DNS_PROVIDER_NAME}" == "linode" ]; then
            # In linode DNS record are duplicated, we don't want so must delete previous record first before adding new
            echo "[${SCRIPT_NAME}]: DNS provider is set to linode. Using linode API"

            echo "[${SCRIPT_NAME}]: Deleting subdomain ${wildcard_domain} record for IPv4 and IPv6 from linode"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
            linode_api_admin "delete-dns-record" "${wildcard_domain}" "*" "A"
            linode_api_admin "delete-dns-record" "${wildcard_domain}" "*" "AAAA"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
            echo ""

            # Also add wildcard domain for linode API here
            echo "[${SCRIPT_NAME}]: Adding wildcard domain ${wildcard_domain} record for IPv4 and IPv6 from linode"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
            #linode_api_admin "add-dns-record" "maxibi.com" "TXT" "x._domainkey" "*i..2uiu1KJM@#9IU@J()!@IJI92" "5"
            linode_api_admin "add-dns-record" "${wildcard_domain}" "A" "*" "${C_IPV4_ADD0}" "5"
            linode_api_admin "add-dns-record" "${wildcard_domain}" "AAAA" "*" "${C_IPV6_ADD0}" "5"
            echo "~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~"
            echo ""
          elif [ "${DNS_PROVIDER_NAME}" == "digitalocean" ]; then
            echo "[${SCRIPT_NAME}]: DNS provider is set to digitalocean"
            # Call digitalocean_api_admin
            #elif other provider
          elif [ "${DNS_PROVIDER_NAME}" == "local" ]; then
            echo "[${SCRIPT_NAME}]: DNS provider is set to local (Internal DNS)"
            # Do nothing
          fi
          ((count_o++))
        done
        ((count_n++))
      done
      ((count_x++))
    done
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_user_subdomains() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local user_count da_user_usernames_count
    da_user_usernames_count=$(echo "${!C_DA_USER_USERNAME@}" | wc -w)
    user_count=1
    while [[ ${user_count} -le ${da_user_usernames_count} ]]; do
      local da_user_username da_user_subdomains da_user_subdomains_count subdomain_count
      typeset -n "da_user_username=C_DA_USER_USERNAME${user_count}"
      typeset -n "da_user_subdomains=C_DA_USER_SUBDOMAIN${user_count}"
      da_user_subdomains_count="${#da_user_subdomains[@]}"

      _echo "$(msg newline)" --plain --verbose 7
      _echo "$(msg yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(msg end)" --name --verbose 7
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7
      _echo "User subdomains details:" --name --verbose 7
      _echo "User count ${user_count} out of ${da_user_usernames_count}" --name --verbose 7
      _echo "da_user_username: ${da_user_username}" --name --verbose 7
      _echo "da_user_subdomains: ${da_user_subdomains[*]}" --name --verbose 7
      _echo "da_user_subdomains_count: ${da_user_subdomains_count}" --name --verbose 7
      _echo "$(msg newline)" --plain --verbose 7

      subdomain_count=0
      while [ ${subdomain_count} -le $((da_user_subdomains_count - 1)) ]; do
        local root_domain sub_domains_raw
        root_domain=$(echo "${da_user_subdomains[subdomain_count]}" | awk -F':' '{ print $1 }')
        sub_domains_raw=$(echo "${da_user_subdomains[subdomain_count]}" | awk -F':' '{ print $2 }')
        sub_domains=$(echo "${sub_domains_raw}" | awk -F',' '{for (i=1;i<=NF;i++)print $i}')

        _echo "root_domain: ${root_domain}" --name --verbose 7
        _echo "sub_domains_raw: ${sub_domains_raw[*]}" --name --verbose 7
        _echo "sub_domains list (below):" --name --verbose 7
        _echo "${sub_domains}" --plain --verbose 7
        _echo "$(msg newline)" --plain --verbose 7

        for sub_domain in ${sub_domains}; do
          _echo "Subdomain for user: ${da_user_username}" --name --verbose 7
          _echo "subdomain: ${sub_domain}" --name --verbose 7
          _echo "$(msg newline)" --plain --verbose 7
          _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7

          # Now we got sub_domain and root_domain, call the da_api_admin:
          # Note that user and user share the same API
          _echo "$(msg cyan)Creating user ${da_user_username} subdomain ${sub_domain}" --name
          da_api_admin create-user-subdomain --sign-as "${da_user_username}" --domain "${root_domain}" --subdomain "${sub_domain}"
          echo ""

          if [ "${DNS_PROVIDER_NAME}" == "linode" ]; then
            _echo "$(msg cyan)Notice, DNS provider is set to linode. Using linode API ...$(msg end)" --name
            # Add delete and add subdomain for linode API here
            _echo "$(msg cyan)Deleting subdomain ${sub_domain} record for IPv4 from linode$(msg end)" --name
            linode_api_admin delete-dns-record --domain "${root_domain}" --record-name "${sub_domain}" --record-type "A"
            echo ""
            _echo "$(msg cyan)Deleting subdomain ${sub_domain} record for IPv6 from linode$(msg end)" --name
            linode_api_admin delete-dns-record --domain "${root_domain}" --record-name "${sub_domain}" --record-type "AAAA"
            echo ""
            _echo "$(msg cyan)Adding subdomain ${sub_domain} record for IPv4 in linode ...$(msg end)" --name
            linode_api_admin add-dns-record --domain "${root_domain}" --record-type "A" --record-name "${sub_domain}" --record-value "${C_IPV4_ADD0}" --record-ttl 30
            echo ""
            _echo "$(msg cyan)Adding subdomain ${sub_domain} record for IPv6 in linode ...$(msg end)" --name
            linode_api_admin add-dns-record --domain "${root_domain}" --record-type "AAAA" --record-name "${sub_domain}" --record-value "${C_IPV6_ADD0}" --record-ttl 30
            echo ""
          elif [ "${DNS_PROVIDER_NAME}" == "digitalocean" ]; then
            _echo "$(msg cyan)Notice, DNS provider is set to digitalocean$(msg end)" --name
            # Call digitalocean_api_admin
            # elif other provider
          elif [ "${DNS_PROVIDER_NAME}" == "local" ]; then
            _echo "$(msg cyan)Notice, DNS provider is set to local (Internal DNS)$(msg end)" --name
            # Do nothing
          fi
        done
        ((subdomain_count++))
      done
      ((user_count++))
    done
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi

}

configure_da_user_email_accounts() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local user_count da_user_usernames_count
    da_user_usernames_count=$(echo "${!C_DA_USER_USERNAME@}" | wc -w)
    user_count=1
    while [[ ${user_count} -le ${da_user_usernames_count} ]]; do

      local da_user_username da_user_mail_accounts da_user_mail_accounts_count

      typeset -n "da_user_username=C_DA_USER_USERNAME${user_count}"
      typeset -n "da_user_mail_accounts=C_DA_USER_MAIL_ACCOUNT${user_count}"

      da_user_mail_accounts_count="${#da_user_mail_accounts[@]}"

      _echo "$(msg newline)" --plain --verbose 7
      _echo "$(msg yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(msg end)" --name --verbose 7
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7
      _echo "User email details:" --name --verbose 7
      _echo "User count ${user_count} out of ${da_user_usernames_count}" --name --verbose 7
      _echo "da_user_username: ${da_user_username}" --name --verbose 7
      _echo "da_user_mail_accounts: ${da_user_mail_accounts[@]}" --name --verbose 7
      _echo "da_user_mail_accounts_count: ${da_user_mail_accounts_count}" --name --verbose 7

      if [ "${da_user_mail_accounts_count}" -eq 0 ]; then
        _echo "$(msg yellow)[Skipped]: Notice, this user ${da_user_username} does not have email set$(msg end)" --name
      else
        mail_count=1
        while [ ${mail_count} -le ${da_user_mail_accounts_count} ]; do
          local mail_user_domain mail_user mail_domain mail_password
          mail_user_domain=$(echo "${da_user_mail_accounts[mail_count - 1]}" | awk -F'\|\|\|' '{ print $1 }')
          mail_user=$(echo "${mail_user_domain}" | awk -F'@' '{ print $1 }')
          mail_domain=$(echo "${mail_user_domain}" | awk -F'@' '{ print $2 }')
          mail_password=$(echo "${da_user_mail_accounts[mail_count - 1]}" | awk -F'\|\|\|' '{ print $2 }')
          _echo "$(msg newline)" --plain --verbose 7
          _echo "User email count ${mail_count}/$((da_user_mail_accounts_count))" --name --verbose 7
          _echo "User_username: ${da_user_username}" --name --verbose 7
          _echo "mail_user_domain (full email): ${mail_user_domain}" --name --verbose 7
          _echo "mail_user (without @domain.com): ${mail_user}" --name --verbose 7
          _echo "mail_domain: ${mail_domain}" --name --verbose 7
          _echo "mail_password: ${mail_password}" --name --verbose 7
          _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7

          # da_api_admin create-user-email --mail-domain "maxibi.com" --mail-user "webmaster" --mail-password "1232123" --mail-quota "0" --mail-limit "200"
          _echo "$(msg cyan)Creating new user email ${mail_user_domain} ...$(msg end)" --name
          da_api_admin create-user-email --sign-as ${da_user_username} --mail-domain "${mail_domain}" --mail-user "${mail_user}" --mail-password "${mail_password}" --mail-quota "0" --mail-limit "200"

          ((mail_count++))
        done
      fi
      ((user_count++))
    done

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# Deprecated function
configure_da_user_emails() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local user_count da_user_usernames_count
    da_user_usernames_count=$(echo "${!C_DA_USER_USERNAME@}" | wc -w)
    user_count=1
    while [[ ${user_count} -le ${da_user_usernames_count} ]]; do

      local da_user_username da_user_mail_users da_user_mail_passwords

      typeset -n "da_user_username=C_DA_USER_USERNAME${user_count}"
      typeset -n "da_user_mail_users=C_DA_USER_MAIL_USER${user_count}"
      typeset -n "da_user_mail_passwords=C_DA_USER_MAIL_PASSWORD${user_count}"
      da_user_mail_users_count="${#da_user_mail_users[@]}"

      _echo "$(msg newline)" --plain --verbose 7
      _echo "$(msg yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(msg end)" --name --verbose 7
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7
      _echo "User email details:" --name --verbose 7
      _echo "User count ${user_count} out of ${da_user_usernames_count}" --name --verbose 7
      _echo "da_user_username: ${da_user_username}" --name --verbose 7
      _echo "da_user_mail_users: ${da_user_mail_users[@]}" --name --verbose 7
      _echo "da_user_mail_passwords: ${da_user_mail_passwords[@]}" --name --verbose 7
      _echo "da_user_mail_users_count: ${da_user_mail_users_count}" --name --verbose 7
      _echo "$(msg newline)" --plain --verbose 7
      mail_count=1

      while [ ${mail_count} -le ${da_user_mail_users_count} ]; do
        mail_user=$(echo "${da_user_mail_users[mail_count - 1]}" | awk -F'@' '{ print $1 }')
        mail_domain=$(echo "${da_user_mail_users[mail_count - 1]}" | awk -F'@' '{ print $2 }')
        mail_password=${da_user_mail_passwords[mail_count - 1]}
        _echo "User email count ${mail_count}/$((da_user_mail_users_count))" --name --verbose 7
        _echo "User_username: ${da_user_username}" --name --verbose 7
        _echo "User full user email address: [${mail_count}]: ${da_user_mail_users[mail_count - 1]}" --name --verbose 7
        _echo "User user email address (without @domain.com): ${mail_user}" --name --verbose 7
        _echo "User email domain: ${mail_domain}" --name --verbose 7
        _echo "User email password:[${mail_count}]: ${da_user_mail_passwords[mail_count - 1]}" --name --verbose 7
        _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7

        ## da_api_admin create-user-email --mail-domain "maxibi.com" --mail-user "webmaster" --mail-password "1232123" --mail-quota "0" --mail-limit "200"
        _echo "$(msg cyan)Creating new user email ${da_user_mail_users[mail_count - 1]} ...$(msg end)" --name
        da_api_admin create-user-email --sign-as ${da_user_username} --mail-domain "${mail_domain}" --mail-user "${mail_user}" --mail-password "${mail_password}" --mail-quota "0" --mail-limit "200"

        ((mail_count++))
      done
      ((user_count++))
    done

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_reseller_domain_ssl_pre() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local reseller_count da_reseller_ssl_sub_names da_reseller_ssl_sub_names_count count_n count_o
    local this_da_reseller_uname this_da_reseller_userpass this_da_reseller_enable_domain_ssl \
      this_da_reseller_ssl_subdomains retval le_select_query
    # Get all the reseller ssl_sub_names
    da_reseller_ssl_sub_names="${!C_DA_RESELLER_SSL_SUBDOMAIN@}"
    # Get the total count for reseller ssl_sub_names
    da_reseller_ssl_sub_names_count=$(echo "${da_reseller_ssl_sub_names}" | wc -w)
    reseller_count=1
    echo "[${SCRIPT_NAME}]: Creating acme-challenge file through custombuild rewrite_confs ..."
    /usr/local/directadmin/custombuild/build rewrite_confs
    while [[ ${reseller_count} -le ${da_reseller_ssl_sub_names_count} ]]; do
      echo ""
      echo "===== Loop count: ${reseller_count} ========="
      typeset -n "this_da_reseller_username"="C_DA_RESELLER_USERNAME${reseller_count}"
      typeset -n "this_da_reseller_userpass"="C_DA_RESELLER_USERPASS${reseller_count}"
      typeset -n "this_da_reseller_enable_domain_ssl"="C_DA_RESELLER_ENABLE_DOMAIN_SSL${reseller_count}"
      typeset -n "this_da_reseller_ssl_subdomains"="C_DA_RESELLER_SSL_SUBDOMAIN${reseller_count}"

      echo "this_da_reseller_username: ${this_da_reseller_username}"
      echo "this_da_reseller_userpass: ${this_da_reseller_userpass}"
      echo "this_da_reseller_enable_domain_ssl: ${this_da_reseller_enable_domain_ssl}"
      echo "this_da_reseller_ssl_subdomains: ${this_da_reseller_ssl_subdomains[*]}"
      echo "this_da_reseller_ssl_subdomains_count: ${#this_da_reseller_ssl_subdomains[*]}"
      echo "=========================================="

      if [[ ${this_da_reseller_enable_domain_ssl} == "yes" ]]; then
        echo ""
        echo "OK, This reseller is set to enable SSL"
        count_n=0
        while [ ${count_n} -le $((this_da_reseller_ssl_subdomains_count - 1)) ]; do
          echo ""

          ssl_provider=$(echo "${this_da_reseller_ssl_subdomains[count_n]}" | awk -F':' '{ print $1 }')
          ssl_domain=$(echo "${this_da_reseller_ssl_subdomains[count_n]}" | awk -F':' '{ print $2 }')
          ssl_subdomains_raw=$(echo "${this_da_reseller_ssl_subdomains[count_n]}" | awk -F':' '{ print $3 }')
          # Debug
          # echo "==============---count_n = ${count_n} ---==============="
          # echo "SSL_PROVIDER: ${ssl_provider}"
          # echo "SSL_DOMAIN: ${ssl_domain}"
          # echo "SSL_SUBDOMAINS_RAW: ${ssl_subdomains_raw}"

          if [ "${ssl_provider}" == "letsencrypt" ]; then
            echo "Testing, requesting letsencrypt SSL certificate for domain ${ssl_domain} in staging mode ..."
            staging=yes /usr/local/directadmin/scripts/letsencrypt.sh request_single "${ssl_domain}"
            retval=$?
            if [ ${retval} -ne 0 ]; then
              echo "Warning, this domain ${ssl_domain} has issue when requesting ssl certificate in staging mode"
            else
              echo "OK, this domain ${ssl_domain} has no issue when requesting ssl certificate in staging mode"
            fi

            count_o=0
            le_select_query=""
            for ssl_subdomain in ${ssl_subdomains}; do
              if [ ${count_o} = 0 ]; then
                le_select[${count_o}]="${ssl_domain}"
                echo "Count OO: ${le_select_query}"
              else
                le_select[${count_o}]="${ssl_subdomain}.${ssl_domain}"
                echo "Count > 00: ${le_select_query}"
              fi
              ((count_o++))
            done
          elif [ "${ssl_provider}" == "digicert" ]; then
            :
          fi
          ((count_n++))
        done
      elif [[ ${this_da_user_enable_domain_ssl} == "no" ]]; then
        echo "Warning This user is set to not enable SSL. Do nothing for this"
      fi
      echo ""
      ((reseller_count++))

    done
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_user_domain_ssl_pre() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_user_ssl_sub_names da_user_ssl_sub_names_count
    local this_da_user_uname this_da_user_userpass this_da_user_enable_domain_ssl \
      this_da_user_ssl_subdomains retval
    # Get all the user ssl_sub_names
    da_user_ssl_sub_names="${!C_DA_USER_SSL_SUBDOMAIN@}"
    # Get the total count for user ssl_sub_names
    da_user_ssl_sub_names_count=$(echo "${da_user_ssl_sub_names}" | wc -w)
    count_x=1
    echo "[${SCRIPT_NAME}]: Creating acme-challenge file through custombuild rewrite_confs ..."
    /usr/local/directadmin/custombuild/build rewrite_confs
    while [[ ${count_x} -le ${da_user_ssl_sub_names_count} ]]; do
      echo ""
      echo "===== Loop count: ${count_x} ========="
      typeset -n "this_da_user_username"="C_DA_USER_USERNAME${count_x}"
      typeset -n "this_da_user_userpass"="C_DA_USER_USERPASS${count_x}"
      typeset -n "this_da_user_enable_domain_ssl"="C_DA_USER_ENABLE_DOMAIN_SSL${count_x}"
      typeset -n "this_da_user_ssl_subdomains"="C_DA_USER_SSL_SUBDOMAIN${count_x}"

      echo "this_da_user_username: ${this_da_user_username}"
      echo "this_da_user_userpass: ${this_da_user_userpass}"
      echo "this_da_user_enable_domain_ssl: ${this_da_user_enable_domain_ssl}"
      echo "this_da_user_ssl_subdomains: ${this_da_user_ssl_subdomains[*]}"
      this_da_user_ssl_subdomains_count=${#this_da_user_ssl_subdomains[@]}
      echo "=========================================="

      if [[ ${this_da_user_enable_domain_ssl} == "yes" ]]; then
        echo ""
        echo "OK, This user is set to enable SSL"
        count_n=0
        while [ ${count_n} -le $((this_da_user_ssl_subdomains_count - 1)) ]; do
          echo ""

          ssl_provider=$(echo "${this_da_user_ssl_subdomains[count_n]}" | awk -F':' '{ print $1 }')
          ssl_domain=$(echo "${this_da_user_ssl_subdomains[count_n]}" | awk -F':' '{ print $2 }')
          ssl_subdomains_raw=$(echo "${this_da_user_ssl_subdomains[count_n]}" | awk -F':' '{ print $3 }')
          # Debug
          # echo "==============---count_n = ${count_n} ---==============="
          # echo "SSL_PROVIDER: ${ssl_provider}"
          # echo "SSL_DOMAIN: ${ssl_domain}"
          # echo "SSL_SUBDOMAINS_RAW: ${ssl_subdomains_raw}"

          if [ "${ssl_provider}" == "letsencrypt" ]; then
            echo "Testing, requesting letsencrypt SSL certificate for domain ${ssl_domain} in staging mode ..."
            staging=yes /usr/local/directadmin/scripts/letsencrypt.sh request_single "${ssl_domain}"
            retval=$?
            if [ ${retval} -ne 0 ]; then
              echo "Warning, this domain ${ssl_domain} has issue when requesting ssl certificate in staging mode"
            else
              echo "OK, this domain ${ssl_domain} has no issue when requesting ssl certificate in staging mode"
            fi
          elif [ "${ssl_provider}" == "digicert" ]; then
            :
          fi
          ((count_n++))
        done
      elif [[ ${this_da_user_enable_domain_ssl} == "no" ]]; then
        echo "Warning This user is set to not enable SSL. Do nothing for this"
      fi
      echo ""
      ((count_x++))

    done
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

# This will also take care the subdomain
configure_da_reseller_domain_ssl() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local reseller_count da_reseller_ssl_sub_names da_reseller_ssl_sub_names_count
    local this_da_reseller_uname this_da_reseller_userpass this_da_reseller_enable_domain_ssl \
      this_da_reseller_ssl_subdomains retval
    # Get all the reseller ssl_sub_names
    da_reseller_ssl_sub_names="${!C_DA_RESELLER_SSL_SUBDOMAIN@}"
    # Get the total count for reseller ssl_sub_names
    da_reseller_ssl_sub_names_count=$(echo "${da_reseller_ssl_sub_names}" | wc -w)

    echo "[${SCRIPT_NAME}]: Creating acme-challenge file through custombuild rewrite_confs ..."
    /usr/local/directadmin/custombuild/build rewrite_confs
    echo ""
    reseller_count=1
    while [[ ${reseller_count} -le ${da_reseller_ssl_sub_names_count} ]]; do
      echo ""
      echo "===== Loop count: ${reseller_count} ========="
      typeset -n "this_da_reseller_username"="C_DA_RESELLER_USERNAME${reseller_count}"
      typeset -n "this_da_reseller_userpass"="C_DA_RESELLER_USERPASS${reseller_count}"
      typeset -n "this_da_reseller_enable_domain_ssl"="C_DA_RESELLER_ENABLE_DOMAIN_SSL${reseller_count}"
      typeset -n "this_da_reseller_ssl_subdomains"="C_DA_RESELLER_SSL_SUBDOMAIN${reseller_count}"

      echo "this_da_reseller_username: ${this_da_reseller_username}"
      echo "this_da_reseller_userpass: ${this_da_reseller_userpass}"
      echo "this_da_reseller_enable_domain_ssl: ${this_da_reseller_enable_domain_ssl}"
      echo "this_da_reseller_ssl_subdomains: ${this_da_reseller_ssl_subdomains[*]}"
      this_da_reseller_ssl_subdomains_count=${#this_da_reseller_ssl_subdomains[@]}
      echo "=========================================="

      if [[ ${this_da_reseller_enable_domain_ssl} == "yes" ]]; then
        echo ""
        echo "OK, This reseller is set to enable SSL"
        count_n=0
        while [ ${count_n} -le $((this_da_reseller_ssl_subdomains_count - 1)) ]; do
          echo ""
          ssl_provider=$(echo "${this_da_reseller_ssl_subdomains[count_n]}" | awk -F':' '{ print $1 }')
          ssl_domain=$(echo "${this_da_reseller_ssl_subdomains[count_n]}" | awk -F':' '{ print $2 }')
          ssl_subdomains_raw=$(echo "${this_da_reseller_ssl_subdomains[count_n]}" | awk -F':' '{ print $3 }')
          # Debug
          echo "==============---count_n = ${count_n} ---==============="
          echo "SSL_PROVIDER: ${ssl_provider}"
          echo "SSL_DOMAIN: ${ssl_domain}"
          echo "SSL_SUBDOMAINS_RAW: ${ssl_subdomains_raw}"
          if [ "${ssl_provider}" == "letsencrypt" ]; then
            echo "Testing, requesting letsencrypt SSL certificate for domain ${ssl_domain} in staging mode ..."
            staging=yes /usr/local/directadmin/scripts/letsencrypt.sh request "${ssl_domain}"
            retval=$?
            if [ ${retval} -ne 0 ]; then
              echo "Warning, this domain ${ssl_domain} has issue when requesting ssl certificate in staging mode"
              # TODO add the ability to resume failed certificate request for reseller (when rerun this script)
            else
              echo "OK, this domain ${ssl_domain} has no issue when requesting ssl certificate in staging mode"
            fi
            ssl_subdomains=$(echo "${ssl_subdomains_raw}" | awk -F',' '{for (i=0;i<=NF;i++)print $i}')
            count_o=0
            le_select_query=""
            for ssl_subdomain in ${ssl_subdomains}; do
              if [ ${count_o} = 0 ]; then
                le_select[${count_o}]="${ssl_domain}"
                ls="le_select${count_o}=${le_select[${count_o}]}"
              else
                le_select[${count_o}]="${ssl_subdomain}.${ssl_domain}"
                ls="&le_select${count_o}=${le_select[${count_o}]}"
              fi
              le_select_query="${le_select_query}${ls}"
              ((count_o++))
            done
            echo "LE_SELECT_QUERY: ${le_select_query}"
            echo "================-------------------======================="
            echo ""
            # Now we got all variables. Call API here:
            # Seems like DA admin or owner level also can use this authentication to request certificate for user (I will verify this again)
            echo "Requesting SSL for domain ${ssl_domain} with the following query: ${le_select_query}"
            da_api_admin request-domain-ssl --sign-as "${this_da_reseller_username}" --ssl-provider "${ssl_provider}" --ssl-root-domain "${ssl_domain}" --ssl-subdomain-query "${le_select_query}"
          elif [ "${ssl_provider}" == "digicert" ]; then
            :
          fi
          ((count_n++))
        done
      elif [[ ${this_da_user_enable_domain_ssl} == "no" ]]; then
        echo "Warning This user is set to not enable SSL. Do nothing for this"
      fi
      echo ""
      ((reseller_count++))

    done
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}
configure_da_user_domain_ssl() {
  # Here we configure SSL for specific domains we want based on the config variable: C_DA_USER_ENABLE_DOMAIN_SSL{?}
  # Where Domain can have 1 or more
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_user_ssl_sub_names da_user_ssl_sub_names_count this_da_user_username this_da_user_userpass \
      this_da_user_enable_domain_ssl this_da_user_ssl_subdomains this_da_user_ssl_subdomains_count
    local ssl_provider ssl_domain ssl_subdomains_raw le_select_query le_s count_o count_n count_x retval
    # Get all the user ssl_sub_names
    da_user_ssl_sub_names="${!C_DA_USER_SSL_SUBDOMAIN@}"
    # Get the total count for user ssl_sub_names
    da_user_ssl_sub_names_count=$(echo "${da_user_ssl_sub_names}" | wc -w)
    count_x=1
    while [[ ${count_x} -le ${da_user_ssl_sub_names_count} ]]; do
      echo ""
      echo ""
      echo "===== countx = ${count_x} ========="
      typeset -n "this_da_user_username"="C_DA_USER_USERNAME${count_x}"
      typeset -n "this_da_user_userpass"="C_DA_USER_USERPASS${count_x}"
      typeset -n "this_da_user_enable_domain_ssl"="C_DA_USER_ENABLE_DOMAIN_SSL${count_x}"
      typeset -n "this_da_user_ssl_subdomains"="C_DA_USER_SSL_SUBDOMAIN${count_x}"

      echo "this_da_user_username: ${this_da_user_username}"
      echo "this_da_user_userpass: ${this_da_user_userpass}"
      echo "this_da_user_enable_domain_ssl: ${this_da_user_enable_domain_ssl}"
      echo "this_da_user_ssl_subdomains: ${this_da_user_ssl_subdomains[*]}"
      this_da_user_ssl_subdomains_count=${#this_da_user_ssl_subdomains[@]}

      if [[ ${this_da_user_enable_domain_ssl} == "yes" ]]; then
        echo ""
        echo "=========================================="
        echo "OK, This user is set to enable SSL"
        count_n=0
        while [ ${count_n} -le $((this_da_user_ssl_subdomains_count - 1)) ]; do
          echo ""
          echo "---count_n=${count_n} ---"
          ssl_provider=$(echo "${this_da_user_ssl_subdomains[count_n]}" | awk -F':' '{ print $1 }')
          ssl_domain=$(echo "${this_da_user_ssl_subdomains[count_n]}" | awk -F':' '{ print $2 }')
          ssl_subdomains_raw=$(echo "${this_da_user_ssl_subdomains[count_n]}" | awk -F':' '{ print $3 }')
          # Debug
          echo "SSL_PROVIDER: ${ssl_provider}"
          echo "SSL_DOMAIN: ${ssl_domain}"
          echo "SSL_SUBDOMAINS_RAW: ${ssl_subdomains_raw}"
          if [ "${ssl_provider}" == "letsencrypt" ]; then
            echo "Testing, requesting letsencrypt SSL certificate for domain ${ssl_domain} in staging mode ..."
            staging=yes /usr/local/directadmin/scripts/letsencrypt.sh request "${ssl_domain}"
            retval=$?
            if [ ${retval} -ne 0 ]; then
              echo "Warning, this domain ${ssl_domain} has issue when requesting ssl certificate in staging mode"
              # TODO add the ability to resume failed certificate request for user when rerun this script
            else
              echo "OK, this domain ${ssl_domain} has no issue when requesting ssl certificate in staging mode"
            fi
            ssl_subdomains=$(echo "${ssl_subdomains_raw}" | awk -F',' '{for (i=0;i<=NF;i++)print $i}')
            count_o=0
            le_select_query=""
            for ssl_subdomain in ${ssl_subdomains}; do
              if [ ${count_o} = 0 ]; then
                le_select[${count_o}]="${ssl_domain}"
                le_s="le_select${count_o}=${le_select[${count_o}]}"
              else
                le_select[${count_o}]="${ssl_subdomain}.${ssl_domain}"
                le_s="&le_select${count_o}=${le_select[${count_o}]}"
              fi
              le_select_query="${le_select_query}${le_s}"
              ((count_o++))
            done
            echo "---------------"
            echo "LE_SELECT_QUERY: ${le_select_query}"
            echo ""
            # Now we got all variables. Call API here:
            # da_api_admin "request-domain-ssl" <provider> <root_domain> <keysize> <encryption> <ssl_sub_domains_query>
            da_api_admin "signas+${this_da_user_username}+${this_da_user_userpass}"
            # Most secure key now is secp521r1 and sha256
            echo "Requesting SSL for domain ${ssl_domain} with the following query: ${le_select_query}"
            da_api_admin "request-domain-ssl" "${ssl_provider}" "${ssl_domain}" "secp521r1" "sha256" "${le_select_query}"

          elif [ "${ssl_provider}" == "digicert" ]; then
            :
          fi

          ((count_n++))
        done

      elif [[ ${this_da_user_enable_domain_ssl} == "no" ]]; then
        echo "Warning This user is set to not enable SSL. Do nothing for this"
      fi
      echo "=========================================="
      ((count_x++))

    done
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_admin_security() {
  # Set admin security and answer questions:
  # da_api_admin "set-security-qna" "Sekolah menengah dulu aliran apa ?" "sains"
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_admin_username da_admin_security_qna da_admin_security_qna_count admin_count question_count

    da_admin_usernames_count=$(echo "${!C_DA_ADMIN_USERNAME@}" | wc -w)
    admin_count=1
    while [ ${admin_count} -le "${da_admin_usernames_count}" ]; do
      # Assign all variables from the config file as array index
      typeset -n "da_admin_username=C_DA_ADMIN_USERNAME${admin_count}"
      typeset -n "da_admin_security_qna=C_DA_ADMIN_SECURITY_QNA${admin_count}"
      da_admin_security_qna_count="${#da_admin_security_qna[@]}"

      _echo "$(msg newline)" --plain --verbose 7
      _echo "$(msg yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(msg end)" --name --verbose 7
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7
      _echo "Admin security question details:" --name --verbose 7
      _echo "Admin count ${admin_count} out of ${da_admin_usernames_count}" --name --verbose 7
      _echo "da_admin_username: ${da_admin_username}" --name --verbose 7
      _echo "da_admin_security_qna  ${da_admin_security_qna[*]}" --name --verbose 7
      _echo "da_admin_security_qna_count: ${da_admin_security_qna_count[*]}" --name --verbose 7
      _echo "$(msg newline)" --plain --verbose 7

      question_count=1
      if [[ "${#da_admin_security_qna}" == 0 ]]; then
        echo "[${SCRIPT_NAME}]: [skipped]: Value defined for security_question for user ${da_admin_username} is empty"
      else
        while [ "${question_count}" -le ${da_admin_security_qna_count} ]; do
          local security_question_answer security_question security_answer
          security_question_answer=${da_admin_security_qna[question_count - 1]}
          security_question="$(echo ${security_question_answer} | awk -F'\|\|\|' '{ print $1 }')"
          security_answer="$(echo ${security_question_answer} | awk -F'\|\|\|' '{ print $2 }')"

          _echo "Security question count ${question_count} out of ${da_admin_security_qna_count}" --name --verbose 7
          _echo "Security question for admin: ${da_admin_username}" --name --verbose 7
          _echo "Security question_answer: ${security_question_answer}" --name --verbose 7
          _echo "Security question: ${security_question}" --name --verbose 7
          _echo "Security answer: ${security_answer}" --name --verbose 7
          _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7

          _echo "$(msg cyan)Setting up security questions and answers for user ${da_admin_username}$(msg end)" --name
          da_api_admin set-security-qna --sign-as "${da_admin_username}" --question "${security_question}" --answer "${security_answer}"
          echo ""
          ((question_count++))
        done

      fi
      ((admin_count++))
    done
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_reseller_security() {
  # Set reseller security and answer questions:
  # da_api_reseller "set-security-qna" "Sekolah menengah dulu aliran apa ?" "sains"
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_reseller_username da_reseller_security_qna da_reseller_security_qna_count reseller_count question_count

    da_reseller_usernames_count=$(echo "${!C_DA_RESELLER_USERNAME@}" | wc -w)
    reseller_count=1
    while [ ${reseller_count} -le "${da_reseller_usernames_count}" ]; do
      # Assign all variables from the config file as array index
      typeset -n "da_reseller_username=C_DA_RESELLER_USERNAME${reseller_count}"
      typeset -n "da_reseller_security_qna=C_DA_RESELLER_SECURITY_QNA${reseller_count}"
      da_reseller_security_qna_count="${#da_reseller_security_qna[@]}"

      _echo "$(msg newline)" --plain --verbose 7
      _echo "$(msg yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(msg end)" --name --verbose 7
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7
      _echo "Reseller security question details:" --name --verbose 7
      _echo "Reseller count ${reseller_count} out of ${da_reseller_usernames_count}" --name --verbose 7
      _echo "da_reseller_username: ${da_reseller_username}" --name --verbose 7
      _echo "da_reseller_security_qna  ${da_reseller_security_qna[*]}" --name --verbose 7
      _echo "da_reseller_security_qna_count: ${da_reseller_security_qna_count[*]}" --name --verbose 7
      _echo "$(msg newline)" --plain --verbose 7

      question_count=1
      if [[ "${#da_reseller_security_qna}" == 0 ]]; then
        echo "[${SCRIPT_NAME}]: [skipped]: Value defined for security_question for user ${da_reseller_username} is empty"
      else
        while [ "${question_count}" -le ${da_reseller_security_qna_count} ]; do
          local security_question_answer security_question security_answer
          security_question_answer=${da_reseller_security_qna[question_count - 1]}
          security_question="$(echo ${security_question_answer} | awk -F'\|\|\|' '{ print $1 }')"
          security_answer="$(echo ${security_question_answer} | awk -F'\|\|\|' '{ print $2 }')"

          _echo "Security question count ${question_count} out of ${da_reseller_security_qna_count}" --name --verbose 7
          _echo "Security question for reseller: ${da_reseller_username}" --name --verbose 7
          _echo "Security question_answer: ${security_question_answer}" --name --verbose 7
          _echo "Security question: ${security_question}" --name --verbose 7
          _echo "Security answer: ${security_answer}" --name --verbose 7
          _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7

          _echo "$(msg cyan)Setting up security questions and answers for user ${da_reseller_username}$(msg end)" --name
          da_api_admin set-security-qna --sign-as "${da_reseller_username}" --question "${security_question}" --answer "${security_answer}"
          echo ""
          ((question_count++))
        done

      fi
      ((reseller_count++))
    done
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_da_user_security() {
  # Set user security and answer questions:
  # Don't use 2 step authentication yet because of this:
  # https://forum.directadmin.com/threads/feature-request-dont-use-online-service-to-generate-otp-qr-code-for-security.63140/

  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    local da_user_username da_user_security_qna da_user_security_qna_count user_count question_count

    da_user_usernames_count=$(echo "${!C_DA_USER_USERNAME@}" | wc -w)
    user_count=1
    while [ ${user_count} -le "${da_user_usernames_count}" ]; do
      # Assign all variables from the config file as array index
      typeset -n "da_user_username=C_DA_USER_USERNAME${user_count}"
      typeset -n "da_user_security_qna=C_DA_USER_SECURITY_QNA${user_count}"
      da_user_security_qna_count="${#da_user_security_qna[@]}"

      _echo "$(msg newline)" --plain --verbose 7
      _echo "$(msg yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(msg end)" --name --verbose 7
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7
      _echo "User security question details:" --name --verbose 7
      _echo "User count ${user_count} out of ${da_user_usernames_count}" --name --verbose 7
      _echo "da_user_username: ${da_user_username}" --name --verbose 7
      _echo "da_user_security_qna  ${da_user_security_qna[*]}" --name --verbose 7
      _echo "da_user_security_qna_count: ${da_user_security_qna_count[*]}" --name --verbose 7
      _echo "$(msg newline)" --plain --verbose 7

      question_count=1
      if [[ "${#da_user_security_qna}" == 0 ]]; then
        echo "[${SCRIPT_NAME}]: [skipped]: Value defined for security_question for user ${da_user_username} is empty"
      else
        while [ "${question_count}" -le ${da_user_security_qna_count} ]; do
          local security_question_answer security_question security_answer
          security_question_answer=${da_user_security_qna[question_count - 1]}
          security_question="$(echo ${security_question_answer} | awk -F'\|\|\|' '{ print $1 }')"
          security_answer="$(echo ${security_question_answer} | awk -F'\|\|\|' '{ print $2 }')"

          _echo "Security question count ${question_count} out of ${da_user_security_qna_count}" --name --verbose 7
          _echo "Security question for user: ${da_user_username}" --name --verbose 7
          _echo "Security question_answer: ${security_question_answer}" --name --verbose 7
          _echo "Security question: ${security_question}" --name --verbose 7
          _echo "Security answer: ${security_answer}" --name --verbose 7
          _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7

          _echo "$(msg cyan)Setting up security questions and answers for user ${da_user_username}$(msg end)" --name
          da_api_admin set-security-qna --sign-as "${da_user_username}" --question "${security_question}" --answer "${security_answer}"
          echo ""
          ((question_count++))
        done

      fi
      ((user_count++))
    done
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi

}

# Function to create all user databases
configure_da_user_databases() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then

    local user_count da_user_usernames_count

    da_user_usernames_count=$(echo "${!C_DA_USER_USERNAME@}" | wc -w)
    user_count=1
    while [[ ${user_count} -le ${da_user_usernames_count} ]]; do
      local da_user_username da_user_db_accounts da_user_db_accounts_count database_count
      typeset -n "da_user_username=C_DA_USER_USERNAME${user_count}"
      typeset -n "da_user_db_accounts=C_DA_USER_DB_ACCOUNT${user_count}"
      _echo "$(msg newline)" --plain --verbose 7
      _echo "$(msg yellow)Warning this information contains sensitive data due to verbosity level was set to 7 or more$(msg end)" --name --verbose 7
      _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7
      _echo "User database details:" --name --verbose 7
      _echo "User count ${user_count} out of ${da_user_usernames_count}" --name --verbose 7
      _echo "da_user_username: ${da_user_username}" --name --verbose 7
      _echo "da_user_db_accounts: ${da_user_db_accounts[*]}" --name --verbose 7
      da_user_db_accounts_count="${#da_user_db_accounts[@]}"
      database_count=1
      if [[ "${#da_user_db_accounts}" == 0 ]]; then
        _echo "$(msg yellow)[skipped]: Value defined for this user ${da_user_username} database is empty$(msg end)" --name
      else
        while [ ${database_count} -le ${da_user_db_accounts_count} ]; do
          local db_domain_name_user db_password db_domain db_name db_user sql_users sql_user_exist

          db_domain_name_user=$(echo "${da_user_db_accounts[database_count - 1]}" | awk -F'\|\|\|' '{ print $1 }')
          db_password=$(echo "${da_user_db_accounts[database_count - 1]}" | awk -F'\|\|\|' '{ print $2 }')
          db_domain=$(echo "${db_domain_name_user}" | awk -F':' '{ print $1 }')
          db_name=$(echo "${db_domain_name_user}" | awk -F':' '{ print $2 }')
          db_user=$(echo "${db_domain_name_user}" | awk -F':' '{ print $3 }')
          sql_users=$(mysql -e "SELECT USER FROM mysql.user;" | jq -rR .)
          sql_user_exist=$(echo "${sql_users}" | grep "${da_user_username}_${db_user}")

          _echo "User database count ${database_count}/$((da_user_db_accounts_count))" --name --verbose 7
          [[ -n "${sql_user_exist}" ]] && _echo "sql_user_exist in mysql system: ${sql_user_exist}" --name --verbose 7
          _echo "db_domain: ${db_domain}" --name --verbose 7
          _echo "db_name: ${db_name}" --name --verbose 7
          _echo "db_user: ${db_user}" --name --verbose 7
          _echo "db_password: ${db_password}" --name --verbose 7
          _echo "$(msg magenta)=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=$(msg end)" --name --verbose 7
          _echo "$(msg newline)" --plain --verbose 7

          #da_api_admin create-user-database --db-domain "maxibi.com" --db-name abc --db-user maxibi --db-password 12321aa (create new user database)

          #da_api_admin --db-domain "maxibi.com" create-user-database --db-name abc --existing-user maxibi  (create database with existing user)

          if [[ -z "${sql_user_exist}" ]]; then
            _echo "$(msg cyan)Creating new database name ${db_name} for user ${da_user_username} on domain ${db_domain} ...$(msg end)" --name
            da_api_admin create-user-database --sign-as "${da_user_username}" --db-domain "${db_domain}" --db-name "${db_name}" --db-user "${db_user}" --db-password "${db_password}"
          else
            _echo "$(msg cyan)Creating new database name ${db_name} for user ${da_user_username} on domain ${db_domain} using existing username ${db_user} ...$(msg end)" --name
            da_api_admin create-user-database --sign-as "${da_user_username}" --db-domain "${db_domain}" --db-name "${db_name}" --db-existing-user "${db_user}"
          fi

          ((database_count++))
        done
      fi
      ((user_count++))
    done

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}
# This is a custom function used to modify user websites configuration based on the type of website
configure_da_custom_webs() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    if [ "${C_USE_CUSTOM_WEB_CONFIG}" == "true" ]; then
      local websetup_bin
      websetup_bin="${DATA_PATH}/maxinet/storage/webapps/websetup"
      if [ -f "${websetup_bin}" ]; then
        chmod +x "${websetup_bin}"
        navigate_path "${DATA_PATH}/maxinet/storage/webapps"
        ./websetup
      else
        echo "[${SCRIPT_NAME}]: Unable to find websetup script at maxinet data storage"
        _exit 147
      fi
    else
      echo "[${SCRIPT_NAME}]: [Skipped]: Custom websetup is not enabled in config file"
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

harden_with_lynis() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    # Suggested by lynis to disable core dump
    limitsconf="/etc/security/limits.conf"
    limit_append="*                hard    core          0"
    read -ra line_array <<<"${limit_append}"
    line_domain=${line_array[0]}
    line_type=${line_array[1]}
    line_item=${line_array[2]}
    line_value=${line_array[3]}
    gr=$(grep "$line_domain *$line_type  *$line_item *$line_value" "${limitsconf}")

    if [[ -z "${gr}" ]]; then
      echo "[${SCRIPT_NAME}]: Disabling core dump with the following options:"
      echo "${limit_append}"
      echo "${limit_append}" >>"${limitsconf}"
    else
      echo "[${SCRIPT_NAME}]: [Skipped]: Found core dump config is already disabled"
    fi

    echo "# This line disables core dumps for all users" >>/etc/profile
    echo "ulimit -S -c 0 > /dev/null 2>&1" >>/etc/profile
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_cronjobs() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    # Stopping some services to reduce memory usage like clamav:
    maxicron --stop-some-services
    # TODO add this:

    # 23 */12 * * * /usr/local/subcode/centmin/csfcf.sh csf >/dev/null 2>&1
    # Add the above command in crontab so it will run on startup
    {
      echo "# Stop some high memory processes 180 seconds (3 minutes) after reboot"
      echo "@reboot sleep 180 && maxicron --stop-some-services"
    } >>/etc/crontab

    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}

configure_os_services() {

  # Disabling some daemon processes to reduce server load
  if [ "${C_ENABLE_CLAMAV_SERVICE}" == "no" ]; then
    # TODO disable clamav here if exist to reduce server load
    # TODO Write disable service <<EOF
    :
  fi

  # check services.status from directadmin
  # clamd=OFF
  #csf=ON
  #da-popb4smtp=OFF
  #directadmin=ON
  #dovecot=ON
  #exim=ON
  #freshclam=ON
  #httpd=ON
  #lfd=ON
  #memcached=ON
  #mysqld=ON
  #named=ON
  #nginx=ON
  #php-fpm72=ON
  #php-fpm73=ON
  #php-fpm74=ON
  #pure-ftpd=OFF
  #rspamd=ON
  #sshd=ON
  #
  # !/bin/bash
  #
  ## STOP STARTUP LIST #
  ## ================= #
  ## stop and disable clamav and freshclam on startup
  ## useful when clamav is updated with the new version, it will re-enable startup
  #echo "stopping services please wait... "
  #sleep 2m
  ##stop clamav / clamd
  #sudo systemctl stop clamd
  #sudo systemctl disable clamav-freshclam.service
  #sudo systemctl disable clamav-daemon.service
  #sudo systemctl disable clamav-daemon.socket
  #sudo systemctl disable clamd
  ##stop freshclam
  #sudo systemctl stop freshclam
  #sudo systemctl disable freshclam
  ##stop da-popb4smtp
  #sudo systemctl stop da-popb4smtp
  #sudo systemctl disable da-popb4smtp
  ##stop pure-ftpd
  #sudo systemctl stop pure-ftpd
  #sudo systemctl disable pure-ftpd
  #echo "services stopped successfully..."
  ##===================#

}
configure_services() {
  :
}

# This is used to get A+ rating for SSL and increase security
# TODO Warning, the next DA version 1.63 will release this hsts header for specific domain via ui, check this for compatibility on next version
# Warning this has issue with new version of DA if using nginx or nginx_apache
# https://www.directadmin.com/features.php?id=2602
configure_da_domain_security() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    if [ "${C_DA_ENABLE_DOMAIN_SECURITY_HEADER}" == "true" ]; then
      local da_bin da_cb_bin da_template_custom_path retval test_count
      da_bin="/usr/local/directadmin/directadmin"
      da_cb_bin="/usr/local/directadmin/custombuild/build"
      da_template_custom_path="/usr/local/directadmin/data/templates/custom"
      if [[ "${C_DA_CB_WEBSERVER_SOFTWARE}" == "nginx" || "${C_DA_CB_WEBSERVER_SOFTWARE}" == "nginx_apache" ]]; then

        _echo -n "$(msg cyan)Writing hsts rule for ${C_DA_CB_WEBSERVER_SOFTWARE} into ${da_template_custom_path}/cust_nginx.CUSTOM.post ...$(msg end)" --name
        mkdir -p "${da_template_custom_path}"
        {
          # Note 1
          # Below can be added into the 3rd box of custom nginx (need testing) for individual domain
          # add_header Strict-Transport-Security "max-age=63072000; includeSubdomains; preload";
          # https://forum.directadmin.com/threads/enable-strict-transport-security-hsts.51351/

          # This if for global domain (every domain will have this header except host):
          # For host, it use option hsts=${second}
          echo -e "\t# ===============================================\n"
          echo -e "\t# This security header section was automatically generated by ${SCRIPT_NAME}\n"
          echo -e "\t# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}\n"
          echo -e "\t# ===============================================\n"
          echo -e "\tadd_header X-Content-Type-Options \"nosniff\";\n"
          echo -e "\tadd_header X-Frame-Options \"SAMEORIGIN\" always;\n"
          echo -e "\tadd_header X-XSS-Protection \"1\";\n"
          echo -e "\tadd_header X-Download-Options \"noopen\";\n"
          echo -e "\tadd_header X-Permitted-Cross-Domain-Policies \"master-only\";\n"
          echo -e "\tadd_header X-DNS-Prefetch-Control \"on\";\n"
          echo -e "\tadd_header Referrer-Policy \"no-referrer-when-downgrade\";\n"
          echo -e "\n"
          if [ "${C_DA_ENABLE_DOMAIN_HSTS}" != "false" ]; then
            local enable_type hsts_max_age
            enable_type=$(echo "${C_DA_ENABLE_DOMAIN_HSTS}" | awk -F':' '{ print $1 }')
            hsts_max_age=$(echo "${C_DA_ENABLE_DOMAIN_HSTS}" | awk -F':' '{ print $2 }')
            if [ "${enable_type}" == "global" ]; then
              echo -e "\t|*if SSL_TEMPLATE=\"1\"|\n"
              # The preload part is important, so that after you have submitted the domain into preload list https://hstspreload.org/,
              # people will not able to delete your domain there. This preload list must be included so people in Google know you want to
              # redirect people to https.
              echo -e "\tadd_header Strict-Transport-Security \"max-age=${hsts_max_age}; includeSubDomains; preload\";\n"
              echo -e "\t|*endif|\n"
            else
              :
              # TODO add hsts based on user ROLE config (let the other header global) (planned feature)
            fi
          fi
          echo -e "\n"
          echo -e "\tadd_header Content-Security-Policy \"block-all-mixed-content\";"
          echo -e "\tadd_header Permissions-Policy 'geolocation=*, midi=(), sync-xhr=(self \"https://|DOMAIN|\" \"https://www.|DOMAIN|\"), \
microphone=(), camera=(), magnetometer=(), gyroscope=(), payment=(), fullscreen=(self \"https://|DOMAIN|\" \"https://www.|DOMAIN|\" )';\n"
          # This is the extra condition to first redirect (if I dont put this, I will have problem submitting preload hsts):
          # Related to my post here: https://forum.directadmin.com/threads/problem-with-ssl-on-hostname-and-da-and-hsts-with-other-aplications-on-other-ports.64137/post-335495
          echo -e "\n"
          echo -e "\t|*if SSL_TEMPLATE=\"0\"|\n"
          echo -e "\treturn 301 https://\$host\$request_uri;\n"
          echo -e "\t|*endif|\n"
        } >"${da_template_custom_path}/cust_nginx.CUSTOM.post"
        get_status_message "$?"
        echo ""

      elif [[ "${C_DA_CB_WEBSERVER_SOFTWARE}" == "apache" ]]; then
        _echo -n "$(msg cyan)Writing hsts rule for ${C_DA_CB_WEBSERVER_SOFTWARE} into ${da_template_custom_path}/cust_httpd.CUSTOM.post ...$(msg end)" --name
        {
          # Reference: https://docs.directadmin.com/webservices/apache/virtualhost-level.html#adding-security-headers-to-get-an-a-rating
          echo -e "\t# ===============================================\n"
          echo -e "\t# This security header section was automatically generated by ${SCRIPT_NAME}\n"
          echo -e "\t# Author: ${C_ADMIN_NAME} | Email: ${C_ADMIN_EMAIL} | Web: ${C_BOX_DOMAIN}\n"
          echo -e "\t# ===============================================\n"
          echo -e "\t<IfModule mod_headers.c>\n"
          echo -e "\tHeader always set X-Content-Type-Options \"nosniff\"\n"
          echo -e "\t<FilesMatch \"\\.(php|html)quot;>\n"
          echo -e "\tHeader always unset X-Powered-By\n"
          echo -e "\tHeader unset X-Powered-By\n"
          echo -e "\tHeader set X-Frame-Options \"SAMEORIGIN\"\n"
          echo -e "\tHeader set X-XSS-Protection \"1\"\n"
          echo -e "\tHeader set X-Download-Options \"noopen\"\n"
          echo -e "\tHeader set X-Permitted-Cross-Domain-Policies \"master-only\"\n"
          echo -e "\tHeader set X-DNS-Prefetch-Control \"on\"\n"
          echo -e "\tHeader set Referrer-Policy \"no-referrer-when-downgrade\"\n"
          echo -e "\n"
          if [ "${C_DA_ENABLE_DOMAIN_HSTS}" != "false" ]; then
            local enable_type hsts_max_age
            enable_type=$(echo "${C_DA_ENABLE_DOMAIN_HSTS}" | awk -F':' '{ print $1 }')
            hsts_max_age=$(echo "${C_DA_ENABLE_DOMAIN_HSTS}" | awk -F':' '{ print $2 }')
            if [ "${enable_type}" == "global" ]; then
              echo -e "\t|*if SSL_TEMPLATE=\"1\"|\n"
              echo -e "\tHeader set Strict-Transport-Security \"max-age=${hsts_max_age}\" includeSubDomains; preload\n"
              echo -e "\t|*endif|\n"
            else
              :
              # TODO add hsts based on user ROLE config (let the other header global) (planned feature)
            fi
          fi
          echo -e "\n"
          echo -e "\tHeader set Content-Security-Policy \"block-all-mixed-content\"\n"
          echo -e "\tHeader Set Permissions-Policy 'geolocation=*, midi=(), sync-xhr=(self \"https://|DOMAIN|\" \"https://www.|DOMAIN|\"), \
    microphone=(), camera=(), magnetometer=(), gyroscope=(), payment=(), fullscreen=(self \"https://|DOMAIN|\" \"https://www.|DOMAIN|\")'\n"
          echo -e "\n"
          echo -e "\t|*if SSL_TEMPLATE=\"0\"|\n"
          echo -e "\treturn 301 https://\$host\$request_uri;\n"
          echo -e "\t|*endif|\n"
          echo -e "\t</FilesMatch>\n"
          echo -e "\t</IfModule>\n"
        } >"${da_template_custom_path}/cust_httpd.CUSTOM.post"
      fi
      # Important, since the above 2 written in global custom virtual host, some headers can be unset via .htaccess for specific domain:
      # eg: Header always unset X-Frame-Options
      # Or I can enable this via specific domain only (TODO)
      _echo "$(msg cyan)Rewriting virtual host config ...$(msg end)" --name
      ${da_cb_bin} rewrite_confs
      get_status_message "$?"
      echo ""
      sleep 5
      # Test the first user domain for header
      test_count=0
      while :; do
        ((test_count++))
        _echo "$(msg cyan)Testing header message for domain ${LABEL_C_DA_USER_DOMAIN1}...$(msg end)" --name
        curl -s -D- https://${C_DA_USER_DOMAIN1[0]} | grep -i Strict
        retval=$?
        if [ "${retval}" -eq 0 ]; then
          echo "Success"
          break
        else
          echo "Failed"
        fi
        echo ""
        _echo "$(msg cyan)Testing another header message for domain ${LABEL_C_DA_RESELLER_DOMAIN1}...$(msg end)" --name
        curl -s -D- https://${C_DA_RESELLER_DOMAIN1[0]} | grep -i Strict
        retval=$?
        if [ "${retval}" -eq 0 ]; then
          echo "Success"
          break
        else
          echo "Failed"
        fi
        echo ""
        # This will not happen in the future when I have obtained SSL and put in backup, I will always have valid SSL
        if [ "${test_count}" -gt 3 ]; then
          _echo "$(msg cyan)Notice, skipped testing because it might be issue with SSL rate limit (this will be fixed automatically with DA auto SSL)$(msg end)" --name
          sleep 2
          break
        fi
        _echo "$(msg cyan)Re-testing in 10 seconds ...$(msg end)" --name
        _pause 10
      done
    fi
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi
}
# This is an alias function of setup_post
post_setup() {
  setup_post "$@"
}

# This is used to install extra packages like ncdu, htop and more
setup_post() {
  local run_mode func_name
  run_mode="$1"
  extra_option="$2"
  func_name="${FUNCNAME[0]}"
  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    start_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    start_execute_options "${run_mode}" "${func_name}"
  fi
  [[ "${SKIP_RUN}" == "true" ]] && return 0
  if [[ ! -f "${CONF_PATH}/${func_name}_executed" && "${FUNCTION_RUN}" == "true" ]]; then
    if [ "${DISTRO_ID}" == "debian" ]; then
      # Install speedtest-cli
      curl -s https://install.speedtest.net/app/cli/install.deb.sh | sudo bash
      apt-get install speedtest
      apt-get -y install ncdu htop gpg vim mutt
    else
      echo "Warning, check the setup_post installation for ${DISTRO_ID}, it's only available for debian!"
    fi
    # TODO: Audit system here with maxinis:
    # maxinis --audit system
    echo ""
    check_finish_reboot "${func_name}"
  else
    _echo "$(msg yellow)[Skipped by system]: $(msg magenta)${func_name}()$(msg end) $(msg yellow)with current option ${run_mode} has ran before $(msg end)" --name
    _echo "$(msg yellow)=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=$(msg end)" --plain
  fi

  if [[ "${extra_option}" == "--silent-if-executed" ]]; then
    end_execute_options "${run_mode}" "${func_name}" &>/dev/null
  else
    end_execute_options "${run_mode}" "${func_name}"
  fi

  # TODO note, at the end of setup_post, must put PermitRootLogin to no to maximum security, previously PermitRootLogin was prohibited-password
}

#############################
# Setup function begin here #
#############################
setup() {
  # Just prevent running setup action if set to local, the other value still run this
  if [ "${EXECUTION_ENV}" == "local" ]; then
    _echo "$(msg red)Error, cannot execute setup action because the execution environment file ${SCRIPT_PATH}/execution_env is not set as remote$(msg end)" --name
    _echo "$(msg red)You can only run this function on remote server$(msg end)" --name
    _exit 147
  else
    script_header
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    option="$1"
    #if [ "${option}" == "remote" ];  then
    #  _echo 'yellow' "Notice, remote setup is set"
    #  :
    #else
    # ==== Locking mechanism ====
    PID=$(pidof -x "${SCRIPT_NAME}")
    # USE ATOMIC LOCK
    LOCK_DIR="/var/lock/${SCRIPT_NAME}"
    LOCK_PID="${LOCK_DIR}/pid"

    # THIS WILL CHECK ONLY ONE INSTANCE OF SCRIPT SHOULD RUN
    if ! mkdir "${LOCK_DIR}" 2>/dev/null; then
      PID=$(cat "${LOCK_PID}")
      if ! kill -0 "${PID}" 2>/dev/null; then
        echo "[${SCRIPT_NAME}]: Removing stale lock of nonexistent PID ${PID}"
        rm -rf "${LOCK_DIR}"
        echo "[${SCRIPT_NAME}]: Restarting (${SCRIPT_NAME})"
        exec "$0" "$@"
      fi
      echo "[${SCRIPT_NAME}]: Warning, another instance of this script is already running with PID [${PID}]"
      echo "[${SCRIPT_NAME}]: Please wait or clear the current running session to re-run this script"
      exit 147
    else
      # LOCK SUCCESS NOW SAVE INFORMATION IN PID
      echo $$ >"${LOCK_PID}"

      CTRL_C_COUNT=0
      # IF SCRIPT EXIT UNSUCCESSFULLY, THEN WE CALL cleanup function
      traps script_exit QUIT INT TERM EXIT
    fi
    # ============End of locking===============

    # Validate config files
    validate_config

    if [[ ${DISTRO_ID} == "centos" || ${DISTRO_ID} == "debian" ]]; then
      #echo "[${SCRIPT_NAME}]: OK, this operating system [${DISTRO_ID}] is supported!"
      :
    else
      _echo "$(msg red)Sorry, this operating system [${DISTRO_ID}] is not supported!$(msg end)" --name
      _exit 147
    fi

    if compgen -G "${CONF_PATH}/*_executed" >/dev/null; then
      _echo "$(msg red)Resuming $(msg cyan)server installation for ${LABEL_C_BOX_HOSTNAME_FQHN} ...$(msg end)" --name
      _pause 5
    else
      _echo "$(msg red)Starting $(msg cyan)server installation for ${LABEL_C_BOX_HOSTNAME_FQHN} ...$(msg end)" --name
    fi

    echo ""

    ############ Setup function call starts here ############
    # Call function documentation #
    # SYNTAX:
    # function_name +<option>
    # + means optional
    # EXAMPLE:
    # eg: secure_os --run-force
    # DESCRIPTION:
    # <option> lists:
    # --run - normal run, after it has finished executed, it is marked as executed and continue to the next function_name call
    # --run-exit - normal run, after it has finished executed, it is marked as executed and then exit or halt (no next function_name call)
    # --run--force - force run (even after being executed previously), after it has finished executed, it is marked as executed and continue to the next function_name call
    # --run--force-exit - force run (even after being executed previously), after it has finished executed, it is marked as executed and then exit or halt (no next function_name call)
    # --skip - do not run the current function_name and do not mark it as executed
    # --skip-exit - do not run the current function_name, do not mark it as executed and then exit or halt (no next function_name call)
    # --skip-mark - do not run the current function_name but mark it as executed
    # --skip-mark-exit - do not run the current function_name but mark it as executed and then exit or halt (no next function_name call)
    # EXTRA INFO:
    # Without <option> argument it is similar to using --run
    # eg: configure_net is equivalent to configure_net --run
    #####################################################

    # Note 1: setup_pre can be used to install screen, disable Selinux in CentOS or other necessary pre install components
    setup_pre --run
    # Upgrade system
    upgrade_os --run
    # Note 1: Clone all setup script from git (recommend to run as --run-force instead of --run so we always get the latest security update)
    get_latest_code --run
    # Note 1: This call contains security hardening server
    secure_os --run
    # Note 1: This is for push notification (eg: to receive notification via android phone)
    configure_gotify --run
    # For yaml editor
    configure_yq --run
    # Note 1: This will configure grub such as setting up password for grub bootloader
    # Note 2: Grub bootloader password can also be used in preseed file, but having preseed file during installation is a bad idea.
    configure_grub --run
    # Note 1: This will configure the basic network such as the LAN interface
    # Note 2: Special note: When this function is executed, when it detects the current LAN interface is not eth0, and C_NIC_INTERFACE_NAME value is not eth0 then
    # the script will use the background script to rename LAN interface using ip link command. In this case, before the background script is executed, it will first
    # call the next function configure_net2 to configure the network files that use network interface based $C_NIC_INTERFACE_NAME value from config file
    # The reason is to prevent the system from network locked out due to unfinished configuration files between network files by using ip link down command.
    # Note 3: That means, configure_net2 will only run once if that is the case. If you still need configure_net2 to run for technical reason, use the option --run-force
    configure_net --run  # This is optional because it was set in debian preseed file but we still can run this
    # Must run configure_net first before running configure_net2 because we need interface to be ${C_NIC_INTERFACE_NAME} first #OK
    configure_net2 --run # The important part is the /etc/hosts
    # This is where we can configure mount option for disk
    configure_fstab --run
    # Tweaking swap for production server
    configure_kernel_swap --run
    # Tweaking file system kernel etc ..
    configure_kernel_filesystem --run
    # Tweaking IPv4 or Ipv6 in kernel
    configure_kernel_ips --run
    if [[ "${C_SERVER_TYPE}" == "directadmin" ]]; then
      if [[ "${C_DA_INSTALL_TYPE}" == "custom" ]]; then
        install_da_pre --run
        install_da --run
        install_da_post --run
        configure_da_auth --run
        configure_bind --run
        install_da_csf --run
        configure_csf --run
        # Add da ipv6 and linking with ipv4 and vice versa (this option has --init argument)
        configure_da_ips --run
        configure_da_sql --run
        configure_da_sql_security --run
        configure_da_mail --run
        configure_da_mail_security --run
        configure_da_ftp --run
        configure_server_security --run
        configure_da_custom_configs --run
        configure_web_apps --run
        configure_da_settings --run
        configure_da_cb_settings --run
        configure_da_redis --run
        configure_da_memcached --run # (Prestashop only support this cache)
        configure_da_geoip --skip    # (skip temporarily until found useful)
        # Important to run configure_da_dns_templates first before creating any domains so that the DNS record can use new template automatically
        configure_da_dns_templates --run
        # " -- host --"
        configure_da_fqhn_server --run
        configure_da_ssl_pre --run
        configure_da_host_server_ssl --run
        # " -- owner --"
        configure_da_owner_accounts --run
        configure_da_owner_skins --run
        configure_da_owner_security --run
        # " -- admin --"
        configure_da_admin_accounts --run
        configure_da_admin_skins --run
        configure_da_admin_security --run
        # " -- reseller --"
        configure_da_reseller_accounts --run
        configure_da_reseller_skins --run
        configure_da_reseller_security --run
        configure_da_reseller_root_domains --skip #(this is deprecated, already done in configure_da_reseller_accounts)
        configure_da_reseller_subdomains --run
        configure_da_reseller_wildcard_domains --skip #(Skipped: Do not use wildcard for security purpose)
        configure_da_reseller_email_accounts --run
        configure_da_reseller_databases --run
        configure_da_reseller_domain_ssl_pre --skip # Deprecated and not needed (new directadmin version has this)
        configure_da_reseller_domain_ssl --skip     # Directadmin has autoSSL but I need this incase autoSSL is slow
        # " -- user ---"
        configure_da_user_accounts --run
        configure_da_user_security --run
        configure_da_user_root_domains --skip #(this is deprecated, already done in configure_da_user_accounts)
        configure_da_user_subdomains --run
        configure_da_user_wildcard_domains --skip #(Skipped: Do not use wildcard for security purpose)
        configure_da_user_email_accounts --run
        configure_da_user_databases --run
        configure_da_user_domain_ssl_pre --skip # Deprecated (new directadmin version has this)
        configure_da_user_domain_ssl --skip     # Directadmin has autoSSL but I need this incase autoSSL is slow
        # " -- others ---"
        configure_da_domain_security --run
        configure_da_custom_webs --skip # (Not really useful at the moment)
        configure_da_wpcli --run        # (this one just install wpcli, no need to configure template)
        # " -- maxicode ---"
        # Note 1: Get the latest security codes from maxicode (recommend to run as --run-force instead of --run so we always get the latest security update)
        update_latest_maxicode --run
        configure_maxicode_pre --skip
        configure_maxicode --run
        configure_maxigpg --run
        configure_maxiaide --run
        configure_maxiperm --run
        configure_maxida --run
        configure_maxinance --skip # (Deprecated function, already combined in maxida)
        configure_maxibox --run    # TODO improve this script (haven't implemented)
        configure_maxinis --run    # TODO improve this script (it contains bug)
        configure_maxirbl --run
        configure_maxiwall --run
        configure_maxicli --run
        configure_maxicloud --run
        configure_maxipass --run
        configure_maxidb --run
        configure_maxify --skip   # (skipped deprecated)
        configure_logs --skip     #-- skip temporarily
        configure_cronjobs --skip # Not useful anymore (already put in configure_maxicron)
        configure_maxicron --run
        # Still need to add more based on lynis suggestion
        harden_with_lynis --run
        # This will disable some services
        configure_services --run
        setup_post --run
      elif [[ "${C_DA_INSTALL_TYPE}" == "auto" ]]; then
        install_da_pre --run
        install_da --run
        install_da_post --run
        configure_da_auth --run
        configure_bind --run
        configure_csf --run
        # Add da ipv6 and linking with ipv4 and vice versa (this option has --init argument)
        configure_da_ips --run
        configure_da_sql --run
        configure_da_mail --run
        configure_da_ftp --run
        configure_server_security --run
        configure_da_custom_configs --run
        configure_web_apps --run
        configure_da_settings --run
        configure_da_cb_settings --run
        configure_da_redis --run
        configure_da_memcached --run # (Prestashop only support this cache)
        configure_da_geoip --skip    # (skip temporarily until found useful)
        # Important to run configure_da_dns_templates first before creating any domains so that the DNS record can use new template automatically
        configure_da_dns_templates --run
        # " -- host --"
        configure_da_fqhn_server --run
        configure_da_ssl_pre --run
        configure_da_host_server_ssl --run
      fi
    elif [[ "${C_SERVER_TYPE}" == "general" ]]; then
      install_da_pre --run
      install_da --run
      install_da_post --run
      install_general_csf --run
      configure_csf --run
    elif [[ "${C_SERVER_TYPE}" == "prestashop" ]]; then
      :
    fi
    ############ Setup function call end here ############

    echo ""
    if [ "${C_SERVER_TYPE}" == "directadmin" ]; then
      echo "=============="
      echo "Directadmin now can be accessed through this URL: "
      echo "http://${LABEL_C_IPV4_ADD0}:${LABEL_C_DA_PORT} or http://${LABEL_C_BOX_HOSTNAME_FQHN}:${LABEL_C_DA_PORT}"
      echo "Username: ${LABEL_C_DA_OWNER_USERNAME1}"
      echo "Password: ${LABEL_C_DA_OWNER_USERPASS1}"
      echo "=============="
      echo ""
      echo ""
    elif [ "${C_SERVER_TYPE}" == "general" ]; then
      :
    fi
    # Show script running time

    script_time
    _echo "$(msg green)========== Installation Completed ==========$(msg end)" --plain
    echo ""

    # Destroy the setup config deeply
    if [ "${C_AUTO_DESTROY_CONFIG}" == "true" ]; then
      _echo "$(msg yellow)Warning, destroying setup configuration information in ${CONFIG_FILE} within 120 seconds ...$(msg end)" --name
      _pause 120
      shred -uvz "${CONFIG_FILE}"
      get_status_message "$?"
    else
      _echo "$(msg yellow)Warning, C_AUTO_DESTROY_CONFIG is not set to auto destroy config file. Please manually backup and destroy the setup configuration information in ${CONFIG_FILE}$(msg end)" --name
      sleep 5
    fi
    # Remove all setup information except CONF_PATH because CONF_PATH and CODE_PATH

    _echo "$(msg cyan)Cleaning installation log files$(msg end)" --name
    rm -rf "${LOG_PATH}"
    # CONF_PATH contains setup step information
    #rm -rf "${CONF_PATH}"
    rm -rf "${DATA_PATH}"
    # CODE_PATH contains autogenerated file/script ending with _ag.extension
    #rm -rf "${CODE_PATH}"
    rm -rf "${TEMP_PATH}"
    rm -rf "${INST_TEMP_DIR}"
    # Clear bash history
    _echo "$(msg cyan)Cleaning bash history$(msg end)" --name
    history -c
    get_status_message "$?"
    echo "# DONE !"
  fi

}
temp1() {
  :
}

test1() {
  :
}

############# End of function #############

# -------------- MAIN FUNCTION --------------#
# Obtain current running script name. eg: maxinet
SCRIPT_NAME=$(basename -- "$0")

# Make sure this script is executed with root permission
if [[ "${EUID}" -ne 0 ]]; then
  echo "[${SCRIPT_NAME}]: Error, this script must be run as root!"
  exit 147
fi

# Obtain current script path location eg: /root/execute/
SCRIPT_PATH="$(dirname "$(readlink -f "$0")")"

# Define date location to be executed eg: /usr/bin/date
DATE_BIN=$(command -v date)

if [ -z "${DATE_BIN}" ]; then
  # If binary for date is empty (does not exist),
  # we quit this script to prevent error because we need this binary for this script
  echo "$(msg -c red)Error, path for binary [date] does not exist!$(msg end)"
  exit 147
fi

# Define each directory's location to be created
LOG_PATH="${SCRIPT_PATH}/log"
CONF_PATH="${SCRIPT_PATH}/conf"
DATA_PATH="${SCRIPT_PATH}/data"
CODE_PATH="${SCRIPT_PATH}/code"
ISO_PATH="${SCRIPT_PATH}/iso"
DOWNLOAD_PATH="${SCRIPT_PATH}/download"
SECURE_PATH="${SCRIPT_PATH}/secure"
STORAGE_PATH="${SCRIPT_PATH}/storage"
TEMP_PATH="${SCRIPT_PATH}/temp"
INST_TEMP_DIR="${TEMP_PATH}/src"

# Create all important directories if they are not exist
mkdir -p "${LOG_PATH}"
mkdir -p "${CONF_PATH}"
mkdir -p "${DATA_PATH}"
mkdir -p "${CODE_PATH}"
mkdir -p "${ISO_PATH}"
mkdir -p "${DOWNLOAD_PATH}"
mkdir -p "${SECURE_PATH}"
mkdir -p "${STORAGE_PATH}"
mkdir -p "${TEMP_PATH}"
mkdir -p "${INST_TEMP_DIR}"

# A global variable that holds the number of progress spin occurrences
SPIN_COUNT=0

# A global variable that temporarily holds initial seconds value
HOLD_SECONDS=0

# A global variable that hold installation count
INSTALL_COUNT=1

# A global variable that holds the switch whether to run a function based on argument
FUNCTION_RUN=false

# A global variable that holds the switch whether to to skip run a function based on argument
SKIP_RUN=false

# This global variable that temporarily hold the current execution time
EXEC_START=$(date +%s.%N)

# A global variable that temporarily holds the current path
PREPATH="${PWD}"

# Get the distro ID. eg: ubuntu
DISTRO_ID=$(get_linux_os "id")

# Get the distro Version. eg: 20.04
DISTRO_VERSION=$(get_linux_os "version")

# Get the distro Codename, eg: bullseye
DISTRO_CODENAME=$(get_linux_os "codename")

#eg: 31-03-2020_11-56-16.12345
DATE_TIME_RANDSTR="$(${DATE_BIN} '+%d-%m-%Y_%H-%M-%S').${RANDOM}"
#eg: 31-03-2020_11-56-16
DATE_TIME_NOW="$(date '+%d-%m-%Y_%H-%M-%S')"

# This is the latest path for the code (the content of this path will be always up to date when get_latest_code() is executed with --run-force
LATEST_CODE_PATH="${DATA_PATH}/latest_${SCRIPT_NAME}"

LATEST_OS_CODE_PATH="${LATEST_CODE_PATH}/storage/os/${DISTRO_ID}"

EXECUTION_ENV="${SCRIPT_PATH}/execution_env"
if [ -s "${EXECUTION_ENV}" ]; then
  EXECUTION_ENV="$(cat "${EXECUTION_ENV}")"
else
  echo "remote" >"${EXECUTION_ENV}"
  EXECUTION_ENV="remote"
fi

if [[ "${C_USE_MULTI_LOG_FILE}" == "true" ]]; then
  # set to use multiple log files with different random date. eg: maxinet-31-03-2020_11-56-16.12345-report.log
  REPORT_FILE="${LOG_PATH}/${SCRIPT_NAME}-${DATE_TIME_RANDSTR}-report.log"
else
  # set to use one log file with only one name. eg: maxinet-report.log
  REPORT_FILE="${LOG_PATH}/${SCRIPT_NAME}-report.log"
fi

# TODO Logging start here with exec after the REPORT_FILE is created

# This report path is for storing error report
# REPORT_FILE_ERROR="${LOG_PATH}/${SCRIPT_NAME}-${DATE_TIME_RANDSTR}-error-report.log"

CONFIG_FILE="${SCRIPT_PATH}/${SCRIPT_NAME}.conf"
CONFIG_TEST=""
# This will only allow sourcing one time
if [ -z "${C_CONFIG_VERSION}" ]; then
  if [ -s "${CONFIG_FILE}" ]; then
    # CONFIG file must follow this regex.
    # eg: 1) abc=2 #OK 2) abc= #NOT-OK 3) abc #NOT-OK 4) @ok=abc #NOT-OK 5) .ok=abc #NOT-OK 6) _ok=abc #OK
    # It will ignore white spaces, blank-lines and comments.
    #CONFIG_TEST=$(grep -Evn '^[A-Za-z0-9_].+=.+$|^[[:space:]]*$|^#' "${CONFIG_FILE}")
    #  if [ -n "${CONFIG_TEST}" ]; then
    #    C_LOG_VERBOSITY_LEVEL="3"
    #    _echo "$(msg red)Error, there is one or more problems found in config file in ${CONFIG_FILE}$(msg end)" --name --verbose 3
    #    _echo "" --plain
    #    _echo "$(msg red)Error lines:$(msg end)" --name --verbose 3
    #    _echo "$(msg red)${CONFIG_TEST}$(msg end)" --plain
    #  else
    source_errs=$(source "${CONFIG_FILE}" 2>&1 >/dev/null)
    # get the return code of the test source
    retval=$?
    if [ ${retval} = 0 ]; then
      # Let's do the weird thing on string:
      if [ -n "${source_errs}" ]; then
        # Need this C_LOG_VERBOSITY_LEVEL=3 here because if config file error, this will not have value to display error
        C_LOG_VERBOSITY_LEVEL="3"
        _echo "$(msg red)Error, there is one or more problems found in config file in ${CONFIG_FILE}$(msg end)" --name --verbose 3
        _echo "" --plain
        _echo "$(msg red)Error details:$(msg end)" --name --verbose 3
        _echo "$(msg red)${source_errs}\n$(msg end)" --plain
        _exit 147
      else
        #If no error then we source the environment file from ${CONFIG_FILE} ..."
        source "${CONFIG_FILE}"
        retval=$?
        if [ ${retval} = 0 ]; then
          #C_LOG_VERBOSITY_LEVEL="7" # Do not use this, because we are overwriting the log
          # We do not need to show if config is valid, just care about the error.
          :
          #_echo "$(msg green)[${retval}] OK, config file is valid$(msg end)" --name --verbose 7
        else
          # In case something is wrong when sourcing it then tell here
          # We need this C_LOG_VERBOSITY_LEVEL=4 here because if config file error, this will not have value to show warning
          C_LOG_VERBOSITY_LEVEL="4"
          _echo "$(msg yellow)Warning, config file is valid but it does not return valid code when sourcing it$(msg end)" --name --verbose 4
          _exit 147
        fi
        #_echo "" --plain
      fi
    else
      # Need this C_LOG_VERBOSITY_LEVEL=3 here because if config file error, this will not have value to display error
      C_LOG_VERBOSITY_LEVEL="3"
      _echo "$(msg red)Error, the source command returns an error code of ${retval} when sourcing ${CONFIG_FILE}$(msg end)" --name --verbose 3
      _echo "$(msg red)Error details:$(msg end)" --name --verbose 3
      _echo "$(msg red)${source_errs}\n$(msg end)" --plain
      _exit 147
    fi
    #fi
  else
    _echo "$(msg red)Error, ${CONFIG_FILE} does not exist or empty. Need this configuration file$(msg red)" --name --verbose 3
    _exit 147
  fi

  # Start logging here after successfully validated config if C_LOG_VERBOSITY_LEVEL from config file is set to 8
  [[ ${C_LOG_VERBOSITY_LEVEL} == "8" ]] && set -x

  # Configuring or creating autogenerate extra scripts and adding autogenerate setup readme
  create_file "ssh-push-scripts setup-readme"

  # This will configure whether to hide the sensitive label from config file or not based on C_HIDE_SENSITIVE_TEXT variable value
  if [ "${C_HIDE_SENSITIVE_TEXT}" == "true" ]; then
    # This will create a source file that will hide the sensitive variable value to equal to its own variable
    create_file "sensitive-label-hide"
    #_echo "$(msg cyan)Note, sensitive labels are hidden from terminal$(msg end)" --name
  else
    # this will create a source file that will show the sensitive variable value to equal to the value in the config file
    create_file "sensitive-label-show"
    # TODO only show warning 2 times after changed C_HIDE_SENSITIVE_TEXT because this is a little annoying
    #_echo "$(msg yellow)Warning, sensitive labels will be shown on terminal because C_HIDE_SENSITIVE_TEXT is not set to true$(msg end)" --name
    #_pause 2
  fi
  # Source the sensitive label whether to hide data or not
  source "${CONF_PATH}/sensitive_label"

  # Obtain DNS provider API information from config variable
  DNS_PROVIDER_NAME=$(echo "${C_DNS_PROVIDER_API1}" | awk -F':' '{ print $1 }')
  DNS_PROVIDER_USER=$(echo "${C_DNS_PROVIDER_API1}" | awk -F':' '{ print $2 }')
  DNS_PROVIDER_API_KEY=$(echo "${C_DNS_PROVIDER_API1}" | awk -F':' '{ print $3 }')

  # if C_HOST_PUBLIC_IP is not set in config file, we retrieve this host IP automatically

  if [ -z "${C_HOST_PUBLIC_IP}" ]; then
    # To disable this check, supply the host IP manually in config file ...
    _echo "$(msg cyan)Getting current host public IP... ${LABEL_C_HOST_PUBLIC_IP}$(msg end)" --name
    # Install required components if does not exist
    required "debian@@apt:dnsutils" "ubuntu@@apt:dnsutils"
    # Get the current host public IP
    TEST_C_HOST_PUBLIC_IP=$(dig TXT +short o-o.myaddr.l.google.com @ns1.google.com | awk -F'"' '{ print $2}')
    if is_valid ipv4 "${TEST_C_HOST_PUBLIC_IP}" || is_valid ipv6 "${TEST_C_HOST_PUBLIC_IP}"; then
      C_HOST_PUBLIC_IP="${TEST_C_HOST_PUBLIC_IP}"
    else
      if ! is_valid ipv4 "${C_HOST_PUBLIC_IP}" || ! is_valid ipv6 "${C_HOST_PUBLIC_IP}"; then
        _echo "$(msg red)Error, could not find the current host public IP and the C_HOST_PUBLIC_IP is not a valid IP. Please insert a valid host public IP manually in config file at ${CONFIG_FILE}$(msg end)" --name
        _exit 147
      else
        :
        # Do nothing because we already have the value of C_HOST_PUBLIC_IP
      fi
    fi
    if [[ "${C_HIDE_SENSITIVE_TEXT}" == "true" ]]; then
      LABEL_C_HOST_PUBLIC_IP="C_HOST_PUBLIC_IP"
    else
      LABEL_C_HOST_PUBLIC_IP="${C_HOST_PUBLIC_IP}"
    fi
    _echo "$(msg magenta)Current host public IP is: ${LABEL_C_HOST_PUBLIC_IP}$(msg end)" --name
  fi

  C_BOX_HOSTNAME=$(echo "${C_BOX_HOSTNAME_FQHN}" | awk -F'.' '{ print $1 }')

  # Copy ssh keys from secure folder to /root/.ssh because some SSH client in linux depend only on this path and must have permission
  # In Windows WSL, secure folder has permission global 777, lish connection will not allow using this ssh key.
  #_echo "$(msg cyan)Copying RSA key public key for login purpose without prompt to replace ...$(msg end)" --name
  # The ssh folder /root/.ssh/* will always have certificate from ${SECURE_PATH}/ssh

  if [ "${EXECUTION_ENV}" == "remote" ]; then
    :
  else
    # Run all local things
    install_pre_packages_local --run --silent-if-executed
    ssh_api copy-public-keys --without-prompt
  fi
else
  # Config has source
  :
fi

ACTION="$1"
ARGNUM="$#"

if [ $ARGNUM -eq 0 ]; then
  _echo "$(msg red)Error, no argument is supplied. Use $(msg yellow)[ ${SCRIPT_NAME} --help ]$(msg red) to see the valid options$(msg end)" --name --verbose 3
  _exit 147
fi

# This option handler method does not require getopt
# because the first argument can be treated as normal action without -- or -
while [ "$#" -gt 0 ]; do
  case "${ACTION}" in
  # test-script
  -t | --test)
    exit 0
    break
    ;;
  -h | --help)
    help
    exit 0
    ;;
  # Display program version
  -V | --version)
    script_header
    break
    exit 0
    ;;
  # This one is for configuring script, for example supplying config file through terminal (TODO)
  -c | --configure)
    shift
    _echo "Configuring ${_APP_SPECIFIC_NAME} ..." --name
    break
    exit 0
    ;;
  --ct | --config-test)
    validate_config
    break
    exit 0
    ;;
  # Clear all paths (dangerous)
  --cls | --clear)
    rm -rf "${LOG_PATH}"
    rm -rf "${CONF_PATH}"
    rm -rf "${DATA_PATH}"
    rm -rf "${CODE_PATH}"
    rm -rf "${TEMP_PATH}"
    rm -rf "${INST_TEMP_DIR}"
    echo "[${SCRIPT_NAME}]: Program path cleaned"
    exit 0
    break
    ;;
  # STARTING BELOW IS ACTION (no symbol --)
  setup | install)
    shift
    setup "$@"
    exit 0
    break
    ;;
  # This option is the starting point for initializing server.
  # It will setup disk from scratch (eg: from linode), call necessary functions and you will get secured server
  # maxinet --init-server <options>
  # Deprecated documentation below (update later):
  # maxinet --init-server optional <init-all> optional <rebuild-iso>
  # Note 1: Only use init-all to remove and start re-creating all partitions
  # Note 2: If you run like this maxinet --init-server init-all
  #   :This will remove all existing partitions including rescue disk and profile. No rescue disk and profile is created
  # Note3: If you run like this (without argument): maxinet --init-server
  #   :This will remove and re-create system related partitions. It will not disturb the rescue option
  init-server | deploy-server | build-server | create-server | setup-server)
    shift
    script_header
    # Make sure internet is OK
    ensure_internet_connected
    init_server "$@"
    exit 0
    break
    ;;
  update-maxinet-remote-script | update-remote-scripts | update-remote-script | update-remote-code)
    ensure_internet_connected
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    shift
    # File to push from local file

    if [ "${C_DA_RESTORE_PREVIOUS_HOSTNAME_SSL}" == "true" ]; then
      LOCAL_FILES_TO_PUSH="${SECURE_PATH}/gpg/gpg_private_key.gpg ${SCRIPT_PATH}/maxinet ${SCRIPT_PATH}/maxinet.conf \
      ${SCRIPT_PATH}/readme.txt ${SECURE_PATH}/ssl/.lego/certificates/${C_BOX_HOSTNAME_FQHN}.crt ${SECURE_PATH}/ssl/.lego/certificates/${C_BOX_HOSTNAME_FQHN}.issuer.crt \
      ${SECURE_PATH}/ssl/.lego/certificates/${C_BOX_HOSTNAME_FQHN}.key ${SECURE_PATH}/ssl/.lego/certificates/${C_BOX_HOSTNAME_FQHN}.json"
    else
      LOCAL_FILES_TO_PUSH="${SECURE_PATH}/gpg/gpg_private_key.gpg ${SCRIPT_PATH}/maxinet ${SCRIPT_PATH}/maxinet.conf ${SCRIPT_PATH}/readme.txt"
    fi

    REMOTE_LOCATION_TO_RECEIVE="~/"
    ssh_api transfer-files --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user "root:${C_ROOT_USERNAME}" --local-files "${LOCAL_FILES_TO_PUSH}" --remote-path "${REMOTE_LOCATION_TO_RECEIVE}"
    exit 0
    break
    ;;
  # This will list out what domain or subdomain that will have problem when request certificate
  srt | ssl-request-test | request-ssl-test)
    # Beta test
    validate_config
    configure_da_reseller_domain_ssl_pre "--run-force"
    configure_da_user_domain_ssl_pre "--run-force"
    exit 0
    break
    ;;
  # This will request certificate
  sr | ssl-request | request-ssl)
    validate_config
    configure_da_reseller_domain_ssl "--run-force"
    configure_da_user_domain_ssl "--run-force"
    exit 0
    break
    ;;
  lui | linode-upload-iso)
    ensure_internet_connected
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    # This is a way to upload iso file from local to remote using scp
    shift
    cp "${SCRIPT_PATH}"/secure/ssh/*.id_rsa* /root/.ssh/
    chmod -R 600 /root/.ssh/
    ssh -i /root/.ssh/linode_lish.id_rsa -tt "${DNS_PROVIDER_USER}@${C_DNS_PROVIDER_TERMINAL_SERVER}" "${C_BOX_HOSTNAME_FQHN}" <linode/permit_root.sh
    echo "Script executed"
    # sleep 30
    #exit 147
    echo "Uploading ISO file into ~/ at ${LABEL_C_IPV4_ADD0} using SCP protocol ..."
    iso_file="${SCRIPT_PATH}/storage/os/debian/deb10mod-final.iso"
    scp "${iso_file}" root@"${C_IPV4_ADD0}":~/mini.iso
    echo "Cloning setup file mini.iso into /dev/sda"
    ssh "root@${C_IPV4_ADD0}" 'bash -s' <<"ENDSSH"
      dd if=mini.iso of=/dev/sda
ENDSSH
    exit 0
    break
    ;;

  lu | luks-unlock | unlock-luks | ssh-luks-unlock | unlock-server)
    ensure_internet_connected
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    shift
    ssh_api luks-unlock "$@"
    exit 0
    break
    ;;
  push-ssh-script | run-ssh-script)
    ensure_internet_connected
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    shift
    ssh_api push-script "$@"
    exit 0
    break
    ;;
  get-remote-log)
    ensure_internet_connected
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    shift
    echo "Download setup log file into ${SCRIPT_PATH}/log/${SCRIPT_NAME}.log ..."
    ssh_api file-download --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user root:root --remote-path ~/maxinet.log --local-path "${SCRIPT_PATH}/log"
    retval=$?
    if [ "${retval}" -eq 0 ]; then
      _echo "$(msg green)Success, now you can view this log file at ${SCRIPT_PATH}/log/${SCRIPT_NAME}.log$(msg end)" --name
    else
      _echo "$(msg red)Error, something is wrong when trying to retrieve the log file at ${SCRIPT_PATH}/log/${SCRIPT_NAME}.log$(msg end)" --name
    fi
    exit 0
    break
    ;;
  # maxinet --get-remote-files "~/maxinet.log"
  get-remote-files | download-remote-files | get-remote-file | download-remote-file)
    ensure_internet_connected
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    shift
    #eg: ~/maxinet.log
    remote_files_path="$1"
    echo "Downloading file(s) ${remote_files_path} into ${DOWNLOAD_PATH}/..."
    ssh_api file-download --server-port "${C_BOX_HOSTNAME_FQHN}:${C_SSH_PORT}" --group-user root:root --remote-path "${remote_files_path}" --local-path "${DOWNLOAD_PATH}/"
    retval=$?
    if [ "${retval}" -eq 0 ]; then
      _echo "$(msg green)Success, file ${remote_files_path} downloaded into ${DOWNLOAD_PATH}/${remote_files_path}$(msg end)" --name
    else
      _echo "$(msg red)Error, something is wrong when trying to download remote file$(msg end)" --name
    fi
    exit 0
    break
    ;;
    # ./maxinet ssh-login <optional_hostname> <optional_port> <optional_user>
    # If hostname or port are not provided, they will use the default ones from config file
  generate-port)
    shift
    generate_unused_port
    exit 0
    break
    ;;
  get-listening-port)
    shift
    get_listening_port "$@"
    exit 0
    break
    ;;
  ssh-login | login-to-server | login)
    ensure_internet_connected
    ensure_domain_server_resolved
    ensure_fqhn_server_resolved
    time ssh_api login
    shift
    exit 0
    break
    ;;
  ssh-api | ssh)
    shift
    ssh_api "$@"
    exit 0
    break
    ;;
  ssh-transfer)
    shift
    ssh_api transfer-files "$@"
    exit 0
    break
    ;;
  boot-linode | boot-server | start-server)
    shift
    if [ "${DNS_PROVIDER_NAME}" == "linode" ]; then
      linode_api_admin boot-linode "$@"
    elif [ "${DNS_PROVIDER_NAME}" == "digitalocean" ]; then
      digitalocean_api_admin boot-do "$@"
    #elif "Other provider"
    else
      _echo "$(msg red)Error, unknown DNS provider to execute boot command! $(msg end)" -- name
    fi
    exit 0
    break
    ;;
  check-server-port)
    shift
    check_server_port "$@"
    exit 0
    break
    ;;
  rs | shutdown-server)
    shift
    _shutdown "$@"
    exit 0
    break
    ;;
  # lish-login <option>
  ll | lish-console | lish | lish-login)
    shift
    lish_console "$@"
    exit 0
    break
    ;;
  dropbox-api | dropbox-api-admin | dropbox | manage-dropbox)
    shift
    dropbox_api "$@"
    exit 0
    break
    ;;
  # This will generate a modified operating system ISO file that can be used to automatically install OS when booting.
  iso-api | iso-api-admin | iso | manage-iso)
    shift
    iso_api "$@"
    exit 0
    break
    ;;
  remove-da-domain)
    shift
    domain="$1"
    echo "Removing domain from /etc/virtual/domains ..."
    grep -v "^${domain}" /etc/virtual/domains >tmpfile
    cat tmpfile >/etc/virtual/domains
    echo ""
    echo "Removing domain from /etc/virtual/domainowners ..."
    grep -v "^${domain}" /etc/virtual/domainowners >tmpfile
    cat tmpfile >/etc/virtual/domainowners
    echo ""
    echo "Removing domain from /etc/virtual/${domain} ..."
    rm -rf /etc/virtual/${domain}
    echo ""
    exit 0
    break
    ;;
  remove-da-user)
    # New method: Manually delete a user
    #-
    #rm -fr /usr/local/directadmin/data/users/examplereseller
    #mv -f /usr/local/directadmin/data/admin/show_all_users.cache /root/show_all_users.cache
    #rm -fr /home/examplereseller
    #userdel examplereseller  (gets the user off from passwd, shadow, group & gshadow files)
    #rm -fr /var/spool/mail/examplereseller
    #locate examplereseller  (delete all occurrences)
    #\cp -a /root/show_all_users.cache /usr/local/directadmin/data/admin/
    #
    #---
    #
    #(one liner ; just change the username)
    #rm -fr /usr/local/directadmin/data/users/examplereseller && mv -f /usr/local/directadmin/data/admin/show_all_users.cache /root/show_all_users.cache && rm -fr /home/examplereseller && userdel examplereseller && rm -fr /var/spool/mail/examplereseller && locate examplereseller (delete all occurrences)
    #and finally:
    #\cp -a /root/show_all_users.cache /usr/local/directadmin/data/admin/show_all_users.cache
    shift
    username="$1"
    user_directory="/usr/local/directadmin/data/users/${username}"
    echo "Removing user directadmin directory at ${user_directory} ..."
    if [ -d "${user_directory}" ]; then
      rm -rf "${user_directory}"
    else
      echo "Warning, path ${user_directory} not found"
    fi
    echo ""
    all_user_cache="/usr/local/directadmin/data/admin/show_all_users_cache"
    echo "Removing all directadmin user cache at ${user_directory} ..."
    if [ -f "${all_user_cache}" ]; then
      rm -rf "${all_user_cache}"
    else
      echo "Warning, path ${all_user_cache} not found"
    fi
    echo ""
    quotaoff_bin="$(command -v quotaoff)"
    _echo "$(msg cyan)Turning off system quota ...$(msg end)" --name
    ${quotaoff_bin} -a
    echo ""
    user_home_directory="/home/${user}"
    echo "Removing user home directory at ${user_home_directory} ..."
    if [ -d "${user_home_directory}" ]; then
      rm -rf "${user_home_directory}"
    else
      echo "Warning, path ${user_home_directory} not found"
    fi
    echo ""
    exit 0
    echo "Removing user or group ${user} from system ..."
    deluser ${user}
    echo ""
    break
    ;;
    # Test or user linode API here
  # eg: maxinet --linode-api "get-linode-id" "sun.sofibox.com"
  linode-api | linode | manage-linode)
    shift
    linode_api_admin "$@"
    break
    exit 0
    ;;
  da-api | da | directadmin-api | directadmin | manage-da | manage-directadmin)
    shift
    da_api_admin "$@"
    exit 0
    break
    ;;
  # maxinet manage-maxicode <action> --app-name maxigpg --distro-name "debian"
  manage-maxicode)
    shift
    maxicode_admin "$@"
    exit 0
    break
    ;;
  build | build-package)
    shift
    package_name="$1"
    navigate_path "${HOME}"
    if [ "${package_name}" == "go" ]; then
      required "debian@@golang-go" "ubuntu@@golang-go"
    elif [ "${package_name}" == "dbxcli" ]; then
      required "debian@@apt:git,golang-go,gox" "ubuntu@@apt:git,golang-go,gox"
      mkdir -p "${HOME}/go"
      go get github.com/dropbox/dbxcli
      navigate_path "${HOME}/go/src/github.com/dropbox/dbxcli"
      # To be continued ...
    elif [ "${package_name}" == "dbx" ]; then
      :
    else
      echo "No known package!"
    fi
    exit 0
    break
    ;;
  *) ;;
  esac
  _echo "$(msg red)Error, invalid action or option [ $1 ]. Use --help to see the valid actions or options$(msg end)" --name
  exit 147
done

[[ ${C_LOG_VERBOSITY_LEVEL} == "8" ]] && set +x
